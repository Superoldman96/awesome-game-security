Project Path: arc_gmh5225_vt-debuuger_lraghlrc

Source Tree:

```txt
arc_gmh5225_vt-debuuger_lraghlrc
├── HyperDbgTool
│   ├── CLoadDriver.h
│   ├── CSymbols.cpp
│   ├── CSymbols.h
│   ├── Function.cpp
│   ├── Function.h
│   ├── HyperDbgTool.aps
│   ├── HyperDbgTool.cpp
│   ├── HyperDbgTool.h
│   ├── HyperDbgTool.rc
│   ├── HyperDbgTool.vcxproj
│   ├── HyperDbgTool.vcxproj.filters
│   ├── HyperDbgTool.vcxproj.user
│   ├── HyperDbgToolDlg.cpp
│   ├── HyperDbgToolDlg.h
│   ├── Symbols
│   │   ├── dbghelp.dll
│   │   ├── symsrv.dll
│   │   └── symsrv.yes
│   ├── dll-exports-main.zip
│   ├── downloadSymbolsTest.cpp
│   ├── downloadSymbolsTest.h
│   ├── framework.h
│   ├── loadDriver.cpp
│   ├── loadDriver.h
│   ├── mylog.cpp
│   ├── mylog.h
│   ├── ntdll.h
│   ├── pch.cpp
│   ├── pch.h
│   ├── res
│   │   ├── HyperDbgTool.ico
│   │   └── HyperDbgTool.rc2
│   ├── resource.h
│   ├── symsrv.yes
│   └── targetver.h
├── HyperHide
│   ├── HyperHide.vcxproj
│   ├── HyperHide.vcxproj.filters
│   ├── HyperHide.vcxproj.user
│   ├── HyperHideDrv.cpp
│   ├── HyperHideDrv.h
│   ├── HyperHideIcon.png
│   ├── IniApi.cpp
│   ├── IniApi.h
│   ├── Ioctl.h
│   ├── Settings.cpp
│   ├── Settings.h
│   ├── Tooltips.cpp
│   ├── Tooltips.h
│   ├── pluginconfig.h
│   ├── pluginmain.cpp
│   ├── pluginmain.h
│   ├── pluginsdk
│   │   ├── DeviceNameResolver
│   │   │   ├── DeviceNameResolver.h
│   │   │   ├── DeviceNameResolver_x64.a
│   │   │   ├── DeviceNameResolver_x64.lib
│   │   │   ├── DeviceNameResolver_x86.a
│   │   │   └── DeviceNameResolver_x86.lib
│   │   ├── TitanEngine
│   │   │   ├── TitanEngine.h
│   │   │   ├── TitanEngine_x64.a
│   │   │   ├── TitanEngine_x64.lib
│   │   │   ├── TitanEngine_x86.a
│   │   │   └── TitanEngine_x86.lib
│   │   ├── XEDParse
│   │   │   ├── XEDParse.h
│   │   │   ├── XEDParse_x64.a
│   │   │   ├── XEDParse_x64.lib
│   │   │   ├── XEDParse_x86.a
│   │   │   └── XEDParse_x86.lib
│   │   ├── _dbgfunctions.h
│   │   ├── _plugin_types.h
│   │   ├── _plugins.h
│   │   ├── _scriptapi.h
│   │   ├── _scriptapi_argument.h
│   │   ├── _scriptapi_assembler.h
│   │   ├── _scriptapi_bookmark.h
│   │   ├── _scriptapi_comment.h
│   │   ├── _scriptapi_debug.h
│   │   ├── _scriptapi_flag.h
│   │   ├── _scriptapi_function.h
│   │   ├── _scriptapi_gui.h
│   │   ├── _scriptapi_label.h
│   │   ├── _scriptapi_memory.h
│   │   ├── _scriptapi_misc.h
│   │   ├── _scriptapi_module.h
│   │   ├── _scriptapi_pattern.h
│   │   ├── _scriptapi_register.h
│   │   ├── _scriptapi_stack.h
│   │   ├── _scriptapi_symbol.h
│   │   ├── bridgegraph.h
│   │   ├── bridgelist.h
│   │   ├── bridgemain.h
│   │   ├── dbghelp
│   │   │   ├── dbghelp.h
│   │   │   ├── dbghelp_x64.a
│   │   │   ├── dbghelp_x64.lib
│   │   │   ├── dbghelp_x86.a
│   │   │   └── dbghelp_x86.lib
│   │   ├── jansson
│   │   │   ├── jansson.h
│   │   │   ├── jansson_config.h
│   │   │   ├── jansson_x64.a
│   │   │   ├── jansson_x64.lib
│   │   │   ├── jansson_x64dbg.h
│   │   │   ├── jansson_x86.a
│   │   │   └── jansson_x86.lib
│   │   ├── lz4
│   │   │   ├── lz4.h
│   │   │   ├── lz4_x64.a
│   │   │   ├── lz4_x64.lib
│   │   │   ├── lz4_x86.a
│   │   │   ├── lz4_x86.lib
│   │   │   ├── lz4file.h
│   │   │   └── lz4hc.h
│   │   ├── x32bridge.lib
│   │   ├── x32dbg.lib
│   │   ├── x64bridge.lib
│   │   └── x64dbg.lib
│   ├── resource.aps
│   ├── resource.h
│   └── resource.rc
├── HyperHide.ini
├── HyperHide.sln
├── HyperHideDrv
│   ├── ActiveProcessDbgList.c
│   ├── ActiveProcessDbgList.h
│   ├── CFunction.cpp
│   ├── CFunction.h
│   ├── CKernelDbg.cpp
│   ├── CKernelDbg.h
│   ├── CKernelTable.cpp
│   ├── CKernelTable.h
│   ├── CPeModule.cpp
│   ├── CPeModule.h
│   ├── DBGTOOL.c
│   ├── DRRWE.c
│   ├── DRRWE.h
│   ├── DbgIsMyProcess.c
│   ├── Dispatcher.cpp
│   ├── Dispatcher.h
│   ├── Driver.cpp
│   ├── GlobalData.h
│   ├── Header.h
│   ├── Heap.cpp
│   ├── Heap.h
│   ├── Hider.cpp
│   ├── Hider.h
│   ├── HookHelper.cpp
│   ├── HookHelper.h
│   ├── HookedFunctions.cpp
│   ├── HookedFunctions.h
│   ├── HyperHideDrv.vcxproj
│   ├── HyperHideDrv.vcxproj.filters
│   ├── HyperHideDrv.vcxproj.user
│   ├── HypervisorGateway.cpp
│   ├── HypervisorGateway.h
│   ├── Ioctl.h
│   ├── KernelApi.cpp
│   ├── KernelApi.h
│   ├── KernelDbgStruct.h
│   ├── KernelExportAPI.h
│   ├── KernelStruct.h
│   ├── KernelStruct1.h
│   ├── KuserSharedData.cpp
│   ├── KuserSharedData.h
│   ├── Log.cpp
│   ├── Log.h
│   ├── Memroy.cpp
│   ├── Memroy.h
│   ├── Notifiers.cpp
│   ├── Notifiers.h
│   ├── Ntapi.h
│   ├── Ntenums.h
│   ├── Ntstructs.h
│   ├── Peb.cpp
│   ├── Peb.h
│   ├── Pte.h
│   ├── RWNoAttach.cpp
│   ├── Ssdt.cpp
│   ├── Ssdt.h
│   ├── Txoo.h
│   ├── Utils.cpp
│   ├── Utils.h
│   ├── dbgk1to2.c
│   ├── dbgk1to2.h
│   ├── dbgtool.h
│   ├── myEthread.h
│   ├── struct.h
│   ├── vmintrin.asm
│   ├── vmintrin.h
│   ├── wrRegstry.c
│   ├── wrRegstry.h
│   └── 获取汇编指令长度.h
├── LICENSE
├── README.md
├── airhv
│   ├── airhv-main
│   │   ├── LICENSE
│   │   ├── README.md
│   │   ├── airhv
│   │   │   ├── airhv.vcxproj
│   │   │   ├── airhv.vcxproj.filters
│   │   │   ├── airhv.vcxproj.user
│   │   │   ├── allocators.h
│   │   │   ├── asm
│   │   │   │   ├── vm_context.asm
│   │   │   │   ├── vm_context.h
│   │   │   │   ├── vm_intrin.asm
│   │   │   │   └── vm_intrin.h
│   │   │   ├── common.h
│   │   │   ├── ept.cpp
│   │   │   ├── hypervisor_gateway.cpp
│   │   │   ├── hypervisor_gateway.h
│   │   │   ├── hypervisor_routines.cpp
│   │   │   ├── hypervisor_routines.h
│   │   │   ├── ia32
│   │   │   │   ├── cpuid.h
│   │   │   │   ├── cr.h
│   │   │   │   ├── dr.h
│   │   │   │   ├── ept.h
│   │   │   │   ├── exception.h
│   │   │   │   ├── msr.h
│   │   │   │   ├── mtrr.h
│   │   │   │   ├── rflags.h
│   │   │   │   ├── segment.h
│   │   │   │   ├── vmcs.h
│   │   │   │   └── vmcs_encodings.h
│   │   │   ├── interrupt.h
│   │   │   ├── invalidators.cpp
│   │   │   ├── invalidators.h
│   │   │   ├── lde
│   │   │   │   └── lde64.asm
│   │   │   ├── log.cpp
│   │   │   ├── log.h
│   │   │   ├── main.cpp
│   │   │   ├── ntapi.h
│   │   │   ├── poolmanager.cpp
│   │   │   ├── poolmanager.h
│   │   │   ├── spinlock.cpp
│   │   │   ├── vmcall_handler.cpp
│   │   │   ├── vmcall_handler.h
│   │   │   ├── vmcall_reason.h
│   │   │   ├── vmcs.cpp
│   │   │   ├── vmexit_handler.cpp
│   │   │   ├── vmexit_handler.h
│   │   │   ├── vmm.cpp
│   │   │   ├── vmm.h
│   │   │   └── xsave.h
│   │   ├── airhv.sln
│   │   └── airhvctrl
│   │       ├── airhvctrl.vcxproj
│   │       ├── airhvctrl.vcxproj.filters
│   │       ├── hypervisor_gateway.cpp
│   │       ├── hypervisor_gateway.h
│   │       ├── log.cpp
│   │       ├── log.h
│   │       ├── main.cpp
│   │       ├── nt.h
│   │       ├── utils.cpp
│   │       ├── utils.h
│   │       └── vmintrin.asm
│   └── airhv.txt
└── vtDebugger.zip

```

`HyperDbgTool/CLoadDriver.h`:

```h
#pragma once
#include <Windows.h>
#include <winsvc.h>
#define CTL_CODE( DeviceType, Function, Method, Access ) ( ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
#define FILE_DEVICE_UNKNOWN             0x00000022
#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3
#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

class CLoadDriver
{

#define  符号名 L"\\\\.\\HyperDbg"
private:

	HANDLE m_hDevice;

public:

	BOOLEAN Load(const WCHAR* DriverName)
	{
		WCHAR DriverPatch[MAX_PATH];
		
		if (!GetCurrentDirectory(sizeof(DriverPatch), DriverPatch))
		{
			return FALSE;
		}
		wcscat_s(DriverPatch, L"\\");
		wcscat_s(DriverPatch, DriverName);

		SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
		SC_HANDLE hService = CreateService(hSCManager, DriverName,
			DriverName, SERVICE_ALL_ACCESS,
			SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START,
			SERVICE_ERROR_IGNORE, DriverPatch, NULL, NULL, NULL, NULL, NULL);

		

		if (hService == 0)
		{
			hService = OpenService(hSCManager, DriverName, SERVICE_ALL_ACCESS);
		}
		bool boole = StartService(hService, 0, NULL);

		CloseServiceHandle(hService);
		CloseServiceHandle(hSCManager);
			if (!boole)
			{
				if (GetLastError()==1056)//驱动已经运行
				{
					return FALSE;
				}
			}
			
			m_hDevice = CreateFile(符号名,
				GENERIC_READ | GENERIC_WRITE,
				0,
				NULL,
				CREATE_ALWAYS,
				FILE_ATTRIBUTE_NORMAL,
				NULL);

			if (m_hDevice == INVALID_HANDLE_VALUE)
			{
				UnLoad(DriverName);
             return FALSE;
			}
			else
			{
				return TRUE;
			}
	}
	BOOL UnLoad(const WCHAR* lpName)
	{
		CloseHandle(m_hDevice);
		SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
		SC_HANDLE hService = OpenService(hSCManager, lpName, SERVICE_ALL_ACCESS);
	
		SERVICE_STATUS ss;
		ControlService(hService, SERVICE_CONTROL_STOP, &ss);
		BOOLEAN boole = DeleteService(hService);
		CloseServiceHandle(hService);
		CloseServiceHandle(hSCManager);
		return boole;
	}

	//CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
	BOOL DeviceControl(DWORD ControlCode, LPVOID lpInBuffer, IN DWORD InBufferSize,OUT LPVOID lpOutBuffer, DWORD OutBufferSize, LPDWORD lpBytesReturned )
	{
	     return	DeviceIoControl(m_hDevice, ControlCode, lpInBuffer, InBufferSize, lpOutBuffer, OutBufferSize, lpBytesReturned, 0);
	}

};


```

`HyperDbgTool/CSymbols.cpp`:

```cpp
#include "pch.h"
#include "CSymbols.h"

#pragma comment(lib,"dbghelp.lib")

BOOLEAN CSymbols::InitSymHandler1()
{
	HANDLE hfile;
	char Path[MAX_PATH] = { 0 };
	char FileName[MAX_PATH] = { 0 };
	char SymPath[MAX_PATH * 2] = { 0 };
	char* SymbolsUrl = "http://msdl.microsoft.com/download/symbols";


	if (!GetCurrentDirectoryA(MAX_PATH, Path))//获取当前目录
	{
		printf("cannot get current directory \n");
		return FALSE;
	}

	strcat(Path, "\\Symbols");//比如:C:\Symbols
	CreateDirectoryA(Path, NULL);//创建目录

	//首先创建一个目录 symsrv.yes文件，symsrv.dll会检查，没有就会弹出一个对话框要求你点确认

	strcpy(FileName, Path);
	strcat(FileName, "\\symsrv.yes");
	printf("%s \n", FileName);

	hfile = CreateFileA(FileName,
		FILE_ALL_ACCESS,
		FILE_SHARE_READ,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (hfile == INVALID_HANDLE_VALUE)
	{
		printf("create or open file error: 0x%X \n", GetLastError());
		return FALSE;

	}
	CloseHandle(hfile);

	//Sleep(3000);

	HANDLE hProcess = GetCurrentProcess();//获取当前进程

	//设置搜索参数：
	//SYMOPT_CASE_INSENSITIVE 该选项使得所有对符号名的搜索区分大小写
	//

	SymSetOptions(SYMOPT_CASE_INSENSITIVE | SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME);

	//这个是不是很眼熟？
	//SRV*d:\localsymbols*http://msdl.microsoft.com/download/symbols
	sprintf(SymPath, "SRV*%s*%s", Path, SymbolsUrl);
	strcpy(SymPath, m_SymbolsPatch);

	//在这里初始化
	if (!SymInitialize(hProcess,
		SymPath,
		TRUE))
	{
		printf("SymInitialize failed %d \n", GetLastError());
		return FALSE;
	}//初始化符号

	//设置搜索路径
    //程序会把win32k的pdb符号文件下载到这个目录Path
	if (!SymSetSearchPath(hProcess, SymPath))
	{
		DWORD dwerr = GetLastError();
		printf("SymSetSearchPath failed %d \n", GetLastError());
		return FALSE;
	}

	return TRUE;
}
//SRV*C:\Symbols* http://msdl.microsoft.com/download/symbols;D:\vt\HyperHide-master\x64\Release


//BOOL LoadSymModule(HANDLE hProc, HMODULE hDll)
//{
//	CHAR szFile[MAX_PATH], SymFile[MAX_PATH];
//
//	MODULEINFO ModInfo;
//
//	GetModuleFileNameA(hDll, szFile, sizeof(szFile) / sizeof(szFile[0]));
//
//	GetModuleInformation(hProc, hDll, &ModInfo, sizeof(ModInfo));
//
//	if (SymGetSymbolFile(hProc, NULL, szFile, sfPdb, SymFile, MAX_PATH, SymFile, MAX_PATH))
//	{
//		return (SymLoadModule64(hProc, NULL, szFile, NULL, (ULONG_PTR)ModInfo.lpBaseOfDll, ModInfo.SizeOfImage) != 0);
//	}
//
//	return FALSE;
//}


CSymbols::CSymbols()
{
	m_ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "ZwQuerySystemInformation");
}
CSymbols::CSymbols(const char* SymbolsPatch)
{
	m_ZwQuerySystemInformation =(ZWQUERYSYSTEMINFORMATION)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "ZwQuerySystemInformation");
	m_SymbolsPatch = SymbolsPatch;

	Module_INFO Module;
		
		if (!GetKernelModuleInfo(&Module))
		{
			MessageBox(0, L"GetKernelModuleInfo error!", L"", 0);	
		}
		DWORD Options = SymGetOptions();
		Options = Options | SYMOPT_DEBUG;
		SymSetOptions(Options);
		m_hProcess = GetCurrentProcess();

		//BOOL bRet = SymInitialize(m_hProcess, 0, FALSE);
		//if (!bRet)
		//{
		//	MessageBox(0, L"SymInitialize error!", L"", 0);
		//	return ;	
		//}

		if (!InitSymHandler1())
		{
			MessageBox(0, L"SymInitialize error!", L"", 0);
			return;
		}
		
		if (m_SymbolsPatch==0)
		{
			MessageBox(0,L"m_SymbolsPatch error",L"",0);
			return ;
		}

		if (!SymSetSearchPath(m_hProcess, m_SymbolsPatch))
		{
			MessageBox(0,L"SymSetSearchPath error!",L"",0);
			return ;
		}

		HMODULE hDll = LoadLibraryEx(TEXT("ntoskrnl.exe"), NULL, DONT_RESOLVE_DLL_REFERENCES);
		char szFile[MAX_PATH], SymFile[MAX_PATH] = {""}; char SymFile1[MAX_PATH] = { "" };
		//MODULEINFO ModInfo;
		GetModuleFileNameA(hDll, szFile, sizeof(szFile) / sizeof(szFile[0]));

		char currentDir[260];
		GetCurrentDirectoryA(260, currentDir);
		//char szcurrFile[MAX_PATH];
		//GetModuleFileNameA(NULL, szcurrFile, sizeof(szcurrFile) / sizeof(szcurrFile[0]));
		//HANDLE hcurr = GetModuleHandleA(szcurrFile);
		//char SymFile[MAX_PATH] = {""}; char SymFile1[MAX_PATH] = { "" };
		if (!SymGetSymbolFile(m_hProcess, NULL, szFile, sfPdb, SymFile, MAX_PATH, SymFile1, MAX_PATH))
		{
			int err = GetLastError();
			char msg[260];
			sprintf(msg, "SymGetSymbolFile error:%d", err);
			MessageBoxA(0, msg, "", 0);
			return;
		}

		char FileName[MAX_PATH];
		GetSystemDirectoryA(FileName, sizeof(FileName));
		strcat_s(FileName, "\\");
		strcat_s(FileName, Module.KernelName);
		HANDLE hFile = CreateFileA(FileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile==INVALID_HANDLE_VALUE)
		{
			MessageBox(0,L"CreateFileA error!",L"",0);
			return ;
		}
		DWORD dwfilesize = GetFileSize(hFile, NULL);
		
		m_BaseOfDll = SymLoadModule64(m_hProcess, hFile, FileName, NULL, (DWORD64)Module.KernelBass, dwfilesize);
		CloseHandle(hFile);
		if (m_BaseOfDll == 0)
		{
			//printf("SymLoadModule64:%d\n", GetLastError());
			MessageBox(0,L"SymLoadModule64 error!",L"",0);
			return ;
		}


}

CSymbols::~CSymbols()
{
	SymUnloadModule64(m_hProcess, m_BaseOfDll);
	SymCleanup(m_hProcess);
}

BOOLEAN CSymbols::GetKernelModuleInfo(
	PModule_INFO ModuleInfo)
{
	ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = m_ZwQuerySystemInformation;
	ULONG  RetLenth=0;
	PSYSTEM_MODULE_INFORMATION Buffer=0 ;
	NTSTATUS status;
	
	do
	{
		Buffer =(PSYSTEM_MODULE_INFORMATION)malloc(RetLenth);
		status=ZwQuerySystemInformation(11, Buffer, RetLenth, &RetLenth);

		if (!NT_SUCCESS(status)&& status != 0xC0000004L)
		{
			free(Buffer);
			return FALSE;
		}

	} while (status== 0xC0000004L);
	
	ModuleInfo->KernelBass = Buffer->Module[0].Base;
	ModuleInfo->KernelSize = Buffer->Module[0].Size;
	strcpy_s(ModuleInfo->KernelPatch, Buffer->Module[0].ImageName);
	strcpy_s(ModuleInfo->KernelName, Buffer->Module[0].ImageName+ Buffer->Module[0].ModuleNameOffset);
	free(Buffer);
	return TRUE;
}


BOOL CALLBACK CSymbols::EnumAllSymbolsCallBack(
	PSYMBOL_INFO pSymInfo,
	ULONG SymbolSize,
	PVOID UserContext)
{
	return ((ENUMSYMBOLSCALLBACK)UserContext)(pSymInfo->Name,(PVOID) pSymInfo->Address);	
}


BOOLEAN CSymbols::GetSymbolsAll(ENUMSYMBOLSCALLBACK callback)
{
	if (SymEnumSymbols(m_hProcess, m_BaseOfDll, 0, &EnumAllSymbolsCallBack, callback))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}






```

`HyperDbgTool/CSymbols.h`:

```h
#pragma once

#include "ntdll.h"

typedef struct _Address_Name
{
IN	char  Name[MAX_PATH];
PVOID Address;
	
}Address_Name,*PAddress_Name;


typedef struct _Module_INFO
{
		char KernelName[MAX_PATH];
		char KernelPatch[MAX_PATH];
		PVOID KernelBass;
		ULONG KernelSize;
}Module_INFO,*PModule_INFO;

typedef bool (*ENUMSYMBOLSCALLBACK)(char* Name, PVOID Address);
class CSymbols
{
public:
	CSymbols(const char* SymbolsPatch);
	CSymbols();
	~CSymbols();

	BOOLEAN GetKernelModuleInfo(OUT PModule_INFO ModuleInfo);
	BOOLEAN GetSymbolsAll(ENUMSYMBOLSCALLBACK callback);


private:
	BOOLEAN CSymbols::InitSymHandler1();

protected:
	HANDLE m_hProcess;
	DWORD64  m_BaseOfDll;
	
	const char* m_SymbolsPatch=0;//"E:\\symbols"
	char* m_Name;
	PVOID* m_Address=0;
	ZWQUERYSYSTEMINFORMATION m_ZwQuerySystemInformation;

	static BOOL CALLBACK EnumAllSymbolsCallBack(
		PSYMBOL_INFO pSymInfo,
		ULONG SymbolSize,
		PVOID UserContext);
	
};





```

`HyperDbgTool/Function.cpp`:

```cpp
#include "pch.h"
#include "Function.h"
#include "CSymbols.h"


SYMBOLS_DATA SymbolsData = { 0 };
ULONG SymbolsDataSize = sizeof(SYMBOLS_DATA) / sizeof(PVOID);


bool CallBack(char* Name, PVOID Address)
{    ///////////////////////////////////////////


	if (strcmp(Name, "PspActiveProcessLock") == 0)
	{
		SymbolsData.PspActiveProcessLock = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ObFastReplaceObject") == 0)
	{
		SymbolsData.ObFastReplaceObject = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsReturnProcessPagedPoolQuota") == 0)
	{
		SymbolsData.PsReturnProcessPagedPoolQuota = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ExDestroyHandle") == 0)
	{
		SymbolsData.ExDestroyHandle = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "MmCleanProcessAddressSpace") == 0)
	{
		SymbolsData.MmCleanProcessAddressSpace = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "MmDeleteProcessAddressSpace") == 0)
	{
		SymbolsData.MmDeleteProcessAddressSpace = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "MmGetFileNameForSection") == 0)
	{
		SymbolsData.MmGetFileNameForSection = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PspCidTable") == 0)
	{
		SymbolsData.PspCidTable = Address;
		SymbolsDataSize--;
	}



	else if (strcmp(Name, "ExfAcquirePushLockExclusive") == 0)
	{
		SymbolsData.ExfAcquirePushLockExclusive = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ExfTryToWakePushLock") == 0)
	{
		SymbolsData.ExfTryToWakePushLock = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PspRemoveProcessFromJob") == 0)
	{
		SymbolsData.PspRemoveProcessFromJob = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PspDeleteLdt") == 0)
	{
		SymbolsData.PspDeleteLdt = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsReturnProcessNonPagedPoolQuota") == 0)
	{
		SymbolsData.PsReturnProcessNonPagedPoolQuota = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "AlpcpCleanupProcessViews") == 0)
	{
		SymbolsData.AlpcpCleanupProcessViews = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ObDereferenceDeviceMap") == 0)
	{
		SymbolsData.ObDereferenceDeviceMap = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PspDereferenceQuotaBlock") == 0)
	{
		SymbolsData.PspDereferenceQuotaBlock = Address;
		SymbolsDataSize--;
	}

	////////////////////////////////////////////
	else if (strcmp(Name, "DbgkExitProcess") == 0)
	{
		SymbolsData.DbgkExitProcess = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkpPostFakeThreadMessages") == 0)
	{
		SymbolsData.DbgkpPostFakeThreadMessages = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkpPostFakeProcessCreateMessages") == 0)
	{
		SymbolsData.DbgkpPostFakeProcessCreateMessages = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkCopyProcessDebugPort") == 0)
	{
		SymbolsData.DbgkCopyProcessDebugPort = Address;
		SymbolsDataSize--;//ok
	}
	else if (strcmp(Name, "DbgkOpenProcessDebugPort") == 0)
	{
		SymbolsData.DbgkOpenProcessDebugPort = Address;
		SymbolsDataSize--;//ok
	}
	else if (strcmp(Name, "DbgkpSetProcessDebugObject") == 0)
	{
		SymbolsData.DbgkpSetProcessDebugObject = Address;
		SymbolsDataSize--;//ok
	}
	else if (strcmp(Name, "DbgkpMarkProcessPeb") == 0)
	{
	   SymbolsData.DbgkpMarkProcessPeb = Address;
	   SymbolsDataSize--;//ok
	}
	else if (strcmp(Name, "DbgkpWakeTarget") == 0)
	{
	   SymbolsData.DbgkpWakeTarget = Address;
	   SymbolsDataSize--;//ok
	}

	else if (strcmp(Name, "DbgkCreateThread") == 0)
	{
		SymbolsData.DbgkCreateThread = Address;
		SymbolsDataSize--;//ok
	}
	else if (strcmp(Name, "DbgkForwardException") == 0)
	{
		SymbolsData.DbgkForwardException = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkMapViewOfSection") == 0)
	{
		SymbolsData.DbgkMapViewOfSection = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkUnMapViewOfSection") == 0)
	{
	    SymbolsData.DbgkUnMapViewOfSection = Address;
	    SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkpPostModuleMessages") == 0)
	{
		SymbolsData.DbgkpPostModuleMessages = Address;
		SymbolsDataSize--;
		MessageBoxA(NULL, "get DbgkpPostModuleMessages ok", "xxx", MB_ICONINFORMATION);
	}
	else if (strcmp(Name, "DbgkpQueueMessage") == 0)
	{
		SymbolsData.DbgkpQueueMessage = Address;
		SymbolsDataSize--;
	}

	else if (strcmp(Name, "DbgkpSendApiMessageLpc") == 0)
	{
		SymbolsData.DbgkpSendApiMessageLpc = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkpSendErrorMessage") == 0)
	{
		SymbolsData.DbgkpSendErrorMessage = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkpFreeDebugEvent") == 0)
	{
	   SymbolsData.DbgkpFreeDebugEvent = Address;
	   SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkpSuspendProcess") == 0)
	{
	    SymbolsData.DbgkpSuspendProcess = Address;
	    SymbolsDataSize--;
	}
	else if (strcmp(Name, "KeResumeThread") == 0)
	{
		SymbolsData.KeResumeThread = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "KiDispatchException") == 0)
	{
		SymbolsData.KiDispatchException = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ObDuplicateObject") == 0)
	{
		SymbolsData.ObDuplicateObject = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ObFastDereferenceObject") == 0)
	{
		SymbolsData.ObFastDereferenceObject = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ObFastReferenceObject") == 0)
	{
		SymbolsData.ObFastReferenceObject = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ObFastReferenceObjectLocked") == 0)
	{
		SymbolsData.ObFastReferenceObjectLocked = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsCallImageNotifyRoutines") == 0)
	{
		SymbolsData.PsCallImageNotifyRoutines = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsSuspendThread") == 0)
	{
		SymbolsData.PsSuspendThread = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsResumeThread") == 0)
	{
	    SymbolsData.PsResumeThread = Address;
	    SymbolsDataSize--;
	}
	
	else if (strcmp(Name, "PsSynchronizeWithThreadInsertion") == 0)
	{
	   SymbolsData.PsSynchronizeWithThreadInsertion = Address;
	   SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkExitThread") == 0)
	{
		SymbolsData.DbgkExitThread = Address;
		SymbolsDataSize--;
	}

	else if (strcmp(Name, "DbgkClearProcessDebugObject") == 0)
	{
		SymbolsData.DbgkClearProcessDebugObject = Address;
		SymbolsDataSize--;
	}

	else if (strcmp(Name, "PspExitThread") == 0)
	{
		SymbolsData.PspExitThread = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PspTerminateAllThreads") == 0)
	{
		SymbolsData.PspTerminateAllThreads = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PspProcessDelete") == 0)
	{
		SymbolsData.PspProcessDelete = Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PspNotifyEnableMask") == 0)
	{
		SymbolsData.PspNotifyEnableMask = (PULONG)Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "KiCheckForKernelApcDelivery") == 0)
	{
		SymbolsData.KiCheckForKernelApcDelivery = (PULONG)Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsQuerySystemDllInfo") == 0)
	{
		SymbolsData.PsQuerySystemDllInfo = (PULONG)Address;
		SymbolsDataSize--;
	}
	//else if (strcmp(Name, "ExAcquireRundownProtection_0") == 0)
	//{
	//   SymbolsData.ExAcquireRundownProtection_0 = (PULONG)Address;
	//   SymbolsDataSize--;
	//}
	else if (strcmp(Name, "PsFreezeProcess") == 0)
	{
		SymbolsData.PsFreezeProcess = (PULONG)Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsThawProcess") == 0)
	{
		SymbolsData.PsThawProcess = (PULONG)Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "ZwFlushInstructionCache") == 0)
	{
		SymbolsData.ZwFlushInstructionCache = (PULONG)Address;
		SymbolsDataSize--;
	}
	else if (strcmp(Name, "LpcRequestWaitReplyPortEx") == 0)
	{
       SymbolsData.LpcRequestWaitReplyPortEx = (PULONG)Address;
	   SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsGetNextProcessThread") == 0)
	{
	   SymbolsData.PsGetNextProcessThread = (PULONG)Address;
	   SymbolsDataSize--;
	}
	else if (strcmp(Name, "DbgkSendSystemDllMessages") == 0)
	{
	   SymbolsData.DbgkSendSystemDllMessages = (PULONG)Address;
	   SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsTestProtectedProcessIncompatibility") == 0)
	{
	   SymbolsData.PsTestProtectedProcessIncompatibility = (PULONG)Address;
	   SymbolsDataSize--;
	}
	else if (strcmp(Name, "PsRequestDebugSecureProcess") == 0)
	{
	SymbolsData.PsRequestDebugSecureProcess = (PULONG)Address;
	SymbolsDataSize--;
	}
	

	if (SymbolsDataSize == 0)
	{
		return FALSE;
	}
	return TRUE;

}

#include <string>
using namespace std;
bool LoadSymbols(const char* symbolPath)
{
	CSymbols Symbols(symbolPath);

	if (Symbols.GetSymbolsAll(&CallBack) && SymbolsDataSize <= 2)
	{
		return TRUE;
	}
	string msg = std::to_string(SymbolsDataSize);
	MessageBoxA(NULL, msg.c_str(), "xxx", MB_ICONINFORMATION);


	if (!SymbolsData.DbgkCopyProcessDebugPort)
	{
		MessageBoxA(NULL, "DbgkCopyProcessDebugPort", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkpSetProcessDebugObject)
	{
		MessageBoxA(NULL, "DbgkpSetProcessDebugObject", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkSendSystemDllMessages)
	{
		MessageBoxA(NULL, "DbgkSendSystemDllMessages", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkpMarkProcessPeb)
	{
		MessageBoxA(NULL, "DbgkpMarkProcessPeb", "xxx", MB_ICONINFORMATION);
	}	
	if (!SymbolsData.DbgkpMarkProcessPeb)
	{
		MessageBoxA(NULL, "DbgkpMarkProcessPeb", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkpSendApiMessageLpc)
	{
		MessageBoxA(NULL, "DbgkpSendApiMessageLpc", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkpSendErrorMessage)
	{
		MessageBoxA(NULL, "DbgkpSendErrorMessage", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkpPostFakeThreadMessages)
	{
		MessageBoxA(NULL, "DbgkpPostFakeThreadMessages", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkpPostFakeProcessCreateMessages)
	{
		MessageBoxA(NULL, "DbgkpPostFakeProcessCreateMessages", "xxx", MB_ICONINFORMATION);
	}	
	if (!SymbolsData.DbgkpFreeDebugEvent)
	{
		MessageBoxA(NULL, "DbgkpFreeDebugEvent", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkExitProcess)
	{
		MessageBoxA(NULL, "DbgkExitProcess", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkExitThread)
	{
		MessageBoxA(NULL, "DbgkExitThread", "xxx", MB_ICONINFORMATION);
	}
	
	if (!SymbolsData.KeResumeThread)
	{
		MessageBoxA(NULL, "KeResumeThread", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkpPostModuleMessages)
	{
		MessageBoxA(NULL, "DbgkpPostModuleMessages", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkpSuspendProcess)
	{
		MessageBoxA(NULL, "DbgkpSuspendProcess", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.ObDuplicateObject)
	{
		MessageBoxA(NULL, "ObDuplicateObject", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsSuspendThread)
	{
		MessageBoxA(NULL, "PsSuspendThread", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsResumeThread)
	{
		MessageBoxA(NULL, "PsResumeThread", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsCallImageNotifyRoutines)
	{
		MessageBoxA(NULL, "PsCallImageNotifyRoutines", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.ObFastReferenceObject)
	{
		MessageBoxA(NULL, "ObFastReferenceObject", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.ObFastReferenceObjectLocked)
	{
		MessageBoxA(NULL, "ObFastReferenceObjectLocked", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.ObFastDereferenceObject)
	{
		MessageBoxA(NULL, "ObFastDereferenceObject", "xxx", MB_ICONINFORMATION);
	}

	if (!SymbolsData.KiCheckForKernelApcDelivery)
	{
		MessageBoxA(NULL, "KiCheckForKernelApcDelivery", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsFreezeProcess)
	{
		MessageBoxA(NULL, "PsFreezeProcess", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsThawProcess)
	{
		MessageBoxA(NULL, "PsThawProcess", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsGetNextProcessThread)
	{
		MessageBoxA(NULL, "PsGetNextProcessThread", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsQuerySystemDllInfo)
	{
		MessageBoxA(NULL, "PsQuerySystemDllInfo", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.MmGetFileNameForSection)
	{
		MessageBoxA(NULL, "MmGetFileNameForSection", "xxx", MB_ICONINFORMATION);
	}
	
	//if (!SymbolsData.ExAcquireRundownProtection_0)
	//{
	//	MessageBoxA(NULL, "ExAcquireRundownProtection_0", "xxx", MB_ICONINFORMATION);
	//}
	
	
	if (!SymbolsData.ZwFlushInstructionCache)
	{
		MessageBoxA(NULL, "ZwFlushInstructionCache", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.LpcRequestWaitReplyPortEx)
	{
		MessageBoxA(NULL, "LpcRequestWaitReplyPortEx", "xxx", MB_ICONINFORMATION);
	}

	if (!SymbolsData.DbgkMapViewOfSection)
	{
		MessageBoxA(NULL, "DbgkMapViewOfSection", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.DbgkUnMapViewOfSection)
	{
		MessageBoxA(NULL, "DbgkUnMapViewOfSection", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsTestProtectedProcessIncompatibility)
	{
		MessageBoxA(NULL, "PsTestProtectedProcessIncompatibility", "xxx", MB_ICONINFORMATION);
	}
	if (!SymbolsData.PsRequestDebugSecureProcess)
	{
		MessageBoxA(NULL, "PsRequestDebugSecureProcess", "xxx", MB_ICONINFORMATION);
	}
	
	
	return FALSE;
}
```

`HyperDbgTool/Function.h`:

```h
#pragma once

typedef struct _SYMBOLS_DATA
{
	PVOID  DbgkExitThread;
	PVOID  DbgkClearProcessDebugObject;
	PVOID  DbgkSendSystemDllMessages;
	PVOID  PspExitThread;
	PVOID  PspTerminateAllThreads;
	PVOID  PspProcessDelete;
	PULONG PspNotifyEnableMask;
	PVOID  DbgkExitProcess;
	PVOID  DbgkpPostFakeThreadMessages;
	PVOID  DbgkpPostFakeProcessCreateMessages;
	PVOID  PsCallImageNotifyRoutines;
	PVOID  ObFastReferenceObjectLocked;
	PVOID  ObFastReferenceObject;
	PVOID  ObFastDereferenceObject;
	PVOID  DbgkpSendApiMessageLpc;
	PVOID  DbgkpSendErrorMessage;
	PVOID  DbgkpQueueMessage;
	PVOID  DbgkpSuspendProcess;
	PVOID  KiDispatchException;
	PVOID  DbgkForwardException;
	PVOID  DbgkMapViewOfSection;
	PVOID  DbgkCreateThread;
	PVOID  DbgkUnMapViewOfSection;
	PVOID  DbgkCopyProcessDebugPort;
	PVOID  DbgkOpenProcessDebugPort;
	PVOID  DbgkpSetProcessDebugObject;
	PVOID  DbgkpMarkProcessPeb;
	PVOID  PsSuspendThread;
	PVOID  PsResumeThread;
	PVOID  KeResumeThread;
	PVOID  PsSynchronizeWithThreadInsertion;
	PVOID  DbgkpPostModuleMessages;
	PVOID  DbgkpFreeDebugEvent;
	PVOID  DbgkpWakeTarget;
	PVOID  ObDuplicateObject;
	PVOID  KiCheckForKernelApcDelivery;
	PVOID  PsQuerySystemDllInfo;
	//PVOID  ExAcquireRundownProtection_0;
	PVOID  PsGetNextProcessThread;
	//PVOID  KeFreezeAllThreads;
	//PVOID  KeThawAllThreads;
	PVOID PsThawProcess;
	PVOID PsFreezeProcess;
	PVOID  ZwFlushInstructionCache;



	//////
	PVOID  PspActiveProcessLock;
	PVOID  ExfAcquirePushLockExclusive;
	PVOID  ExfTryToWakePushLock;
	PVOID  PspRemoveProcessFromJob;
	PVOID  PspDeleteLdt;
	PVOID  PsReturnProcessNonPagedPoolQuota;
	PVOID  AlpcpCleanupProcessViews;
	PVOID  ObDereferenceDeviceMap;
	PVOID  PspDereferenceQuotaBlock;
	PVOID  PsReturnProcessPagedPoolQuota;
	PVOID  ExDestroyHandle;
	PVOID  MmCleanProcessAddressSpace;
	PVOID  MmDeleteProcessAddressSpace;
	PVOID  MmGetFileNameForSection;
	PVOID  PspCidTable;
	PVOID  ObFastReplaceObject;
	PVOID  LpcRequestWaitReplyPortEx;
	PVOID  PsTestProtectedProcessIncompatibility;
	PVOID  PsRequestDebugSecureProcess;

}SYMBOLS_DATA,*PSYMBOLS_DATA;

bool LoadSymbols(const char* symbolPath);
```

`HyperDbgTool/HyperDbgTool.cpp`:

```cpp

// HyperDbgTool.cpp: 定义应用程序的类行为。
//

#include "pch.h"
#include "framework.h"
#include "HyperDbgTool.h"
#include "HyperDbgToolDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CHyperDbgToolApp

BEGIN_MESSAGE_MAP(CHyperDbgToolApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CHyperDbgToolApp 构造

CHyperDbgToolApp::CHyperDbgToolApp()
{
	// 支持重新启动管理器
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: 在此处添加构造代码，
	// 将所有重要的初始化放置在 InitInstance 中
}


// 唯一的 CHyperDbgToolApp 对象

CHyperDbgToolApp theApp;


// CHyperDbgToolApp 初始化

BOOL CHyperDbgToolApp::InitInstance()
{
	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// 将它设置为包括所有要在应用程序中使用的
	// 公共控件类。
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();


	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	CShellManager *pShellManager = new CShellManager;

	// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	SetRegistryKey(_T("应用程序向导生成的本地应用程序"));

	CHyperDbgToolDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: 在此放置处理何时用
		//  “确定”来关闭对话框的代码
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: 在此放置处理何时用
		//  “取消”来关闭对话框的代码
	}
	else if (nResponse == -1)
	{
		TRACE(traceAppMsg, 0, "警告: 对话框创建失败，应用程序将意外终止。\n");
		TRACE(traceAppMsg, 0, "警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n");
	}

	// 删除上面创建的 shell 管理器。
	if (pShellManager != nullptr)
	{
		delete pShellManager;
	}

#if !defined(_AFXDLL) && !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)
	ControlBarCleanUp();
#endif

	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
	//  而不是启动应用程序的消息泵。
	return FALSE;
}


```

`HyperDbgTool/HyperDbgTool.h`:

```h

// HyperDbgTool.h: PROJECT_NAME 应用程序的主头文件
//

#pragma once

#ifndef __AFXWIN_H__
	#error "在包含此文件之前包含 'pch.h' 以生成 PCH"
#endif

#include "resource.h"		// 主符号


// CHyperDbgToolApp:
// 有关此类的实现，请参阅 HyperDbgTool.cpp
//

class CHyperDbgToolApp : public CWinApp
{
public:
	CHyperDbgToolApp();

// 重写
public:
	virtual BOOL InitInstance();

// 实现

	DECLARE_MESSAGE_MAP()
};

extern CHyperDbgToolApp theApp;

```

`HyperDbgTool/HyperDbgTool.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\n"
    "LANGUAGE 4, 2\r\n"
    "#include ""res\\HyperDbgTool.rc2""  // 非 Microsoft Visual C++ 编辑的资源\r\n"
    "#include ""l.CHS\\afxres.rc""      // 标准组件\r\n"
    "#if !defined(_AFXDLL)\r\n"
    "#include ""l.CHS\\afxribbon.rc""   // MFC 功能区和控制条资源\r\n"
    "#endif\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\HyperDbgTool.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 HyperDbgTool"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,21,20
    LTEXT           "HyperDbgTool，版本 1.0",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "版权所有 (C) 2022",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

IDD_HYPERDBGTOOL_DIALOG DIALOGEX 0, 0, 320, 200
STYLE DS_SETFONT | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
EXSTYLE WS_EX_APPWINDOW
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CTEXT           "超级无敌vt调试器",IDC_STATIC,9,31,297,8
    PUSHBUTTON      "Start",IDC_BUTTON_START,68,123,50,14
    PUSHBUTTON      "stop",IDC_BUTTON_STOP,153,122,50,14
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404B0"
        BEGIN
            VALUE "CompanyName", "TODO: <公司名>"
            VALUE "FileDescription", "HyperDbgTool"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "HyperDbgTool.exe"
            VALUE "LegalCopyright", "TODO:  (C) <公司名>。  保留所有权利。"
            VALUE "OriginalFilename", "HyperDbgTool.exe"
            VALUE "ProductName", "TODO: <产品名>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_HYPERDBGTOOL_DIALOG, DIALOG
    BEGIN
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_HYPERDBGTOOL_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "关于 HyperDbgTool(&A)..."
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2
#include "res\HyperDbgTool.rc2"  // 非 Microsoft Visual C++ 编辑的资源
#include "l.CHS\afxres.rc"      // 标准组件
#if !defined(_AFXDLL)
#include "l.CHS\afxribbon.rc"   // MFC 功能区和控制条资源
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`HyperDbgTool/HyperDbgTool.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{1D006F03-96FA-418D-A0A5-244CE96877E5}</ProjectGuid>
    <Keyword>MFCProj</Keyword>
    <RootNamespace>HyperDbgTool</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_WINDOWS;NDEBUG;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_WINDOWS;_DEBUG;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="CLoadDriver.h" />
    <ClInclude Include="CSymbols.h" />
    <ClInclude Include="downloadSymbolsTest.h" />
    <ClInclude Include="framework.h" />
    <ClInclude Include="Function.h" />
    <ClInclude Include="HyperDbgTool.h" />
    <ClInclude Include="HyperDbgToolDlg.h" />
    <ClInclude Include="loadDriver.h" />
    <ClInclude Include="mylog.h" />
    <ClInclude Include="ntdll.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CSymbols.cpp" />
    <ClCompile Include="downloadSymbolsTest.cpp" />
    <ClCompile Include="Function.cpp" />
    <ClCompile Include="HyperDbgTool.cpp" />
    <ClCompile Include="HyperDbgToolDlg.cpp" />
    <ClCompile Include="loadDriver.cpp" />
    <ClCompile Include="mylog.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="HyperDbgTool.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\HyperDbgTool.rc2" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\HyperDbgTool.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HyperDbgTool/HyperDbgTool.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HyperDbgTool.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="HyperDbgToolDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="framework.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="ntdll.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Function.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="CSymbols.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="CLoadDriver.h">
      <Filter>源文件</Filter>
    </ClInclude>
    <ClInclude Include="loadDriver.h">
      <Filter>源文件</Filter>
    </ClInclude>
    <ClInclude Include="mylog.h">
      <Filter>源文件</Filter>
    </ClInclude>
    <ClInclude Include="downloadSymbolsTest.h">
      <Filter>源文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HyperDbgTool.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="HyperDbgToolDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="CSymbols.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Function.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="loadDriver.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="mylog.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="downloadSymbolsTest.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="HyperDbgTool.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\HyperDbgTool.rc2">
      <Filter>资源文件</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\HyperDbgTool.ico">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`HyperDbgTool/HyperDbgTool.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <RESOURCE_FILE>HyperDbgTool.rc</RESOURCE_FILE>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>WindowsRemoteDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`HyperDbgTool/HyperDbgToolDlg.cpp`:

```cpp

// HyperDbgToolDlg.cpp: 实现文件
//

#include "pch.h"
#include "framework.h"
#include "HyperDbgTool.h"
#include "HyperDbgToolDlg.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CHyperDbgToolDlg 对话框



CHyperDbgToolDlg::CHyperDbgToolDlg(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_HYPERDBGTOOL_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CHyperDbgToolDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CHyperDbgToolDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON_START, &CHyperDbgToolDlg::OnBnClickedButtonStart)
	ON_BN_CLICKED(IDC_BUTTON_STOP, &CHyperDbgToolDlg::OnBnClickedButtonStop)
END_MESSAGE_MAP()


// CHyperDbgToolDlg 消息处理程序

BOOL CHyperDbgToolDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();
	
	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != nullptr)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}
	
	// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	// TODO: 在此添加额外的初始化代码

	

	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CHyperDbgToolDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CHyperDbgToolDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CHyperDbgToolDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

#include "Function.h"
#include "loadDriver.h"
#include "CLoadDriver.h"
#define DriverName0 L"HyperVisor.sys"
#define DriverName L"HyperDbg.sys"
CLoadDriver Driver;
#define CTL_LOAD_DRIVER        0x800
#define CTL_UNLOAD_DRIVER      0x801

#include "downloadSymbolsTest.h"

void CHyperDbgToolDlg::OnBnClickedButtonStart()
{
	// TODO: 在此添加控件通知处理程序代码

	extern SYMBOLS_DATA SymbolsData;
	PVOID InBufer;
	ULONG Insize;
	PVOID OutBufer;
	ULONG Outsize;
	ULONG Retsize;
	InBufer = 0;

	OutBufer = 0;
	Outsize = 0;

	WCHAR DriverPatch[MAX_PATH];
	if (!GetCurrentDirectory(MAX_PATH, DriverPatch))
	{
		MessageBoxA(NULL, "GetCurrentDirectory failed", "error", MB_ICONERROR);
		return;
	}
	wcscat_s(DriverPatch, L"\\");
	wcscat_s(DriverPatch, DriverName0);
	installDriver(L"HyperVisor",L"HyperVisor", DriverPatch);
	startDriver(L"HyperVisor");

	char str[260] = "SRV*D:\\vt\\HyperHide-master\\x64\\Release\\Symbols*http://msdl.microsoft.com/download/symbols";

	if (Driver.Load(DriverName))
	{
		if (LoadSymbols(str))
		{
			InBufer = &SymbolsData;
			Insize = sizeof(SYMBOLS_DATA);
			if (!Driver.DeviceControl(CTL_CODE(FILE_DEVICE_UNKNOWN, CTL_LOAD_DRIVER, METHOD_BUFFERED, FILE_ANY_ACCESS), InBufer, Insize, OutBufer, Outsize, &Retsize))
			{
				char chmsg[260];
				sprintf_s(chmsg, "DeviceControl CTL_LOAD_DRIVER failed:%d", GetLastError());
				MessageBoxA(NULL,chmsg, "error", MB_ICONERROR);
			}		
		}
		else
		{
			MessageBoxA(NULL, "LoadSymbols error", "error", MB_ICONERROR);
		}
	}
	else
	{
		MessageBoxA(NULL, "Load driver failed", "error", MB_ICONERROR);
	}
}


void CHyperDbgToolDlg::OnBnClickedButtonStop()
{
	// TODO: 在此添加控件通知处理程序代码
	PVOID InBufer;
	ULONG Insize;
	PVOID OutBufer;
	ULONG Outsize;
	ULONG Retsize;
	InBufer = 0;
	Insize = 0;
	OutBufer = 0;
	Outsize = 0;
	if (Driver.DeviceControl(CTL_CODE(FILE_DEVICE_UNKNOWN, CTL_UNLOAD_DRIVER, METHOD_BUFFERED, FILE_ANY_ACCESS), InBufer, Insize, OutBufer, Outsize, &Retsize))
	{
		Driver.UnLoad(DriverName);
		//Sleep(5000);
		//stopDriver(L"HyperVisor");
	}
}

```

`HyperDbgTool/HyperDbgToolDlg.h`:

```h

// HyperDbgToolDlg.h: 头文件
//

#pragma once


// CHyperDbgToolDlg 对话框
class CHyperDbgToolDlg : public CDialogEx
{
// 构造
public:
	CHyperDbgToolDlg(CWnd* pParent = nullptr);	// 标准构造函数

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_HYPERDBGTOOL_DIALOG };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持


// 实现
protected:
	HICON m_hIcon;

	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnBnClickedButtonStart();
	afx_msg void OnBnClickedButtonStop();
};

```

`HyperDbgTool/downloadSymbolsTest.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#ifdef __cplusplus
extern "C"
{
#endif
#include "DbgHelp.h"//这里包含需要用C方式编译的头文件
#ifdef __cplusplus
}
#endif 
#pragma comment(lib , "DbgHelp.lib")
#pragma comment(lib , "ntdll.lib")
#define STATUS_UNSUCCESSFUL (0xC0000001L)
#define  SystemModuleInformation 11
#define STATUS_SUCCESS        0x00000000 
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)

extern "C" NTSTATUS __stdcall  ZwQuerySystemInformation(
    __in       ULONG SystemInformationClass,
    __inout    PVOID SystemInformation,
    __in       ULONG SystemInformationLength,
    __out_opt  PULONG ReturnLength
);


typedef BOOL(__stdcall* IMAGEUNLOAD)(
    __in  PLOADED_IMAGE LoadedImage
    );
IMAGEUNLOAD pImageUnload;
int FuncCount = 0;
typedef PLOADED_IMAGE(__stdcall* IMAGELOAD)(
    __in  PSTR DllName,
    __in  PSTR DllPath
    );
IMAGELOAD pImageLoad;


typedef BOOL(__stdcall* SYMGETSYMBOLFILE)(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PSTR DbgFile,
    __in size_t cDbgFile
    );
SYMGETSYMBOLFILE pSymGetSymbolFile;

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY
{
    ULONG Unknow1;
    ULONG Unknow2;
    ULONG Unknow3;
    ULONG Unknow4;
    PVOID Base;
    ULONG Size;
    ULONG Flags;
    USHORT Index;
    USHORT NameLength;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    char ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG Count;//内核中以加载的模块的个数
    SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

PLOADED_IMAGE pli;
typedef struct _tagSysModuleList {          //模块链结构
    ULONG ulCount;
    SYSTEM_MODULE_INFORMATION smi[2];
} MODULES, * PMODULES;


//-------------------------------------------------------------------------
//保存所有内核函数的一个结构
//-------------------------------------------------------------------------
typedef struct _KERNELFUNC_ADDRESS_INFORMATION {
    ULONG ulAddress;
    CHAR FuncName[50];
}KERNELFUNC_ADDRESS_INFORMATION, * PKERNELFUNC_ADDRESS_INFORMATION;

typedef struct _WIN32KFUNCINFO {          //PNTOSFUNCINFO
    ULONG ulCount;
    KERNELFUNC_ADDRESS_INFORMATION Win32KFuncInfo[1];
} WIN32KFUNCINFO, * PWIN32KFUNCINFO;

PWIN32KFUNCINFO FuncAddressInfo;




HANDLE hProcess;
BOOLEAN InitSymHandler()
{
    HANDLE hfile;
    char Path[MAX_PATH] = { 0 };
    char FileName[MAX_PATH] = { 0 };
    char SymPath[MAX_PATH * 2] = { 0 };
    char* SymbolsUrl = "http://msdl.microsoft.com/download/symbols";


    if (!GetCurrentDirectoryA(MAX_PATH, Path))//获取当前目录
    {
        printf("cannot get current directory \n");
        return FALSE;
    }

    strcat(Path, "\\Symbols");//比如:C:\Symbols
    CreateDirectoryA(Path, NULL);//创建目录

    //首先创建一个目录 symsrv.yes文件，symsrv.dll会检查，没有就会弹出一个对话框要求你点确认

    strcpy(FileName, Path);
    strcat(FileName, "\\symsrv.yes");

    printf("%s \n", FileName);

    hfile = CreateFileA(FileName,
        FILE_ALL_ACCESS,
        FILE_SHARE_READ,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hfile == INVALID_HANDLE_VALUE)
    {
        printf("create or open file error: 0x%X \n", GetLastError());
        return FALSE;

    }
    CloseHandle(hfile);

    Sleep(3000);

    hProcess = GetCurrentProcess();//获取当前进程

    //设置搜索参数：
    //SYMOPT_CASE_INSENSITIVE 该选项使得所有对符号名的搜索区分大小写
    //

    SymSetOptions(SYMOPT_CASE_INSENSITIVE | SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME);

    //设置搜索路径
    //程序会把win32k的pdb符号文件下载到这个目录Path
    SymSetSearchPath(hProcess, Path);

    //这个是不是很眼熟？
    //SRV*d:\localsymbols*http://msdl.microsoft.com/download/symbols
    sprintf(SymPath, "SRV*%s*%s", Path, SymbolsUrl);

    //在这里初始化
    if (!SymInitialize(hProcess,
        SymPath,
        TRUE))
    {
        printf("SymInitialize failed %d \n", GetLastError());
        return FALSE;
    }//初始化符号
    return TRUE;
}

ULONG GetKernelInfo(char* lpKernelName, ULONG* ulBase, ULONG* ulSize)
{
    DWORD    dwsize;
    DWORD    dwSizeReturn;
    PUCHAR    pBuffer = NULL;

    PMODULES    pSmi = NULL;
    NTSTATUS    ntStatus = STATUS_UNSUCCESSFUL;

    //明明是内核的api，怎么能在驱动层调用呢？
    //ntdll!ZwQuerySystemInformation 
    //ntdll!NtQuerySystemInformation
    //所以，我们在这里调用的是ntdll的函数，而不是ntoskrnel.exe
    ntStatus = ZwQuerySystemInformation(
        SystemModuleInformation,
        pSmi,
        0,
        &dwSizeReturn
    );
    if (ntStatus != STATUS_INFO_LENGTH_MISMATCH)
    {
        return 0;
    }
    dwsize = dwSizeReturn * 2;
    pSmi = (PMODULES)new char[dwsize];
    if (pSmi == NULL)
    {
        return 0;
    }

    ntStatus = ZwQuerySystemInformation(
        SystemModuleInformation,
        pSmi,
        dwsize,
        &dwSizeReturn
    );
    if (ntStatus != STATUS_SUCCESS)
    {
        return 0;
    }
    for (int i = 0; i < pSmi->ulCount; i++)
    {
        //循环从链表对比
        if (_stricmp(pSmi->smi[i].Module->ImageName, lpKernelName) == 0)
        {
            printf("found %08X %X\,,%s,,,r\n", pSmi->smi[i].Module->Base, pSmi->smi[i].Module->Size, pSmi->smi[i].Module->ImageName);
            *ulBase = (ULONG)pSmi->smi[i].Module->Base;
            *ulSize = pSmi->smi[i].Module->Size;
            break;
        }
    }
    delete pSmi;

    return TRUE;
}


BOOLEAN LoadSymModule(
    char* ImageName,
    DWORD ModuleBase)
{
    DWORD64 tmp;
    char    SymFileName[MAX_PATH] = { 0 };
    BOOL bRetOK = FALSE;

    HINSTANCE hmod = LoadLibraryA("Imagehlp.dll");
    if (!hmod)
        return FALSE;

    pImageLoad = (IMAGELOAD)GetProcAddress(hmod, "ImageLoad");
    pImageUnload = (IMAGEUNLOAD)GetProcAddress(hmod, "ImageUnload");
    if (!pImageLoad ||
        !pImageUnload)
        return FALSE;

    pli = pImageLoad(ImageName, NULL);
    if (pli == NULL)
    {
        printf("cannot get loaded module of %s \n", ImageName);
        return FALSE;
    }
    printf("ModuleName:%s:%08x\n", pli->ModuleName, pli->SizeOfImage);

    HINSTANCE hDbgHelp = LoadLibraryA("dbghelp.dll");
    if (!hDbgHelp)
        return FALSE;

    pSymGetSymbolFile = (SYMGETSYMBOLFILE)GetProcAddress(hDbgHelp, "SymGetSymbolFile");
    if (!pSymGetSymbolFile) {
        printf("pSymGetSymbolFile() failed %X\r\n", pSymGetSymbolFile);
        return FALSE;
    }
    //欲解析符号前,使用SymGetSymbolFile来取得符号文件,如果搜索路径没有这个文件,那么将从微软服务器下载win32k的pdb,然后调用SymLoadModule64加载解析它咯
    if (pSymGetSymbolFile(hProcess,
        NULL,
        pli->ModuleName,
        sfPdb,
        SymFileName,
        MAX_PATH,
        SymFileName,
        MAX_PATH))
    {
        //然后调用SymLoadModule64加载它咯
        tmp = SymLoadModule64(hProcess,
            pli->hFile,
            pli->ModuleName,
            NULL,
            (DWORD64)ModuleBase,
            pli->SizeOfImage);
        if (tmp)
        {
            bRetOK = TRUE;
        }
    }
    //加载了，就要卸载
    //申请了内存，就要释放一样的道理
    //学java的同学要注意。
    pImageUnload(pli);
    return bRetOK;
}


BOOLEAN EnumSyms(
    char* ImageName,
    DWORD ModuleBase,
    PSYM_ENUMERATESYMBOLS_CALLBACK EnumRoutine,
    PVOID Context)
{
    BOOLEAN bEnum;

    //首先加载符号模块
    if (!LoadSymModule(ImageName, ModuleBase))
    {
        printf("cannot load symbols ,error: %d \n", GetLastError());
        return FALSE;
    }
    //解析符号
    bEnum = SymEnumSymbols(hProcess,
        ModuleBase,
        NULL,
        EnumRoutine, //有一个回调
        Context);
    if (!bEnum)
    {
        printf("cannot enum symbols ,error: %d \n", GetLastError());
    }
    return bEnum;
}


//这个就是回调函数
BOOLEAN CALLBACK EnumSymRoutine(
    PSYMBOL_INFO psi,
    ULONG     SymSize,
    PVOID     Context)
{
    if (_stricmp(psi->Name, "NtUserFindWindowEx") == 0)
    {
        /*
            typedef struct _WIN32KFUNCINFO {          //PNTOSFUNCINFO
            ULONG ulCount;
            KERNELFUNC_ADDRESS_INFORMATION Win32KFuncInfo[1];
        } WIN32KFUNCINFO, *PWIN32KFUNCINFO;

        PWIN32KFUNCINFO FuncAddressInfo;
        */
        FuncAddressInfo->Win32KFuncInfo[FuncCount].ulAddress = (ULONG)psi->Address;
        strcat(FuncAddressInfo->Win32KFuncInfo[FuncCount].FuncName, psi->Name);
        FuncCount++;
    }
    if (_stricmp(psi->Name, "NtUserQueryWindow") == 0)
    {
        FuncAddressInfo->Win32KFuncInfo[FuncCount].ulAddress = (ULONG)psi->Address;
        strcat(FuncAddressInfo->Win32KFuncInfo[FuncCount].FuncName, psi->Name);
        FuncCount++;
    }
    FuncAddressInfo->ulCount = FuncCount;
    return TRUE;
}


int downloadSymbolsTest()
{
    ULONG ulBase;
    ULONG ulSize;
    //先初始化符号
    if (InitSymHandler())
    {
        if (GetKernelInfo("\\SystemRoot\\System32\\ntoskrnl.exe", &ulBase, &ulSize))
        {

            FuncAddressInfo = (PWIN32KFUNCINFO)VirtualAlloc(0, (sizeof(WIN32KFUNCINFO) + sizeof(KERNELFUNC_ADDRESS_INFORMATION)) * 10, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
            if (FuncAddressInfo)//分配成功的话
            {
                memset(FuncAddressInfo, 0, (sizeof(WIN32KFUNCINFO) + sizeof(KERNELFUNC_ADDRESS_INFORMATION)) * 10);

                //到这里，开始枚举（并且保存到结构体）
                EnumSyms("ntoskrnl.exe", ulBase, (PSYM_ENUMERATESYMBOLS_CALLBACK)EnumSymRoutine, NULL);

                //要接触加载
                SymUnloadModule64(GetCurrentProcess(), ulBase);

                //清理
                SymCleanup(GetCurrentProcess());

                for (int i = 0; i < FuncAddressInfo->ulCount; i++)
                {
                    //打印测试
                    printf("%s[0x%08X]\r\n", FuncAddressInfo->Win32KFuncInfo[i].FuncName, FuncAddressInfo->Win32KFuncInfo[i].ulAddress);
                }
                //传到内核（用到我们学到的通信了吧）
                //CallDriver(WIN32K_FUNCTION,FuncAddressInfo,(sizeof(WIN32KFUNCINFO)+sizeof(KERNELFUNC_ADDRESS_INFORMATION))*10);
            }
        }
    }
    getchar();
    return 0;
}
```

`HyperDbgTool/downloadSymbolsTest.h`:

```h
#pragma once

int downloadSymbolsTest();
```

`HyperDbgTool/framework.h`:

```h
#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

// 关闭 MFC 的一些常见且经常可放心忽略的隐藏警告消息
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展


#include <afxdisp.h>        // MFC 自动化类



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // MFC 支持功能区和控制条









#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`HyperDbgTool/loadDriver.cpp`:

```cpp
#include "loadDriver.h"
#include "mylog.h"
#include <Shlwapi.h>

bool installDriver(LPCWSTR serviceName, LPCWSTR displayName, LPCWSTR driverFilePath)//安装
{
	bool bok = false;
	char chServiceName[260];
	SHTCharToAnsi(serviceName, chServiceName, 260);
	SC_HANDLE schSCManager;
	schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (schSCManager)
	{
		SC_HANDLE schService = CreateService(schSCManager,
			serviceName,
			displayName,
			SERVICE_ALL_ACCESS,
			SERVICE_KERNEL_DRIVER, //创建的服务类型1为驱动服务
			SERVICE_DEMAND_START, //用于当有进程调用StartService 函数时由服务控制管理器(SCM)启动的服务
			SERVICE_ERROR_IGNORE,
			driverFilePath,//驱动文件放路径
			NULL,
			NULL,
			NULL,
			NULL,
			NULL);
		if (schService)
		{
			WriteLog(1,1,"install service:%s ok", chServiceName);
			CloseServiceHandle(schService); //创建完记得释放句柄
			bok = true;
		}
		else
		{
			WriteLog(1,1,"install driver %s failed:%d", chServiceName, GetLastError());
		}

		CloseServiceHandle(schSCManager);
	}

	return bok;
}

bool unloadDriver(LPCWSTR serviceName)//卸载
{
	bool bok = false;
	char chServiceName[260];
	SHTCharToAnsi(serviceName, chServiceName, 260);
	SC_HANDLE schSCManager;
	SC_HANDLE hs;
	schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (schSCManager)
	{
		hs = OpenService(schSCManager, serviceName, SERVICE_ALL_ACCESS); //打开服务
		if (hs)
		{
			bool a = DeleteService(hs);   //删除服务
			if (!a)
			{
				WriteLog(1,1,"DeleteService:%s failed", chServiceName);
			}
			else
			{
				bok = true;
				WriteLog(1,1,"DeleteService:%s ok", chServiceName);
			}

			CloseServiceHandle(hs);//释放完后可完服务可从服务表中消失 释放前是
		}
		CloseServiceHandle(schSCManager);
	}
	return bok;
}

void startDriver(LPCWSTR serviceName)//启动
{
	SC_HANDLE schSCManager;
	SC_HANDLE hs;
	schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (schSCManager)
	{
		hs = OpenService(schSCManager, serviceName, SERVICE_ALL_ACCESS); //打开服务
		char chserviceName[260];
		SHTCharToAnsi(serviceName, chserviceName, 260);
		if (hs)
		{
			SERVICE_STATUS serviceStatus;
			BOOL bqueryok = QueryServiceStatus(hs, &serviceStatus);
			if (bqueryok)
			{
				if (serviceStatus.dwCurrentState == SERVICE_STOPPED)
				{
					if (StartService(hs, 0, 0))
					{
						WriteLog(1,1,"start service:%s ok", chserviceName);
					}
					else
					{
						WriteLog(1,1,"start service:%s failed:%d", chserviceName, GetLastError());
					}
				}
				else if (serviceStatus.dwCurrentState == SERVICE_RUNNING)
				{
					WriteLog(1,1,"service:%s is running", chserviceName);
				}
			}
			else
			{
				WriteLog(1,1,"QueryServiceStatus failed:%d, start service:%s failed", GetLastError(), chserviceName);
			}

			CloseServiceHandle(hs);
		}
		else
		{
			WriteLog(1,1,"service:%s have not install yet", chserviceName);
		}
		CloseServiceHandle(schSCManager);
	}
}

void stopDriver(LPCWSTR serviceName)//停止
{
	char chServiceName[260];
	SHTCharToAnsi(serviceName, chServiceName, 260);
	SC_HANDLE schSCManager;
	SC_HANDLE hs;
	schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (schSCManager)
	{
		hs = OpenService(schSCManager, serviceName, SERVICE_ALL_ACCESS); //打开服务
		if (hs)
		{
			SERVICE_STATUS status;
			int num = 0;
			if (QueryServiceStatus(hs, &status))
			{
				//if (status.dwCurrentState != SERVICE_STOPPED && status.dwCurrentState != SERVICE_STOP_PENDING)
				if (status.dwCurrentState == SERVICE_RUNNING)
				{
					ControlService(hs, SERVICE_CONTROL_STOP, &status);
					do
					{
						Sleep(50);
						num++;
						QueryServiceStatus(hs, &status);
					} while (status.dwCurrentState != SERVICE_STOPPED || num < 80);
					if (num > 80)
					{
						WriteLog(1,1,"stop service:%s failed:%d", chServiceName, GetLastError());
					}
					else
					{
						WriteLog(1,1,"stop service:%s service ok", chServiceName);
					}
				}
				else if (status.dwCurrentState == SERVICE_STOPPED)
				{
					WriteLog(1,1,"service:%s has been stoped", chServiceName);
				}
				else if (status.dwCurrentState == ERROR_SERVICE_DOES_NOT_EXIST)
				{
					WriteLog(1,1,"service:%s not exist", chServiceName);
				}
				else
				{
					WriteLog(1,1,"service:%s status:%d", chServiceName, status.dwCurrentState);
				}
			}

			CloseServiceHandle(hs);
		}
		CloseServiceHandle(schSCManager);
	}
}


```

`HyperDbgTool/loadDriver.h`:

```h
#pragma once

#include <Windows.h>
bool installDriver(LPCWSTR serviceName, LPCWSTR displayName, LPCWSTR driverFilePath);
void startDriver(LPCWSTR serviceName);//启动驱动
void stopDriver(LPCWSTR serviceName);//停止驱动
bool unloadDriver(LPCWSTR serviceName);//卸载驱动
```

`HyperDbgTool/mylog.cpp`:

```cpp
#include  "pch.h"
#include <Windows.h>
#include <iostream>

char g_szLogFileName[MAX_PATH] = { 0 };
#define MaxLogLen 1024*10
#define MaxLogFileLen 1024*1024

void GetRunPathA(char* lpPath)
{
	if (lpPath == NULL) return;

	GetModuleFileNameA(NULL, lpPath, MAX_PATH);

	for (int i = strlen(lpPath) - 1; i > 0; i--)
	{
		if (lpPath[i] == '\\')
		{
			lpPath[i] = '\0';
			break;
		}
	}
}

void GetLogFileName()
{
	//取临时日志文件的名字
	if (strlen(g_szLogFileName) <= 0)
	{
		WCHAR wcsTemp[MAX_PATH] = { 0 };
		char csTemp[MAX_PATH] = { 0 };
		GetRunPathA(csTemp);
		strcat_s(csTemp, "\\HyperDbgTool.log");
		strcpy_s(g_szLogFileName, csTemp);
	}
}

void WriteLog(bool bOutput, bool bWantProcessName, const char* fmt, ...)//其实就是WriteLogFile
{
	if (!bOutput) return;

	GetLogFileName();

	HANDLE hFile = INVALID_HANDLE_VALUE;
	hFile = CreateFileA(g_szLogFileName, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		return;
	}
	va_list args;
	char temp[MaxLogLen] = { 0 };
	DWORD dwFileLen = GetFileSize(hFile, NULL);
	if (dwFileLen > MaxLogFileLen)//避免文件太大造成假死
	{
		SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
		SetEndOfFile(hFile);
	}
	else
	{
		SetFilePointer(hFile, 0, NULL, FILE_END);
	}

	SYSTEMTIME time;
	GetLocalTime(&time);
	sprintf_s(temp, "%d-%d-%d %d:%d:%d ", time.wYear, time.wMonth, time.wDay, time.wHour, time.wMinute, time.wSecond);

	DWORD dw;
	if (bWantProcessName)
	{
		char modname[MAX_PATH];
		GetModuleFileNameA(NULL, modname, sizeof(modname));
		wsprintfA(temp + strlen(temp), "%s:", modname);
	}
	va_start(args, fmt);
	vsprintf(temp + strlen(temp), fmt, args);
	va_end(args);

	strcat_s(temp, "\r\n");
	WriteFile(hFile, temp, strlen(temp), &dw, NULL);

	CloseHandle(hFile);
}
```

`HyperDbgTool/mylog.h`:

```h
#pragma once

void WriteLog(bool bOutput, bool bWantProcessName, const char* fmt, ...);
```

`HyperDbgTool/ntdll.h`:

```h
#pragma once
#include <Windows.h>
#include <ImageHlp.h>
#include "CSymbols.h"


typedef NTSTATUS(*ZWQUERYSYSTEMINFORMATION)
(
    IN ULONG	SystemInformationClass,
    OUT PVOID	SystemInformation,
    IN ULONG	Length,
    OUT PULONG	ReturnLength
    );

typedef unsigned long DWORD;

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY
{
    ULONG Unknow1;
    ULONG Unknow2;
    ULONG Unknow3;
    ULONG Unknow4;
    PVOID Base;
    ULONG Size;
    ULONG Flags;
    USHORT Index;
    USHORT NameLength;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    char ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG Count;//内核中以加载的模块的个数
    SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;


#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

```

`HyperDbgTool/pch.cpp`:

```cpp
// pch.cpp: 与预编译标头对应的源文件

#include "pch.h"

// 当使用预编译的头时，需要使用此源文件，编译才能成功。

```

`HyperDbgTool/pch.h`:

```h
// pch.h: 这是预编译标头文件。
// 下方列出的文件仅编译一次，提高了将来生成的生成性能。
// 这还将影响 IntelliSense 性能，包括代码完成和许多代码浏览功能。
// 但是，如果此处列出的文件中的任何一个在生成之间有更新，它们全部都将被重新编译。
// 请勿在此处添加要频繁更新的文件，这将使得性能优势无效。

#ifndef PCH_H
#define PCH_H

// 添加要在此处预编译的标头
#include "framework.h"

#endif //PCH_H

```

`HyperDbgTool/res/HyperDbgTool.rc2`:

```rc2
//
// HyperDbgTool.rc2 - Microsoft Visual C++ 不会直接编辑的资源
//

#ifdef APSTUDIO_INVOKED
#error 此文件不能用 Microsoft Visual C++ 编辑
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// 在此处添加手动编辑的资源...

/////////////////////////////////////////////////////////////////////////////

```

`HyperDbgTool/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 HyperDbgTool.rc 使用
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_HYPERDBGTOOL_DIALOG         102
#define IDR_MAINFRAME                   128
#define IDC_BUTTON_START                1000
#define IDC_BUTTON_STOP                 1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`HyperDbgTool/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`HyperHide.ini`:

```ini
[SETTINGS]
CurrentProfile=Default Create Process
[Default Create Process]
NtQueryInformationProcess=1
NtQueryInformationJobObject=1
NtQueryObject=1
NtQueryPerformanceCounter=1
NtQuerySystemInformation=1
NtQuerySystemTime=1
NtClose=1
NtGetContextThread=1
NtSetContextThread=1
NtContinue=1
NtCreateUserProcess=1
NtCreateProcessEx=1
NtCreateThreadEx=1
NtGetNextProcess=1
NtOpenThread=1
NtOpenProcess=1
NtCreateFile=1
NtYieldExecution=1
NtSystemDebugControl=1
NtSetInformationThread=1
NtUserBuildHwndList=1
NtUserFindWindowEx=1
NtUserGetForegroundWindow=1
NtUserQueryWindow=1
KiExceptionDispatch=1
HookKuserSharedData=1
HeapFlags=1
ClearKuserSharedData=0
ThreadHideFromDebuggerFlag=0
ThreadBypassProcessFreeze=0
NtQueryInformationThread=1
NtSetInformationProcess=1
ProcessBreakOnTerminationFlag=0
ThreadBreakOnTerminationFlag=0
ProcessDebugFlags=0
ProcessHandleTracing=0
PebBeingDebugged=1
PebNtGlobalFlag=1
[Default Attach]
NtQueryInformationProcess=1
NtQueryInformationJobObject=1
NtQueryInformationThread=1
NtQueryObject=1
NtQueryPerformanceCounter=1
NtQuerySystemInformation=1
NtQuerySystemTime=1
NtClose=1
NtGetContextThread=1
NtSetContextThread=1
NtContinue=1
NtCreateUserProcess=1
NtCreateProcessEx=1
NtCreateThreadEx=1
NtGetNextProcess=1
NtOpenThread=1
NtOpenProcess=1
NtCreateFile=1
NtYieldExecution=1
NtSystemDebugControl=1
NtSetInformationThread=1
NtSetInformationProcess=1
NtUserBuildHwndList=1
NtUserFindWindowEx=1
NtUserGetForegroundWindow=1
NtUserQueryWindow=1
KiExceptionDispatch=1
HookKuserSharedData=1
HeapFlags=0
ClearKuserSharedData=0
ThreadHideFromDebuggerFlag=1
ThreadBypassProcessFreeze=1
ProcessBreakOnTerminationFlag=1
ThreadBreakOnTerminationFlag=1
ProcessDebugFlags=1
ProcessHandleTracing=1
PebBeingDebugged=1
PebNtGlobalFlag=0
[Themida]
NtQueryInformationProcess=1
NtQueryInformationJobObject=0
NtQueryInformationThread=0
NtQueryObject=0
NtQueryPerformanceCounter=0
NtQuerySystemInformation=1
NtQuerySystemTime=0
NtClose=0
NtGetContextThread=0
NtSetContextThread=0
NtContinue=0
NtCreateUserProcess=0
NtCreateProcessEx=0
NtCreateThreadEx=0
NtGetNextProcess=0
NtOpenThread=0
NtOpenProcess=0
NtCreateFile=0
NtYieldExecution=0
NtSystemDebugControl=0
NtSetInformationThread=0
NtSetInformationProcess=0
NtUserBuildHwndList=1
NtUserFindWindowEx=1
NtUserGetForegroundWindow=1
NtUserQueryWindow=1
KiExceptionDispatch=0
HookKuserSharedData=0
HeapFlags=1
ClearKuserSharedData=0
ThreadHideFromDebuggerFlag=0
ThreadBypassProcessFreeze=0
ProcessBreakOnTerminationFlag=0
ThreadBreakOnTerminationFlag=0
ProcessDebugFlags=0
ProcessHandleTracing=0
PebBeingDebugged=1
PebNtGlobalFlag=1
[VMProtect]
NtQueryInformationProcess=1
NtQueryInformationJobObject=0
NtQueryInformationThread=0
NtQueryObject=1
NtQueryPerformanceCounter=0
NtQuerySystemInformation=0
NtQuerySystemTime=0
NtClose=1
NtGetContextThread=0
NtSetContextThread=0
NtContinue=0
NtCreateUserProcess=0
NtCreateProcessEx=0
NtCreateThreadEx=0
NtGetNextProcess=0
NtOpenThread=0
NtOpenProcess=0
NtCreateFile=0
NtYieldExecution=0
NtSystemDebugControl=0
NtSetInformationThread=1
NtSetInformationProcess=0
NtUserBuildHwndList=0
NtUserFindWindowEx=0
NtUserGetForegroundWindow=0
NtUserQueryWindow=0
KiExceptionDispatch=0
HookKuserSharedData=0
HeapFlags=1
ClearKuserSharedData=0
ThreadHideFromDebuggerFlag=0
ThreadBypassProcessFreeze=0
ProcessBreakOnTerminationFlag=0
ThreadBreakOnTerminationFlag=0
ProcessDebugFlags=0
ProcessHandleTracing=0
[Obsidium]
NtQueryInformationProcess=1
NtQueryInformationJobObject=0
NtQueryInformationThread=0
NtQueryObject=0
NtQueryPerformanceCounter=0
NtQuerySystemInformation=1
NtQuerySystemTime=0
NtClose=1
NtGetContextThread=0
NtSetContextThread=0
NtContinue=0
NtCreateUserProcess=0
NtCreateProcessEx=0
NtCreateThreadEx=0
NtGetNextProcess=0
NtOpenThread=0
NtOpenProcess=0
NtCreateFile=0
NtYieldExecution=0
NtSystemDebugControl=0
NtSetInformationThread=0
NtSetInformationProcess=1
NtUserBuildHwndList=1
NtUserFindWindowEx=1
NtUserGetForegroundWindow=1
NtUserQueryWindow=1
KiExceptionDispatch=0
HookKuserSharedData=0
HeapFlags=1
ClearKuserSharedData=0
ThreadHideFromDebuggerFlag=0
ThreadBypassProcessFreeze=0
ProcessBreakOnTerminationFlag=0
ThreadBreakOnTerminationFlag=0
ProcessDebugFlags=0
ProcessHandleTracing=0
PebBeingDebugged=1
PebNtGlobalFlag=1
[Disabled]
NtQueryInformationProcess=0
NtQueryInformationJobObject=0
NtQueryObject=0
NtQueryPerformanceCounter=0
NtQuerySystemInformation=0
NtQuerySystemTime=0
NtClose=0
NtGetContextThread=0
NtSetContextThread=0
NtContinue=0
NtCreateUserProcess=0
NtCreateProcessEx=0
NtCreateThreadEx=0
NtGetNextProcess=0
NtOpenThread=0
NtOpenProcess=0
NtCreateFile=0
NtYieldExecution=0
NtSystemDebugControl=0
NtSetInformationThread=0
NtUserBuildHwndList=0
NtUserFindWindowEx=0
NtUserGetForegroundWindow=0
NtUserQueryWindow=0
KiExceptionDispatch=0
HookKuserSharedData=0
HeapFlags=0
ClearKuserSharedData=0
ThreadHideFromDebuggerFlag=0
ThreadBypassProcessFreeze=0
NtSetInformationProcess=0
ProcessBreakOnTerminationFlag=0
ThreadBreakOnTerminationFlag=0
ProcessDebugFlags=0
ProcessHandleTracing=0
NtQueryInformationThread=0

```

`HyperHide.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31313.79
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HyperHide", "HyperHide\HyperHide.vcxproj", "{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HyperHideDrv", "HyperHideDrv\HyperHideDrv.vcxproj", "{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HyperDbgTool", "HyperDbgTool\HyperDbgTool.vcxproj", "{1D006F03-96FA-418D-A0A5-244CE96877E5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}.Debug|x64.ActiveCfg = Debug|x64
		{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}.Debug|x64.Build.0 = Debug|x64
		{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}.Debug|x86.ActiveCfg = Debug|Win32
		{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}.Debug|x86.Build.0 = Debug|Win32
		{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}.Release|x64.ActiveCfg = Release|x64
		{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}.Release|x64.Build.0 = Release|x64
		{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}.Release|x86.ActiveCfg = Release|Win32
		{062CB708-969A-4A0D-8A4C-3C2ADE786BCA}.Release|x86.Build.0 = Release|Win32
		{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}.Debug|x64.ActiveCfg = Debug|x64
		{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}.Debug|x64.Build.0 = Debug|x64
		{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}.Debug|x64.Deploy.0 = Debug|x64
		{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}.Debug|x86.ActiveCfg = Debug|x64
		{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}.Release|x64.ActiveCfg = Release|x64
		{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}.Release|x64.Build.0 = Release|x64
		{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}.Release|x64.Deploy.0 = Release|x64
		{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}.Release|x86.ActiveCfg = Release|x64
		{1D006F03-96FA-418D-A0A5-244CE96877E5}.Debug|x64.ActiveCfg = Debug|x64
		{1D006F03-96FA-418D-A0A5-244CE96877E5}.Debug|x64.Build.0 = Debug|x64
		{1D006F03-96FA-418D-A0A5-244CE96877E5}.Debug|x86.ActiveCfg = Debug|Win32
		{1D006F03-96FA-418D-A0A5-244CE96877E5}.Debug|x86.Build.0 = Debug|Win32
		{1D006F03-96FA-418D-A0A5-244CE96877E5}.Release|x64.ActiveCfg = Release|x64
		{1D006F03-96FA-418D-A0A5-244CE96877E5}.Release|x64.Build.0 = Release|x64
		{1D006F03-96FA-418D-A0A5-244CE96877E5}.Release|x86.ActiveCfg = Release|Win32
		{1D006F03-96FA-418D-A0A5-244CE96877E5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {76619BE2-56D9-493D-AB43-205FF39B24D1}
	EndGlobalSection
EndGlobal

```

`HyperHide/HyperHide.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{062cb708-969a-4a0d-8a4c-3c2ade786bca}</ProjectGuid>
    <RootNamespace>HyperHide</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dp32</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp32</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetExt>.dp64</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp64</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;HYPERHIDE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;HYPERHIDE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;HYPERHIDE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;HYPERHIDE_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="HyperHideDrv.h" />
    <ClInclude Include="IniApi.h" />
    <ClInclude Include="Ioctl.h" />
    <ClInclude Include="Pluginconfig.h" />
    <ClInclude Include="Pluginmain.h" />
    <ClInclude Include="pluginsdk\bridgegraph.h" />
    <ClInclude Include="pluginsdk\bridgelist.h" />
    <ClInclude Include="pluginsdk\bridgemain.h" />
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h" />
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h" />
    <ClInclude Include="pluginsdk\jansson\jansson.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_config.h" />
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h" />
    <ClInclude Include="pluginsdk\lz4\lz4.h" />
    <ClInclude Include="pluginsdk\lz4\lz4file.h" />
    <ClInclude Include="pluginsdk\lz4\lz4hc.h" />
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h" />
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h" />
    <ClInclude Include="pluginsdk\_dbgfunctions.h" />
    <ClInclude Include="pluginsdk\_plugins.h" />
    <ClInclude Include="pluginsdk\_plugin_types.h" />
    <ClInclude Include="pluginsdk\_scriptapi.h" />
    <ClInclude Include="pluginsdk\_scriptapi_argument.h" />
    <ClInclude Include="pluginsdk\_scriptapi_assembler.h" />
    <ClInclude Include="pluginsdk\_scriptapi_bookmark.h" />
    <ClInclude Include="pluginsdk\_scriptapi_comment.h" />
    <ClInclude Include="pluginsdk\_scriptapi_debug.h" />
    <ClInclude Include="pluginsdk\_scriptapi_flag.h" />
    <ClInclude Include="pluginsdk\_scriptapi_function.h" />
    <ClInclude Include="pluginsdk\_scriptapi_gui.h" />
    <ClInclude Include="pluginsdk\_scriptapi_label.h" />
    <ClInclude Include="pluginsdk\_scriptapi_memory.h" />
    <ClInclude Include="pluginsdk\_scriptapi_misc.h" />
    <ClInclude Include="pluginsdk\_scriptapi_module.h" />
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h" />
    <ClInclude Include="pluginsdk\_scriptapi_register.h" />
    <ClInclude Include="pluginsdk\_scriptapi_stack.h" />
    <ClInclude Include="pluginsdk\_scriptapi_symbol.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="Settings.h" />
    <ClInclude Include="Tooltips.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HyperHideDrv.cpp" />
    <ClCompile Include="IniApi.cpp" />
    <ClCompile Include="Pluginmain.cpp" />
    <ClCompile Include="Settings.cpp" />
    <ClCompile Include="Tooltips.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="HyperHideIcon.png" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HyperHide/HyperHide.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="pluginsdk">
      <UniqueIdentifier>{dab66bff-41b8-4565-9014-fcbdfb5f90ef}</UniqueIdentifier>
    </Filter>
    <Filter Include="pluginsdk\XEDParse">
      <UniqueIdentifier>{55fdb174-9c3c-4aa1-a29e-633b2116b0e2}</UniqueIdentifier>
    </Filter>
    <Filter Include="pluginsdk\TitanEngine">
      <UniqueIdentifier>{b509bc64-712e-4f1d-8fcd-8464ab18027d}</UniqueIdentifier>
    </Filter>
    <Filter Include="pluginsdk\lz4">
      <UniqueIdentifier>{f1442a93-12a2-4f66-804f-1736a7cff4e9}</UniqueIdentifier>
    </Filter>
    <Filter Include="pluginsdk\jansson">
      <UniqueIdentifier>{90b96485-c119-4993-bb63-6ea7a28c19c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="pluginsdk\DeviceNameResolver">
      <UniqueIdentifier>{3d0c3f46-f5e3-4201-ae30-650129cdb2fd}</UniqueIdentifier>
    </Filter>
    <Filter Include="pluginsdk\dbghelp">
      <UniqueIdentifier>{94f82481-a832-4632-8075-fa3357383883}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Pluginconfig.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Pluginmain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_dbgfunctions.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugin_types.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_plugins.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_argument.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_assembler.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_bookmark.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_comment.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_debug.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_flag.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_function.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_gui.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_label.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_memory.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_misc.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_module.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_pattern.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_register.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_stack.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\_scriptapi_symbol.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgegraph.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgelist.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\bridgemain.h">
      <Filter>pluginsdk</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\XEDParse\XEDParse.h">
      <Filter>pluginsdk\XEDParse</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\TitanEngine\TitanEngine.h">
      <Filter>pluginsdk\TitanEngine</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4file.h">
      <Filter>pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4hc.h">
      <Filter>pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\lz4\lz4.h">
      <Filter>pluginsdk\lz4</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_x64dbg.h">
      <Filter>pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson.h">
      <Filter>pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\jansson\jansson_config.h">
      <Filter>pluginsdk\jansson</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\DeviceNameResolver\DeviceNameResolver.h">
      <Filter>pluginsdk\DeviceNameResolver</Filter>
    </ClInclude>
    <ClInclude Include="pluginsdk\dbghelp\dbghelp.h">
      <Filter>pluginsdk\dbghelp</Filter>
    </ClInclude>
    <ClInclude Include="IniApi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Ioctl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Settings.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Tooltips.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HyperHideDrv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Pluginmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IniApi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Settings.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Tooltips.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HyperHideDrv.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="HyperHideIcon.png">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`HyperHide/HyperHide.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`HyperHide/HyperHideDrv.cpp`:

```cpp
#include <Windows.h>
#include "HyperHideDrv.h"
#include "Ioctl.h"


HyperHideDrv::HyperHideDrv()
{
}

HyperHideDrv::~HyperHideDrv() 
{
    SetHyperVisorVisibility(TRUE);
	if (this->DriverHandle != 0 && this->DriverHandle != INVALID_HANDLE_VALUE)
		CloseHandle(this->DriverHandle);
}

BOOLEAN HyperHideDrv::CreateHandleToDriver() 
{
	this->DriverHandle = CreateFileA("\\\\.\\HyperDbg", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
	if (this->DriverHandle == INVALID_HANDLE_VALUE)
		return FALSE;
	return TRUE;
}

BOOLEAN HyperHideDrv::CallDriver(size_t Ioctl)
{
    if (this->Pid == 0)
        return FALSE;

    DWORD BytesReturned = 0;
    return DeviceIoControl
    (
        this->DriverHandle,
        Ioctl,
        &Pid, sizeof(UINT32),
        0, 0,
        &BytesReturned, NULL
    );
}

void HyperHideDrv::SetHyperVisorVisibility(BOOLEAN Value)
{
    DWORD BytesReturned = 0;
    DeviceIoControl
    (
        this->DriverHandle,
        IOCTL_SET_HYPERVISOR_VISIBILITY,
        &Value, sizeof(BOOLEAN),
        0, 0,
        &BytesReturned, NULL
    );
}

BOOLEAN HyperHideDrv::Hide(HIDE_INFO& HideInfo)
{
    if (this->Pid == NULL)
        return FALSE;

    DWORD BytesReturned = 0;
    HideInfo.Pid = Pid;

    return DeviceIoControl
    (
        this->DriverHandle,
        IOCTL_HIDE_FROM_SYSCALL,
        &HideInfo, sizeof(HIDE_INFO),
        0, 0,
        &BytesReturned, NULL
    );
}

HANDLE HyperHideDrv::GetDriverHandleValue() 
{
    return this->DriverHandle;
}

void HyperHideDrv::SetTargetPid(UINT32 Pid)
{
    this->Pid = Pid;
}
```

`HyperHide/HyperHideDrv.h`:

```h
#pragma once
#include <iostream>
#include <Windows.h>

typedef struct _HIDE_INFO
{
    ULONG Pid;
    BOOLEAN HookNtQueryInformationProcess;
    BOOLEAN HookNtQuerySystemInformation;
    BOOLEAN HookNtQueryInformationThread;
    BOOLEAN HookNtQueryInformationJobObject;
    BOOLEAN HookNtQueryObject;
    BOOLEAN HookNtQuerySystemTime;
    BOOLEAN HookNtQueryPerformanceCounter;
    BOOLEAN HookNtCreateUserProcess;
    BOOLEAN HookNtCreateProcessEx;
    BOOLEAN HookNtCreateThreadEx;
    BOOLEAN HookNtSetContextThread;
    BOOLEAN HookNtGetContextThread;
    BOOLEAN HookNtOpenProcess;
    BOOLEAN HookNtOpenThread;
    BOOLEAN HookNtSetInformationThread;
    BOOLEAN HookNtSystemDebugControl;
    BOOLEAN HookNtGetNextProcess;
    BOOLEAN HookNtYieldExecution;
    BOOLEAN HookNtCreateFile;
    BOOLEAN HookNtContinue;
    BOOLEAN HookNtClose;
    BOOLEAN HookNtUserBuildHwndList;
    BOOLEAN HookNtUserFindWindowEx;
    BOOLEAN HookNtUserQueryWindow;
    BOOLEAN HookNtUserGetForegroundWindow;
    BOOLEAN HookKuserSharedData;
    BOOLEAN HookKiDispatchException;
    BOOLEAN HookNtSetInformationProcess;
    BOOLEAN ClearPebBeingDebugged;
    BOOLEAN ClearPebNtGlobalFlag;
    BOOLEAN ClearHeapFlags;
    BOOLEAN ClearKuserSharedData;
    BOOLEAN ClearHideFromDebuggerFlag;
    BOOLEAN ClearBypassProcessFreeze;
    BOOLEAN ClearProcessBreakOnTerminationFlag;
    BOOLEAN ClearThreadBreakOnTerminationFlag;
    BOOLEAN SaveProcessDebugFlags;
    BOOLEAN SaveProcessHandleTracing;
}HIDE_INFO, * PHIDE_INFO;

class HyperHideDrv 
{
public:
	HyperHideDrv();
	~HyperHideDrv();
	BOOLEAN CreateHandleToDriver();
	BOOLEAN CallDriver(size_t Ioctl);
    BOOLEAN Hide(HIDE_INFO& HideInfo);
	void SetTargetPid(UINT32 Pid);
    void SetHyperVisorVisibility(BOOLEAN Value);
	HANDLE GetDriverHandleValue();

private:
	const std::string HyperHideDrvLink = "\\\\.\\HyperDbg";
	HANDLE DriverHandle = 0;
	UINT32 Pid = 0;
};
```

`HyperHide/IniApi.cpp`:

```cpp
#include "IniApi.h"

std::vector<std::string> IniLoadSectionNames(const std::string File) 
{
	std::string Buf;
	std::vector<std::string> Sections;
	DWORD Ret = 0;

	while (((DWORD)Buf.size() - Ret) < 3) 
	{
		Buf.resize(Buf.size() + MAX_PATH);
		Ret = GetPrivateProfileSectionNamesA(&Buf[0], (DWORD)Buf.size(), File.c_str());
	}

	const char* Data = Buf.c_str();
	for (; Data[0]; Data += lstrlenA(Data) + 1) 
		Sections.push_back(Data);

	return Sections;
}

std::string IniLoadString(const std::string File, const std::string Section, const std::string Key, const std::string DefaultValue) 
{
	std::string Buf;
	DWORD Ret = 0;

	while (((DWORD)Buf.size() - Ret) < 3) {
		Buf.resize(Buf.size() + MAX_PATH);
		Ret = GetPrivateProfileStringA(Section.c_str(), Key.c_str(), DefaultValue.c_str(), &Buf[0], (DWORD)Buf.size(), File.c_str());
	}
	Buf.resize(Ret);

	return Buf;
}

BOOL IniSaveString(const std::string File, const std::string Section, const std::string Key, const std::string Value)
{
	return WritePrivateProfileStringA(Section.c_str(), Key.c_str(), Value.c_str(), File.c_str()) == TRUE;
}
```

`HyperHide/IniApi.h`:

```h
#pragma once
#include <Windows.h>
#include <codecvt>
#include <locale>
#include <sstream>
#include <string>
#include <vector>
#include <cstdio>

std::vector<std::string> IniLoadSectionNames(const std::string File);

std::string IniLoadString(const std::string File, const std::string Section, const std::string Key, const std::string DefaultValue);

BOOL IniSaveString(const std::string File, const std::string Section, const std::string Key, const std::string Value);

template<typename ValueType>
ValueType IniLoadValue(const std::string File, const std::string Section, const std::string Key, ValueType DefaultValue)
{
	DWORD Ret = 0;
	ValueType Value;
	std::string DefaultValueStr = std::to_string(DefaultValue);
	std::string Buf;

	Buf = IniLoadString(File, Section, Key, DefaultValueStr);

	std::istringstream ss(Buf);

	ss >> Value;

	return Value;
}

template<typename ValueType>
BOOL IniSaveValue(const std::string File, const std::string Section, const std::string Key, ValueType Value)
{
	return IniSaveString(File, Section, Key, std::to_string(Value));
}
```

`HyperHide/Ioctl.h`:

```h
#pragma once

#define IOCTL_ADD_HIDER_ENTRY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_CLEAR_PEB_DEBUGGER_FLAG CTL_CODE(FILE_DEVICE_UNKNOWN, 0x901, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_SET_PEB_DEBUGGER_FLAG CTL_CODE(FILE_DEVICE_UNKNOWN, 0x902, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_HIDE_FROM_SYSCALL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x903, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_HIDE_PROCESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x904, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_REMOVE_HIDER_ENTRY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x905, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_PROCESS_STOPPED CTL_CODE(FILE_DEVICE_UNKNOWN, 0x906, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_PROCESS_RESUMED CTL_CODE(FILE_DEVICE_UNKNOWN, 0x907, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_SET_HYPERVISOR_VISIBILITY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x908, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
```

`HyperHide/Settings.cpp`:

```cpp
#include "Settings.h"
#include "IniApi.h"

VOID Settings::LoadProfile(std::string ProfileName)
{
    // Nt hooks
    CurrentProfile.HookNtQueryInformationProcess = IniLoadValue(IniFile, ProfileName, "NtQueryInformationProcess", 1);
    CurrentProfile.HookNtQueryInformationJobObject = IniLoadValue(IniFile, ProfileName, "NtQueryInformationJobObject", 1);
    CurrentProfile.HookNtQueryInformationThread = IniLoadValue(IniFile, ProfileName, "NtQueryInformationThread", 1);
    CurrentProfile.HookNtQueryObject = IniLoadValue(IniFile, ProfileName, "NtQueryObject", 1);
    CurrentProfile.HookNtQueryPerformanceCounter = IniLoadValue(IniFile, ProfileName, "NtQueryPerformanceCounter", 1);
    CurrentProfile.HookNtQuerySystemInformation = IniLoadValue(IniFile, ProfileName, "NtQuerySystemInformation", 1);
    CurrentProfile.HookNtQuerySystemTime = IniLoadValue(IniFile, ProfileName, "NtQuerySystemTime", 1);
    CurrentProfile.HookNtClose = IniLoadValue(IniFile, ProfileName, "NtClose", 1);
    CurrentProfile.HookNtGetContextThread = IniLoadValue(IniFile, ProfileName, "NtGetContextThread", 1);
    CurrentProfile.HookNtSetContextThread = IniLoadValue(IniFile, ProfileName, "NtSetContextThread", 1);
    CurrentProfile.HookNtContinue = IniLoadValue(IniFile, ProfileName, "NtContinue", 1);
    CurrentProfile.HookNtCreateUserProcess = IniLoadValue(IniFile, ProfileName, "NtCreateUserProcess", 1);
    CurrentProfile.HookNtCreateProcessEx = IniLoadValue(IniFile, ProfileName, "NtCreateProcessEx", 1);
    CurrentProfile.HookNtCreateThreadEx = IniLoadValue(IniFile, ProfileName, "NtCreateThreadEx", 1);
    CurrentProfile.HookNtGetNextProcess = IniLoadValue(IniFile, ProfileName, "NtGetNextProcess", 1);
    CurrentProfile.HookNtOpenThread = IniLoadValue(IniFile, ProfileName, "NtOpenThread", 1);
    CurrentProfile.HookNtOpenProcess = IniLoadValue(IniFile, ProfileName, "NtOpenProcess", 1);
    CurrentProfile.HookNtCreateFile = IniLoadValue(IniFile, ProfileName, "NtCreateFile", 1);
    CurrentProfile.HookNtYieldExecution = IniLoadValue(IniFile, ProfileName, "NtYieldExecution", 1);
    CurrentProfile.HookNtSystemDebugControl = IniLoadValue(IniFile, ProfileName, "NtSystemDebugControl", 1);
    CurrentProfile.HookNtSetInformationThread = IniLoadValue(IniFile, ProfileName, "NtSetInformationThread", 1);
    CurrentProfile.HookNtSetInformationProcess = IniLoadValue(IniFile, ProfileName, "NtSetInformationProcess", 1);

    // Win32k Hooks
    CurrentProfile.HookNtUserBuildHwndList = IniLoadValue(IniFile, ProfileName, "NtUserBuildHwndList", 1);
    CurrentProfile.HookNtUserFindWindowEx = IniLoadValue(IniFile, ProfileName, "NtUserFindWindowEx", 1);
    CurrentProfile.HookNtUserGetForegroundWindow = IniLoadValue(IniFile, ProfileName, "NtUserGetForegroundWindow", 1);
    CurrentProfile.HookNtUserQueryWindow = IniLoadValue(IniFile, ProfileName, "NtUserQueryWindow", 1);

    // Other
    CurrentProfile.HookKiExceptionDispatch = IniLoadValue(IniFile, ProfileName, "KiExceptionDispatch", 1);
    CurrentProfile.HookKuserSharedData = IniLoadValue(IniFile, ProfileName, "HookKuserSharedData", 1);
    CurrentProfile.ClearPebBeingDebugged = IniLoadValue(IniFile, ProfileName, "PebBeingDebugged", 1);
    CurrentProfile.ClearPebNtGlobalFlag = IniLoadValue(IniFile, ProfileName, "PebNtGlobalFlag", 1);
    CurrentProfile.ClearHeapFlags = IniLoadValue(IniFile, ProfileName, "HeapFlags", 1);
    CurrentProfile.ClearKuserSharedData = IniLoadValue(IniFile, ProfileName, "ClearKuserSharedData", 1);
    CurrentProfile.ClearHideFromDebuggerFlag = IniLoadValue(IniFile, ProfileName, "ThreadHideFromDebuggerFlag", 1);
    CurrentProfile.ClearBypassProcessFreeze = IniLoadValue(IniFile, ProfileName, "ThreadBypassProcessFreeze", 1);
    CurrentProfile.ClearProcessBreakOnTerminationFlag = IniLoadValue(IniFile, ProfileName, "ProcessBreakOnTerminationFlag", 1);
    CurrentProfile.ClearThreadBreakOnTerminationFlag = IniLoadValue(IniFile, ProfileName, "ThreadBreakOnTerminationFlag", 1);
    CurrentProfile.SaveProcessDebugFlags = IniLoadValue(IniFile, ProfileName, "ProcessDebugFlags", 1);
    CurrentProfile.SaveProcessHandleTracing = IniLoadValue(IniFile, ProfileName, "ProcessHandleTracing", 1);
}

BOOL Settings::SaveProfile()
{
    BOOL Success = TRUE;

    // Nt Hooks
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtQueryInformationProcess", CurrentProfile.HookNtQueryInformationProcess);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtQueryInformationJobObject", CurrentProfile.HookNtQueryInformationJobObject);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtQueryInformationThread", CurrentProfile.HookNtQueryInformationThread);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtQueryObject", CurrentProfile.HookNtQueryObject);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtQueryPerformanceCounter", CurrentProfile.HookNtQueryPerformanceCounter);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtQuerySystemInformation", CurrentProfile.HookNtQuerySystemInformation);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtQuerySystemTime", CurrentProfile.HookNtQuerySystemTime);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtClose", CurrentProfile.HookNtClose);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtGetContextThread", CurrentProfile.HookNtGetContextThread);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtSetContextThread", CurrentProfile.HookNtSetContextThread);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtContinue", CurrentProfile.HookNtContinue);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtCreateUserProcess", CurrentProfile.HookNtCreateUserProcess);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtCreateProcessEx", CurrentProfile.HookNtCreateProcessEx);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtCreateThreadEx", CurrentProfile.HookNtCreateThreadEx);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtGetNextProcess", CurrentProfile.HookNtGetNextProcess);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtOpenThread", CurrentProfile.HookNtOpenThread);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtOpenProcess", CurrentProfile.HookNtOpenProcess);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtCreateFile", CurrentProfile.HookNtCreateFile);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtYieldExecution", CurrentProfile.HookNtYieldExecution);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtSystemDebugControl", CurrentProfile.HookNtSystemDebugControl);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtSetInformationThread", CurrentProfile.HookNtSetInformationThread);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtSetInformationProcess", CurrentProfile.HookNtSetInformationProcess);

    // Win32k Hooks
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtUserBuildHwndList", CurrentProfile.HookNtUserBuildHwndList);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtUserFindWindowEx", CurrentProfile.HookNtUserFindWindowEx);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtUserGetForegroundWindow", CurrentProfile.HookNtUserGetForegroundWindow);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "NtUserQueryWindow", CurrentProfile.HookNtUserQueryWindow);

    // Other
    Success &= IniSaveValue(IniFile, CurrentProfileName, "KiExceptionDispatch", CurrentProfile.HookKiExceptionDispatch);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "HookKuserSharedData", CurrentProfile.HookKuserSharedData);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "PebBeingDebugged", CurrentProfile.ClearPebBeingDebugged);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "PebNtGlobalFlag", CurrentProfile.ClearPebNtGlobalFlag);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "HeapFlags", CurrentProfile.ClearHeapFlags);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "ClearKuserSharedData", CurrentProfile.ClearKuserSharedData);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "ThreadHideFromDebuggerFlag", CurrentProfile.ClearHideFromDebuggerFlag);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "ThreadBypassProcessFreeze", CurrentProfile.ClearBypassProcessFreeze);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "ProcessBreakOnTerminationFlag", CurrentProfile.ClearProcessBreakOnTerminationFlag);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "ThreadBreakOnTerminationFlag", CurrentProfile.ClearThreadBreakOnTerminationFlag);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "ProcessDebugFlags", CurrentProfile.SaveProcessDebugFlags);
    Success &= IniSaveValue(IniFile, CurrentProfileName, "ProcessHandleTracing", CurrentProfile.SaveProcessHandleTracing);

    return Success;
}

BOOL Settings::AddProfile(std::string ProfileName)
{
    if (std::find(ProfileNames.begin(), ProfileNames.end(), ProfileName) != ProfileNames.end())
        return FALSE;

    ProfileNames.push_back(ProfileName);
    return TRUE;
}

VOID Settings::SetProfile(std::string ProfileName)
{
    if (CurrentProfileName == ProfileName)
        return;

    CurrentProfileName = ProfileName;
    IniSaveString(IniFile, SettingsSectionName, CurrentProfileKey, ProfileName);

    LoadProfile(ProfileName);
}

VOID Settings::Load(std::string IniPath)
{
    IniFile = IniPath + IniFileName;
    ProfileNames = IniLoadSectionNames(IniFile);

    ProfileNames.erase(std::remove(ProfileNames.begin(), ProfileNames.end(), SettingsSectionName), ProfileNames.end());

    CurrentProfileName = IniLoadString(IniFile, SettingsSectionName, CurrentProfileKey, DefaultProfile);
    LoadProfile(CurrentProfileName);
}

std::vector<std::string>& Settings::GetProfileNames()
{
    return ProfileNames;
}

Settings::Profile& Settings::GetCurrentProfile()
{
    return CurrentProfile;
}

std::string Settings::GetCurrentProfileName()
{
    return CurrentProfileName;
}
```

`HyperHide/Settings.h`:

```h
#pragma once
#include <Windows.h>
#include <Windows.h>
#include <codecvt>
#include <locale>
#include <sstream>
#include <string>
#include <vector>
#include <cstdio>

class Settings
{
public:
    struct Profile
    {
        BOOLEAN HookNtQueryInformationProcess;
        BOOLEAN HookNtQuerySystemInformation;
        BOOLEAN HookNtQueryInformationThread;
        BOOLEAN HookNtQueryInformationJobObject;
        BOOLEAN HookNtQueryObject;
        BOOLEAN HookNtQuerySystemTime;
        BOOLEAN HookNtQueryPerformanceCounter;
        BOOLEAN HookNtCreateUserProcess;
        BOOLEAN HookNtCreateProcessEx;
        BOOLEAN HookNtCreateThreadEx;
        BOOLEAN HookNtSetContextThread;
        BOOLEAN HookNtGetContextThread;
        BOOLEAN HookNtOpenProcess;
        BOOLEAN HookNtOpenThread;
        BOOLEAN HookNtSetInformationThread;
        BOOLEAN HookNtSystemDebugControl;
        BOOLEAN HookNtGetNextProcess;
        BOOLEAN HookNtYieldExecution;
        BOOLEAN HookNtCreateFile;
        BOOLEAN HookNtContinue;
        BOOLEAN HookNtClose;
        BOOLEAN HookNtUserBuildHwndList;
        BOOLEAN HookNtUserFindWindowEx;
        BOOLEAN HookNtUserQueryWindow;
        BOOLEAN HookNtUserGetForegroundWindow;
        BOOLEAN HookKuserSharedData;
        BOOLEAN HookKiExceptionDispatch;
        BOOLEAN HookNtSetInformationProcess;
        BOOLEAN ClearPebBeingDebugged;
        BOOLEAN ClearPebNtGlobalFlag;
        BOOLEAN ClearHeapFlags;
        BOOLEAN ClearKuserSharedData;
        BOOLEAN ClearHideFromDebuggerFlag;
        BOOLEAN ClearBypassProcessFreeze;
        BOOLEAN ClearProcessBreakOnTerminationFlag;
        BOOLEAN ClearThreadBreakOnTerminationFlag;
        BOOLEAN SaveProcessDebugFlags;
        BOOLEAN SaveProcessHandleTracing;
    };

    VOID LoadProfile(std::string ProfileName);

    BOOL SaveProfile();

    BOOL AddProfile(std::string ProfileName);

    VOID SetProfile(std::string ProfileName);

    VOID Load(std::string IniPath);

    std::vector<std::string>& GetProfileNames();

    Profile& GetCurrentProfile();

    std::string GetCurrentProfileName();

private:
    std::string IniFile;
    CONST std::string IniFileName = "HyperHide.ini";
    CONST std::string SettingsSectionName = "SETTINGS";
    CONST std::string DefaultProfile = "Default";
    CONST std::string CurrentProfileKey = "CurrentProfile";
    std::vector<std::string> ProfileNames;
    std::string CurrentProfileName;
    Profile CurrentProfile;
};
```

`HyperHide/Tooltips.cpp`:

```cpp
#include <Windows.h>
#include <commctrl.h>
#include "resource.h"

HWND CreateTooltips(HWND hDlg)
{
    static const struct
    {
        unsigned Id;
        const wchar_t* Text;
    }Tooltips[] = {
        {
            IDC_BTN_OK,
            L"Apply Settings and save profile"
        },
        {
            IDC_CHK_SELECT_ALL,
            L"Set all checkboxes"
        },
        {
            IDC_CHK_NTQUERYINFORMATIONPROCESS,
            L"PROCESSINFOCLASS values can be used to detect a debugger.\r\n"
            L"ProcessDebugFlags: Should return 1 in the supplied buffer.\r\n"
            L"ProcessDebugPort: Should return 0 in the supplied buffer.\r\n"
            L"ProcessDebugObjectHandle: Should return 0 in the supplied buffer\r\nand the error STATUS_PORT_NOT_SET(0xC0000353)\r\n"
            L"ProcessBasicInformation: Reveals the parent process ID.\r\n"
            L"ProcessBreakOnTermination: Return depends on value passed to NtSetInformationProcess.\r\n"
            L"ProcessHandleTracing: Return depends on value passed to NtSetInformationProcess.\r\n"
            L"ProcessIoCounters: Field OtherOperationCount in IO_COUNTERS should be 1"
        },
        {
            IDC_CHK_NTSETINFORMATIONTHREAD,
            L"First THREADINFOCLASS value ThreadHideFromDebugger is a well-known\r\n"
            L"anti-debug techinque. The debugger cannot handle hidden threads.\r\n"
            L"This leads to a loss of control over the target.HyperHide will save information which thread supposed to be hidden\r\n"
            L"and uses that information in NtQueryInformationThread"
            L"Second THREADINFOCLASS value ThreadWow64Context can be used only in WOW64 app\r\n"
            L"and it can be used to clear hardware breakpoints\r\n"
            L"Third THREADINFOCLASS ThreadBreakOnTermination can cause a bsod when thread is being terminated\r\n"
            L"HyperHide will save information which thread has this flag set"
        },
        {
            IDC_CHK_NTQUERYINFORMATIONTHREAD,
            L"THREADINFOCLASS value ThreadHideFromDebugger can be used to retrive information if thread has HideFromDebugger flag set\r\n"
            L"THREADINFOCLASS value ThreadWow64Context can be used to retrive context of thread, can be only used in WOW64 app\r\n"
            L"THREADINFOCLASS value ThreadBreakOnTermination can be used to retrive information if thread has BreakOnTermination flag set"
        },
        {
            IDC_CHK_NTQUERYOBJECT,
            L"OBJECT_INFORMATION_CLASS ObjectTypesInformation and ObjectTypeInformation\r\n"
            L"can be used to detect debuggers. HyperHide filters only debugger DebugObject references because debugged process\r\n"
            L"can also create DebugObject."
        },
        {
            IDC_CHK_NTSYSTEMDEBUGCONTROL,
            L"The SYSDBG_COMMAND SysDbgGetTriageDump should return STATUS_INFO_LENGTH_MISMATCH\r\n"
            L"and for other values STATUS_DEBUGGER_INACTIVE."
        },
        {
            IDC_CHK_NTCLOSE,
            L"This is called with an invalid handle or with handle protected from closing to detect a debugger.\r\n"
            L"HyperHide calls ZwQueryObject to check the validity of the handle."
        },
        {
            IDC_CHK_NTSETCONTEXTTHREAD,
            L"NtSetContextThread is used to clear hardware breakpoints"
            L"Doens't work under WOW64 Process."
        },
        {
            IDC_CHK_NTQUERYSYSTEMINFORMATION,
            L"SYSTEM_INFORMATION_CLASS values SystemKernelDebuggerInformation,SystemKernelDebuggerInformationEx\r\n"
            L"and SystemKernelDebuggerFlags can be used to detect kernel debuggers.\r\n"
            L"SYSTEM_INFORMATION_CLASS values SystemProcessInformation,SystemSessionProcessInformation\r\n"
            L"SystemExtendedProcessInformation and SystemFullProcessInformation\r\n"
            L"are used to get a process list and process parent pid\r\n"
            L"SystemHandleInformation and SystemExtendedHandleInformation are used to\r\n"
            L"enumerate system process handles to detect e.g. handles to the debuggee process.\r\n"
            L"The SYSTEM_INFORMATION_CLASS value SystemCodeIntegrityInformation can be used to detect test signing mode."
        },
        {
            IDC_CHK_NTGETCONTEXTTHREAD,
            L"NtGetContextThread is used to check hardware breakpoints\r\n"
            L"Doens't work under WOW64 Process."
        },
        {
            IDC_CHK_NTCREATETHREADEX,
            L"NtCreateThreadEx can be used to create thread with ThreadHideFromDebugger which effect is the same\r\n"
            L"as NtSetInformationThread or with ThreadCreateFlagsBypassFrocessFreeze\r\n"
            L"which can make thread unable to pause (this option is only avalibe on windows 19h1 and newer)"
        },
        {
            IDC_CHK_NTCREATEFILE,
            L"NtCreateFile can be used to create handle to some driver for example\r\n"
            L"Hypervisor or HyperHide driver."
        },
        {
            IDC_CHK_NTYIELDEXECUTION,
            L"A very unrealiable anti-debug method. This is only used in some UnpackMe's\r\n"
            L"or in some Proof of Concept code. Only activate this if you really need it.\r\n"
            L"Probably you will never need this option."
        },
        {
            IDC_CHK_NTCREATEUSERPROCESS,
            L"NtCreateProcessEx can be used to create a process with thread\r\n"
            L"HyperHide will hide process which was created by another hidden process."
        },
        {
            IDC_CHK_NTUSERBUILDHWNDLIST,
            L"This is a system call function in user32.dll.\r\n"
            L"The windows APIs EnumWindows and EnumThreadWindows call this internally.\r\n"
            L"The debugger and other tools (procmon,procexp,wireshark etc.) windows will be hidden."
        },
        {
            IDC_CHK_NTUSERFINDWINDOWEX,
            L"This is a system call function in user32.dll.\r\n"
            L"The windows APIs FindWindowA/W and FindWindowExA/W call this internally.\r\n"
            L"The debugger and other tools (procmon,procexp,wireshark etc.) windows will be hidden."
        },
        {
            IDC_CHK_NTUSERQUERYWINDOW,
            L"This is a system call function in user32.dll.\r\n"
            L"The windows API GetWindowThreadProcessId calls this internally.\r\n"
            L"This is used to hide the debugger and other tools (procmon,procexp,wireshark etc.) processes."
        },
        {
            IDC_CHK_NTQUERYSYSTEMTIME,
            L"There are a few windows APIs to measure the time. Timing can be used to\r\n"
            L"detect debuggers, because they slow down the execution. If KsuerSharedData option is checked\r\n"
            L"this function will return value from spoofed KsuerSharedData page."
        },
        {
            IDC_CHK_NTQUERYPERFORMANCECOUNTER,
            L"There are a few windows APIs to measure the time. Timing can be used to\r\n"
            L"detect debuggers, because they slow down the execution. If KsuerSharedData option is checked\r\n"
            L"this function will return value from spoofed KsuerSharedData page."
        },
        {
            IDC_CHK_KUSER_SHARED_DATA,
            L"If checked it will replace debugee pfn of kusershareddata with our new created page pfn\r\n"
            L"When process is paused all counters won't update until you unpause so no time attacks will be possible."
        },
        {
            IDC_CHK_NTCONTINUE,
            L"NtContinue can be used to detect/clear hardware breakpoints"
        },
        {
            IDC_CHK_KIEXCEPTIONDISPATCH,
            L"If checked HyperHideDrv will clear all hardware breakpoints and restore them in NtContinue so\r\n"
            L"hooked KiUserExceptionDispatcher won't spot anything"
        },
        {
            IDC_CHK_NTQUERYINFORMATIONJOBOBJECT,
            L"When process is created by x64dbg/x32dbg it belongs to his job object\r\n"
            L"so we have to clear it"
        },
        {
            IDC_CHK_NTCREATEPROCESSEX,
            L"Probably you won't ever use this because it's deprecated function and is no longer used to create user mode process\r\n"
            L"If checked HyperHide will also hide process which was created by another hidden process."
        },
        {
            IDC_CHK_NTGETNEXTPROCESS,
            L"Can be used to enumerate all existing process so we have to filter it in case of our debugge or other toolsr"
        },
        {
            IDC_CHK_NTOPENPROCESS,
            L"Can be used to enumerate all existing process so we have to filter it in case of our debugger or other tools"
        },
        {
            IDC_CHK_NTOPENTHREAD,
            L"Can be used to enumerate all existing threads so we have to filter it in case of our debugger or other tools"
        },
        {
            IDC_CHK_NTUSERGETFOREGROUNDWINDOW,
            L"This is a system call function in user32.dll.\r\n"
            L"The windows API GetForegroundWindow calls this internally.\r\n"
            L"The debugger window will be hidden."
        },
        {
            IDC_CHK_NTSETINFORMATIONPROCESS,
            L"PROCESSINFOCLASS values ProcessHandleTracing and ProcessDebugFlags can be used to\r\n"
            L"detect a debugger (Valuse passed to NtSetInformationProcess will be saved and later used in NtQueryInformation Process).\r\n"
            L"PROCESSINFOCLASS value ProcessBreakOnTermination can be used to generate a bsod on process termination."
        },
        {
            IDC_CHK_CLEARPEBBEINGDEBUGGED,
            L"Clear BeingDebugged which indicates that process is debugged"
        },
        {
            IDC_CHK_CLEARHEAPFLAGS,
            L"Clear HeapFlags and HeapForceFlags which indicates that process is debugged"
        },
        {
            IDC_CHK_CLEARPEBNTGLOBALFLAG,
            L"Clear NtGlobalFlag which indcates that process is debugged."
        },
        {
            IDC_CHK_CLEARKUSERSHAREDDATA,
            L"It clears KernelDebugging flag from kusershareddata spoofed page\r\n"
            L"Use only if you checked Kusershareddata option and if kernel debugger is present"
        },
        {
            IDC_CHK_CLEARHIDEFROMDEBUGGER,
            L"If you are attaching to existing process it will clear ThreadHideFromDebugger flag from\r\n"
            L"all threads and will save information about which one were hidden, for use in NtQueryThreadInformation"
        },
        {
            IDC_CHK_CLEARBYPASSFREEZEFLAG,
            L"If you are attaching to existing process it will clear BypassFreezeFlag flag from all process threads"
        },
        {
            IDC_CHK_CLEARPROCESSBREAKONTERM,
            L"If you are attaching to existing process it will clear ProcessBreakOnTremination flag\r\n"
            L"and will save information about it, for use in NtQueryInformationProcess"
        },
        {
            IDC_CHK_CLEARTHREADBREAKONTERM,
            L"If you are attaching to existing process it will clear ThreadBreakOnTermination flag from\r\n"
            L"all process threads and will save information about which one were hidden, for use in NtQueryThreadInformation"
        },
        {
            IDC_CHK_SAVEPROCESSDEBUGFLAGS,
            L"If you are attaching to existing process it will save ProcessDebugFlags value for use in NtQueryProcessInformation"
        },
        {
            IDC_CHK_SAVEPROCESSHANDLETRACING,
            L"If you are attaching to existing process it will save ProcessHandleTracing value for use in NtQueryProcessInformation"
        }
    };

    HINSTANCE Instance = (HINSTANCE)GetWindowLongPtrW(hDlg, GWLP_HINSTANCE);
    if (Instance == NULL)
        return 0;

    HWND TooltipsWnd = CreateWindowExW(WS_EX_TOPMOST, TOOLTIPS_CLASSW, 0,
        WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        hDlg, 0, Instance, 0);

    if (TooltipsWnd == NULL)
        return 0;

    for (int i = 0; i < sizeof(Tooltips) / sizeof(Tooltips[0]); i++)
    {
        HWND Ctrl = GetDlgItem(hDlg, Tooltips[i].Id);
        if (!Ctrl)
            continue;

        TOOLINFOA Ti;
        Ti.cbSize = TTTOOLINFOW_V1_SIZE;
        Ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
        Ti.hwnd = hDlg;
        Ti.uId = (UINT_PTR)Ctrl;
        Ti.hinst = Instance;
        Ti.lpszText = (char*)(Tooltips[i].Text);
        Ti.lParam = 0;

        SendMessageW(TooltipsWnd, TTM_ADDTOOL, 0, (LPARAM)&Ti);
    }

    SendMessageW(TooltipsWnd, TTM_SETMAXTIPWIDTH, 0, 500);
    SendMessageW(TooltipsWnd, TTM_ACTIVATE, TRUE, 0);

    return TooltipsWnd;
}
```

`HyperHide/Tooltips.h`:

```h
#pragma once
#include <Windows.h>
HWND CreateTooltips(HWND hDlg);
```

`HyperHide/pluginconfig.h`:

```h
#pragma once
#define PLUGIN_NAME "HyperHide"
#define PLUGIN_VERSION 1

```

`HyperHide/pluginmain.cpp`:

```cpp
#include <Windows.h>
#include <commctrl.h>
#include "pluginmain.h"
#include "resource.h"
#include "IniApi.h"
#include "Ioctl.h"
#include "Settings.h"
#include "Tooltips.h"
#include "HyperHideDrv.h"

enum MenuItems
{
    MENU_OPTIONS,
    MENU_HYPERVISOR_VISIBLE,
};

HINSTANCE hinst;
HWND hwndDlg;
int pluginHandle;
int hMenu;
int hMenuDisasm;
int hMenuDump;
int hMenuStack;

CONST ULONG CheckBoxNumber = IDC_CHK_SELECT_ALL - IDC_CHK_NTQUERYINFORMATIONPROCESS;

BOOLEAN Paused = FALSE;
BOOLEAN Attached = FALSE;
BOOLEAN PebFix = FALSE;
BOOLEAN BeingDebuggedCleared = FALSE;

ICONDATA IconData = { 0 };

Settings* g_Settings;
HyperHideDrv* g_HyperHideDrv;

std::string g_HyperHideIniPath;

HMODULE NtdllModule = 0;

std::string GetModulePath(HMODULE hModule)
{
    std::string FileName;
    DWORD Copied = 0;
    do {
        FileName.resize(FileName.size() + MAX_PATH);
        Copied = GetModuleFileNameA(hModule, &FileName[0], (DWORD)FileName.size());
    } while (Copied >= FileName.size());

    FileName.resize(Copied);
    return FileName;
}

BOOL SaveOptions(HWND hWnd)
{
    BOOLEAN* ProfileField = &g_Settings->GetCurrentProfile().HookNtQueryInformationProcess;
    for (size_t i = 0; i < CheckBoxNumber; i++)
        *(ProfileField + i) = IsDlgButtonChecked(hWnd, IDC_CHK_NTQUERYINFORMATIONPROCESS + i);

    return g_Settings->SaveProfile();
}

VOID UpdateOptions(HWND hDlg) 
{
    BOOLEAN* ProfileField = &g_Settings->GetCurrentProfile().HookNtQueryInformationProcess;
    for (size_t i = 0; i < CheckBoxNumber; i++)
        CheckDlgButton(hDlg, IDC_CHK_NTQUERYINFORMATIONPROCESS + i, *(ProfileField + i));
}

VOID Hide()
{
    HIDE_INFO HideInfo = { 0 };

    RtlCopyMemory(&HideInfo.HookNtQueryInformationProcess, &g_Settings->GetCurrentProfile().HookNtQueryInformationProcess, sizeof(g_Settings->GetCurrentProfile()));

    g_HyperHideDrv->Hide(HideInfo);
}

PLUG_EXPORT void CBATTACH(CBTYPE cbType, PLUG_CB_ATTACH* info) 
{
    g_HyperHideDrv->SetTargetPid(info->dwProcessId);

    if (g_HyperHideDrv->GetDriverHandleValue() == INVALID_HANDLE_VALUE)
    {
        if (!g_HyperHideDrv->CreateHandleToDriver())
        {
            MessageBoxA(NULL, "CBATTACH CreateHandleToDriver failed", "x64dbg", MB_ICONWARNING);
        }    
    }

    if (g_HyperHideDrv->GetDriverHandleValue() != INVALID_HANDLE_VALUE && Attached == FALSE)
    {
        if (g_HyperHideDrv->CallDriver(IOCTL_ADD_HIDER_ENTRY) == TRUE)
        {
            Hide();
        }
    }

    Attached = TRUE;
}

PLUG_EXPORT void CBDETACH(CBTYPE cbType, PLUG_CB_DETACH* info) 
{
    if (g_HyperHideDrv->GetDriverHandleValue() != INVALID_HANDLE_VALUE && Attached == TRUE)
        g_HyperHideDrv->CallDriver(IOCTL_REMOVE_HIDER_ENTRY);

    Attached = FALSE;
    Paused = FALSE;
    BeingDebuggedCleared = FALSE;
}

PLUG_EXPORT void CBEXITPROCESS(CBTYPE cbType, PLUG_CB_EXITPROCESS* info) 
{
    if (g_HyperHideDrv->GetDriverHandleValue() != INVALID_HANDLE_VALUE && Attached == TRUE)
        g_HyperHideDrv->CallDriver(IOCTL_REMOVE_HIDER_ENTRY);

    Attached = FALSE;
    Paused = FALSE;
    BeingDebuggedCleared = FALSE;
}

PLUG_EXPORT void CBPAUSEDEBUG(CBTYPE cbType, PLUG_CB_PAUSEDEBUG* info) 
{
    if (g_HyperHideDrv->GetDriverHandleValue() != INVALID_HANDLE_VALUE)
        g_HyperHideDrv->CallDriver(IOCTL_PROCESS_STOPPED);
    Paused = TRUE;
}

PLUG_EXPORT void CBRESUMEDEBUG(CBTYPE cbType, PLUG_CB_RESUMEDEBUG* info)
{
    if (g_HyperHideDrv->GetDriverHandleValue() != INVALID_HANDLE_VALUE)
        g_HyperHideDrv->CallDriver(IOCTL_PROCESS_RESUMED);
    Paused = FALSE;
}

void DebugLoop(CBTYPE cbType, void* callbackInfo) 
{
    PLUG_CB_DEBUGEVENT* de = (PLUG_CB_DEBUGEVENT*)callbackInfo;
    DEBUG_EVENT* DebugEvent = de->DebugEvent;

    if (g_Settings->GetCurrentProfile().ClearHeapFlags == TRUE)
    {
        if (PebFix == TRUE)
        {
            g_HyperHideDrv->CallDriver(IOCTL_SET_PEB_DEBUGGER_FLAG);
            PebFix = FALSE;
        }
        
        if (DebugEvent->u.LoadDll.lpBaseOfDll == NtdllModule)
        {
            g_HyperHideDrv->SetTargetPid(DebugEvent->dwProcessId);
            g_HyperHideDrv->CallDriver(IOCTL_CLEAR_PEB_DEBUGGER_FLAG);
            PebFix = TRUE;
        }
    }

    switch (DebugEvent->dwDebugEventCode)
    {
        case CREATE_PROCESS_DEBUG_EVENT:
        {
            if (DebugEvent->u.CreateProcessInfo.lpStartAddress == NULL)
            {
                if (Attached == TRUE && BeingDebuggedCleared == FALSE && g_Settings->GetCurrentProfile().ClearPebBeingDebugged == TRUE)
                {
                    BeingDebuggedCleared = TRUE;
                    g_HyperHideDrv->CallDriver(IOCTL_CLEAR_PEB_DEBUGGER_FLAG);
                }
            }

            break;
        }

        case EXCEPTION_DEBUG_EVENT:
        {
            if (DebugEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT)
            {
                g_HyperHideDrv->SetTargetPid(DebugEvent->dwProcessId);

                // Try to create handle to our driver
                if (g_HyperHideDrv->GetDriverHandleValue() == INVALID_HANDLE_VALUE)
                    g_HyperHideDrv->CreateHandleToDriver();

                if (g_HyperHideDrv->GetDriverHandleValue() != INVALID_HANDLE_VALUE && Attached == FALSE && g_HyperHideDrv->CallDriver(IOCTL_ADD_HIDER_ENTRY) == TRUE)
                    Hide();

                Attached = TRUE;
            }
            break;
        }
    }
}

INT_PTR CALLBACK HiderDialog(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    switch (Message)
    {
        case WM_INITDIALOG:
        {
            UpdateOptions(hDlg);

            for (size_t i = 0; i < g_Settings->GetProfileNames().size(); i++)
            {
                SendDlgItemMessageA(hDlg, IDC_COB_CURRENTPROFILE, CB_ADDSTRING, 0, (LPARAM)g_Settings->GetProfileNames()[i].c_str());
                if(g_Settings->GetCurrentProfileName() == g_Settings->GetProfileNames()[i])
                    SendDlgItemMessageA(hDlg, IDC_COB_CURRENTPROFILE, CB_SETCURSEL, i, 0);
            }

            CreateTooltips(hDlg);
            return TRUE;
        }

        case WM_CLOSE:
        {
            EndDialog(hDlg, 0);
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_BTN_OK: 
                {
                    if (SaveOptions(hDlg) == FALSE)
                    {
                        _plugin_logprintf("Error: Saving options failed\n");
                        break;
                    }

                    MessageBoxW(hDlg, L"Settings applied!", L"[HyperHide Options]", MB_ICONINFORMATION);

                    UpdateOptions(hDlg);

                    Hide();

                    break;
                }

                case IDC_BTN_CREATENEWPROFILE: 
                {
                    std::string NewProfileName;
                    NewProfileName.resize(GUI_MAX_LINE_SIZE);
                    if (!GuiGetLineWindow("Pass new profile name", &NewProfileName[0]))
                        break;

                    if (g_Settings->AddProfile(NewProfileName) == FALSE)
                        break;

                    g_Settings->SaveProfile();
                    g_Settings->SetProfile(NewProfileName);
                    SendDlgItemMessageA(hDlg, IDC_COB_CURRENTPROFILE, CB_ADDSTRING, 0, (LPARAM)NewProfileName.c_str());
                    int ProfileCount = SendDlgItemMessageA(hDlg, IDC_COB_CURRENTPROFILE, CB_GETCOUNT, 0, 0);
                    SendDlgItemMessageA(hDlg, IDC_COB_CURRENTPROFILE, CB_SETCURSEL, ProfileCount - 1, 0);

                    UpdateOptions(hDlg);

                    break;
                }

                case IDC_COB_CURRENTPROFILE: 
                {
                    if (HIWORD(wParam) != CBN_SELCHANGE)
                        break;

                    int ProfileIdx = (int)SendDlgItemMessageA(hDlg, IDC_COB_CURRENTPROFILE, CB_GETCURSEL, 0, 0);
                    g_Settings->SetProfile(g_Settings->GetProfileNames()[ProfileIdx]);

                    UpdateOptions(hDlg);
                    break;
                }

                case IDC_CHK_SELECT_ALL:
                {
                    if (IsDlgButtonChecked(hDlg, IDC_CHK_SELECT_ALL) == TRUE)
                    {
                        for (size_t i = 0; i < CheckBoxNumber; i++)
                        {
                            BOOL status = CheckDlgButton(hDlg, i + IDC_CHK_NTQUERYINFORMATIONPROCESS, BST_CHECKED);
                        }
                    }

                    else
                    {
                        for (size_t i = 0; i < CheckBoxNumber; i++)
                        {
                            CheckDlgButton(hDlg, i + IDC_CHK_NTQUERYINFORMATIONPROCESS, BST_UNCHECKED);
                        }
                    }

                    break;
                }
            }
        }
        return TRUE;
    }

    return FALSE;
}

void MenuEntry(CBTYPE cbType, void* CallbackInfo)
{
    PLUG_CB_MENUENTRY* Info = (PLUG_CB_MENUENTRY*)CallbackInfo;
    switch (Info->hEntry)
    {
        case MENU_OPTIONS:
        {
            if (g_HyperHideDrv->GetDriverHandleValue() == INVALID_HANDLE_VALUE)
            {
                if (g_HyperHideDrv->CreateHandleToDriver() == FALSE)
                {
                    MessageBoxA(hwndDlg, "Couldn't establish connection with HyperHide Driver\r\n", "Error", MB_OK);
                    break;
                }
            }

            DialogBox(hinst, MAKEINTRESOURCE(DLG_MAIN), NULL, HiderDialog);
            break;
        }

        case MENU_HYPERVISOR_VISIBLE:
        {
            static BOOLEAN HypervisorPresent = TRUE;
            HypervisorPresent = !HypervisorPresent;

            g_HyperHideDrv->SetHyperVisorVisibility(HypervisorPresent);
            break;
        }

        default:
        {
            break;
        }
    }
}


PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    initStruct->pluginVersion = PLUGIN_VERSION;
    initStruct->sdkVersion = PLUG_SDKVERSION;
    strncpy_s(initStruct->pluginName, PLUGIN_NAME, _TRUNCATE);
    pluginHandle = initStruct->pluginHandle;

    _plugin_registercallback(initStruct->pluginHandle, CB_MENUENTRY, MenuEntry);
    _plugin_registercallback(pluginHandle, CB_DEBUGEVENT, DebugLoop);

    return true;
}

PLUG_EXPORT bool plugstop()
{
    delete g_HyperHideDrv;
    return true;
}

PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    hwndDlg = setupStruct->hwndDlg;
    hMenu = setupStruct->hMenu;
    hMenuDisasm = setupStruct->hMenuDisasm;
    hMenuDump = setupStruct->hMenuDump;
    hMenuStack = setupStruct->hMenuStack;
    
    g_HyperHideDrv = new HyperHideDrv();
    g_HyperHideDrv->CreateHandleToDriver();
    g_Settings = new Settings();
    g_Settings->Load(g_HyperHideIniPath);

    _plugin_menuaddentry(hMenu, MENU_OPTIONS, "&Options");
    _plugin_menuaddentry(hMenu, MENU_HYPERVISOR_VISIBLE, "&Hypervisor not visible");
    _plugin_menuentrysetchecked(pluginHandle, MENU_HYPERVISOR_VISIBLE, 0);

    HRSRC Icon = FindResourceW(hinst, MAKEINTRESOURCEW(IDB_ICON), L"PNG");
    if (Icon != NULL)
    {
        HGLOBAL IconResource = LoadResource(hinst, Icon);
        if (IconResource != NULL)
        {
            IconData.data = LockResource(IconResource);
            IconData.size = SizeofResource(hinst, Icon);

            if (IconData.data != NULL && IconData.size != NULL)
                _plugin_menuseticon(hMenu, &IconData);
        }
    }


    //PLUG_CB_ATTACH info;
    //info.dwProcessId = 123;
    //CBATTACH(CB_ATTACH, &info);

}

BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,   
    LPVOID lpReserved) 
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            hinst = hinstDLL;
            g_HyperHideIniPath = GetModulePath(hinstDLL);
            g_HyperHideIniPath.resize(g_HyperHideIniPath.find_last_of(L'\\') + 1);
            NtdllModule = GetModuleHandleW(L"ntdll.dll");

            break;
        }

    }

    return TRUE;
}
```

`HyperHide/pluginmain.h`:

```h
#pragma once

// Plugin information
#ifndef PLUGIN_NAME
#include "pluginconfig.h"
#else
#define PLUGIN_NAME "UnnamedPlugin"
#endif // PLUGIN_NAME
#define PLUGIN_VERSION 1

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"

#include "pluginsdk/_scriptapi_argument.h"
#include "pluginsdk/_scriptapi_assembler.h"
#include "pluginsdk/_scriptapi_bookmark.h"
#include "pluginsdk/_scriptapi_comment.h"
#include "pluginsdk/_scriptapi_debug.h"
#include "pluginsdk/_scriptapi_flag.h"
#include "pluginsdk/_scriptapi_function.h"
#include "pluginsdk/_scriptapi_gui.h"
#include "pluginsdk/_scriptapi_label.h"
#include "pluginsdk/_scriptapi_memory.h"
#include "pluginsdk/_scriptapi_misc.h"
#include "pluginsdk/_scriptapi_module.h"
#include "pluginsdk/_scriptapi_pattern.h"
#include "pluginsdk/_scriptapi_register.h"
#include "pluginsdk/_scriptapi_stack.h"
#include "pluginsdk/_scriptapi_symbol.h"

#include "pluginsdk/DeviceNameResolver/DeviceNameResolver.h"
#include "pluginsdk/jansson/jansson.h"
#include "pluginsdk/lz4/lz4file.h"
#include "pluginsdk/TitanEngine/TitanEngine.h"
#include "pluginsdk/XEDParse/XEDParse.h"

#ifdef _WIN64
#pragma comment(lib, "pluginsdk/x64dbg.lib")
#pragma comment(lib, "pluginsdk/x64bridge.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x64.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x64.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x64.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x64.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x64.lib")
#else
#pragma comment(lib, "pluginsdk/x32dbg.lib")
#pragma comment(lib, "pluginsdk/x32bridge.lib")
#pragma comment(lib, "pluginsdk/DeviceNameResolver/DeviceNameResolver_x86.lib")
#pragma comment(lib, "pluginsdk/jansson/jansson_x86.lib")
#pragma comment(lib, "pluginsdk/lz4/lz4_x86.lib")
#pragma comment(lib, "pluginsdk/TitanEngine/TitanEngine_x86.lib")
#pragma comment(lib, "pluginsdk/XEDParse/XEDParse_x86.lib")
#endif //_WIN64

#define Cmd(x) DbgCmdExecDirect(x)
#define Eval(x) DbgValFromString(x)
#define dprintf(x, ...) _plugin_logprintf("[" PLUGIN_NAME "] " x, __VA_ARGS__)
#define dputs(x) _plugin_logputs("[" PLUGIN_NAME "] " x)
#define PLUG_EXPORT extern "C" __declspec(dllexport)

//superglobal variables
extern int pluginHandle;
extern HWND hwndDlg;
extern int hMenu;
extern int hMenuDisasm;
extern int hMenuDump;
extern int hMenuStack;
```

`HyperHide/pluginsdk/DeviceNameResolver/DeviceNameResolver.h`:

```h
#ifndef _DEVICENAMERESOLVER_H
#define _DEVICENAMERESOLVER_H

#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif

__declspec(dllexport) bool DevicePathToPathW(const wchar_t* szDevicePath, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathToPathA(const char* szDevicePath, char* szPath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleW(HANDLE hFile, wchar_t* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool DevicePathFromFileHandleA(HANDLE hFile, char* szDevicePath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleW(HANDLE hFile, wchar_t* szPath, size_t nSizeInChars);
__declspec(dllexport) bool PathFromFileHandleA(HANDLE hFile, char* szPath, size_t nSizeInChars);

#ifdef __cplusplus
}
#endif

#endif // _DEVICENAMERESOLVER_H

```

`HyperHide/pluginsdk/TitanEngine/TitanEngine.h`:

```h
#ifndef TITANENGINE
#define TITANENGINE

#define TITCALL

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <stdint.h>

#pragma pack(push, 1)

// Global.Constant.Structure.Declaration:
// Engine.External:
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13
#define UE_STRUCT_X87FPUREGISTER 14
#define UE_STRUCT_X87FPU 15
#define UE_STRUCT_TITAN_ENGINE_CONTEXT 16

#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8
#define UE_ENGINE_SET_DEBUG_PRIVILEGE 9
#define UE_ENGINE_SAFE_ATTACH 10

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
#define UE_DLLCHARACTERISTICS 25
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_VANOTFOUND = -2;

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25
#define UE_CH_DEBUGEVENT 26

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4

#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

#define UE_BPXREMOVED 0
#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_PLATFORM_x86 1
#define UE_PLATFORM_x64 2
#define UE_PLATFORM_ALL 3

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#ifdef _WIN64
#define UE_CFLAGS UE_RFLAGS
#else
#define UE_CFLAGS UE_EFLAGS
#endif
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42
#define UE_x87_r0 43
#define UE_x87_r1 44
#define UE_x87_r2 45
#define UE_x87_r3 46
#define UE_x87_r4 47
#define UE_x87_r5 48
#define UE_x87_r6 49
#define UE_x87_r7 50
#define UE_X87_STATUSWORD 51
#define UE_X87_CONTROLWORD 52
#define UE_X87_TAGWORD 53
#define UE_MXCSR 54
#define UE_MMX0 55
#define UE_MMX1 56
#define UE_MMX2 57
#define UE_MMX3 58
#define UE_MMX4 59
#define UE_MMX5 60
#define UE_MMX6 61
#define UE_MMX7 62
#define UE_XMM0 63
#define UE_XMM1 64
#define UE_XMM2 65
#define UE_XMM3 66
#define UE_XMM4 67
#define UE_XMM5 68
#define UE_XMM6 69
#define UE_XMM7 70
#define UE_XMM8 71
#define UE_XMM9 72
#define UE_XMM10 73
#define UE_XMM11 74
#define UE_XMM12 75
#define UE_XMM13 76
#define UE_XMM14 77
#define UE_XMM15 78
#define UE_x87_ST0 79
#define UE_x87_ST1 80
#define UE_x87_ST2 81
#define UE_x87_ST3 82
#define UE_x87_ST4 83
#define UE_x87_ST5 84
#define UE_x87_ST6 85
#define UE_x87_ST7 86
#define UE_YMM0 87
#define UE_YMM1 88
#define UE_YMM2 89
#define UE_YMM3 90
#define UE_YMM4 91
#define UE_YMM5 92
#define UE_YMM6 93
#define UE_YMM7 94
#define UE_YMM8 95
#define UE_YMM9 96
#define UE_YMM10 97
#define UE_YMM11 98
#define UE_YMM12 99
#define UE_YMM13 100
#define UE_YMM14 101
#define UE_YMM15 102

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#if defined(_WIN64)
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

typedef struct
{
    char PluginName[64];
    DWORD PluginMajorVersion;
    DWORD PluginMinorVersion;
    HMODULE PluginBaseAddress;
    void* TitanDebuggingCallBack;
    void* TitanRegisterPlugin;
    void* TitanReleasePlugin;
    void* TitanResetPlugin;
    bool PluginDisabled;
} PluginInformation, *PPluginInformation;

#define TEE_MAXIMUM_HOOK_SIZE 14
#define TEE_MAXIMUM_HOOK_RELOCS 7
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

typedef struct DECLSPEC_ALIGN(16) _XmmRegister_t
{
    ULONGLONG Low;
    LONGLONG High;
} XmmRegister_t;

typedef struct
{
    XmmRegister_t Low; //XMM/SSE part
    XmmRegister_t High; //AVX part
} YmmRegister_t;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} x87FPURegister_t;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} x87FPU_t;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    x87FPU_t x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XmmRegister_t XmmRegisters[16];
    YmmRegister_t YmmRegisters[16];
#else // x86
    XmmRegister_t XmmRegisters[8];
    YmmRegister_t YmmRegisters[8];
#endif
} TITAN_ENGINE_CONTEXT_t;

#ifdef __cplusplus
extern "C"
{
#endif

// Global.Function.Declaration:
// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, const char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, const wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, const char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, const wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, const char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, const wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(const char* szFileName, const char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(const wchar_t* szFileName, const wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(const char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(const char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(const wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(const char* szFileName, const char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(const wchar_t* szFileName, const wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(const char* szFileName, const char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(const wchar_t* szFileName, const wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(const char* szInFileName, const char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(const wchar_t* szInFileName, const wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(const char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(const char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(const char* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(const char* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(const wchar_t* szFileName, const char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(const char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(const wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(const char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(const wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(const char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(const char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(const wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) ULONG_PTR TITCALL GetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(const char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(const wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(const char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(const wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) ULONG_PTR TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(const char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(const wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(const char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(const wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(const char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(const wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(const char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(const wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(const char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(const wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(const char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(const wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(const char* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(const wchar_t* szFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, const char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, const wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const char* szDumpFile1, const char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, const wchar_t* szDumpFile1, const wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(const char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(const wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(const char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(const wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUse(const char* szFileName);
__declspec(dllexport) ULONG_PTR TITCALL ResourcerLoadFileForResourceUseW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(HMODULE hFile, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(const char* szFileName, const char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(const wchar_t* szFileName, char* szResourceType, const char* szResourceName, const char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(const char* szFileName, const char* szResourceType, DWORD ResourceType, const char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(const wchar_t* szFileName, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, const wchar_t* szResourceType, DWORD ResourceType, const wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(const char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(const wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) ULONG_PTR TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) ULONG_PTR TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitNativeDebugW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(const char* szFileName, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(const wchar_t* szFileName, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) void TITCALL Getx87FPURegisters(x87FPURegister_t x87FPURegisters[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL GetMMXRegisters(uint64_t mmx[8], TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL GetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetFullContextDataEx(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) ULONG_PTR TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) ULONG_PTR TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL GetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) bool TITCALL SetAVXContext(HANDLE hActiveThread, TITAN_ENGINE_CONTEXT_t* titcontext);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) ULONG_PTR TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) ULONG_PTR TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) ULONG_PTR TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) ULONG_PTR TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) ULONG_PTR TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) PROCESS_INFORMATION* TITCALL TitanGetProcessInformation();
__declspec(dllexport) STARTUPINFOW* TITCALL TitanGetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(const char* szFileName, bool ReserveModuleBase, const char* szCommandLine, const char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(const wchar_t* szFileName, bool ReserveModuleBase, const wchar_t* szCommandLine, const wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(const char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(const wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(const char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(const char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(const char* szDumpFileName, const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(const wchar_t* szDumpFileName, const wchar_t* szExportFileName, const wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIWriteLocation(const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) ULONG_PTR TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteAPIAddressEx(const char* szDLLName, const char* szAPIName);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, const char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, const wchar_t* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) ULONG_PTR TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(const char* szOriginalFile, const char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(const char* szOriginalFile, const char* szDumpFile, const char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(const wchar_t* szOriginalFile, const wchar_t* szDumpFile, const char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, const char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, const wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, const char* szDumpedFile, const char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, const wchar_t* szDumpedFile, const wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, const char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, const wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(const char* szModuleName, const char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(const char* szModuleName, const char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(const char* szModuleName, const char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(const char* szModuleName, const char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) ULONG_PTR TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) ULONG_PTR TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, const char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, const char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(const char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(const char* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(const wchar_t* szExportFileName, const char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(const char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(const wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(const char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(const char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(const char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(const wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(const char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(const wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(const char* szLibraryName, void* EnumFunction);
__declspec(dllexport) HANDLE TITCALL TitanOpenProcess(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwProcessId);
__declspec(dllexport) HANDLE TITCALL TitanOpenThread(DWORD dwDesiredAccess, bool bInheritHandle, DWORD dwThreadId);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(const char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(const wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(const char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(const wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(const char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(const wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(const char* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(const wchar_t* szFileName, const char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(const char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(const wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(const char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(const wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, const char* szMutexString);
__declspec(dllexport) ULONG_PTR TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, const wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(const char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(const wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, const char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, const wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(const char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(const wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(const char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(const wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(const char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(const wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, const wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(const wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(const char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(const char* szFileName, const char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(const wchar_t* szFileName, const wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(const char* szFileName, const char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(const wchar_t* szFileName, const wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(const char* WindowUnpackerTitle, const char* WindowUnpackerLongTitle, const char* WindowUnpackerName, const char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(const char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);
// Global.Engine.Extension.Functions:
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginLoaded(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginEnabled(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerDisableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerDisablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerEnableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerEnablePlugin(const char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadPlugin(const char* szPluginName);
__declspec(dllexport) void* TITCALL ExtensionManagerGetPluginInfo(const char* szPluginName);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif /*TITANENGINE*/

```

`HyperHide/pluginsdk/XEDParse/XEDParse.h`:

```h
#ifndef _XEDPARSE_H
#define _XEDPARSE_H

#include <windows.h>

//XEDParse defines
#ifdef XEDPARSE_BUILD
#define XEDPARSE_EXPORT __declspec(dllexport)
#else
#define XEDPARSE_EXPORT __declspec(dllimport)
#endif //XEDPARSE_BUILD

#define XEDPARSE_CALL //calling convention

#define XEDPARSE_MAXBUFSIZE 256
#define XEDPARSE_MAXASMSIZE 16

//typedefs
typedef bool (XEDPARSE_CALL* CBXEDPARSE_UNKNOWN)(const char* text, ULONGLONG* value);

//XEDParse enums
enum XEDPARSE_STATUS
{
    XEDPARSE_ERROR = 0,
    XEDPARSE_OK = 1
};

//XEDParse structs
#pragma pack(push,8)
struct XEDPARSE
{
    bool x64; // use 64-bit instructions
    ULONGLONG cip; //instruction pointer (for relative addressing)
    unsigned int dest_size; //destination size (returned by XEDParse)
    CBXEDPARSE_UNKNOWN cbUnknown; //unknown operand callback
    unsigned char dest[XEDPARSE_MAXASMSIZE]; //destination buffer
    char instr[XEDPARSE_MAXBUFSIZE]; //instruction text
    char error[XEDPARSE_MAXBUFSIZE]; //error text (in case of an error)
};
#pragma pack(pop)

#ifdef __cplusplus
extern "C"
{
#endif

XEDPARSE_EXPORT XEDPARSE_STATUS XEDPARSE_CALL XEDParseAssemble(XEDPARSE* XEDParse);

#ifdef __cplusplus
}
#endif

#endif // _XEDPARSE_H

```

`HyperHide/pluginsdk/_dbgfunctions.h`:

```h
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    duint addr;
    duint handler;
} DBGSEHRECORD;

typedef struct
{
    duint total;
    DBGSEHRECORD* records;
} DBGSEHCHAIN;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
    char szExeMainWindowTitle[MAX_PATH];
    char szExeArgs[MAX_COMMAND_LINE_SIZE];
} DBGPROCESSINFO;

typedef struct
{
    DWORD rva;
    BYTE type;
    WORD size;
} DBGRELOCATIONINFO;

typedef enum
{
    InstructionBody = 0,
    InstructionHeading = 1,
    InstructionTailing = 2,
    InstructionOverlapped = 3, // The byte was executed with differing instruction base addresses
    DataByte,  // This and the following is not implemented yet.
    DataWord,
    DataDWord,
    DataQWord,
    DataFloat,
    DataDouble,
    DataLongDouble,
    DataXMM,
    DataYMM,
    DataMMX,
    DataMixed, //the byte is accessed in multiple ways
    InstructionDataMixed //the byte is both executed and written
} TRACERECORDBYTETYPE;

typedef enum
{
    TraceRecordNone,
    TraceRecordBitExec,
    TraceRecordByteWithExecTypeAndCounter,
    TraceRecordWordWithExecTypeAndCounter
} TRACERECORDTYPE;

typedef struct
{
    duint Handle;
    unsigned char TypeNumber;
    unsigned int GrantedAccess;
} HANDLEINFO;

// The longest ip address is 1234:6789:1234:6789:1234:6789:123.567.901.345 (46 bytes)
#define TCP_ADDR_SIZE 50

typedef struct
{
    char RemoteAddress[TCP_ADDR_SIZE];
    unsigned short RemotePort;
    char LocalAddress[TCP_ADDR_SIZE];
    unsigned short LocalPort;
    char StateText[TCP_ADDR_SIZE];
    unsigned int State;
} TCPCONNECTIONINFO;

typedef struct
{
    duint handle;
    duint parent;
    DWORD threadId;
    DWORD style;
    DWORD styleEx;
    duint wndProc;
    bool enabled;
    RECT position;
    char windowTitle[MAX_COMMENT_SIZE];
    char windowClass[MAX_COMMENT_SIZE];
} WINDOW_INFO;

typedef struct
{
    duint addr;
    duint size;
    duint flags;
} HEAPINFO;

typedef struct
{
    const char* name;
    duint value;
} CONSTANTINFO;

typedef enum
{
    MODSYMUNLOADED = 0,
    MODSYMLOADING,
    MODSYMLOADED
} MODULESYMBOLSTATUS;

typedef bool (*ASSEMBLEATEX)(duint addr, const char* instruction, char* error, bool fillnop);
typedef bool (*SECTIONFROMADDR)(duint addr, char* section);
typedef bool (*MODNAMEFROMADDR)(duint addr, char* modname, bool extension);
typedef duint(*MODBASEFROMADDR)(duint addr);
typedef duint(*MODBASEFROMNAME)(const char* modname);
typedef duint(*MODSIZEFROMADDR)(duint addr);
typedef bool (*ASSEMBLE)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
typedef bool (*PATCHGET)(duint addr);
typedef bool (*PATCHINRANGE)(duint start, duint end);
typedef bool (*MEMPATCH)(duint va, const unsigned char* src, duint size);
typedef void (*PATCHRESTORERANGE)(duint start, duint end);
typedef bool (*PATCHENUM)(DBGPATCHINFO* patchlist, size_t* cbsize);
typedef bool (*PATCHRESTORE)(duint addr);
typedef int (*PATCHFILE)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
typedef int (*MODPATHFROMADDR)(duint addr, char* path, int size);
typedef int (*MODPATHFROMNAME)(const char* modname, char* path, int size);
typedef bool (*DISASMFAST)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
typedef void (*MEMUPDATEMAP)();
typedef void (*GETCALLSTACK)(DBGCALLSTACK* callstack);
typedef void (*GETSEHCHAIN)(DBGSEHCHAIN* sehchain);
typedef void (*SYMBOLDOWNLOADALLSYMBOLS)(const char* szSymbolStore);
typedef bool (*GETJIT)(char* jit, bool x64);
typedef bool (*GETJITAUTO)(bool* jitauto);
typedef bool (*GETDEFJIT)(char* defjit);
typedef bool (*GETPROCESSLIST)(DBGPROCESSINFO** entries, int* count);
typedef bool (*GETPAGERIGHTS)(duint addr, char* rights);
typedef bool (*SETPAGERIGHTS)(duint addr, const char* rights);
typedef bool (*PAGERIGHTSTOSTRING)(DWORD protect, char* rights);
typedef bool (*ISPROCESSELEVATED)();
typedef bool (*GETCMDLINE)(char* cmdline, size_t* cbsize);
typedef bool (*SETCMDLINE)(const char* cmdline);
typedef duint(*FILEOFFSETTOVA)(const char* modname, duint offset);
typedef duint(*VATOFILEOFFSET)(duint va);
typedef duint(*GETADDRFROMLINE)(const char* szSourceFile, int line, duint* displacement);
typedef bool (*GETSOURCEFROMADDR)(duint addr, char* szSourceFile, int* line);
typedef bool (*VALFROMSTRING)(const char* string, duint* value);
typedef bool (*PATCHGETEX)(duint addr, DBGPATCHINFO* info);
typedef bool (*GETBRIDGEBP)(BPXTYPE type, duint addr, BRIDGEBP* bp);
typedef bool (*STRINGFORMATINLINE)(const char* format, size_t resultSize, char* result);
typedef void (*GETMNEMONICBRIEF)(const char* mnem, size_t resultSize, char* result);
typedef unsigned int (*GETTRACERECORDHITCOUNT)(duint address);
typedef TRACERECORDBYTETYPE(*GETTRACERECORDBYTETYPE)(duint address);
typedef bool (*SETTRACERECORDTYPE)(duint pageAddress, TRACERECORDTYPE type);
typedef TRACERECORDTYPE(*GETTRACERECORDTYPE)(duint pageAddress);
typedef bool (*ENUMHANDLES)(ListOf(HANDLEINFO) handles);
typedef bool (*GETHANDLENAME)(duint handle, char* name, size_t nameSize, char* typeName, size_t typeNameSize);
typedef bool (*ENUMTCPCONNECTIONS)(ListOf(TCPCONNECTIONINFO) connections);
typedef duint(*GETDBGEVENTS)();
typedef int (*MODGETPARTY)(duint base);
typedef void (*MODSETPARTY)(duint base, int party);
typedef bool(*WATCHISWATCHDOGTRIGGERED)(unsigned int id);
typedef bool(*MEMISCODEPAGE)(duint addr, bool refresh);
typedef bool(*ANIMATECOMMAND)(const char* command);
typedef void(*DBGSETDEBUGGEEINITSCRIPT)(const char* fileName);
typedef const char* (*DBGGETDEBUGGEEINITSCRIPT)();
typedef bool(*HANDLESENUMWINDOWS)(ListOf(WINDOW_INFO) windows);
typedef bool(*HANDLESENUMHEAPS)(ListOf(HEAPINFO) heaps);
typedef bool(*THREADGETNAME)(DWORD tid, char* name);
typedef bool(*ISDEPENABLED)();
typedef void(*GETCALLSTACKEX)(DBGCALLSTACK* callstack, bool cache);
typedef bool(*GETUSERCOMMENT)(duint addr, char* comment);
typedef void(*ENUMCONSTANTS)(ListOf(CONSTANTINFO) constants);
typedef duint(*MEMBPSIZE)(duint addr);
typedef bool(*MODRELOCATIONSFROMADDR)(duint addr, ListOf(DBGRELOCATIONINFO) relocations);
typedef bool(*MODRELOCATIONATADDR)(duint addr, DBGRELOCATIONINFO* relocation);
typedef bool(*MODRELOCATIONSINRANGE)(duint addr, duint size, ListOf(DBGRELOCATIONINFO) relocations);
typedef duint(*DBGETHASH)();
typedef int(*SYMAUTOCOMPLETE)(const char* Search, char** Buffer, int MaxSymbols);
typedef void(*REFRESHMODULELIST)();
typedef duint(*GETADDRFROMLINEEX)(duint mod, const char* szSourceFile, int line);
typedef MODULESYMBOLSTATUS(*MODSYMBOLSTATUS)(duint mod);

//The list of all the DbgFunctions() return value.
//WARNING: This list is append only. Do not insert things in the middle or plugins would break.
typedef struct DBGFUNCTIONS_
{
    ASSEMBLEATEX AssembleAtEx;
    SECTIONFROMADDR SectionFromAddr;
    MODNAMEFROMADDR ModNameFromAddr;
    MODBASEFROMADDR ModBaseFromAddr;
    MODBASEFROMNAME ModBaseFromName;
    MODSIZEFROMADDR ModSizeFromAddr;
    ASSEMBLE Assemble;
    PATCHGET PatchGet;
    PATCHINRANGE PatchInRange;
    MEMPATCH MemPatch;
    PATCHRESTORERANGE PatchRestoreRange;
    PATCHENUM PatchEnum;
    PATCHRESTORE PatchRestore;
    PATCHFILE PatchFile;
    MODPATHFROMADDR ModPathFromAddr;
    MODPATHFROMNAME ModPathFromName;
    DISASMFAST DisasmFast;
    MEMUPDATEMAP MemUpdateMap;
    GETCALLSTACK GetCallStack;
    GETSEHCHAIN GetSEHChain;
    SYMBOLDOWNLOADALLSYMBOLS SymbolDownloadAllSymbols;
    GETJITAUTO GetJitAuto;
    GETJIT GetJit;
    GETDEFJIT GetDefJit;
    GETPROCESSLIST GetProcessList;
    GETPAGERIGHTS GetPageRights;
    SETPAGERIGHTS SetPageRights;
    PAGERIGHTSTOSTRING PageRightsToString;
    ISPROCESSELEVATED IsProcessElevated;
    GETCMDLINE GetCmdline;
    SETCMDLINE SetCmdline;
    FILEOFFSETTOVA FileOffsetToVa;
    VATOFILEOFFSET VaToFileOffset;
    GETADDRFROMLINE GetAddrFromLine;
    GETSOURCEFROMADDR GetSourceFromAddr;
    VALFROMSTRING ValFromString;
    PATCHGETEX PatchGetEx;
    GETBRIDGEBP GetBridgeBp;
    STRINGFORMATINLINE StringFormatInline;
    GETMNEMONICBRIEF GetMnemonicBrief;
    GETTRACERECORDHITCOUNT GetTraceRecordHitCount;
    GETTRACERECORDBYTETYPE GetTraceRecordByteType;
    SETTRACERECORDTYPE SetTraceRecordType;
    GETTRACERECORDTYPE GetTraceRecordType;
    ENUMHANDLES EnumHandles;
    GETHANDLENAME GetHandleName;
    ENUMTCPCONNECTIONS EnumTcpConnections;
    GETDBGEVENTS GetDbgEvents;
    MODGETPARTY ModGetParty;
    MODSETPARTY ModSetParty;
    WATCHISWATCHDOGTRIGGERED WatchIsWatchdogTriggered;
    MEMISCODEPAGE MemIsCodePage;
    ANIMATECOMMAND AnimateCommand;
    DBGSETDEBUGGEEINITSCRIPT DbgSetDebuggeeInitScript;
    DBGGETDEBUGGEEINITSCRIPT DbgGetDebuggeeInitScript;
    HANDLESENUMWINDOWS EnumWindows;
    HANDLESENUMHEAPS EnumHeaps;
    THREADGETNAME ThreadGetName;
    ISDEPENABLED IsDepEnabled;
    GETCALLSTACKEX GetCallStackEx;
    GETUSERCOMMENT GetUserComment;
    ENUMCONSTANTS EnumConstants;
    ENUMCONSTANTS EnumErrorCodes;
    ENUMCONSTANTS EnumExceptions;
    MEMBPSIZE MemBpSize;
    MODRELOCATIONSFROMADDR ModRelocationsFromAddr;
    MODRELOCATIONATADDR ModRelocationAtAddr;
    MODRELOCATIONSINRANGE ModRelocationsInRange;
    DBGETHASH DbGetHash;
    SYMAUTOCOMPLETE SymAutoComplete;
    REFRESHMODULELIST RefreshModuleList;
    GETADDRFROMLINEEX GetAddrFromLineEx;
    MODSYMBOLSTATUS ModSymbolStatus;
} DBGFUNCTIONS;

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H

```

`HyperHide/pluginsdk/_plugin_types.h`:

```h
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"
#include "jansson/jansson.h"
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)

#else

#ifdef __GNUC__
#include "dbghelp/dbghelp.h"
#else
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "jansson/jansson.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H

```

`HyperHide/pluginsdk/_plugins.h`:

```h
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

#define PLUG_DB_LOADSAVE_DATA 1
#define PLUG_DB_LOADSAVE_ALL 2

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
    int hMenuGraph; //plugin graph menu handle
    int hMenuMemmap; //plugin memory map menu handle
    int hMenuSymmod; //plugin symbol module menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    IMAGEHLP_MODULE64* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

typedef struct
{
    json_t* root;
    int loadSaveType;
} PLUG_CB_LOADSAVEDB;

typedef struct
{
    const char* symbol;
    bool retval;
} PLUG_CB_FILTERSYMBOL;

typedef struct
{
    duint cip;
    bool stop;
} PLUG_CB_TRACEEXECUTE;

typedef struct
{
    int hWindow;
    duint VA;
} PLUG_CB_SELCHANGED;

typedef struct
{
    BridgeCFGraphList graph;
} PLUG_CB_ANALYZE;

typedef struct
{
    duint addr;
    BRIDGE_ADDRINFO* addrinfo;
    bool retval;
} PLUG_CB_ADDRINFO;

typedef struct
{
    const char* string;
    duint value;
    int* value_size;
    bool* isvar;
    bool* hexonly;
    bool retval;
} PLUG_CB_VALFROMSTRING;

typedef struct
{
    const char* string;
    duint value;
    bool retval;
} PLUG_CB_VALTOSTRING;

typedef struct
{
    GUIMENUTYPE hMenu;
} PLUG_CB_MENUPREPARE;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL, //PLUG_CB_WINEVENTGLOBAL
    CB_LOADDB, //PLUG_CB_LOADSAVEDB
    CB_SAVEDB, //PLUG_CB_LOADSAVEDB
    CB_FILTERSYMBOL, //PLUG_CB_FILTERSYMBOL
    CB_TRACEEXECUTE, //PLUG_CB_TRACEEXECUTE
    CB_SELCHANGED, //PLUG_CB_SELCHANGED
    CB_ANALYZE, //PLUG_CB_ANALYZE
    CB_ADDRINFO, //PLUG_CB_ADDRINFO
    CB_VALFROMSTRING, //PLUG_CB_VALFROMSTRING
    CB_VALTOSTRING, //PLUG_CB_VALTOSTRING
    CB_MENUPREPARE, //PLUG_CB_MENUPREPARE
    CB_LAST
} CBTYPE;

typedef enum
{
    FORMAT_ERROR, //generic failure (no message)
    FORMAT_SUCCESS, //success
    FORMAT_ERROR_MESSAGE, //formatting failed but an error was put in the buffer (there are always at least 511 characters available).
    FORMAT_BUFFER_TOO_SMALL //buffer too small (x64dbg will retry until the buffer is big enough)
} FORMATRESULT;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int argc, char** argv);
typedef void (*CBPLUGINSCRIPT)();
typedef duint(*CBPLUGINEXPRFUNCTION)(int argc, duint* argv, void* userdata);
typedef FORMATRESULT(*CBPLUGINFORMATFUNCTION)(char* dest, size_t destCount, int argc, char* argv[], duint value, void* userdata);
typedef bool (*CBPLUGINPREDICATE)(void* userdata);

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_logprint(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentrysetchecked(int pluginHandle, int hEntry, bool checked);
PLUG_IMPEXP void _plugin_menusetvisible(int pluginHandle, int hMenu, bool visible);
PLUG_IMPEXP void _plugin_menuentrysetvisible(int pluginHandle, int hEntry, bool visible);
PLUG_IMPEXP void _plugin_menusetname(int pluginHandle, int hMenu, const char* name);
PLUG_IMPEXP void _plugin_menuentrysetname(int pluginHandle, int hEntry, const char* name);
PLUG_IMPEXP void _plugin_menuentrysethotkey(int pluginHandle, int hEntry, const char* hotkey);
PLUG_IMPEXP bool _plugin_menuremove(int hMenu);
PLUG_IMPEXP bool _plugin_menuentryremove(int pluginHandle, int hEntry);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();
PLUG_IMPEXP bool _plugin_registerexprfunction(int pluginHandle, const char* name, int argc, CBPLUGINEXPRFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterexprfunction(int pluginHandle, const char* name);
PLUG_IMPEXP bool _plugin_unload(const char* pluginName);
PLUG_IMPEXP bool _plugin_load(const char* pluginName);
PLUG_IMPEXP duint _plugin_hash(const void* data, duint size);
PLUG_IMPEXP bool _plugin_registerformatfunction(int pluginHandle, const char* type, CBPLUGINFORMATFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterformatfunction(int pluginHandle, const char* type);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H

```

`HyperHide/pluginsdk/_scriptapi.h`:

```h
#ifndef _SCRIPT_API_H
#define _SCRIPT_API_H

#include "_plugins.h"

#define SCRIPT_EXPORT PLUG_IMPEXP

#endif //_SCRIPT_API_H
```

`HyperHide/pluginsdk/_scriptapi_argument.h`:

```h
#ifndef _SCRIPTAPI_ARGUMENT_H
#define _SCRIPTAPI_ARGUMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Argument
    {
        struct ArgumentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const ArgumentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, ArgumentInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual = false);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(ArgumentInfo) list); //caller has the responsibility to free the list
    }; //Argument
}; //Script

#endif //_SCRIPTAPI_ARGUMENT_H
```

`HyperHide/pluginsdk/_scriptapi_assembler.h`:

```h
#ifndef _SCRIPTAPI_ASSEMBLER_H
#define _SCRIPTAPI_ASSEMBLER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Assembler
    {
        SCRIPT_EXPORT bool Assemble(duint addr, unsigned char* dest, int* size, const char* instruction); //dest[16]
        SCRIPT_EXPORT bool AssembleEx(duint addr, unsigned char* dest, int* size, const char* instruction, char* error); //dest[16], error[MAX_ERROR_SIZE]
        SCRIPT_EXPORT bool AssembleMem(duint addr, const char* instruction);
        SCRIPT_EXPORT bool AssembleMemEx(duint addr, const char* instruction, int* size, char* error, bool fillnop); //error[MAX_ERROR_SIZE]
    }; //Assembler
}; //Script

#endif //_SCRIPTAPI_ASSEMBLER_H
```

`HyperHide/pluginsdk/_scriptapi_bookmark.h`:

```h
#ifndef _SCRIPTAPI_BOOKMARK_H
#define _SCRIPTAPI_BOOKMARK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Bookmark
    {
        struct BookmarkInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, bool manual = false);
        SCRIPT_EXPORT bool Set(const BookmarkInfo* info);
        SCRIPT_EXPORT bool Get(duint addr);
        SCRIPT_EXPORT bool GetInfo(duint addr, BookmarkInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(BookmarkInfo) list); //caller has the responsibility to free the list
    }; //Bookmark
}; //Script

#endif //_SCRIPTAPI_BOOKMARK_H
```

`HyperHide/pluginsdk/_scriptapi_comment.h`:

```h
#ifndef _SCRIPTAPI_COMMENT_H
#define _SCRIPTAPI_COMMENT_H

#include "_scriptapi.h"

namespace Script
{
    namespace Comment
    {
        struct CommentInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const CommentInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_COMMENT_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, CommentInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(CommentInfo) list); //caller has the responsibility to free the list
    }; //Comment
}; //Script

#endif //_SCRIPTAPI_COMMENT_H
```

`HyperHide/pluginsdk/_scriptapi_debug.h`:

```h
#ifndef _SCRIPTAPI_DEBUG_H
#define _SCRIPTAPI_DEBUG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Debug
    {
        enum HardwareType
        {
            HardwareAccess,
            HardwareWrite,
            HardwareExecute
        };

        SCRIPT_EXPORT void Wait();
        SCRIPT_EXPORT void Run();
        SCRIPT_EXPORT void Pause();
        SCRIPT_EXPORT void Stop();
        SCRIPT_EXPORT void StepIn();
        SCRIPT_EXPORT void StepOver();
        SCRIPT_EXPORT void StepOut();
        SCRIPT_EXPORT bool SetBreakpoint(duint address);
        SCRIPT_EXPORT bool DeleteBreakpoint(duint address);
        SCRIPT_EXPORT bool DisableBreakpoint(duint address);
        SCRIPT_EXPORT bool SetHardwareBreakpoint(duint address, HardwareType type = HardwareExecute);
        SCRIPT_EXPORT bool DeleteHardwareBreakpoint(duint address);
    }; //Debug
}; //Script

#endif //_SCRIPTAPI_DEBUG_H
```

`HyperHide/pluginsdk/_scriptapi_flag.h`:

```h
#ifndef _SCRIPTAPI_FLAG_H
#define _SCRIPTAPI_FLAG_H

#include "_scriptapi.h"

namespace Script
{
    namespace Flag
    {
        enum FlagEnum
        {
            ZF,
            OF,
            CF,
            PF,
            SF,
            TF,
            AF,
            DF,
            IF
        };

        SCRIPT_EXPORT bool Get(FlagEnum flag);
        SCRIPT_EXPORT bool Set(FlagEnum flag, bool value);

        SCRIPT_EXPORT bool GetZF();
        SCRIPT_EXPORT bool SetZF(bool value);
        SCRIPT_EXPORT bool GetOF();
        SCRIPT_EXPORT bool SetOF(bool value);
        SCRIPT_EXPORT bool GetCF();
        SCRIPT_EXPORT bool SetCF(bool value);
        SCRIPT_EXPORT bool GetPF();
        SCRIPT_EXPORT bool SetPF(bool value);
        SCRIPT_EXPORT bool GetSF();
        SCRIPT_EXPORT bool SetSF(bool value);
        SCRIPT_EXPORT bool GetTF();
        SCRIPT_EXPORT bool SetTF(bool value);
        SCRIPT_EXPORT bool GetAF();
        SCRIPT_EXPORT bool SetAF(bool value);
        SCRIPT_EXPORT bool GetDF();
        SCRIPT_EXPORT bool SetDF(bool value);
        SCRIPT_EXPORT bool GetIF();
        SCRIPT_EXPORT bool SetIF(bool value);
    };
};

#endif //_SCRIPTAPI_FLAG_H
```

`HyperHide/pluginsdk/_scriptapi_function.h`:

```h
#ifndef _SCRIPTAPI_FUNCTION_H
#define _SCRIPTAPI_FUNCTION_H

#include "_scriptapi.h"

namespace Script
{
    namespace Function
    {
        struct FunctionInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rvaStart;
            duint rvaEnd;
            bool manual;
            duint instructioncount;
        };

        SCRIPT_EXPORT bool Add(duint start, duint end, bool manual, duint instructionCount = 0);
        SCRIPT_EXPORT bool Add(const FunctionInfo* info);
        SCRIPT_EXPORT bool Get(duint addr, duint* start = nullptr, duint* end = nullptr, duint* instructionCount = nullptr);
        SCRIPT_EXPORT bool GetInfo(duint addr, FunctionInfo* info);
        SCRIPT_EXPORT bool Overlaps(duint start, duint end);
        SCRIPT_EXPORT bool Delete(duint address);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end, bool deleteManual);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(FunctionInfo) list); //caller has the responsibility to free the list
    }; //Function
}; //Script

#endif //_SCRIPTAPI_FUNCTION_H

```

`HyperHide/pluginsdk/_scriptapi_gui.h`:

```h
#ifndef _SCRIPTAPI_GUI_H
#define _SCRIPTAPI_GUI_H

#include "_scriptapi.h"

namespace Script
{
    namespace Gui
    {
        namespace Disassembly
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Disassembly

        namespace Dump
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Dump

        namespace Stack
        {
            SCRIPT_EXPORT bool SelectionGet(duint* start, duint* end);
            SCRIPT_EXPORT bool SelectionSet(duint start, duint end);
            SCRIPT_EXPORT duint SelectionGetStart();
            SCRIPT_EXPORT duint SelectionGetEnd();
        }; //Stack

        namespace Graph
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //Graph

        namespace MemMap
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //MemoryMap

        namespace SymMod
        {
            SCRIPT_EXPORT duint SelectionGetStart();
        }; //SymMod
    }; //Gui

    namespace Gui
    {
        enum Window
        {
            DisassemblyWindow,
            DumpWindow,
            StackWindow,
            GraphWindow,
            MemMapWindow,
            SymModWindow
        };

        SCRIPT_EXPORT bool SelectionGet(Window window, duint* start, duint* end);
        SCRIPT_EXPORT bool SelectionSet(Window window, duint start, duint end);
        SCRIPT_EXPORT duint SelectionGetStart(Window window);
        SCRIPT_EXPORT duint SelectionGetEnd(Window window);
        SCRIPT_EXPORT void Message(const char* message);
        SCRIPT_EXPORT bool MessageYesNo(const char* message);
        SCRIPT_EXPORT bool InputLine(const char* title, char* text); //text[GUI_MAX_LINE_SIZE]
        SCRIPT_EXPORT bool InputValue(const char* title, duint* value);
        SCRIPT_EXPORT void Refresh();
        SCRIPT_EXPORT void AddQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void ShowQWidgetTab(void* qWidget);
        SCRIPT_EXPORT void CloseQWidgetTab(void* qWidget);

    }; //Gui
}; //Script

#endif //_SCRIPTAPI_GUI_H
```

`HyperHide/pluginsdk/_scriptapi_label.h`:

```h
#ifndef _SCRIPTAPI_LABEL_H
#define _SCRIPTAPI_LABEL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Label
    {
        struct LabelInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char text[MAX_LABEL_SIZE];
            bool manual;
        };

        SCRIPT_EXPORT bool Set(duint addr, const char* text, bool manual = false);
        SCRIPT_EXPORT bool Set(const LabelInfo* info);
        SCRIPT_EXPORT bool FromString(const char* label, duint* addr);
        SCRIPT_EXPORT bool Get(duint addr, char* text); //text[MAX_LABEL_SIZE]
        SCRIPT_EXPORT bool GetInfo(duint addr, LabelInfo* info);
        SCRIPT_EXPORT bool Delete(duint addr);
        SCRIPT_EXPORT void DeleteRange(duint start, duint end);
        SCRIPT_EXPORT void Clear();
        SCRIPT_EXPORT bool GetList(ListOf(LabelInfo) list); //caller has the responsibility to free the list
    }; //Label
}; //Script

#endif //_SCRIPTAPI_LABEL_H
```

`HyperHide/pluginsdk/_scriptapi_memory.h`:

```h
#ifndef _SCRIPTAPI_MEMORY_H
#define _SCRIPTAPI_MEMORY_H

#include "_scriptapi.h"

namespace Script
{
    namespace Memory
    {
        SCRIPT_EXPORT bool Read(duint addr, void* data, duint size, duint* sizeRead);
        SCRIPT_EXPORT bool Write(duint addr, const void* data, duint size, duint* sizeWritten);
        SCRIPT_EXPORT bool IsValidPtr(duint addr);
        SCRIPT_EXPORT duint RemoteAlloc(duint addr, duint size);
        SCRIPT_EXPORT bool RemoteFree(duint addr);
        SCRIPT_EXPORT unsigned int GetProtect(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetBase(duint addr, bool reserved = false, bool cache = true);
        SCRIPT_EXPORT duint GetSize(duint addr, bool reserved = false, bool cache = true);

        SCRIPT_EXPORT unsigned char ReadByte(duint addr);
        SCRIPT_EXPORT bool WriteByte(duint addr, unsigned char data);
        SCRIPT_EXPORT unsigned short ReadWord(duint addr);
        SCRIPT_EXPORT bool WriteWord(duint addr, unsigned short data);
        SCRIPT_EXPORT unsigned int ReadDword(duint addr);
        SCRIPT_EXPORT bool WriteDword(duint addr, unsigned int data);
        SCRIPT_EXPORT unsigned long long ReadQword(duint addr);
        SCRIPT_EXPORT bool WriteQword(duint addr, unsigned long long data);
        SCRIPT_EXPORT duint ReadPtr(duint addr);
        SCRIPT_EXPORT bool WritePtr(duint addr, duint data);
    }; //Memory
}; //Script

#endif //_SCRIPTAPI_MEMORY_H
```

`HyperHide/pluginsdk/_scriptapi_misc.h`:

```h
#ifndef _SCRIPTAPI_MISC_H
#define _SCRIPTAPI_MISC_H

#include "_scriptapi.h"

namespace Script
{
    namespace Misc
    {
        /// <summary>
        /// Evaluates an expression and returns the result. Analagous to using the Command field in x64dbg.
        ///
        /// Expressions can consist of memory locations, registers, flags, API names, labels, symbols, variables etc.
        ///
        /// Example: bool success = ParseExpression("[esp+8]", &val)
        /// </summary>
        /// <param name="expression">The expression to evaluate.</param>
        /// <param name="value">The result of the expression.</param>
        /// <returns>True on success, False on failure.</returns>
        SCRIPT_EXPORT bool ParseExpression(const char* expression, duint* value);

        /// <summary>
        /// Returns the address of a function in the debuggee's memory space.
        ///
        /// Example: duint addr = RemoteGetProcAddress("kernel32.dll", "GetProcAddress")
        /// </summary>
        /// <param name="module">The name of the module.</param>
        /// <param name="api">The name of the function.</param>
        /// <returns>The address of the function in the debuggee.</returns>
        SCRIPT_EXPORT duint RemoteGetProcAddress(const char* module, const char* api);

        /// <summary>
        /// Returns the address for a label created in the disassembly window.
        ///
        /// Example: duint addr = ResolveLabel("sneaky_crypto")
        /// </summary>
        /// <param name="label">The name of the label to resolve.</param>
        /// <returns>The memory address for the label.</returns>
        SCRIPT_EXPORT duint ResolveLabel(const char* label);

        /// <summary>
        /// Allocates the requested number of bytes from x64dbg's default process heap.
        ///
        /// Note: this allocation is in the debugger, not the debuggee.
        ///
        /// Memory allocated using this function should be Free'd after use.
        ///
        /// Example: void* addr = Alloc(0x100000)
        /// </summary>
        /// <param name="size">Number of bytes to allocate.</param>
        /// <returns>A pointer to the newly allocated memory.</returns>
        SCRIPT_EXPORT void* Alloc(duint size);

        /// <summary>
        /// Frees memory previously allocated by Alloc.
        ///
        /// Example: Free(addr)
        /// </summary>
        /// <param name="ptr">Pointer returned by Alloc.</param>
        /// <returns>Nothing.</returns>
        SCRIPT_EXPORT void Free(void* ptr);
    }; //Misc
}; //Script

#endif //_SCRIPTAPI_MISC_H
```

`HyperHide/pluginsdk/_scriptapi_module.h`:

```h
#ifndef _SCRIPTAPI_MODULE_H
#define _SCRIPTAPI_MODULE_H

#include "_scriptapi.h"

namespace Script
{
    namespace Module
    {
        struct ModuleInfo
        {
            duint base;
            duint size;
            duint entry;
            int sectionCount;
            char name[MAX_MODULE_SIZE];
            char path[MAX_PATH];
        };

        struct ModuleSectionInfo
        {
            duint addr;
            duint size;
            char name[MAX_SECTION_SIZE * 5];
        };

        struct ModuleExport
        {
            duint ordinal;
            duint rva;
            duint va;
            bool forwarded;
            char forwardName[MAX_STRING_SIZE];
            char name[MAX_STRING_SIZE];
            char undecoratedName[MAX_STRING_SIZE];
        };

        struct ModuleImport
        {
            duint iatRva;
            duint iatVa;
            duint ordinal; //equal to -1 if imported by name
            char name[MAX_STRING_SIZE];
            char undecoratedName[MAX_STRING_SIZE];
        };

        SCRIPT_EXPORT bool InfoFromAddr(duint addr, ModuleInfo* info);
        SCRIPT_EXPORT bool InfoFromName(const char* name, ModuleInfo* info);
        SCRIPT_EXPORT duint BaseFromAddr(duint addr);
        SCRIPT_EXPORT duint BaseFromName(const char* name);
        SCRIPT_EXPORT duint SizeFromAddr(duint addr);
        SCRIPT_EXPORT duint SizeFromName(const char* name);
        SCRIPT_EXPORT bool NameFromAddr(duint addr, char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool PathFromAddr(duint addr, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool PathFromName(const char* name, char* path); //path[MAX_PATH]
        SCRIPT_EXPORT duint EntryFromAddr(duint addr);
        SCRIPT_EXPORT duint EntryFromName(const char* name);
        SCRIPT_EXPORT int SectionCountFromAddr(duint addr);
        SCRIPT_EXPORT int SectionCountFromName(const char* name);
        SCRIPT_EXPORT bool SectionFromAddr(duint addr, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionFromName(const char* name, int number, ModuleSectionInfo* section);
        SCRIPT_EXPORT bool SectionListFromAddr(duint addr, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool SectionListFromName(const char* name, ListOf(ModuleSectionInfo) list);
        SCRIPT_EXPORT bool GetMainModuleInfo(ModuleInfo* info);
        SCRIPT_EXPORT duint GetMainModuleBase();
        SCRIPT_EXPORT duint GetMainModuleSize();
        SCRIPT_EXPORT duint GetMainModuleEntry();
        SCRIPT_EXPORT int GetMainModuleSectionCount();
        SCRIPT_EXPORT bool GetMainModuleName(char* name); //name[MAX_MODULE_SIZE]
        SCRIPT_EXPORT bool GetMainModulePath(char* path); //path[MAX_PATH]
        SCRIPT_EXPORT bool GetMainModuleSectionList(ListOf(ModuleSectionInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetList(ListOf(ModuleInfo) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetExports(const ModuleInfo* mod, ListOf(ModuleExport) list); //caller has the responsibility to free the list
        SCRIPT_EXPORT bool GetImports(const ModuleInfo* mod, ListOf(ModuleImport) list); //caller has the responsibility to free the list
    }; //Module
}; //Script

#endif //_SCRIPTAPI_MODULE_H

```

`HyperHide/pluginsdk/_scriptapi_pattern.h`:

```h
#ifndef _SCRIPTAPI_PATTERN_H
#define _SCRIPTAPI_PATTERN_H

#include "_scriptapi.h"

namespace Script
{
    namespace Pattern
    {
        SCRIPT_EXPORT duint Find(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT duint FindMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT void Write(unsigned char* data, duint datasize, const char* pattern);
        SCRIPT_EXPORT void WriteMem(duint start, duint size, const char* pattern);
        SCRIPT_EXPORT bool SearchAndReplace(unsigned char* data, duint datasize, const char* searchpattern, const char* replacepattern);
        SCRIPT_EXPORT bool SearchAndReplaceMem(duint start, duint size, const char* searchpattern, const char* replacepattern);
    };
};

#endif //_SCRIPTAPI_FIND_H
```

`HyperHide/pluginsdk/_scriptapi_register.h`:

```h
#ifndef _SCRIPTAPI_REGISTER_H
#define _SCRIPTAPI_REGISTER_H

#include "_scriptapi.h"

namespace Script
{
    namespace Register
    {
        enum RegisterEnum
        {
            DR0,
            DR1,
            DR2,
            DR3,
            DR6,
            DR7,

            EAX,
            AX,
            AH,
            AL,
            EBX,
            BX,
            BH,
            BL,
            ECX,
            CX,
            CH,
            CL,
            EDX,
            DX,
            DH,
            DL,
            EDI,
            DI,
            ESI,
            SI,
            EBP,
            BP,
            ESP,
            SP,
            EIP,

#ifdef _WIN64
            RAX,
            RBX,
            RCX,
            RDX,
            RSI,
            SIL,
            RDI,
            DIL,
            RBP,
            BPL,
            RSP,
            SPL,
            RIP,
            R8,
            R8D,
            R8W,
            R8B,
            R9,
            R9D,
            R9W,
            R9B,
            R10,
            R10D,
            R10W,
            R10B,
            R11,
            R11D,
            R11W,
            R11B,
            R12,
            R12D,
            R12W,
            R12B,
            R13,
            R13D,
            R13W,
            R13B,
            R14,
            R14D,
            R14W,
            R14B,
            R15,
            R15D,
            R15W,
            R15B,
#endif //_WIN64

            CIP,
            CSP,
            CAX,
            CBX,
            CCX,
            CDX,
            CDI,
            CSI,
            CBP,
            CFLAGS
        }; //RegisterEnum

        SCRIPT_EXPORT duint Get(RegisterEnum reg);
        SCRIPT_EXPORT bool Set(RegisterEnum reg, duint value);
        SCRIPT_EXPORT int Size(); //gets architecture register size in bytes

        SCRIPT_EXPORT duint GetDR0();
        SCRIPT_EXPORT bool SetDR0(duint value);
        SCRIPT_EXPORT duint GetDR1();
        SCRIPT_EXPORT bool SetDR1(duint value);
        SCRIPT_EXPORT duint GetDR2();
        SCRIPT_EXPORT bool SetDR2(duint value);
        SCRIPT_EXPORT duint GetDR3();
        SCRIPT_EXPORT bool SetDR3(duint value);
        SCRIPT_EXPORT duint GetDR6();
        SCRIPT_EXPORT bool SetDR6(duint value);
        SCRIPT_EXPORT duint GetDR7();
        SCRIPT_EXPORT bool SetDR7(duint value);

        SCRIPT_EXPORT unsigned int GetEAX();
        SCRIPT_EXPORT bool SetEAX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetAX();
        SCRIPT_EXPORT bool SetAX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetAH();
        SCRIPT_EXPORT bool SetAH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetAL();
        SCRIPT_EXPORT bool SetAL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEBX();
        SCRIPT_EXPORT bool SetEBX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBX();
        SCRIPT_EXPORT bool SetBX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetBH();
        SCRIPT_EXPORT bool SetBH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetBL();
        SCRIPT_EXPORT bool SetBL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetECX();
        SCRIPT_EXPORT bool SetECX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetCX();
        SCRIPT_EXPORT bool SetCX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetCH();
        SCRIPT_EXPORT bool SetCH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetCL();
        SCRIPT_EXPORT bool SetCL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDX();
        SCRIPT_EXPORT bool SetEDX(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDX();
        SCRIPT_EXPORT bool SetDX(unsigned short value);
        SCRIPT_EXPORT unsigned char GetDH();
        SCRIPT_EXPORT bool SetDH(unsigned char value);
        SCRIPT_EXPORT unsigned char GetDL();
        SCRIPT_EXPORT bool SetDL(unsigned char value);
        SCRIPT_EXPORT unsigned int GetEDI();
        SCRIPT_EXPORT bool SetEDI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetDI();
        SCRIPT_EXPORT bool SetDI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESI();
        SCRIPT_EXPORT bool SetESI(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSI();
        SCRIPT_EXPORT bool SetSI(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEBP();
        SCRIPT_EXPORT bool SetEBP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetBP();
        SCRIPT_EXPORT bool SetBP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetESP();
        SCRIPT_EXPORT bool SetESP(unsigned int value);
        SCRIPT_EXPORT unsigned short GetSP();
        SCRIPT_EXPORT bool SetSP(unsigned short value);
        SCRIPT_EXPORT unsigned int GetEIP();
        SCRIPT_EXPORT bool SetEIP(unsigned int value);

#ifdef _WIN64
        SCRIPT_EXPORT unsigned long long GetRAX();
        SCRIPT_EXPORT bool SetRAX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRBX();
        SCRIPT_EXPORT bool SetRBX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRCX();
        SCRIPT_EXPORT bool SetRCX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRDX();
        SCRIPT_EXPORT bool SetRDX(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetRSI();
        SCRIPT_EXPORT bool SetRSI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSIL();
        SCRIPT_EXPORT bool SetSIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRDI();
        SCRIPT_EXPORT bool SetRDI(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetDIL();
        SCRIPT_EXPORT bool SetDIL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRBP();
        SCRIPT_EXPORT bool SetRBP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetBPL();
        SCRIPT_EXPORT bool SetBPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRSP();
        SCRIPT_EXPORT bool SetRSP(unsigned long long value);
        SCRIPT_EXPORT unsigned char GetSPL();
        SCRIPT_EXPORT bool SetSPL(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetRIP();
        SCRIPT_EXPORT bool SetRIP(unsigned long long value);
        SCRIPT_EXPORT unsigned long long GetR8();
        SCRIPT_EXPORT bool SetR8(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR8D();
        SCRIPT_EXPORT bool SetR8D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR8W();
        SCRIPT_EXPORT bool SetR8W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR8B();
        SCRIPT_EXPORT bool SetR8B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR9();
        SCRIPT_EXPORT bool SetR9(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR9D();
        SCRIPT_EXPORT bool SetR9D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR9W();
        SCRIPT_EXPORT bool SetR9W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR9B();
        SCRIPT_EXPORT bool SetR9B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR10();
        SCRIPT_EXPORT bool SetR10(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR10D();
        SCRIPT_EXPORT bool SetR10D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR10W();
        SCRIPT_EXPORT bool SetR10W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR10B();
        SCRIPT_EXPORT bool SetR10B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR11();
        SCRIPT_EXPORT bool SetR11(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR11D();
        SCRIPT_EXPORT bool SetR11D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR11W();
        SCRIPT_EXPORT bool SetR11W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR11B();
        SCRIPT_EXPORT bool SetR11B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR12();
        SCRIPT_EXPORT bool SetR12(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR12D();
        SCRIPT_EXPORT bool SetR12D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR12W();
        SCRIPT_EXPORT bool SetR12W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR12B();
        SCRIPT_EXPORT bool SetR12B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR13();
        SCRIPT_EXPORT bool SetR13(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR13D();
        SCRIPT_EXPORT bool SetR13D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR13W();
        SCRIPT_EXPORT bool SetR13W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR13B();
        SCRIPT_EXPORT bool SetR13B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR14();
        SCRIPT_EXPORT bool SetR14(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR14D();
        SCRIPT_EXPORT bool SetR14D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR14W();
        SCRIPT_EXPORT bool SetR14W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR14B();
        SCRIPT_EXPORT bool SetR14B(unsigned char value);
        SCRIPT_EXPORT unsigned long long GetR15();
        SCRIPT_EXPORT bool SetR15(unsigned long long value);
        SCRIPT_EXPORT unsigned int GetR15D();
        SCRIPT_EXPORT bool SetR15D(unsigned int value);
        SCRIPT_EXPORT unsigned short GetR15W();
        SCRIPT_EXPORT bool SetR15W(unsigned short value);
        SCRIPT_EXPORT unsigned char GetR15B();
        SCRIPT_EXPORT bool SetR15B(unsigned char value);
#endif //_WIN64

        SCRIPT_EXPORT duint GetCAX();
        SCRIPT_EXPORT bool SetCAX(duint value);
        SCRIPT_EXPORT duint GetCBX();
        SCRIPT_EXPORT bool SetCBX(duint value);
        SCRIPT_EXPORT duint GetCCX();
        SCRIPT_EXPORT bool SetCCX(duint value);
        SCRIPT_EXPORT duint GetCDX();
        SCRIPT_EXPORT bool SetCDX(duint value);
        SCRIPT_EXPORT duint GetCDI();
        SCRIPT_EXPORT bool SetCDI(duint value);
        SCRIPT_EXPORT duint GetCSI();
        SCRIPT_EXPORT bool SetCSI(duint value);
        SCRIPT_EXPORT duint GetCBP();
        SCRIPT_EXPORT bool SetCBP(duint value);
        SCRIPT_EXPORT duint GetCSP();
        SCRIPT_EXPORT bool SetCSP(duint value);
        SCRIPT_EXPORT duint GetCIP();
        SCRIPT_EXPORT bool SetCIP(duint value);
        SCRIPT_EXPORT duint GetCFLAGS();
        SCRIPT_EXPORT bool SetCFLAGS(duint value);
    }; //Register
}; //Script

#endif //_SCRIPTAPI_REGISTER_H
```

`HyperHide/pluginsdk/_scriptapi_stack.h`:

```h
#ifndef _SCRIPTAPI_STACK_H
#define _SCRIPTAPI_STACK_H

#include "_scriptapi.h"

namespace Script
{
    namespace Stack
    {
        SCRIPT_EXPORT duint Pop();
        SCRIPT_EXPORT duint Push(duint value); //returns the previous top, equal to Peek(1)
        SCRIPT_EXPORT duint Peek(int offset = 0); //offset is in multiples of Register::Size(), for easy x32/x64 portability
    }; //Stack
}; //Script

#endif //_SCRIPTAPI_STACK_H
```

`HyperHide/pluginsdk/_scriptapi_symbol.h`:

```h
#ifndef _SCRIPTAPI_SYMBOL_H
#define _SCRIPTAPI_SYMBOL_H

#include "_scriptapi.h"

namespace Script
{
    namespace Symbol
    {
        enum SymbolType
        {
            Function, //user-defined function
            Import, //IAT entry
            Export //export
        };

        struct SymbolInfo
        {
            char mod[MAX_MODULE_SIZE];
            duint rva;
            char name[MAX_LABEL_SIZE];
            bool manual;
            SymbolType type;
        };

        SCRIPT_EXPORT bool GetList(ListOf(SymbolInfo) list); //caller has the responsibility to free the list
    }; //Symbol
}; //Script

#endif //_SCRIPTAPI_SYMBOL_H
```

`HyperHide/pluginsdk/bridgegraph.h`:

```h
#ifndef _GRAPH_H
#define _GRAPH_H

typedef struct
{
    duint addr; //virtual address of the instruction
    unsigned char data[15]; //instruction bytes
} BridgeCFInstruction;

typedef struct
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    ListInfo exits; //exits (including brtrue and brfalse, duint)
    ListInfo instrs; //block instructions
} BridgeCFNodeList;

typedef struct
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    ListInfo nodes; //graph nodes (BridgeCFNodeList)
} BridgeCFGraphList;

#ifdef __cplusplus
#if _MSC_VER >= 1700 && !defined(NO_CPP11)

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <utility>

struct BridgeCFNode
{
    duint parentGraph = 0; //function of which this node is a part
    duint start = 0; //start of the block
    duint end = 0; //end of the block (inclusive)
    duint brtrue = 0; //destination if condition is true
    duint brfalse = 0; //destination if condition is false
    duint icount = 0; //number of instructions in node
    bool terminal = false; //node is a RET
    bool split = false; //node is a split (brtrue points to the next node)
    bool indirectcall = false; //node contains indirect calls (call reg, call [reg+X])
    void* userdata = nullptr; //user data
    std::vector<duint> exits; //exits (including brtrue and brfalse)
    std::vector<BridgeCFInstruction> instrs; //block instructions

    static void Free(const BridgeCFNodeList* nodeList)
    {
        if(!BridgeList<duint>::Free(&nodeList->exits))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::Free(&nodeList->instrs))
            __debugbreak();
    }

    BridgeCFNode() = default;

    BridgeCFNode(const BridgeCFNodeList* nodeList, bool freedata)
    {
        if(!nodeList)
            __debugbreak();
        parentGraph = nodeList->parentGraph;
        start = nodeList->start;
        end = nodeList->end;
        brtrue = nodeList->brtrue;
        brfalse = nodeList->brfalse;
        icount = nodeList->icount;
        terminal = nodeList->terminal;
        indirectcall = nodeList->indirectcall;
        split = nodeList->split;
        userdata = nodeList->userdata;
        if(!BridgeList<duint>::ToVector(&nodeList->exits, exits, freedata))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::ToVector(&nodeList->instrs, instrs, freedata))
            __debugbreak();
    }

    BridgeCFNode(duint parentGraph, duint start, duint end)
        : parentGraph(parentGraph),
          start(start),
          end(end)
    {
    }

    BridgeCFNodeList ToNodeList() const
    {
        BridgeCFNodeList out;
        out.parentGraph = parentGraph;
        out.start = start;
        out.end = end;
        out.brtrue = brtrue;
        out.brfalse = brfalse;
        out.icount = icount;
        out.terminal = terminal;
        out.indirectcall = indirectcall;
        out.split = split;
        out.userdata = userdata;
        BridgeList<duint>::CopyData(&out.exits, exits);
        BridgeList<BridgeCFInstruction>::CopyData(&out.instrs, instrs);
        return std::move(out);
    }
};

struct BridgeCFGraph
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    std::unordered_map<duint, BridgeCFNode> nodes; //CFNode.start -> CFNode
    std::unordered_map<duint, std::unordered_set<duint>> parents; //CFNode.start -> parents

    static void Free(const BridgeCFGraphList* graphList)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            BridgeCFNode::Free(&data[i]);
        BridgeFree(data);
    }

    explicit BridgeCFGraph(const BridgeCFGraphList* graphList, bool freedata)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        entryPoint = graphList->entryPoint;
        userdata = graphList->userdata;
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            AddNode(BridgeCFNode(&data[i], freedata));
        if(freedata && data)
            BridgeFree(data);
    }

    explicit BridgeCFGraph(duint entryPoint)
        : entryPoint(entryPoint),
          userdata(nullptr)
    {
    }

    void AddNode(const BridgeCFNode & node)
    {
        nodes[node.start] = node;
        AddParent(node.start, node.brtrue);
        AddParent(node.start, node.brfalse);
    }

    void AddParent(duint child, duint parent)
    {
        if(!child || !parent)
            return;
        auto found = parents.find(child);
        if(found == parents.end())
        {
            parents[child] = std::unordered_set<duint>();
            parents[child].insert(parent);
        }
        else
            found->second.insert(parent);
    }

    BridgeCFGraphList ToGraphList() const
    {
        BridgeCFGraphList out;
        out.entryPoint = entryPoint;
        out.userdata = userdata;
        std::vector<BridgeCFNodeList> nodeList;
        nodeList.reserve(nodes.size());
        for(const auto & nodeIt : nodes)
            nodeList.push_back(nodeIt.second.ToNodeList());
        BridgeList<BridgeCFNodeList>::CopyData(&out.nodes, nodeList);
        return std::move(out);
    }
};

#endif //_MSC_VER
#endif //__cplusplus

#endif //_GRAPH_H
```

`HyperHide/pluginsdk/bridgelist.h`:

```h
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type)) //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count())) //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

    static bool Free(const ListInfo* listInfo)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        BridgeFree(listInfo->data);
        return true;
    }

    static bool ToVector(const ListInfo* listInfo, std::vector<Type> & listData, bool freedata = true)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        listData.resize(listInfo->count);
        for(int i = 0; i < listInfo->count; i++)
            listData[i] = ((Type*)listInfo->data)[i];
        if(freedata && listInfo->data)
            BridgeFree(listInfo->data);
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H
```

`HyperHide/pluginsdk/bridgemain.h`:

```h
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <windows.h>

#ifndef __cplusplus
#include <stdbool.h>
#define DEFAULT_PARAM(name, value) name
#else
#define DEFAULT_PARAM(name, value) name = value
#endif

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions

/// <summary>
/// Initialize the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeInit();

/// <summary>
/// Start the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeStart();

/// <summary>
/// Allocate buffer. Use BridgeFree to free the buffer.
/// </summary>
/// <param name="size">Size in bytes of the buffer to allocate.</param>
/// <returns>A pointer to the allocated buffer. This function will trigger a crash dump if unsuccessful.</returns>
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);

/// <summary>
/// Free buffer allocated by BridgeAlloc.
/// </summary>
/// <param name="ptr">Buffer to free.</param>
BRIDGE_IMPEXP void BridgeFree(void* ptr);

/// <summary>
/// Get a string setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output buffer for the value. Should be of MAX_SETTING_SIZE. Cannot be null.</param>
/// <returns>True if the setting was found and copied in the value parameter.</returns>
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);

/// <summary>
/// Get an integer setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output value.</param>
/// <returns>True if the setting was found and successfully converted to an integer.</returns>
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);

/// <summary>
/// Set a string setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value. Set to null to remove the key from the section.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);

/// <summary>
/// Set an integer setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);

/// <summary>
/// Flush the in-memory setting store to disk.
/// </summary>
/// <returns></returns>
BRIDGE_IMPEXP bool BridgeSettingFlush();

/// <summary>
/// Read the in-memory setting store from disk.
/// </summary>
/// <param name="errorLine">Line where the error occurred. Set to null to ignore this.</param>
/// <returns>True if the setting were read and parsed correctly.</returns>
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);

/// <summary>
/// Get the debugger version.
/// </summary>
/// <returns>25</returns>
BRIDGE_IMPEXP int BridgeGetDbgVersion();

/// <summary>
/// Checks if the current process is elevated.
/// </summary>
/// <returns>true if the process is elevated, false otherwise.</returns>
BRIDGE_IMPEXP bool BridgeIsProcessElevated();

#ifdef __cplusplus
}
#endif

//list structure (and C++ wrapper)
#include "bridgelist.h"

#include "bridgegraph.h"

#ifdef __cplusplus
extern "C"
{
#endif

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 65536
#define MAX_BREAKPOINT_SIZE 256
#define MAX_CONDITIONAL_EXPR_SIZE 256
#define MAX_CONDITIONAL_TEXT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_WATCH_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG") + 1)
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64
#define PAGE_SIZE 0x1000

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 0x1,
    flaglabel = 0x2,
    flagcomment = 0x4,
    flagbookmark = 0x8,
    flagfunction = 0x10,
    flagloop = 0x20,
    flagargs = 0x40,
    flagNoFuncOffset = 0x80
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4,
    bp_dll = 8,
    bp_exception = 16
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END,
    LOOP_SINGLE
} LOOPTYPE;

//order by most important type last
typedef enum
{
    XREF_NONE,
    XREF_DATA,
    XREF_JMP,
    XREF_CALL
} XREFTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END,
    ARG_SINGLE
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_DELETE_COMMENT_RANGE,       // param1=duint start,               param2=duint end
    DBG_DELETE_LABEL_RANGE,         // param1=duint start,               param2=duint end
    DBG_DELETE_BOOKMARK_RANGE,      // param1=duint start,               param2=duint end
    DBG_GET_XREF_COUNT_AT,          // param1=duint addr,                param2=unused
    DBG_GET_XREF_TYPE_AT,           // param1=duint addr,                param2=unused
    DBG_XREF_ADD,                   // param1=duint addr,                param2=duint from
    DBG_XREF_DEL_ALL,               // param1=duint addr,                param2=unused
    DBG_XREF_GET,                   // param1=duint addr,                param2=XREF_INFO* info
    DBG_GET_ENCODE_TYPE_BUFFER,     // param1=duint addr,                param2=unused
    DBG_ENCODE_TYPE_GET,            // param1=duint addr,                param2=duint size
    DBG_DELETE_ENCODE_TYPE_RANGE,   // param1=duint start,               param2=duint end
    DBG_ENCODE_SIZE_GET,            // param1=duint addr,                param2=duint codesize
    DBG_DELETE_ENCODE_TYPE_SEG,     // param1=duint addr,                param2=unused
    DBG_RELEASE_ENCODE_TYPE_BUFFER, // param1=void* buffer,              param2=unused
    DBG_ARGUMENT_GET,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_OVERLAPS,          // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_ADD,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_DEL,               // param1=FUNCTION* info,            param2=unused
    DBG_GET_WATCH_LIST,             // param1=ListOf(WATCHINFO),         param2=unused
    DBG_SELCHANGED,                 // param1=hWindow,                   param2=VA
    DBG_GET_PROCESS_HANDLE,         // param1=unused,                    param2=unused
    DBG_GET_THREAD_HANDLE,          // param1=unused,                    param2=unused
    DBG_GET_PROCESS_ID,             // param1=unused,                    param2=unused
    DBG_GET_THREAD_ID,              // param1=unused,                    param2=unused
    DBG_GET_PEB_ADDRESS,            // param1=DWORD ProcessId,           param2=unused
    DBG_GET_TEB_ADDRESS,            // param1=DWORD ThreadId,            param2=unused
    DBG_ANALYZE_FUNCTION,           // param1=BridgeCFGraphList* graph,  param2=duint entry
    DBG_MENU_PREPARE,               // param1=int hMenu,                 param2=unused
    DBG_GET_SYMBOL_INFO,            // param1=void* symbol,              param2=SYMBOLINFO* info
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8
} MEMORY_SIZE;

typedef enum
{
    enc_unknown,  //must be 0
    enc_byte,     //1 byte
    enc_word,     //2 bytes
    enc_dword,    //4 bytes
    enc_fword,    //6 bytes
    enc_qword,    //8 bytes
    enc_tbyte,    //10 bytes
    enc_oword,    //16 bytes
    enc_mmword,   //8 bytes
    enc_xmmword,  //16 bytes
    enc_ymmword,  //32 bytes
    enc_zmmword,  //64 bytes avx512 not supported
    enc_real4,    //4 byte float
    enc_real8,    //8 byte double
    enc_real10,   //10 byte decimal
    enc_ascii,    //ascii sequence
    enc_unicode,  //unicode sequence
    enc_code,     //start of code
    enc_junk,     //junk code
    enc_middle    //middle of data
} ENCODETYPE;

typedef enum
{
    TYPE_UINT, // unsigned integer
    TYPE_INT,  // signed integer
    TYPE_FLOAT,// single precision floating point value
    TYPE_ASCII, // ascii string
    TYPE_UNICODE, // unicode string
    TYPE_INVALID // invalid watch expression or data type
} WATCHVARTYPE;

typedef enum
{
    MODE_DISABLED, // watchdog is disabled
    MODE_ISTRUE,   // alert if expression is not 0
    MODE_ISFALSE,  // alert if expression is 0
    MODE_CHANGED,  // alert if expression is changed
    MODE_UNCHANGED // alert if expression is not changed
} WATCHDOGMODE;

typedef enum
{
    hw_access,
    hw_write,
    hw_execute
} BPHWTYPE;

typedef enum
{
    mem_access,
    mem_read,
    mem_write,
    mem_execute
} BPMEMTYPE;

typedef enum
{
    dll_load = 1,
    dll_unload,
    dll_all
} BPDLLTYPE;

typedef enum
{
    ex_firstchance = 1,
    ex_secondchance,
    ex_all
} BPEXTYPE;

typedef enum
{
    hw_byte,
    hw_word,
    hw_dword,
    hw_qword
} BPHWSIZE;

typedef enum
{
    sym_import,
    sym_export,
    sym_symbol
} SYMBOLTYPE;

//Debugger typedefs
typedef MEMORY_SIZE VALUE_SIZE;

typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

typedef bool (*CBSYMBOLENUM)(const struct SYMBOLPTR_* symbol, void* user);

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
    // extended part
    unsigned char typeEx; //BPHWTYPE/BPMEMTYPE/BPDLLTYPE/BPEXTYPE
    unsigned char hwSize; //BPHWSIZE
    unsigned int hitCount;
    bool fastResume;
    bool silent;
    char breakCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char logText[MAX_CONDITIONAL_TEXT_SIZE];
    char logCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char commandText[MAX_CONDITIONAL_TEXT_SIZE];
    char commandCondition[MAX_CONDITIONAL_EXPR_SIZE];
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    char WatchName[MAX_WATCH_NAME_SIZE];
    char Expression[MAX_CONDITIONAL_EXPR_SIZE];
    unsigned int window;
    unsigned int id;
    WATCHVARTYPE varType;
    WATCHDOGMODE watchdogMode;
    duint value;
    bool watchdogTriggered;
} WATCHINFO;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} LOOP;

typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
    FUNCTION args;
} BRIDGE_ADDRINFO;

typedef struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    SYMBOLTYPE type;
    bool freeDecorated;
    bool freeUndecorated;
    DWORD ordinal;
} SYMBOLINFO;

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool ES;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    DWORD code;
    char name[128];
} LASTERROR;

typedef struct
{
    DWORD code;
    char name[128];
} LASTSTATUS;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
    LASTSTATUS lastStatus;
} REGDUMP;

typedef struct
{
    DISASM_ARGTYPE type; //normal/memory
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant; //constant in the instruction (imm/disp)
    duint value; //equal to constant or equal to the register value
    duint memvalue; //memsize:[value]
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
    FILETIME UserTime;
    FILETIME KernelTime;
    FILETIME CreationTime;
    ULONG64 Cycles; // Windows Vista or greater
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

typedef struct
{
    duint addr;
    XREFTYPE type;
} XREF_RECORD;

typedef struct
{
    duint refcount;
    XREF_RECORD* references;
} XREF_INFO;

typedef struct SYMBOLPTR_
{
    duint modbase;
    const void* symbol;
} SYMBOLPTR;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, void* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const void* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);

/// <summary>
/// Asynchronously execute a debugger command by adding it to the command queue.
/// Note: the command may not have completed before this call returns. Use this
/// function if you don't care when the command gets executed.
///
/// Example: DbgCmdExec("ClearLog")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command was successfully submitted to the command queue. False if the submission failed.</returns>
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);

/// <summary>
/// Performs synchronous execution of a debugger command. This function call only
/// returns after the command has completed.
///
/// Example: DbgCmdExecDirect("loadlib advapi32.dll")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command executed successfully, False if there was a problem.</returns>
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP void DbgClearBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDumpEx(REGDUMP* regdump, size_t size);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP void DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP void DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgArgumentGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgArgumentOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgXrefAdd(duint addr, duint from);
BRIDGE_IMPEXP bool DbgXrefDelAll(duint addr);
BRIDGE_IMPEXP bool DbgXrefGet(duint addr, XREF_INFO* info);
BRIDGE_IMPEXP size_t DbgGetXrefCountAt(duint addr);
BRIDGE_IMPEXP XREFTYPE DbgGetXrefTypeAt(duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);
BRIDGE_IMPEXP void* DbgGetEncodeTypeBuffer(duint addr, duint* size);
BRIDGE_IMPEXP void DbgReleaseEncodeTypeBuffer(void* buffer);
BRIDGE_IMPEXP ENCODETYPE DbgGetEncodeTypeAt(duint addr, duint size);
BRIDGE_IMPEXP duint DbgGetEncodeSizeAt(duint addr, duint codesize);
BRIDGE_IMPEXP bool DbgSetEncodeType(duint addr, duint size, ENCODETYPE type);
BRIDGE_IMPEXP void DbgDelEncodeTypeRange(duint start, duint end);
BRIDGE_IMPEXP void DbgDelEncodeTypeSegment(duint start);
BRIDGE_IMPEXP bool DbgGetWatchList(ListOf(WATCHINFO) list);
BRIDGE_IMPEXP void DbgSelChanged(int hWindow, duint VA);
BRIDGE_IMPEXP HANDLE DbgGetProcessHandle();
BRIDGE_IMPEXP HANDLE DbgGetThreadHandle();
BRIDGE_IMPEXP DWORD DbgGetProcessId();
BRIDGE_IMPEXP DWORD DbgGetThreadId();
BRIDGE_IMPEXP duint DbgGetPebAddress(DWORD ProcessId);
BRIDGE_IMPEXP duint DbgGetTebAddress(DWORD ThreadId);
BRIDGE_IMPEXP bool DbgAnalyzeFunction(duint entry, BridgeCFGraphList* graph);
BRIDGE_IMPEXP duint DbgEval(const char* expression, bool* DEFAULT_PARAM(success, nullptr));
BRIDGE_IMPEXP void DbgGetSymbolInfo(const SYMBOLPTR* symbolptr, SYMBOLINFO* info);

//Gui defines
typedef enum
{
    GUI_PLUGIN_MENU,
    GUI_DISASM_MENU,
    GUI_DUMP_MENU,
    GUI_STACK_MENU,
    GUI_GRAPH_MENU,
    GUI_MEMMAP_MENU,
    GUI_SYMMOD_MENU,
} GUIMENUTYPE;

BRIDGE_IMPEXP void DbgMenuPrepare(GUIMENUTYPE hMenu);

typedef enum
{
    GUI_DISASSEMBLY,
    GUI_DUMP,
    GUI_STACK,
    GUI_GRAPH,
    GUI_MEMMAP,
    GUI_SYMMOD,
} GUISELECTIONTYPE;

#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums
typedef enum
{
    GUI_DISASSEMBLE_AT,             // param1=(duint)va,            param2=(duint)cip
    GUI_SET_DEBUG_STATE,            // param1=(DBGSTATE)state,      param2=unused
    GUI_ADD_MSG_TO_LOG,             // param1=(const char*)msg,     param2=unused
    GUI_CLEAR_LOG,                  // param1=unused,               param2=unused
    GUI_UPDATE_REGISTER_VIEW,       // param1=unused,               param2=unused
    GUI_UPDATE_DISASSEMBLY_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_BREAKPOINTS_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_WINDOW_TITLE,        // param1=(const char*)file,    param2=unused
    GUI_GET_WINDOW_HANDLE,          // param1=unused,               param2=unused
    GUI_DUMP_AT,                    // param1=(duint)va             param2=unused
    GUI_SCRIPT_ADD,                 // param1=int count,            param2=const char** lines
    GUI_SCRIPT_CLEAR,               // param1=unused,               param2=unused
    GUI_SCRIPT_SETIP,               // param1=int line,             param2=unused
    GUI_SCRIPT_ERROR,               // param1=int line,             param2=const char* message
    GUI_SCRIPT_SETTITLE,            // param1=const char* title,    param2=unused
    GUI_SCRIPT_SETINFOLINE,         // param1=int line,             param2=const char* info
    GUI_SCRIPT_MESSAGE,             // param1=const char* message,  param2=unused
    GUI_SCRIPT_MSGYN,               // param1=const char* message,  param2=unused
    GUI_SYMBOL_LOG_ADD,             // param1(const char*)msg,      param2=unused
    GUI_SYMBOL_LOG_CLEAR,           // param1=unused,               param2=unused
    GUI_SYMBOL_SET_PROGRESS,        // param1=int percent           param2=unused
    GUI_SYMBOL_UPDATE_MODULE_LIST,  // param1=int count,            param2=SYMBOLMODULEINFO* modules
    GUI_REF_ADDCOLUMN,              // param1=int width,            param2=(const char*)title
    GUI_REF_SETROWCOUNT,            // param1=int rows,             param2=unused
    GUI_REF_GETROWCOUNT,            // param1=unused,               param2=unused
    GUI_REF_DELETEALLCOLUMNS,       // param1=unused,               param2=unused
    GUI_REF_SETCELLCONTENT,         // param1=(CELLINFO*)info,      param2=unused
    GUI_REF_GETCELLCONTENT,         // param1=int row,              param2=int col
    GUI_REF_RELOADDATA,             // param1=unused,               param2=unused
    GUI_REF_SETSINGLESELECTION,     // param1=int index,            param2=bool scroll
    GUI_REF_SETPROGRESS,            // param1=int progress,         param2=unused
    GUI_REF_SETCURRENTTASKPROGRESS, // param1=int progress,         param2=const char* taskTitle
    GUI_REF_SETSEARCHSTARTCOL,      // param1=int col               param2=unused
    GUI_STACK_DUMP_AT,              // param1=duint addr,           param2=duint csp
    GUI_UPDATE_DUMP_VIEW,           // param1=unused,               param2=unused
    GUI_UPDATE_THREAD_VIEW,         // param1=unused,               param2=unused
    GUI_ADD_RECENT_FILE,            // param1=(const char*)file,    param2=unused
    GUI_SET_LAST_EXCEPTION,         // param1=unsigned int code,    param2=unused
    GUI_GET_DISASSEMBLY,            // param1=duint addr,           param2=char* text
    GUI_MENU_ADD,                   // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_ENTRY,             // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_SEPARATOR,         // param1=int hMenu,            param2=unused
    GUI_MENU_CLEAR,                 // param1=int hMenu,            param2=unused
    GUI_SELECTION_GET,              // param1=GUISELECTIONTYPE,     param2=SELECTIONDATA* selection
    GUI_SELECTION_SET,              // param1=GUISELECTIONTYPE,     param2=const SELECTIONDATA* selection
    GUI_GETLINE_WINDOW,             // param1=const char* title,    param2=char* text
    GUI_AUTOCOMPLETE_ADDCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_DELCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_CLEARALL,      // param1=unused,               param2=unused
    GUI_SCRIPT_ENABLEHIGHLIGHTING,  // param1=bool enable,          param2=unused
    GUI_ADD_MSG_TO_STATUSBAR,       // param1=const char* msg,      param2=unused
    GUI_UPDATE_SIDEBAR,             // param1=unused,               param2=unused
    GUI_REPAINT_TABLE_VIEW,         // param1=unused,               param2=unused
    GUI_UPDATE_PATCHES,             // param1=unused,               param2=unused
    GUI_UPDATE_CALLSTACK,           // param1=unused,               param2=unused
    GUI_UPDATE_SEHCHAIN,            // param1=unused,               param2=unused
    GUI_SYMBOL_REFRESH_CURRENT,     // param1=unused,               param2=unused
    GUI_UPDATE_MEMORY_VIEW,         // param1=unused,               param2=unused
    GUI_REF_INITIALIZE,             // param1=const char* name,     param2=unused
    GUI_LOAD_SOURCE_FILE,           // param1=const char* path,     param2=duint addr
    GUI_MENU_SET_ICON,              // param1=int hMenu,            param2=ICONINFO*
    GUI_MENU_SET_ENTRY_ICON,        // param1=int hEntry,           param2=ICONINFO*
    GUI_SHOW_CPU,                   // param1=unused,               param2=unused
    GUI_ADD_QWIDGET_TAB,            // param1=QWidget*,             param2=unused
    GUI_SHOW_QWIDGET_TAB,           // param1=QWidget*,             param2=unused
    GUI_CLOSE_QWIDGET_TAB,          // param1=QWidget*,             param2=unused
    GUI_EXECUTE_ON_GUI_THREAD,      // param1=GUICALLBACKEX cb,     param2=void* userdata
    GUI_UPDATE_TIME_WASTED_COUNTER, // param1=unused,               param2=unused
    GUI_SET_GLOBAL_NOTES,           // param1=const char* text,     param2=unused
    GUI_GET_GLOBAL_NOTES,           // param1=char** text,          param2=unused
    GUI_SET_DEBUGGEE_NOTES,         // param1=const char* text,     param2=unused
    GUI_GET_DEBUGGEE_NOTES,         // param1=char** text,          param2=unused
    GUI_DUMP_AT_N,                  // param1=int index,            param2=duint va
    GUI_DISPLAY_WARNING,            // param1=const char *text,     param2=unused
    GUI_REGISTER_SCRIPT_LANG,       // param1=SCRIPTTYPEINFO* info, param2=unused
    GUI_UNREGISTER_SCRIPT_LANG,     // param1=int id,               param2=unused
    GUI_UPDATE_ARGUMENT_VIEW,       // param1=unused,               param2=unused
    GUI_FOCUS_VIEW,                 // param1=int hWindow,          param2=unused
    GUI_UPDATE_WATCH_VIEW,          // param1=unused,               param2=unused
    GUI_LOAD_GRAPH,                 // param1=BridgeCFGraphList*    param2=unused
    GUI_GRAPH_AT,                   // param1=duint addr            param2=unused
    GUI_UPDATE_GRAPH_VIEW,          // param1=unused,               param2=unused
    GUI_SET_LOG_ENABLED,            // param1=bool isEnabled        param2=unused
    GUI_ADD_FAVOURITE_TOOL,         // param1=const char* name      param2=const char* description
    GUI_ADD_FAVOURITE_COMMAND,      // param1=const char* command   param2=const char* shortcut
    GUI_SET_FAVOURITE_TOOL_SHORTCUT,// param1=const char* name      param2=const char* shortcut
    GUI_FOLD_DISASSEMBLY,           // param1=duint startAddress    param2=duint length
    GUI_SELECT_IN_MEMORY_MAP,       // param1=duint addr,           param2=unused
    GUI_GET_ACTIVE_VIEW,            // param1=ACTIVEVIEW*,          param2=unused
    GUI_MENU_SET_ENTRY_CHECKED,     // param1=int hEntry,           param2=bool checked
    GUI_ADD_INFO_LINE,              // param1=const char* infoline, param2=unused
    GUI_PROCESS_EVENTS,             // param1=unused,               param2=unused
    GUI_TYPE_ADDNODE,               // param1=void* parent,         param2=TYPEDESCRIPTOR* type
    GUI_TYPE_CLEAR,                 // param1=unused,               param2=unused
    GUI_UPDATE_TYPE_WIDGET,         // param1=unused,               param2=unused
    GUI_CLOSE_APPLICATION,          // param1=unused,               param2=unused
    GUI_MENU_SET_VISIBLE,           // param1=int hMenu,            param2=bool visible
    GUI_MENU_SET_ENTRY_VISIBLE,     // param1=int hEntry,           param2=bool visible
    GUI_MENU_SET_NAME,              // param1=int hMenu,            param2=const char* name
    GUI_MENU_SET_ENTRY_NAME,        // param1=int hEntry,           param2=const char* name
    GUI_FLUSH_LOG,                  // param1=unused,               param2=unused
    GUI_MENU_SET_ENTRY_HOTKEY,      // param1=int hEntry,           param2=const char* hack
    GUI_REF_SEARCH_GETROWCOUNT,     // param1=unused,               param2=unused
    GUI_REF_SEARCH_GETCELLCONTENT,  // param1=int row,              param2=int col
    GUI_MENU_REMOVE,                // param1=int hEntryMenu,       param2=unused
    GUI_REF_ADDCOMMAND,             // param1=const char* title,    param2=const char* command
    GUI_OPEN_TRACE_FILE,            // param1=const char* file name,param2=unused
    GUI_UPDATE_TRACE_BROWSER,       // param1=unused,               param2=unused
    GUI_INVALIDATE_SYMBOL_SOURCE,   // param1=duint base,           param2=unused
    GUI_GET_CURRENT_GRAPH,          // param1=BridgeCFGraphList*,   param2=unused
} GUIMSG;

//GUI Typedefs
struct _TYPEDESCRIPTOR;

typedef void (*GUICALLBACK)();
typedef void (*GUICALLBACKEX)(void*);
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);
typedef bool (*TYPETOSTRING)(const struct _TYPEDESCRIPTOR* type, char* dest, size_t* destCount); //don't change destCount for final failure

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

typedef struct
{
    void* titleHwnd;
    void* classHwnd;
    char title[MAX_STRING_SIZE];
    char className[MAX_STRING_SIZE];
} ACTIVEVIEW;

typedef struct _TYPEDESCRIPTOR
{
    bool expanded; //is the type node expanded?
    bool reverse; //big endian?
    const char* name; //type name (int b)
    duint addr; //virtual address
    duint offset; //offset to addr for the actual location
    int id; //type id
    int size; //sizeof(type)
    TYPETOSTRING callback; //convert to string
    void* userdata; //user data
} TYPEDESCRIPTOR;

//GUI functions
//code page is utf8
BRIDGE_IMPEXP const char* GuiTranslateText(const char* Source);
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiSetDebugStateFast(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP int GuiReferenceSearchGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP char* GuiReferenceSearchGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateWatchView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP void GuiMenuRemove(int hEntryMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(GUISELECTIONTYPE hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(GUISELECTIONTYPE hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiUpdateSEHChain();
BRIDGE_IMPEXP void GuiLoadSourceFileEx(const char* path, duint addr);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryChecked(int hEntry, bool checked);
BRIDGE_IMPEXP void GuiMenuSetVisible(int hMenu, bool visible);
BRIDGE_IMPEXP void GuiMenuSetEntryVisible(int hEntry, bool visible);
BRIDGE_IMPEXP void GuiMenuSetName(int hMenu, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryName(int hEntry, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryHotkey(int hEntry, const char* hack);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);
BRIDGE_IMPEXP void GuiUpdateArgumentWidget();
BRIDGE_IMPEXP void GuiFocusView(int hWindow);
BRIDGE_IMPEXP bool GuiIsUpdateDisabled();
BRIDGE_IMPEXP void GuiUpdateEnable(bool updateNow);
BRIDGE_IMPEXP void GuiUpdateDisable();
BRIDGE_IMPEXP bool GuiLoadGraph(BridgeCFGraphList* graph, duint addr);
BRIDGE_IMPEXP duint GuiGraphAt(duint addr);
BRIDGE_IMPEXP void GuiUpdateGraphView();
BRIDGE_IMPEXP void GuiDisableLog();
BRIDGE_IMPEXP void GuiEnableLog();
BRIDGE_IMPEXP void GuiAddFavouriteTool(const char* name, const char* description);
BRIDGE_IMPEXP void GuiAddFavouriteCommand(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiFoldDisassembly(duint startAddress, duint length);
BRIDGE_IMPEXP void GuiSelectInMemoryMap(duint addr);
BRIDGE_IMPEXP void GuiGetActiveView(ACTIVEVIEW* activeView);
BRIDGE_IMPEXP void GuiAddInfoLine(const char* infoLine);
BRIDGE_IMPEXP void GuiProcessEvents();
BRIDGE_IMPEXP void* GuiTypeAddNode(void* parent, const TYPEDESCRIPTOR* type);
BRIDGE_IMPEXP bool GuiTypeClear();
BRIDGE_IMPEXP void GuiUpdateTypeWidget();
BRIDGE_IMPEXP void GuiCloseApplication();
BRIDGE_IMPEXP void GuiFlushLog();
BRIDGE_IMPEXP void GuiReferenceAddCommand(const char* title, const char* command);
BRIDGE_IMPEXP void GuiUpdateTraceBrowser();
BRIDGE_IMPEXP void GuiOpenTraceFile(const char* fileName);
BRIDGE_IMPEXP void GuiInvalidateSymbolSource(duint base);
BRIDGE_IMPEXP void GuiExecuteOnGuiThreadEx(GUICALLBACKEX cbGuiThread, void* userdata);
BRIDGE_IMPEXP void GuiGetCurrentGraph(BridgeCFGraphList* graphList);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_

```

`HyperHide/pluginsdk/dbghelp/dbghelp.h`:

```h
#ifndef _DBGHELP_
#define _DBGHELP_


// As a general principal always call the 64 bit version
// of every API, if a choice exists.  The 64 bit version
// works great on 32 bit platforms, and is forward
// compatible to 64 bit platforms.

#ifdef _WIN64
#ifndef _IMAGEHLP64
#define _IMAGEHLP64
#endif
#endif

#pragma pack(push,8)

// For those without specstrings.h
// Since there are different versions of this header, I need to
// individually test each item and define it if it is not around.

#ifndef __in
#define __in
#endif
#ifndef __out
#define __out
#endif
#ifndef __inout
#define __inout
#endif
#ifndef __in_opt
#define __in_opt
#endif
#ifndef __out_opt
#define __out_opt
#endif
#ifndef __inout_opt
#define __inout_opt
#endif
#ifndef __in_ecount
#define __in_ecount(x)
#endif
#ifndef __out_ecount
#define __out_ecount(x)
#endif
#ifndef __inout_ecount
#define __inout_ecount(x)
#endif
#ifndef __in_bcount
#define __in_bcount(x)
#endif
#ifndef __out_bcount
#define __out_bcount(x)
#endif
#ifndef __inout_bcount
#define __inout_bcount(x)
#endif
#ifndef __out_xcount
#define __out_xcount(x)
#endif
#ifndef __deref_opt_out
#define __deref_opt_out
#endif
#ifndef __deref_out
#define __deref_out
#endif
#ifndef __out_ecount_opt
#define __out_ecount_opt(x)
#endif
#ifndef __in_bcount_opt
#define __in_bcount_opt(x)
#endif
#ifndef __out_bcount_opt
#define __out_bcount_opt(x)
#endif
#ifndef __deref_out_opt
#define __deref_out_opt
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifdef _IMAGEHLP_SOURCE_
#define IMAGEAPI __stdcall
#define DBHLP_DEPRECIATED
#else
#define IMAGEAPI DECLSPEC_IMPORT __stdcall
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DBHLP_DEPRECIATED   __declspec(deprecated)
#else
#define DBHLP_DEPRECIATED
#endif
#endif

#define DBHLPAPI IMAGEAPI

#define IMAGE_SEPARATION (64*1024)

// Observant readers may notice that 2 new fields,
// 'fReadOnly' and 'Version' have been added to
// the LOADED_IMAGE structure after 'fDOSImage'.
// This does not change the size of the structure
// from previous headers.  That is because while
// 'fDOSImage' is a byte, it is padded by the
// compiler to 4 bytes.  So the 2 new fields are
// slipped into the extra space.

typedef struct _LOADED_IMAGE
{
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
#ifdef _IMAGEHLP64
    PIMAGE_NT_HEADERS64   FileHeader;
#else
    PIMAGE_NT_HEADERS32   FileHeader;
#endif
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    BOOLEAN               fReadOnly;
    UCHAR                 Version;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

#define MAX_SYM_NAME            2000


// Error codes set by dbghelp functions.  Call GetLastError
// to see them.
// Dbghelp also sets error codes found in winerror.h

#define ERROR_IMAGE_NOT_STRIPPED    0x8800  // the image is not stripped.  No dbg file available.
#define ERROR_NO_DBG_POINTER        0x8801  // image is stripped but there is no pointer to a dbg file
#define ERROR_NO_PDB_POINTER        0x8802  // image does not point to a pdb file

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFile(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_DEBUG_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in PVOID  CallerData
);

HANDLE
IMAGEAPI
SymFindDebugInfoFileW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFile(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR DebugFilePath
);

HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR  DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindDebugInfoFileExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR DebugFilePath,
    __in_opt PFIND_DEBUG_FILE_CALLBACKW Callback,
    __in_opt PVOID CallerData
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACK)(
    __in PCSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPath(
    __in HANDLE hprocess,
    __in_opt PCSTR SearchPath,
    __in PCSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACK callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFINDFILEINPATHCALLBACKW)(
    __in PCWSTR filename,
    __in PVOID context
);

BOOL
IMAGEAPI
SymFindFileInPathW(
    __in HANDLE hprocess,
    __in_opt PCWSTR SearchPath,
    __in PCWSTR FileName,
    __in_opt PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PWSTR FoundFile,
    __in_opt PFINDFILEINPATHCALLBACKW callback,
    __in_opt PVOID context
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACK)(
    __in HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImage(
    __in HANDLE hProcess,
    __in PCSTR FileName,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACK Callback,
    __in PVOID CallerData
);

typedef BOOL
(CALLBACK* PFIND_EXE_FILE_CALLBACKW)(
    __in HANDLE FileHandle,
    __in PCWSTR FileName,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
SymFindExecutableImageW(
    __in HANDLE hProcess,
    __in PCWSTR FileName,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImage(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath
);

HANDLE
IMAGEAPI
FindExecutableImageEx(
    __in PCSTR FileName,
    __in PCSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACK Callback,
    __in_opt PVOID CallerData
);

HANDLE
IMAGEAPI
FindExecutableImageExW(
    __in PCWSTR FileName,
    __in PCWSTR SymbolPath,
    __out_ecount(MAX_PATH + 1) PWSTR ImageFilePath,
    __in_opt PFIND_EXE_FILE_CALLBACKW Callback,
    __in PVOID CallerData
);

PIMAGE_NT_HEADERS
IMAGEAPI
ImageNtHeader(
    __in PVOID Base
);

PVOID
IMAGEAPI
ImageDirectoryEntryToDataEx(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size,
    __out_opt PIMAGE_SECTION_HEADER* FoundHeader
);

PVOID
IMAGEAPI
ImageDirectoryEntryToData(
    __in PVOID Base,
    __in BOOLEAN MappedAsImage,
    __in USHORT DirectoryEntry,
    __out PULONG Size
);

PIMAGE_SECTION_HEADER
IMAGEAPI
ImageRvaToSection(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva
);

PVOID
IMAGEAPI
ImageRvaToVa(
    __in PIMAGE_NT_HEADERS NtHeaders,
    __in PVOID Base,
    __in ULONG Rva,
    __in_opt OUT PIMAGE_SECTION_HEADER* LastRvaSection
);

#ifndef _WIN64
// This api won't be ported to Win64 - Fix your code.

typedef struct _IMAGE_DEBUG_INFORMATION
{
    LIST_ENTRY List;
    DWORD ReservedSize;
    PVOID ReservedMappedBase;
    USHORT ReservedMachine;
    USHORT ReservedCharacteristics;
    DWORD ReservedCheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;

    DWORD ReservedNumberOfSections;
    PIMAGE_SECTION_HEADER ReservedSections;

    DWORD ReservedExportedNamesSize;
    PSTR ReservedExportedNames;

    DWORD ReservedNumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY ReservedFunctionTableEntries;
    DWORD ReservedLowestFunctionStartingAddress;
    DWORD ReservedHighestFunctionEndingAddress;

    DWORD ReservedNumberOfFpoTableEntries;
    PFPO_DATA ReservedFpoTableEntries;

    DWORD SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;

    DWORD ReservedSizeOfCodeViewSymbols;
    PVOID ReservedCodeViewSymbols;

    PSTR ImageFilePath;
    PSTR ImageFileName;
    PSTR ReservedDebugFilePath;

    DWORD ReservedTimeDateStamp;

    BOOL  ReservedRomImage;
    PIMAGE_DEBUG_DIRECTORY ReservedDebugDirectory;
    DWORD ReservedNumberOfDebugDirectories;

    DWORD ReservedOriginalFunctionTableBaseAddress;

    DWORD Reserved[ 2 ];

} IMAGE_DEBUG_INFORMATION, *PIMAGE_DEBUG_INFORMATION;


PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    __in_opt HANDLE FileHandle,
    __in PCSTR FileName,
    __in_opt PCSTR SymbolPath,
    __in ULONG ImageBase
);

BOOL
IMAGEAPI
UnmapDebugInformation(
    __out_xcount(unknown) PIMAGE_DEBUG_INFORMATION DebugInfo
);

#endif

BOOL
IMAGEAPI
SearchTreeForFile(
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PSTR OutputPathBuffer
);

BOOL
IMAGEAPI
SearchTreeForFileW(
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount(MAX_PATH + 1) PWSTR OutputPathBuffer
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACK)(
    __in PCSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTree(
    __in_opt HANDLE hProcess,
    __in PCSTR RootPath,
    __in PCSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACK cb,
    __in_opt PVOID data
);

typedef BOOL
(CALLBACK* PENUMDIRTREE_CALLBACKW)(
    __in PCWSTR FilePath,
    __in_opt PVOID CallerData
);

BOOL
IMAGEAPI
EnumDirTreeW(
    __in_opt HANDLE hProcess,
    __in PCWSTR RootPath,
    __in PCWSTR InputPathName,
    __out_ecount_opt(MAX_PATH + 1) PWSTR OutputPathBuffer,
    __in_opt PENUMDIRTREE_CALLBACKW cb,
    __in_opt PVOID data
);

BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    __in PCSTR DirPath
);

//
// UnDecorateSymbolName Flags
//

#define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
#define UNDNAME_NO_LEADING_UNDERSCORES   (0x0001)  // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS           (0x0002)  // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS      (0x0004)  // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL      (0x0008)  // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE   (0x0010)  // Disable expansion of the declaration language specifier
#define UNDNAME_NO_MS_THISTYPE           (0x0020)  // NYI Disable expansion of MS keywords on the 'this' type for primary declaration
#define UNDNAME_NO_CV_THISTYPE           (0x0040)  // NYI Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE              (0x0060)  // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS     (0x0080)  // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES      (0x0100)  // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE           (0x0200)  // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL      (0x0400)  // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE            (0x0800)  // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
//  return just [scope::]name.  Does expand template params
#define UNDNAME_NO_ARGUMENTS             (0x2000)  // Don't undecorate arguments to function
#define UNDNAME_NO_SPECIAL_SYMS          (0x4000)  // Don't undecorate special names (v-table, vcall, vector xxx, metatype, etc)

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    __in PCSTR name,
    __out_ecount(maxStringLength) PSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolNameW(
    __in PCWSTR name,
    __out_ecount(maxStringLength) PWSTR outputString,
    __in DWORD maxStringLength,
    __in DWORD flags
);

//
// these values are used for synthesized file types
// that can be passed in as image headers instead of
// the standard ones from ntimage.h
//

#define DBHHEADER_DEBUGDIRS     0x1
#define DBHHEADER_CVMISC        0x2
#define DBHHEADER_PDBGUID       0x3
typedef struct _MODLOAD_DATA
{
    DWORD   ssize;                  // size of this struct
    DWORD   ssig;                   // signature identifying the passed data
    PVOID   data;                   // pointer to passed data
    DWORD   size;                   // size of passed data
    DWORD   flags;                  // options
} MODLOAD_DATA, *PMODLOAD_DATA;

typedef struct _MODLOAD_CVMISC
{
    DWORD   oCV;                    // ofset to the codeview record
    size_t  cCV;                    // size of the codeview record
    DWORD   oMisc;                  // offset to the misc record
    size_t  cMisc;                  // size of the misc record
    DWORD   dtImage;                // datetime stamp of the image
    DWORD   cImage;                 // size of the image
} MODLOAD_CVMISC, *PMODLOAD_CVMISC;

typedef struct _MODLOAD_PDBGUID_PDBAGE
{
    GUID    PdbGuid;                // Pdb Guid
    DWORD   PdbAge;                 // Pdb Age
} MODLOAD_PDBGUID_PDBAGE, *PMODLOAD_PDBGUID_PDBAGE;

//
// StackWalking API
//

typedef enum
{
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
} ADDRESS_MODE;

typedef struct _tagADDRESS64
{
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS64, *LPADDRESS64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define ADDRESS ADDRESS64
#define LPADDRESS LPADDRESS64
#else
typedef struct _tagADDRESS
{
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
} ADDRESS, *LPADDRESS;

__inline
void
Address32To64(
    __in LPADDRESS a32,
    __out LPADDRESS64 a64
)
{
    a64->Offset = (ULONG64)(LONG64)(LONG)a32->Offset;
    a64->Segment = a32->Segment;
    a64->Mode = a32->Mode;
}

__inline
void
Address64To32(
    __in LPADDRESS64 a64,
    __out LPADDRESS a32
)
{
    a32->Offset = (ULONG)a64->Offset;
    a32->Segment = a64->Segment;
    a32->Mode = a64->Mode;
}
#endif

//
// This structure is included in the STACKFRAME structure,
// and is used to trace through usermode callbacks in a thread's
// kernel stack.  The values must be copied by the kernel debugger
// from the DBGKD_GET_VERSION and WAIT_STATE_CHANGE packets.
//

//
// New KDHELP structure for 64 bit system support.
// This structure is preferred in new code.
//
typedef struct _KDHELP64
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD64   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;


    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD64   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD64   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD64   SystemRangeStart;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD64   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD64   StackBase;
    DWORD64   StackLimit;

    DWORD64   Reserved[5];

} KDHELP64, *PKDHELP64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define KDHELP KDHELP64
#define PKDHELP PKDHELP64
#else
typedef struct _KDHELP
{

    //
    // address of kernel thread object, as provided in the
    // WAIT_STATE_CHANGE packet.
    //
    DWORD   Thread;

    //
    // offset in thread object to pointer to the current callback frame
    // in kernel stack.
    //
    DWORD   ThCallbackStack;

    //
    // offsets to values in frame:
    //
    // address of next callback frame
    DWORD   NextCallback;

    // address of saved frame pointer (if applicable)
    DWORD   FramePointer;

    //
    // Address of the kernel function that calls out to user mode
    //
    DWORD   KiCallUserMode;

    //
    // Address of the user mode dispatcher function
    //
    DWORD   KeUserCallbackDispatcher;

    //
    // Lowest kernel mode address
    //
    DWORD   SystemRangeStart;

    //
    // offset in thread object to pointer to the current callback backing
    // store frame in kernel stack.
    //
    DWORD   ThCallbackBStore;

    //
    // Address of the user mode exception dispatcher function.
    // Added in API version 10.
    //
    DWORD   KiUserExceptionDispatcher;

    //
    // Stack bounds, added in API version 11.
    //
    DWORD   StackBase;
    DWORD   StackLimit;

    DWORD   Reserved[5];

} KDHELP, *PKDHELP;

__inline
void
KdHelp32To64(
    __in PKDHELP p32,
    __out PKDHELP64 p64
)
{
    p64->Thread = p32->Thread;
    p64->ThCallbackStack = p32->ThCallbackStack;
    p64->NextCallback = p32->NextCallback;
    p64->FramePointer = p32->FramePointer;
    p64->KiCallUserMode = p32->KiCallUserMode;
    p64->KeUserCallbackDispatcher = p32->KeUserCallbackDispatcher;
    p64->SystemRangeStart = p32->SystemRangeStart;
    p64->KiUserExceptionDispatcher = p32->KiUserExceptionDispatcher;
    p64->StackBase = p32->StackBase;
    p64->StackLimit = p32->StackLimit;
}
#endif

typedef struct _tagSTACKFRAME64
{
    ADDRESS64   AddrPC;               // program counter
    ADDRESS64   AddrReturn;           // return address
    ADDRESS64   AddrFrame;            // frame pointer
    ADDRESS64   AddrStack;            // stack pointer
    ADDRESS64   AddrBStore;           // backing store pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD64     Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD64     Reserved[3];
    KDHELP64    KdHelp;
} STACKFRAME64, *LPSTACKFRAME64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define STACKFRAME STACKFRAME64
#define LPSTACKFRAME LPSTACKFRAME64
#else
typedef struct _tagSTACKFRAME
{
    ADDRESS     AddrPC;               // program counter
    ADDRESS     AddrReturn;           // return address
    ADDRESS     AddrFrame;            // frame pointer
    ADDRESS     AddrStack;            // stack pointer
    PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
    DWORD       Params[4];            // possible arguments to the function
    BOOL        Far;                  // WOW far call
    BOOL        Virtual;              // is this a virtual frame?
    DWORD       Reserved[3];
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;           // backing store pointer
} STACKFRAME, *LPSTACKFRAME;
#endif


typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 qwBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out LPDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE64)(
    __in HANDLE ahProcess,
    __in DWORD64 AddrBase
);

typedef
DWORD64
(__stdcall* PGET_MODULE_BASE_ROUTINE64)(
    __in HANDLE hProcess,
    __in DWORD64 Address
);

typedef
DWORD64
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE64)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __in LPADDRESS64 lpaddr
);

BOOL
IMAGEAPI
StackWalk64(
    __in DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME64 StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PREAD_PROCESS_MEMORY_ROUTINE PREAD_PROCESS_MEMORY_ROUTINE64
#define PFUNCTION_TABLE_ACCESS_ROUTINE PFUNCTION_TABLE_ACCESS_ROUTINE64
#define PGET_MODULE_BASE_ROUTINE PGET_MODULE_BASE_ROUTINE64
#define PTRANSLATE_ADDRESS_ROUTINE PTRANSLATE_ADDRESS_ROUTINE64

#define StackWalk StackWalk64

#else

typedef
BOOL
(__stdcall* PREAD_PROCESS_MEMORY_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD lpBaseAddress,
    __out_bcount(nSize) PVOID lpBuffer,
    __in DWORD nSize,
    __out PDWORD lpNumberOfBytesRead
);

typedef
PVOID
(__stdcall* PFUNCTION_TABLE_ACCESS_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);

typedef
DWORD
(__stdcall* PGET_MODULE_BASE_ROUTINE)(
    __in HANDLE hProcess,
    __in DWORD Address
);

typedef
DWORD
(__stdcall* PTRANSLATE_ADDRESS_ROUTINE)(
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __out LPADDRESS lpaddr
);

BOOL
IMAGEAPI
StackWalk(
    DWORD MachineType,
    __in HANDLE hProcess,
    __in HANDLE hThread,
    __inout LPSTACKFRAME StackFrame,
    __inout PVOID ContextRecord,
    __in_opt PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
    __in_opt PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
    __in_opt PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
    __in_opt PTRANSLATE_ADDRESS_ROUTINE TranslateAddress
);

#endif


#define API_VERSION_NUMBER 11

typedef struct API_VERSION
{
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  Revision;
    USHORT  Reserved;
} API_VERSION, *LPAPI_VERSION;

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
);

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    __in LPAPI_VERSION AppVersion
);

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    __in HMODULE Module
);

//
// typedefs for function pointers
//
typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK64)(
    __in PCSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACKW64)(
    __in PCWSTR ModuleName,
    __in DWORD64 ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64)(
    __in PCSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK64W)(
    __in PCWSTR SymbolName,
    __in DWORD64 SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt ULONG64 CallbackData,
    __in_opt ULONG64 UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK)(
    __in HANDLE hProcess,
    __in DWORD AddrBase,
    __in_opt PVOID UserContext
);

typedef
PVOID
(CALLBACK* PSYMBOL_FUNCENTRY_CALLBACK64)(
    __in HANDLE hProcess,
    __in ULONG64 AddrBase,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define PSYM_ENUMMODULES_CALLBACK PSYM_ENUMMODULES_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACK PSYM_ENUMSYMBOLS_CALLBACK64
#define PSYM_ENUMSYMBOLS_CALLBACKW PSYM_ENUMSYMBOLS_CALLBACK64W
#define PENUMLOADED_MODULES_CALLBACK PENUMLOADED_MODULES_CALLBACK64
#define PSYMBOL_REGISTERED_CALLBACK PSYMBOL_REGISTERED_CALLBACK64
#define PSYMBOL_FUNCENTRY_CALLBACK PSYMBOL_FUNCENTRY_CALLBACK64

#else

typedef BOOL
(CALLBACK* PSYM_ENUMMODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG BaseOfDll,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACK)(
    __in PCSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSYMBOLS_CALLBACKW)(
    __in PCWSTR SymbolName,
    __in ULONG SymbolAddress,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PENUMLOADED_MODULES_CALLBACK)(
    __in PCSTR ModuleName,
    __in ULONG ModuleBase,
    __in ULONG ModuleSize,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYMBOL_REGISTERED_CALLBACK)(
    __in HANDLE hProcess,
    __in ULONG ActionCode,
    __in_opt PVOID CallbackData,
    __in_opt PVOID UserContext
);

#endif


// values found in SYMBOL_INFO.Tag
//
// This was taken from cvconst.h and should
// not override any values found there.
//
// #define _NO_CVCONST_H_ if you don't
// have access to that file...

#ifdef _NO_CVCONST_H

// DIA enums

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

#endif

//
// flags found in SYMBOL_INFO.Flags
//

#define SYMFLAG_VALUEPRESENT     0x00000001
#define SYMFLAG_REGISTER         0x00000008
#define SYMFLAG_REGREL           0x00000010
#define SYMFLAG_FRAMEREL         0x00000020
#define SYMFLAG_PARAMETER        0x00000040
#define SYMFLAG_LOCAL            0x00000080
#define SYMFLAG_CONSTANT         0x00000100
#define SYMFLAG_EXPORT           0x00000200
#define SYMFLAG_FORWARDER        0x00000400
#define SYMFLAG_FUNCTION         0x00000800
#define SYMFLAG_VIRTUAL          0x00001000
#define SYMFLAG_THUNK            0x00002000
#define SYMFLAG_TLSREL           0x00004000
#define SYMFLAG_SLOT             0x00008000
#define SYMFLAG_ILREL            0x00010000
#define SYMFLAG_METADATA         0x00020000
#define SYMFLAG_CLR_TOKEN        0x00040000

// this resets SymNext/Prev to the beginning
// of the module passed in the address field

#define SYMFLAG_RESET            0x80000000

//
// symbol type enumeration
//
typedef enum
{
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,       // .sym file
    SymDia,
    SymVirtual,
    NumSymTypes
} SYM_TYPE;

//
// symbol data structure
//

typedef struct _IMAGEHLP_SYMBOL64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR    Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;

typedef struct _IMAGEHLP_SYMBOL64_PACKAGE
{
    IMAGEHLP_SYMBOL64 sym;
    CHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL64_PACKAGE, *PIMAGEHLP_SYMBOL64_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW64
{
    DWORD   SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW64)
    DWORD64 Address;                // virtual address including dll base address
    DWORD   Size;                   // estimated size of symbol, can be zero
    DWORD   Flags;                  // info about the symbols, see the SYMF defines
    DWORD   MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR   Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW64, *PIMAGEHLP_SYMBOLW64;

typedef struct _IMAGEHLP_SYMBOLW64_PACKAGE
{
    IMAGEHLP_SYMBOLW64 sym;
    WCHAR              name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW64_PACKAGE, *PIMAGEHLP_SYMBOLW64_PACKAGE;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)

#define IMAGEHLP_SYMBOL IMAGEHLP_SYMBOL64
#define PIMAGEHLP_SYMBOL PIMAGEHLP_SYMBOL64
#define IMAGEHLP_SYMBOL_PACKAGE IMAGEHLP_SYMBOL64_PACKAGE
#define PIMAGEHLP_SYMBOL_PACKAGE PIMAGEHLP_SYMBOL64_PACKAGE
#define IMAGEHLP_SYMBOLW IMAGEHLP_SYMBOLW64
#define PIMAGEHLP_SYMBOLW PIMAGEHLP_SYMBOLW64
#define IMAGEHLP_SYMBOLW_PACKAGE IMAGEHLP_SYMBOLW64_PACKAGE
#define PIMAGEHLP_SYMBOLW_PACKAGE PIMAGEHLP_SYMBOLW64_PACKAGE

#else

typedef struct _IMAGEHLP_SYMBOL
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    CHAR                        Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOL, *PIMAGEHLP_SYMBOL;

typedef struct _IMAGEHLP_SYMBOL_PACKAGE
{
    IMAGEHLP_SYMBOL sym;
    CHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOL_PACKAGE, *PIMAGEHLP_SYMBOL_PACKAGE;

typedef struct _IMAGEHLP_SYMBOLW
{
    DWORD SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOLW)
    DWORD Address;                // virtual address including dll base address
    DWORD Size;                   // estimated size of symbol, can be zero
    DWORD Flags;                  // info about the symbols, see the SYMF defines
    DWORD                       MaxNameLength;          // maximum size of symbol name in 'Name'
    WCHAR                       Name[1];                // symbol name (null terminated string)
} IMAGEHLP_SYMBOLW, *PIMAGEHLP_SYMBOLW;

typedef struct _IMAGEHLP_SYMBOLW_PACKAGE
{
    IMAGEHLP_SYMBOLW sym;
    WCHAR            name[MAX_SYM_NAME + 1];
} IMAGEHLP_SYMBOLW_PACKAGE, *PIMAGEHLP_SYMBOLW_PACKAGE;

#endif

//
// module data structure
//

typedef struct _IMAGEHLP_MODULE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
    // new elements: 07-Jun-2002
    CHAR     LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    CHAR     CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;

typedef struct _IMAGEHLP_MODULEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    // new elements: 07-Jun-2002
    WCHAR    LoadedImageName[256];   // symbol file name
    WCHAR    LoadedPdbName[256];     // pdb file name
    DWORD    CVSig;                  // Signature of the CV record in the debug directories
    WCHAR        CVData[MAX_PATH * 3];   // Contents of the CV record
    DWORD    PdbSig;                 // Signature of PDB
    GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
    DWORD    PdbAge;                 // DBI age of pdb
    BOOL     PdbUnmatched;           // loaded an unmatched pdb
    BOOL     DbgUnmatched;           // loaded an unmatched dbg
    BOOL     LineNumbers;            // we have line number information
    BOOL     GlobalSymbols;          // we have internal symbol information
    BOOL     TypeInfo;               // we have type information
    // new elements: 17-Dec-2003
    BOOL     SourceIndexed;          // pdb supports source server
    BOOL     Publics;                // contains public symbols
} IMAGEHLP_MODULEW64, *PIMAGEHLP_MODULEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_MODULE IMAGEHLP_MODULE64
#define PIMAGEHLP_MODULE PIMAGEHLP_MODULE64
#define IMAGEHLP_MODULEW IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULEW PIMAGEHLP_MODULEW64
#else
typedef struct _IMAGEHLP_MODULE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    CHAR     ModuleName[32];         // module name
    CHAR     ImageName[256];         // image name
    CHAR     LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULE, *PIMAGEHLP_MODULE;

typedef struct _IMAGEHLP_MODULEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    ImageSize;              // virtual size of the loaded module
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    NumSyms;                // number of symbols in the symbol table
    SYM_TYPE SymType;                // type of symbols loaded
    WCHAR    ModuleName[32];         // module name
    WCHAR    ImageName[256];         // image name
    WCHAR    LoadedImageName[256];   // symbol file name
} IMAGEHLP_MODULEW, *PIMAGEHLP_MODULEW;
#endif

//
// source file line data structure
//

typedef struct _IMAGEHLP_LINE64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;

typedef struct _IMAGEHLP_LINEW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PWSTR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW64, *PIMAGEHLP_LINEW64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_LINE IMAGEHLP_LINE64
#define PIMAGEHLP_LINE PIMAGEHLP_LINE64
#else
typedef struct _IMAGEHLP_LINE
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD    Address;                // first instruction of line
} IMAGEHLP_LINE, *PIMAGEHLP_LINE;

typedef struct _IMAGEHLP_LINEW
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
    PVOID    Key;                    // internal
    DWORD    LineNumber;             // line number in file
    PCHAR    FileName;               // full filename
    DWORD64  Address;                // first instruction of line
} IMAGEHLP_LINEW, *PIMAGEHLP_LINEW;
#endif

//
// source file structure
//

typedef struct _SOURCEFILE
{
    DWORD64  ModBase;                // base address of loaded module
    PCHAR    FileName;               // full filename of source
} SOURCEFILE, *PSOURCEFILE;

typedef struct _SOURCEFILEW
{
    DWORD64  ModBase;                // base address of loaded module
    PWSTR    FileName;               // full filename of source
} SOURCEFILEW, *PSOURCEFILEW;

//
// data structures used for registered symbol callbacks
//

#define CBA_DEFERRED_SYMBOL_LOAD_START          0x00000001
#define CBA_DEFERRED_SYMBOL_LOAD_COMPLETE       0x00000002
#define CBA_DEFERRED_SYMBOL_LOAD_FAILURE        0x00000003
#define CBA_SYMBOLS_UNLOADED                    0x00000004
#define CBA_DUPLICATE_SYMBOL                    0x00000005
#define CBA_READ_MEMORY                         0x00000006
#define CBA_DEFERRED_SYMBOL_LOAD_CANCEL         0x00000007
#define CBA_SET_OPTIONS                         0x00000008
#define CBA_EVENT                               0x00000010
#define CBA_DEFERRED_SYMBOL_LOAD_PARTIAL        0x00000020
#define CBA_DEBUG_INFO                          0x10000000
#define CBA_SRCSRV_INFO                         0x20000000
#define CBA_SRCSRV_EVENT                        0x40000000

typedef struct _IMAGEHLP_CBA_READ_MEMORY
{
    DWORD64   addr;                                     // address to read from
    PVOID     buf;                                      // buffer to read to
    DWORD     bytes;                                    // amount of bytes to read
    DWORD*    bytesread;                                // pointer to store amount of bytes read
} IMAGEHLP_CBA_READ_MEMORY, *PIMAGEHLP_CBA_READ_MEMORY;

enum
{
    sevInfo = 0,
    sevProblem,
    sevAttn,
    sevFatal,
    sevMax  // unused
};

#define EVENT_SRCSPEW_START 100
#define EVENT_SRCSPEW       100
#define EVENT_SRCSPEW_END   199

typedef struct _IMAGEHLP_CBA_EVENT
{
    DWORD severity;                                     // values from sevInfo to sevFatal
    DWORD code;                                         // numerical code IDs the error
    PCHAR desc;                                         // may contain a text description of the error
    PVOID object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENT, *PIMAGEHLP_CBA_EVENT;

typedef struct _IMAGEHLP_CBA_EVENTW
{
    DWORD  severity;                                     // values from sevInfo to sevFatal
    DWORD  code;                                         // numerical code IDs the error
    PCWSTR desc;                                         // may contain a text description of the error
    PVOID  object;                                       // value dependant upon the error code
} IMAGEHLP_CBA_EVENTW, *PIMAGEHLP_CBA_EVENTW;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;                     //
} IMAGEHLP_DEFERRED_SYMBOL_LOAD64, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD64;

typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOADW64
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOADW64)
    DWORD64  BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    WCHAR    FileName[MAX_PATH + 1]; // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
    DWORD    Flags;         //
} IMAGEHLP_DEFERRED_SYMBOL_LOADW64, *PIMAGEHLP_DEFERRED_SYMBOL_LOADW64;

#define DSLFLAG_MISMATCHED_PDB  0x1
#define DSLFLAG_MISMATCHED_DBG  0x2

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD IMAGEHLP_DEFERRED_SYMBOL_LOAD64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD PIMAGEHLP_DEFERRED_SYMBOL_LOAD64
#else
typedef struct _IMAGEHLP_DEFERRED_SYMBOL_LOAD
{
    DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD)
    DWORD    BaseOfImage;            // base load address of module
    DWORD    CheckSum;               // checksum from the pe header
    DWORD    TimeDateStamp;          // date/time stamp from pe header
    CHAR     FileName[MAX_PATH];     // symbols file or image name
    BOOLEAN  Reparse;                // load failure reparse
    HANDLE   hFile;                  // file handle, if passed
} IMAGEHLP_DEFERRED_SYMBOL_LOAD, *PIMAGEHLP_DEFERRED_SYMBOL_LOAD;
#endif

typedef struct _IMAGEHLP_DUPLICATE_SYMBOL64
{
    DWORD              SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL64)
    DWORD              NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL64 Symbol;                 // array of duplicate symbols
    DWORD              SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL64, *PIMAGEHLP_DUPLICATE_SYMBOL64;

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define IMAGEHLP_DUPLICATE_SYMBOL IMAGEHLP_DUPLICATE_SYMBOL64
#define PIMAGEHLP_DUPLICATE_SYMBOL PIMAGEHLP_DUPLICATE_SYMBOL64
#else
typedef struct _IMAGEHLP_DUPLICATE_SYMBOL
{
    DWORD            SizeOfStruct;           // set to sizeof(IMAGEHLP_DUPLICATE_SYMBOL)
    DWORD            NumberOfDups;           // number of duplicates in the Symbol array
    PIMAGEHLP_SYMBOL Symbol;                 // array of duplicate symbols
    DWORD            SelectedSymbol;         // symbol selected (-1 to start)
} IMAGEHLP_DUPLICATE_SYMBOL, *PIMAGEHLP_DUPLICATE_SYMBOL;
#endif

// If dbghelp ever needs to display graphical UI, it will use this as the parent window.

BOOL
IMAGEAPI
SymSetParentWindow(
    __in HWND hwnd
);

PCHAR
IMAGEAPI
SymSetHomeDirectory(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR dir
);

PWSTR
IMAGEAPI
SymSetHomeDirectoryW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR dir
);

PCHAR
IMAGEAPI
SymGetHomeDirectory(
    __in DWORD type,
    __out_ecount(size) PSTR dir,
    __in size_t size
);

PWSTR
IMAGEAPI
SymGetHomeDirectoryW(
    __in DWORD type,
    __out_ecount(size) PWSTR dir,
    __in size_t size
);

enum
{
    hdBase = 0, // root directory for dbghelp
    hdSym,      // where symbols are stored
    hdSrc,      // where source is stored
    hdMax       // end marker
};

typedef struct _OMAP
{
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

BOOL
IMAGEAPI
SymGetOmaps(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll,
    __out POMAP* OmapTo,
    __out PDWORD64 cOmapTo,
    __out POMAP* OmapFrom,
    __out PDWORD64 cOmapFrom
);

//
// options that are set/returned by SymSetOptions() & SymGetOptions()
// these are used as a mask
//
#define SYMOPT_CASE_INSENSITIVE          0x00000001
#define SYMOPT_UNDNAME                   0x00000002
#define SYMOPT_DEFERRED_LOADS            0x00000004
#define SYMOPT_NO_CPP                    0x00000008
#define SYMOPT_LOAD_LINES                0x00000010
#define SYMOPT_OMAP_FIND_NEAREST         0x00000020
#define SYMOPT_LOAD_ANYTHING             0x00000040
#define SYMOPT_IGNORE_CVREC              0x00000080
#define SYMOPT_NO_UNQUALIFIED_LOADS      0x00000100
#define SYMOPT_FAIL_CRITICAL_ERRORS      0x00000200
#define SYMOPT_EXACT_SYMBOLS             0x00000400
#define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS    0x00000800
#define SYMOPT_IGNORE_NT_SYMPATH         0x00001000
#define SYMOPT_INCLUDE_32BIT_MODULES     0x00002000
#define SYMOPT_PUBLICS_ONLY              0x00004000
#define SYMOPT_NO_PUBLICS                0x00008000
#define SYMOPT_AUTO_PUBLICS              0x00010000
#define SYMOPT_NO_IMAGE_SEARCH           0x00020000
#define SYMOPT_SECURE                    0x00040000
#define SYMOPT_NO_PROMPTS                0x00080000
#define SYMOPT_OVERWRITE                 0x00100000
#define SYMOPT_IGNORE_IMAGEDIR           0x00200000
#define SYMOPT_FLAT_DIRECTORY            0x00400000
#define SYMOPT_FAVOR_COMPRESSED          0x00800000
#define SYMOPT_ALLOW_ZERO_ADDRESS        0x01000000
#define SYMOPT_DISABLE_SYMSRV_AUTODETECT 0x02000000

#define SYMOPT_DEBUG                     0x80000000

DWORD
IMAGEAPI
SymSetOptions(
    __in DWORD   SymOptions
);

DWORD
IMAGEAPI
SymGetOptions(
    VOID
);

BOOL
IMAGEAPI
SymCleanup(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymMatchString(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringA(
    __in PCSTR string,
    __in PCSTR expression,
    __in BOOL fCase
);

BOOL
IMAGEAPI
SymMatchStringW(
    __in PCWSTR string,
    __in PCWSTR expression,
    __in BOOL fCase
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACK)(
    __in PSOURCEFILE pSourceFile,
    __in_opt PVOID UserContext
);

// for backwards compatibility - don't use this
#define PSYM_ENUMSOURCFILES_CALLBACK PSYM_ENUMSOURCEFILES_CALLBACK

BOOL
IMAGEAPI
SymEnumSourceFiles(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACK cbSrcFiles,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMSOURCEFILES_CALLBACKW)(
    __in PSOURCEFILEW pSourceFile,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceFilesW(
    __in HANDLE hProcess,
    __in ULONG64 ModBase,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMSOURCEFILES_CALLBACKW cbSrcFiles,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModules64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumerateModulesW64(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACKW64 EnumModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateModules SymEnumerateModules64
#else
BOOL
IMAGEAPI
SymEnumerateModules(
    __in HANDLE hProcess,
    __in PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    __in_opt PVOID UserContext
);
#endif

BOOL
IMAGEAPI
EnumerateLoadedModulesEx(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesExW(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModules64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
EnumerateLoadedModulesW64(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define EnumerateLoadedModules EnumerateLoadedModules64
#else
BOOL
IMAGEAPI
EnumerateLoadedModules(
    __in HANDLE hProcess,
    __in PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback,
    __in_opt PVOID UserContext
);
#endif

PVOID
IMAGEAPI
SymFunctionTableAccess64(
    __in HANDLE hProcess,
    __in DWORD64 AddrBase
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymFunctionTableAccess SymFunctionTableAccess64
#else
PVOID
IMAGEAPI
SymFunctionTableAccess(
    __in HANDLE hProcess,
    __in DWORD AddrBase
);
#endif

BOOL
IMAGEAPI
SymGetUnwindInfo(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_bcount_opt(*Size) PVOID Buffer,
    __inout PULONG Size
);

BOOL
IMAGEAPI
SymGetModuleInfo64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULE64 ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PIMAGEHLP_MODULEW64 ModuleInfo
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleInfo   SymGetModuleInfo64
#define SymGetModuleInfoW  SymGetModuleInfoW64
#else
BOOL
IMAGEAPI
SymGetModuleInfo(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULE ModuleInfo
);

BOOL
IMAGEAPI
SymGetModuleInfoW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PIMAGEHLP_MODULEW ModuleInfo
);
#endif

DWORD64
IMAGEAPI
SymGetModuleBase64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetModuleBase SymGetModuleBase64
#else
DWORD
IMAGEAPI
SymGetModuleBase(
    __in HANDLE hProcess,
    __in DWORD dwAddr
);
#endif

typedef struct _SRCCODEINFO
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    CHAR    Obj[MAX_PATH + 1];      // the object file within the module
    CHAR    FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFO, *PSRCCODEINFO;

typedef struct _SRCCODEINFOW
{
    DWORD   SizeOfStruct;           // set to sizeof(SRCCODEINFO)
    PVOID   Key;                    // not used
    DWORD64 ModBase;                // base address of module this applies to
    WCHAR   Obj[MAX_PATH + 1];      // the object file within the module
    WCHAR   FileName[MAX_PATH + 1]; // full filename
    DWORD   LineNumber;             // line number in file
    DWORD64 Address;                // first instruction of line
} SRCCODEINFOW, *PSRCCODEINFOW;

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACK)(
    __in PSRCCODEINFO LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMLINES_CALLBACKW)(
    __in PSRCCODEINFOW LineInfo,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE64 Line64
);

BOOL
IMAGEAPI
SymGetLineFromAddrW64(
    __in HANDLE hProcess,
    __in DWORD64 dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW64 Line
);

BOOL
IMAGEAPI
SymEnumSourceLines(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Obj,
    __in_opt PCSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACK EnumLinesCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSourceLinesW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Obj,
    __in_opt PCWSTR File,
    __in_opt DWORD Line,
    __in DWORD Flags,
    __in PSYM_ENUMLINES_CALLBACKW EnumLinesCallback,
    __in_opt PVOID UserContext
);

// flags for SymEnumSourceLines

#define ESLFLAG_FULLPATH        0x1
#define ESLFLAG_NEAREST         0x2
#define ESLFLAG_PREV            0x4
#define ESLFLAG_NEXT            0x8

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromAddr SymGetLineFromAddr64
#define SymGetLineFromAddrW SymGetLineFromAddrW64
#else
BOOL
IMAGEAPI
SymGetLineFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineFromAddrW(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out PDWORD pdwDisplacement,
    __out PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLineFromName64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineFromNameW64(
    __in HANDLE hProcess,
    __in_opt PCWSTR ModuleName,
    __in_opt PCWSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineFromName SymGetLineFromName64
#else
BOOL
IMAGEAPI
SymGetLineFromName(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in_opt PCSTR FileName,
    __in DWORD dwLineNumber,
    __out PLONG plDisplacement,
    __inout PIMAGEHLP_LINE Line
);
#endif

BOOL
IMAGEAPI
SymGetLineNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLineNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLineNext SymGetLineNext64
#else
BOOL
IMAGEAPI
SymGetLineNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLineNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

BOOL
IMAGEAPI
SymGetLinePrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE64 Line
);

BOOL
IMAGEAPI
SymGetLinePrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW64 Line
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetLinePrev SymGetLinePrev64
#else
BOOL
IMAGEAPI
SymGetLinePrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINE Line
);

BOOL
IMAGEAPI
SymGetLinePrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_LINEW Line
);
#endif

ULONG
IMAGEAPI
SymGetFileLineOffsets64(
    __in HANDLE hProcess,
    __in_opt PCSTR ModuleName,
    __in PCSTR FileName,
    __out_ecount(BufferLines) PDWORD64 Buffer,
    __in ULONG BufferLines
);

BOOL
IMAGEAPI
SymMatchFileName(
    __in PCSTR FileName,
    __in PCSTR Match,
    __deref_opt_out PSTR* FileNameStop,
    __deref_opt_out PSTR* MatchStop
);

BOOL
IMAGEAPI
SymMatchFileNameW(
    __in PCWSTR FileName,
    __in PCWSTR Match,
    __deref_opt_out PWSTR* FileNameStop,
    __deref_opt_out PWSTR* MatchStop
);

BOOL
IMAGEAPI
SymGetSourceFile(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR Params,
    __in PCSTR FileSpec,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR Params,
    __in PCWSTR FileSpec,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileToken(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileTokenW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PCWSTR FileSpec,
    __deref_out PVOID* Token,
    __out DWORD* Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __out_ecount(Size) PSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceFileFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __out_ecount(Size) PWSTR FilePath,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromToken(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCSTR Params,
    __in PCSTR VarName,
    __out_ecount(Size) PSTR Value,
    __in DWORD Size
);

BOOL
IMAGEAPI
SymGetSourceVarFromTokenW(
    __in HANDLE hProcess,
    __in PVOID Token,
    __in_opt PCWSTR Params,
    __in PCWSTR VarName,
    __out_ecount(Size) PWSTR Value,
    __in DWORD Size
);

typedef BOOL (CALLBACK* PENUMSOURCEFILETOKENSCALLBACK)(__in PVOID token,  __in size_t size);

BOOL
IMAGEAPI
SymEnumSourceFileTokens(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in PENUMSOURCEFILETOKENSCALLBACK Callback
);

BOOL
IMAGEAPI
SymInitialize(
    __in HANDLE hProcess,
    __in_opt PCSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymInitializeW(
    __in HANDLE hProcess,
    __in_opt PCWSTR UserSearchPath,
    __in BOOL fInvadeProcess
);

BOOL
IMAGEAPI
SymGetSearchPath(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymGetSearchPathW(
    __in HANDLE hProcess,
    __out_ecount(SearchPathLength) PWSTR SearchPath,
    __in DWORD SearchPathLength
);

BOOL
IMAGEAPI
SymSetSearchPath(
    __in HANDLE hProcess,
    __in_opt PCSTR SearchPath
);

BOOL
IMAGEAPI
SymSetSearchPathW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SearchPath
);

#define SLMFLAG_VIRTUAL     0x1
#define SLMFLAG_ALT_INDEX   0x2
#define SLMFLAG_NO_SYMBOLS  0x4

DWORD64
IMAGEAPI
SymLoadModuleEx(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

DWORD64
IMAGEAPI
SymLoadModuleExW(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCWSTR ImageName,
    __in_opt PCWSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD DllSize,
    __in_opt PMODLOAD_DATA Data,
    __in_opt DWORD Flags
);

BOOL
IMAGEAPI
SymUnloadModule64(
    __in HANDLE hProcess,
    __in DWORD64 BaseOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnloadModule SymUnloadModule64
#else
BOOL
IMAGEAPI
SymUnloadModule(
    __in HANDLE hProcess,
    __in DWORD BaseOfDll
);
#endif

BOOL
IMAGEAPI
SymUnDName64(
    __in PIMAGEHLP_SYMBOL64 sym,            // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymUnDName SymUnDName64
#else
BOOL
IMAGEAPI
SymUnDName(
    __in PIMAGEHLP_SYMBOL sym,              // Symbol to undecorate
    __out_ecount(UnDecNameLength) PSTR UnDecName,   // Buffer to store undecorated name in
    __in DWORD UnDecNameLength              // Size of the buffer
);
#endif

BOOL
IMAGEAPI
SymRegisterCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterCallbackW64(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    __in ULONG64 UserContext
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymRegisterCallback SymRegisterCallback64
#define SymRegisterFunctionEntryCallback SymRegisterFunctionEntryCallback64
#else
BOOL
IMAGEAPI
SymRegisterCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    __in HANDLE hProcess,
    __in PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    __in_opt PVOID UserContext
);
#endif


typedef struct _IMAGEHLP_SYMBOL_SRC
{
    DWORD sizeofstruct;
    DWORD type;
    char  file[MAX_PATH];
} IMAGEHLP_SYMBOL_SRC, *PIMAGEHLP_SYMBOL_SRC;

typedef struct _MODULE_TYPE_INFO   // AKA TYPTYP
{
    USHORT      dataLength;
    USHORT      leaf;
    BYTE        data[1];
} MODULE_TYPE_INFO, *PMODULE_TYPE_INFO;

typedef struct _SYMBOL_INFO
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    CHAR        Name[1];          // Name of symbol
} SYMBOL_INFO, *PSYMBOL_INFO;

typedef struct _SYMBOL_INFO_PACKAGE
{
    SYMBOL_INFO si;
    CHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGE, *PSYMBOL_INFO_PACKAGE;

typedef struct _SYMBOL_INFOW
{
    ULONG       SizeOfStruct;
    ULONG       TypeIndex;        // Type Index of symbol
    ULONG64     Reserved[2];
    ULONG       Index;
    ULONG       Size;
    ULONG64     ModBase;          // Base Address of module comtaining this symbol
    ULONG       Flags;
    ULONG64     Value;            // Value of symbol, ValuePresent should be 1
    ULONG64     Address;          // Address of symbol including base address of module
    ULONG       Register;         // register holding value or pointer to value
    ULONG       Scope;            // scope of the symbol
    ULONG       Tag;              // pdb classification
    ULONG       NameLen;          // Actual length of name
    ULONG       MaxNameLen;
    WCHAR       Name[1];          // Name of symbol
} SYMBOL_INFOW, *PSYMBOL_INFOW;

typedef struct _SYMBOL_INFO_PACKAGEW
{
    SYMBOL_INFOW si;
    WCHAR        name[MAX_SYM_NAME + 1];
} SYMBOL_INFO_PACKAGEW, *PSYMBOL_INFO_PACKAGEW;

typedef struct _IMAGEHLP_STACK_FRAME
{
    ULONG64 InstructionOffset;
    ULONG64 ReturnOffset;
    ULONG64 FrameOffset;
    ULONG64 StackOffset;
    ULONG64 BackingStoreOffset;
    ULONG64 FuncTableEntry;
    ULONG64 Params[4];
    ULONG64 Reserved[5];
    BOOL    Virtual;
    ULONG   Reserved2;
} IMAGEHLP_STACK_FRAME, *PIMAGEHLP_STACK_FRAME;

typedef VOID IMAGEHLP_CONTEXT, *PIMAGEHLP_CONTEXT;


BOOL
IMAGEAPI
SymSetContext(
    __in HANDLE hProcess,
    __in PIMAGEHLP_STACK_FRAME StackFrame,
    __in_opt PIMAGEHLP_CONTEXT Context
);

BOOL
IMAGEAPI
SymSetScopeFromAddr(
    __in HANDLE hProcess,
    __in ULONG64 Address
);

BOOL
IMAGEAPI
SymSetScopeFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index
);

typedef BOOL
(CALLBACK* PSYM_ENUMPROCESSES_CALLBACK)(
    __in HANDLE hProcess,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumProcesses(
    __in PSYM_ENUMPROCESSES_CALLBACK EnumProcessesCallback,
    __in PVOID UserContext
);

BOOL
IMAGEAPI
SymFromAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __out_opt PDWORD64 Displacement,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromToken(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromTokenW(
    __in HANDLE hProcess,
    __in DWORD64 Base,
    __in DWORD Token,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymNext(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymNextW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

BOOL
IMAGEAPI
SymPrev(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFO si
);

BOOL
IMAGEAPI
SymPrevW(
    __in HANDLE hProcess,
    __inout PSYMBOL_INFOW siw
);

// While SymFromName will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromNameW(
    __in HANDLE hProcess,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACK)(
    __in PSYMBOL_INFO pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbols(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

typedef BOOL
(CALLBACK* PSYM_ENUMERATESYMBOLS_CALLBACKW)(
    __in PSYMBOL_INFOW pSymInfo,
    __in ULONG SymbolSize,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddr(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumSymbolsForAddrW(
    __in HANDLE hProcess,
    __in DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

#define SYMSEARCH_MASKOBJS      0x01    // used internally to implement other APIs
#define SYMSEARCH_RECURSE       0X02    // recurse scopes
#define SYMSEARCH_GLOBALSONLY   0X04    // search only for global symbols
#define SYMSEARCH_ALLITEMS      0X08    // search for everything in the pdb, not just normal scoped symbols

BOOL
IMAGEAPI
SymSearch(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymSearchW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt DWORD Index,
    __in_opt DWORD SymTag,
    __in_opt PCWSTR Mask,
    __in_opt DWORD64 Address,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext,
    __in DWORD Options
);

BOOL
IMAGEAPI
SymGetScope(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetScopeW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymFromIndex(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymFromIndexW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in DWORD Index,
    __inout PSYMBOL_INFOW Symbol
);

typedef enum _IMAGEHLP_SYMBOL_TYPE_INFO
{
    TI_GET_SYMTAG,
    TI_GET_SYMNAME,
    TI_GET_LENGTH,
    TI_GET_TYPE,
    TI_GET_TYPEID,
    TI_GET_BASETYPE,
    TI_GET_ARRAYINDEXTYPEID,
    TI_FINDCHILDREN,
    TI_GET_DATAKIND,
    TI_GET_ADDRESSOFFSET,
    TI_GET_OFFSET,
    TI_GET_VALUE,
    TI_GET_COUNT,
    TI_GET_CHILDRENCOUNT,
    TI_GET_BITPOSITION,
    TI_GET_VIRTUALBASECLASS,
    TI_GET_VIRTUALTABLESHAPEID,
    TI_GET_VIRTUALBASEPOINTEROFFSET,
    TI_GET_CLASSPARENTID,
    TI_GET_NESTED,
    TI_GET_SYMINDEX,
    TI_GET_LEXICALPARENT,
    TI_GET_ADDRESS,
    TI_GET_THISADJUST,
    TI_GET_UDTKIND,
    TI_IS_EQUIV_TO,
    TI_GET_CALLING_CONVENTION,
    TI_IS_CLOSE_EQUIV_TO,
    TI_GTIEX_REQS_VALID,
    TI_GET_VIRTUALBASEOFFSET,
    TI_GET_VIRTUALBASEDISPINDEX,
    TI_GET_IS_REFERENCE,
    TI_GET_INDIRECTVIRTUALBASECLASS,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX,
} IMAGEHLP_SYMBOL_TYPE_INFO;

typedef struct _TI_FINDCHILDREN_PARAMS
{
    ULONG Count;
    ULONG Start;
    ULONG ChildId[1];
} TI_FINDCHILDREN_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfo(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __in ULONG TypeId,
    __in IMAGEHLP_SYMBOL_TYPE_INFO GetType,
    __out PVOID pInfo
);

#define IMAGEHLP_GET_TYPE_INFO_UNCACHED 0x00000001
#define IMAGEHLP_GET_TYPE_INFO_CHILDREN 0x00000002

typedef struct _IMAGEHLP_GET_TYPE_INFO_PARAMS
{
    IN  ULONG    SizeOfStruct;
    IN  ULONG    Flags;
    IN  ULONG    NumIds;
    IN  PULONG   TypeIds;
    IN  ULONG64  TagFilter;
    IN  ULONG    NumReqs;
    IN  IMAGEHLP_SYMBOL_TYPE_INFO* ReqKinds;
    IN  PULONG_PTR ReqOffsets;
    IN  PULONG   ReqSizes;
    IN  ULONG_PTR ReqStride;
    IN  ULONG_PTR BufferSize;
    OUT PVOID    Buffer;
    OUT ULONG    EntriesMatched;
    OUT ULONG    EntriesFilled;
    OUT ULONG64  TagsFound;
    OUT ULONG64  AllReqsValid;
    IN  ULONG    NumReqsValid;
    OUT PULONG64 ReqsValid OPTIONAL;
} IMAGEHLP_GET_TYPE_INFO_PARAMS, *PIMAGEHLP_GET_TYPE_INFO_PARAMS;

BOOL
IMAGEAPI
SymGetTypeInfoEx(
    __in HANDLE hProcess,
    __in DWORD64 ModBase,
    __inout PIMAGEHLP_GET_TYPE_INFO_PARAMS Params
);

BOOL
IMAGEAPI
SymEnumTypes(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymEnumTypesByNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR mask,
    __in PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

BOOL
IMAGEAPI
SymGetTypeFromName(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __inout PSYMBOL_INFO Symbol
);

BOOL
IMAGEAPI
SymGetTypeFromNameW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __inout PSYMBOL_INFOW Symbol
);

BOOL
IMAGEAPI
SymAddSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymAddSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbol(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymDeleteSymbolW(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in_opt PCWSTR Name,
    __in DWORD64 Address,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymRefreshModuleList(
    __in HANDLE hProcess
);

BOOL
IMAGEAPI
SymAddSourceStream(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAM)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamA(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCSTR StreamFile,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

typedef BOOL (WINAPI* SYMADDSOURCESTREAMA)(HANDLE, ULONG64, PCSTR, PBYTE, size_t);

BOOL
IMAGEAPI
SymAddSourceStreamW(
    __in HANDLE hProcess,
    __in ULONG64 Base,
    __in_opt PCWSTR FileSpec,
    __in_bcount_opt(Size) PBYTE Buffer,
    __in size_t Size
);

BOOL
IMAGEAPI
SymSrvIsStoreW(
    __in_opt HANDLE hProcess,
    __in PCWSTR path
);

BOOL
IMAGEAPI
SymSrvIsStore(
    __in_opt HANDLE hProcess,
    __in PCSTR path
);

PCSTR
IMAGEAPI
SymSrvDeltaName(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Type,
    __in PCSTR File1,
    __in PCSTR File2
);

PCWSTR
IMAGEAPI
SymSrvDeltaNameW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Type,
    __in PCWSTR File1,
    __in PCWSTR File2
);

PCSTR
IMAGEAPI
SymSrvGetSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR Node,
    __in PCSTR File
);

PCWSTR
IMAGEAPI
SymSrvGetSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File
);

BOOL
IMAGEAPI
SymSrvGetFileIndexes(
    __in PCSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexesW(
    __in PCWSTR File,
    __out GUID* Id,
    __out PDWORD Val1,
    __out_opt PDWORD Val2,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexStringW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __out_ecount(Size) PWSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexString(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __out_ecount(Size) PSTR Index,
    __in size_t Size,
    __in DWORD Flags
);

typedef struct
{
    DWORD sizeofstruct;
    char file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    char dbgfile[MAX_PATH + 1];
    char pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFO, *PSYMSRV_INDEX_INFO;

typedef struct
{
    DWORD sizeofstruct;
    WCHAR file[MAX_PATH + 1];
    BOOL  stripped;
    DWORD timestamp;
    DWORD size;
    WCHAR dbgfile[MAX_PATH + 1];
    WCHAR pdbfile[MAX_PATH + 1];
    GUID  guid;
    DWORD sig;
    DWORD age;
} SYMSRV_INDEX_INFOW, *PSYMSRV_INDEX_INFOW;

BOOL
IMAGEAPI
SymSrvGetFileIndexInfo(
    __in PCSTR File,
    __out PSYMSRV_INDEX_INFO Info,
    __in DWORD Flags
);

BOOL
IMAGEAPI
SymSrvGetFileIndexInfoW(
    __in PCWSTR File,
    __out PSYMSRV_INDEX_INFOW Info,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreSupplement(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR Node,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreSupplementW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR Node,
    __in PCWSTR File,
    __in DWORD Flags
);

PCSTR
IMAGEAPI
SymSrvStoreFile(
    __in HANDLE hProcess,
    __in_opt PCSTR SrvPath,
    __in PCSTR File,
    __in DWORD Flags
);

PCWSTR
IMAGEAPI
SymSrvStoreFileW(
    __in HANDLE hProcess,
    __in_opt PCWSTR SrvPath,
    __in PCWSTR File,
    __in DWORD Flags
);

// used by SymGetSymbolFile's "Type" parameter

enum
{
    sfImage = 0,
    sfDbg,
    sfPdb,
    sfMpd,
    sfMax
};

BOOL
IMAGEAPI
SymGetSymbolFile(
    __in_opt HANDLE hProcess,
    __in_opt PCSTR SymPath,
    __in PCSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PSTR DbgFile,
    __in size_t cDbgFile
);

BOOL
IMAGEAPI
SymGetSymbolFileW(
    __in_opt HANDLE hProcess,
    __in_opt PCWSTR SymPath,
    __in PCWSTR ImageFile,
    __in DWORD Type,
    __out_ecount(cSymbolFile) PWSTR SymbolFile,
    __in size_t cSymbolFile,
    __out_ecount(cDbgFile) PWSTR DbgFile,
    __in size_t cDbgFile
);

//
// Full user-mode dump creation.
//

typedef BOOL (WINAPI* PDBGHELP_CREATE_USER_DUMP_CALLBACK)(
    __in DWORD DataType,
    __in PVOID* Data,
    __out LPDWORD DataLength,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDump(
    __in_opt LPCSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

BOOL
WINAPI
DbgHelpCreateUserDumpW(
    __in_opt LPCWSTR FileName,
    __in PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback,
    __in_opt PVOID UserData
);

// -----------------------------------------------------------------
// The following 4 legacy APIs are fully supported, but newer
// ones are recommended.  SymFromName and SymFromAddr provide
// much more detailed info on the returned symbol.

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    __in HANDLE hProcess,
    __in DWORD64 qwAddr,
    __out_opt PDWORD64 pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL64  Symbol
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromAddr SymGetSymFromAddr64
#else
BOOL
IMAGEAPI
SymGetSymFromAddr(
    __in HANDLE hProcess,
    __in DWORD dwAddr,
    __out_opt PDWORD pdwDisplacement,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif

// While following two APIs will provide a symbol from a name,
// SymEnumSymbols can provide the same matching information
// for ALL symbols with a matching name, even regular
// expressions.  That way you can search across modules
// and differentiate between identically named symbols.

BOOL
IMAGEAPI
SymGetSymFromName64(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymFromName SymGetSymFromName64
#else
BOOL
IMAGEAPI
SymGetSymFromName(
    __in HANDLE hProcess,
    __in PCSTR Name,
    __inout PIMAGEHLP_SYMBOL Symbol
);
#endif


// Symbol server exports

typedef BOOL (WINAPI* PSYMBOLSERVERPROC)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCA)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPROCW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROC)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCA)(PCSTR, PCSTR, PCSTR, PSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERBYINDEXPROCW)(PCWSTR, PCWSTR, PCWSTR, PWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVEROPENPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERCLOSEPROC)(VOID);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSPROC)(UINT_PTR, ULONG64);
typedef BOOL (WINAPI* PSYMBOLSERVERSETOPTIONSWPROC)(UINT_PTR, ULONG64);
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERCALLBACKPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);
typedef UINT_PTR(WINAPI* PSYMBOLSERVERGETOPTIONSPROC)();
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROC)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCA)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERPINGPROCW)(PCWSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERGETVERSION)(LPAPI_VERSION);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAME)(PCSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERDELTANAMEW)(PCWSTR, PVOID, DWORD, DWORD, PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETSUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENT)(PCSTR, PCSTR, PCSTR, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTORESUPPLEMENTW)(PCWSTR, PCWSTR, PCWSTR, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRING)(PVOID, DWORD, DWORD, PSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERGETINDEXSTRINGW)(PVOID, DWORD, DWORD, PWSTR, size_t);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILE)(PCSTR, PCSTR, PVOID, DWORD, DWORD, PSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERSTOREFILEW)(PCWSTR, PCWSTR, PVOID, DWORD, DWORD, PWSTR, size_t, DWORD);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTORE)(PCSTR);
typedef BOOL (WINAPI* PSYMBOLSERVERISSTOREW)(PCWSTR);
typedef DWORD (WINAPI* PSYMBOLSERVERVERSION)();
typedef BOOL (CALLBACK WINAPI* PSYMBOLSERVERMESSAGEPROC)(UINT_PTR action, ULONG64 data, ULONG64 context);

#define SYMSRV_VERSION              2

#define SSRVOPT_CALLBACK            0x00000001
#define SSRVOPT_DWORD               0x00000002
#define SSRVOPT_DWORDPTR            0x00000004
#define SSRVOPT_GUIDPTR             0x00000008
#define SSRVOPT_OLDGUIDPTR          0x00000010
#define SSRVOPT_UNATTENDED          0x00000020
#define SSRVOPT_NOCOPY              0x00000040
#define SSRVOPT_GETPATH             0x00000040
#define SSRVOPT_PARENTWIN           0x00000080
#define SSRVOPT_PARAMTYPE           0x00000100
#define SSRVOPT_SECURE              0x00000200
#define SSRVOPT_TRACE               0x00000400
#define SSRVOPT_SETCONTEXT          0x00000800
#define SSRVOPT_PROXY               0x00001000
#define SSRVOPT_DOWNSTREAM_STORE    0x00002000
#define SSRVOPT_OVERWRITE           0x00004000
#define SSRVOPT_RESETTOU            0x00008000
#define SSRVOPT_CALLBACKW           0x00010000
#define SSRVOPT_FLAT_DEFAULT_STORE  0x00020000
#define SSRVOPT_PROXYW              0x00040000
#define SSRVOPT_MESSAGE             0x00080000
#define SSRVOPT_SERVICE             0x00100000   // deprecated
#define SSRVOPT_FAVOR_COMPRESSED    0x00200000
#define SSRVOPT_STRING              0x00400000
#define SSRVOPT_WINHTTP             0x00800000
#define SSRVOPT_WININET             0x01000000

#define SSRVOPT_MAX                 0x0100000

#define SSRVOPT_RESET               ((ULONG_PTR)-1)


#define NUM_SSRVOPTS                30

#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4
#define SSRVACTION_SIZE         5

#define SYMSTOREOPT_COMPRESS        0x01
#define SYMSTOREOPT_OVERWRITE       0x02
#define SYMSTOREOPT_RETURNINDEX     0x04
#define SYMSTOREOPT_POINTER         0x08
#define SYMSTOREOPT_ALT_INDEX       0x10
#define SYMSTOREOPT_UNICODE         0x20
#define SYMSTOREOPT_PASS_IF_EXISTS  0x40

#ifdef DBGHELP_TRANSLATE_TCHAR
#define SymInitialize                     SymInitializeW
#define SymAddSymbol                      SymAddSymbolW
#define SymDeleteSymbol                   SymDeleteSymbolW
#define SearchTreeForFile                 SearchTreeForFileW
#define UnDecorateSymbolName              UnDecorateSymbolNameW
#define SymGetLineFromName64              SymGetLineFromNameW64
#define SymGetLineFromAddr64              SymGetLineFromAddrW64
#define SymGetLineNext64                  SymGetLineNextW64
#define SymGetLinePrev64                  SymGetLinePrevW64
#define SymFromName                       SymFromNameW
#define SymFindExecutableImage            SymFindExecutableImageW
#define FindExecutableImageEx             FindExecutableImageExW
#define SymSearch                         SymSearchW
#define SymEnumLines                      SymEnumLinesW
#define SymEnumSourceLines                SymEnumSourceLinesW
#define SymGetTypeFromName                SymGetTypeFromNameW
#define SymEnumSymbolsForAddr             SymEnumSymbolsForAddrW
#define SymFromAddr                       SymFromAddrW
#define SymMatchString                    SymMatchStringW
#define SymEnumSourceFiles                SymEnumSourceFilesW
#define SymEnumSymbols                    SymEnumSymbolsW
#define SymLoadModuleEx                   SymLoadModuleExW
#define SymSetSearchPath                  SymSetSearchPathW
#define SymGetSearchPath                  SymGetSearchPathW
#define EnumDirTree                       EnumDirTreeW
#define SymFromToken                      SymFromTokenW
#define SymFromIndex                      SymFromIndexW
#define SymGetScope                       SymGetScopeW
#define SymNext                           SymNextW
#define SymPrev                           SymPrevW
#define SymEnumTypes                      SymEnumTypesW
#define SymEnumTypesByName                SymEnumTypesByNameW
#define SymRegisterCallback64             SymRegisterCallbackW64
#define SymFindDebugInfoFile              SymFindDebugInfoFileW
#define FindDebugInfoFileEx               FindDebugInfoFileExW
#define SymFindFileInPath                 SymFindFileInPathW
#define SymEnumerateModules64             SymEnumerateModulesW64
#define SymSetHomeDirectory               SymSetHomeDirectoryW
#define SymGetHomeDirectory               SymGetHomeDirectoryW
#define SymGetSourceFile                  SymGetSourceFileW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetSourceFileToken             SymGetSourceFileTokenW
#define SymGetFileLineOffsets64           SymGetFileLineOffsetsW64
#define SymFindFileInPath                 SymFindFileInPathW
#define SymMatchFileName                  SymMatchFileNameW
#define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
#define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
#define SymGetModuleInfo64                SymGetModuleInfoW64
#define SymSrvIsStore                     SymSrvIsStoreW
#define SymSrvDeltaName                   SymSrvDeltaNameW
#define SymSrvGetSupplement               SymSrvGetSupplementW
#define SymSrvStoreSupplement             SymSrvStoreSupplementW
#define SymSrvGetFileIndexes              SymSrvGetFileIndexes
#define SymSrvGetFileIndexString          SymSrvGetFileIndexStringW
#define SymSrvStoreFile                   SymSrvStoreFileW
#define SymGetSymbolFile                  SymGetSymbolFileW
#define EnumerateLoadedModules64          EnumerateLoadedModulesW64
#define EnumerateLoadedModulesEx          EnumerateLoadedModulesExW
#define SymSrvGetFileIndexInfo            SymSrvGetFileIndexInfoW

#define IMAGEHLP_LINE64                   IMAGEHLP_LINEW64
#define PIMAGEHLP_LINE64                  PIMAGEHLP_LINEW64
#define SYMBOL_INFO                       SYMBOL_INFOW
#define PSYMBOL_INFO                      PSYMBOL_INFOW
#define SYMBOL_INFO_PACKAGE               SYMBOL_INFO_PACKAGEW
#define PSYMBOL_INFO_PACKAGE              PSYMBOL_INFO_PACKAGEW
#define FIND_EXE_FILE_CALLBACK            FIND_EXE_FILE_CALLBACKW
#define PFIND_EXE_FILE_CALLBACK           PFIND_EXE_FILE_CALLBACKW
#define SYM_ENUMERATESYMBOLS_CALLBACK     SYM_ENUMERATESYMBOLS_CALLBACKW
#define PSYM_ENUMERATESYMBOLS_CALLBACK    PSYM_ENUMERATESYMBOLS_CALLBACKW
#define SRCCODEINFO                       SRCCODEINFOW
#define PSRCCODEINFO                      PSRCCODEINFOW
#define SOURCEFILE                        SOURCEFILEW
#define PSOURCEFILE                       PSOURCEFILEW
#define SYM_ENUMSOURECFILES_CALLBACK      SYM_ENUMSOURCEFILES_CALLBACKW
#define PSYM_ENUMSOURCEFILES_CALLBACK     PSYM_ENUMSOURECFILES_CALLBACKW
#define IMAGEHLP_CBA_EVENT                IMAGEHLP_CBA_EVENTW
#define PIMAGEHLP_CBA_EVENT               PIMAGEHLP_CBA_EVENTW
#define PENUMDIRTREE_CALLBACK             PENUMDIRTREE_CALLBACKW
#define IMAGEHLP_DEFERRED_SYMBOL_LOAD64   IMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PIMAGEHLP_DEFERRED_SYMBOL_LOAD64  PIMAGEHLP_DEFERRED_SYMBOL_LOADW64
#define PFIND_DEBUG_FILE_CALLBACK         PFIND_DEBUG_FILE_CALLBACKW
#define PFINDFILEINPATHCALLBACK           PFINDFILEINPATHCALLBACKW
#define IMAGEHLP_MODULE64                 IMAGEHLP_MODULEW64
#define PIMAGEHLP_MODULE64                PIMAGEHLP_MODULEW64
#define SYMSRV_INDEX_INFO                 SYMSRV_INDEX_INFOW
#define PSYMSRV_INDEX_INFO                PSYMSRV_INDEX_INFOW

#define PSYMBOLSERVERPROC                 PSYMBOLSERVERPROCW
#define PSYMBOLSERVERPINGPROC             PSYMBOLSERVERPINGPROCW
#endif

// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in DWORD one,
    __in DWORD two,
    __in DWORD three,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    __in_opt PVOID UserContext
);


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
);

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
);
#endif

// use SymLoadModuleEx

DWORD64
IMAGEAPI
SymLoadModule64(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD SizeOfDll
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD BaseOfDll,
    __in DWORD SizeOfDll
);
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#define SymGetSymNextW SymGetSymNextW64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
);

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#define SymGetSymPrevW SymGetSymPrevW64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
);

BOOL
IMAGEAPI
SymGetSymPrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
);
#endif


// These values should not be used.
// They have been replaced by SYMFLAG_ values.

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
#define SYMF_THUNK            0x00002000
#define SYMF_TLSREL           0x00004000

// These values should also not be used.
// They have been replaced by SYMFLAG_ values.

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000
#define IMAGEHLP_SYMBOL_THUNK                      SYMF_THUNK           // 0x2000
#define IMAGEHLP_SYMBOL_INFO_TLSRELATIVE           SYMF_TLSREL          // 0x4000

#pragma pack(pop)


#pragma pack(push,4)

#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR
{
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64
{
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR
{
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64
{
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER
{
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union
    {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY
{
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING
{
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE
{

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,
    MemoryInfoListStream        = 16,
    ThreadInfoListStream        = 17,
    HandleOperationListStream   = 18,
    TokenStream                 = 19,

    ceStreamNull                = 0x8000,
    ceStreamSystemInfo          = 0x8001,
    ceStreamException           = 0x8002,
    ceStreamModuleList          = 0x8003,
    ceStreamProcessList         = 0x8004,
    ceStreamThreadList          = 0x8005,
    ceStreamThreadContextList   = 0x8006,
    ceStreamThreadCallStackList = 0x8007,
    ceStreamMemoryVirtualList   = 0x8008,
    ceStreamMemoryPhysicalList  = 0x8009,
    ceStreamBucketParameters    = 0x800A,
    ceStreamProcessModuleMap    = 0x800B,
    ceStreamDiagnosisList       = 0x800C,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
//

//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION
{

    //
    // X86 platforms use CPUID function to obtain processor information.
    //

    struct
    {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //

        ULONG32 VendorId [ 3 ];

        //
        // CPUID Subfunction 1, register EAX
        //

        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //

        ULONG32 FeatureInformation;


        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //

        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //

    struct
    {

        ULONG64 ProcessorFeatures [ 2 ];

    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;

typedef struct _MINIDUMP_SYSTEM_INFO
{

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //

    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    union
    {
        USHORT Reserved0;
        struct
        {
            UCHAR NumberOfProcessors;
            UCHAR ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //

    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //

    RVA CSDVersionRva;

    union
    {
        ULONG32 Reserved1;
        struct
        {
            USHORT SuiteMask;
            USHORT Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT(sizeof(((PPROCESS_INFORMATION)0)->dwThreadId) == 4);

typedef struct _MINIDUMP_THREAD
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX
{
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST
{
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION
{
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM
{
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST
{
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST
{
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST
{
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION
{
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64
{
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

// Per-handle object information varies according to
// the OS, the OS version, the processor type and
// so on.  The minidump gives a minidump identifier
// to each possible data format for identification
// purposes but does not control nor describe the actual data.
typedef enum _MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE
{
    MiniHandleObjectInformationNone,
    MiniThreadInformation1,
    MiniMutantInformation1,
    MiniMutantInformation2,
    MiniProcessInformation1,
    MiniProcessInformation2,
    MiniHandleObjectInformationTypeMax
} MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE;

typedef struct _MINIDUMP_HANDLE_OBJECT_INFORMATION
{
    RVA NextInfoRva;
    ULONG32 InfoType;
    ULONG32 SizeOfInfo;
    // Raw information follows.
} MINIDUMP_HANDLE_OBJECT_INFORMATION;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR_2
{
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
    RVA ObjectInfoRva;
    ULONG32 Reserved0;
} MINIDUMP_HANDLE_DESCRIPTOR_2, *PMINIDUMP_HANDLE_DESCRIPTOR_2;

// The latest MINIDUMP_HANDLE_DESCRIPTOR definition.
typedef MINIDUMP_HANDLE_DESCRIPTOR_2 MINIDUMP_HANDLE_DESCRIPTOR_N;
typedef MINIDUMP_HANDLE_DESCRIPTOR_N* PMINIDUMP_HANDLE_DESCRIPTOR_N;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;

// Some operating systems can track the last operations
// performed on a handle.  For example, Application Verifier
// can enable this for some versions of Windows.  The
// handle operation list collects handle operations
// known for the dump target.
// Each entry is an AVRF_HANDLE_OPERATION.
typedef struct _MINIDUMP_HANDLE_OPERATION_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_OPERATION_LIST, *PMINIDUMP_HANDLE_OPERATION_LIST;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR
{
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE
{
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST
{
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID            0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES         0x00000002
#define MINIDUMP_MISC1_PROCESSOR_POWER_INFO  0x00000004
#define MINIDUMP_MISC3_PROCESS_INTEGRITY     0x00000010
#define MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS 0x00000020
#define MINIDUMP_MISC3_TIMEZONE              0x00000040
#define MINIDUMP_MISC3_PROTECTED_PROCESS     0x00000080

typedef struct _MINIDUMP_MISC_INFO
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;

typedef struct _MINIDUMP_MISC_INFO_2
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
} MINIDUMP_MISC_INFO_2, *PMINIDUMP_MISC_INFO_2;

typedef struct _MINIDUMP_MISC_INFO_3
{
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
    ULONG32 ProcessIntegrityLevel;
    ULONG32 ProcessExecuteFlags;
    ULONG32 ProtectedProcess;
    ULONG32 TimeZoneId;
    TIME_ZONE_INFORMATION TimeZone;
} MINIDUMP_MISC_INFO_3, *PMINIDUMP_MISC_INFO_3;

// The latest MINIDUMP_MISC_INFO definition.
typedef MINIDUMP_MISC_INFO_3 MINIDUMP_MISC_INFO_N;
typedef MINIDUMP_MISC_INFO_N* PMINIDUMP_MISC_INFO_N;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

typedef struct _MINIDUMP_MEMORY_INFO
{
    ULONG64 BaseAddress;
    ULONG64 AllocationBase;
    ULONG32 AllocationProtect;
    ULONG32 __alignment1;
    ULONG64 RegionSize;
    ULONG32 State;
    ULONG32 Protect;
    ULONG32 Type;
    ULONG32 __alignment2;
} MINIDUMP_MEMORY_INFO, *PMINIDUMP_MEMORY_INFO;

typedef struct _MINIDUMP_MEMORY_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG64 NumberOfEntries;
} MINIDUMP_MEMORY_INFO_LIST, *PMINIDUMP_MEMORY_INFO_LIST;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

// Thread dump writer status flags.
#define MINIDUMP_THREAD_INFO_ERROR_THREAD    0x00000001
#define MINIDUMP_THREAD_INFO_WRITING_THREAD  0x00000002
#define MINIDUMP_THREAD_INFO_EXITED_THREAD   0x00000004
#define MINIDUMP_THREAD_INFO_INVALID_INFO    0x00000008
#define MINIDUMP_THREAD_INFO_INVALID_CONTEXT 0x00000010
#define MINIDUMP_THREAD_INFO_INVALID_TEB     0x00000020

typedef struct _MINIDUMP_THREAD_INFO
{
    ULONG32 ThreadId;
    ULONG32 DumpFlags;
    ULONG32 DumpError;
    ULONG32 ExitStatus;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartAddress;
    ULONG64 Affinity;
} MINIDUMP_THREAD_INFO, *PMINIDUMP_THREAD_INFO;

typedef struct _MINIDUMP_THREAD_INFO_LIST
{
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG NumberOfEntries;
} MINIDUMP_THREAD_INFO_LIST, *PMINIDUMP_THREAD_INFO_LIST;

//
// Support for token information.
//
typedef struct _MINIDUMP_TOKEN_INFO_HEADER
{
    ULONG   TokenSize;   // The size of the token structure.
    ULONG   TokenId;     // The PID in NtOpenProcessToken() call or TID in NtOpenThreadToken() call.
    ULONG64 TokenHandle; // The handle value returned.
} MINIDUMP_TOKEN_INFO_HEADER, *PMINIDUMP_TOKEN_INFO_HEADER;

typedef struct _MINIDUMP_TOKEN_INFO_LIST
{
    ULONG TokenListSize;
    ULONG TokenListEntries;
    ULONG ListHeaderSize;
    ULONG ElementHeaderSize;
} MINIDUMP_TOKEN_INFO_LIST, *PMINIDUMP_TOKEN_INFO_LIST;

//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD
{
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM
{
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION
{
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE
{
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
    MemoryCallback,
    CancelCallback,
    WriteKernelMinidumpCallback,
    KernelMinidumpStatusCallback,
    RemoveMemoryCallback,
    IncludeVmRegionCallback,
    IoStartCallback,
    IoWriteAllCallback,
    IoFinishCallback,
    ReadMemoryFailureCallback,
    SecondaryFlagsCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK
{
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK
{
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS
{
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
    ThreadWriteThreadInfo        = 0x0040,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK
{
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord;
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK
{
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS
{
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010,
    ModuleWriteTlsData       = 0x0020,
    ModuleWriteCodeSegs      = 0x0040,
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_IO_CALLBACK
{
    HANDLE Handle;
    ULONG64 Offset;
    PVOID Buffer;
    ULONG BufferBytes;
} MINIDUMP_IO_CALLBACK, *PMINIDUMP_IO_CALLBACK;


typedef struct _MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
{
    ULONG64 Offset;
    ULONG Bytes;
    HRESULT FailureStatus;
} MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
*PMINIDUMP_READ_MEMORY_FAILURE_CALLBACK;


typedef struct _MINIDUMP_CALLBACK_INPUT
{
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union
    {
        HRESULT Status;
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
        MINIDUMP_IO_CALLBACK Io;
        MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
        ULONG SecondaryFlags;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT
{
    union
    {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
        ULONG SecondaryFlags;
        struct
        {
            ULONG64 MemoryBase;
            ULONG MemorySize;
        };
        struct
        {
            BOOL CheckCancel;
            BOOL Cancel;
        };
        HANDLE Handle;
        struct
        {
            MINIDUMP_MEMORY_INFO VmRegion;
            BOOL Continue;
        };
        HRESULT Status;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;


//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//
// When doing a full memory dump it's possible to store all
// of the enumerated memory region descriptive information
// in a memory information stream.
//
// Additional thread information beyond the basic thread
// structure can be collected if desired.
//
// A minidump with code segments includes all of the code
// and code-related sections from loaded modules in order
// to capture executable content.
//
// MiniDumpWithoutAuxiliaryState turns off any secondary,
// auxiliary-supported memory gathering.
//
// MiniDumpWithFullAuxiliaryState asks any present auxiliary
// data providers to include all of their state in the dump.
// The exact set of what is provided depends on the auxiliary.
// This can be quite large.
//

typedef enum _MINIDUMP_TYPE
{
    MiniDumpNormal                         = 0x00000000,
    MiniDumpWithDataSegs                   = 0x00000001,
    MiniDumpWithFullMemory                 = 0x00000002,
    MiniDumpWithHandleData                 = 0x00000004,
    MiniDumpFilterMemory                   = 0x00000008,
    MiniDumpScanMemory                     = 0x00000010,
    MiniDumpWithUnloadedModules            = 0x00000020,
    MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
    MiniDumpFilterModulePaths              = 0x00000080,
    MiniDumpWithProcessThreadData          = 0x00000100,
    MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
    MiniDumpWithoutOptionalData            = 0x00000400,
    MiniDumpWithFullMemoryInfo             = 0x00000800,
    MiniDumpWithThreadInfo                 = 0x00001000,
    MiniDumpWithCodeSegs                   = 0x00002000,
    MiniDumpWithoutAuxiliaryState          = 0x00004000,
    MiniDumpWithFullAuxiliaryState         = 0x00008000,
    MiniDumpWithPrivateWriteCopyMemory     = 0x00010000,
    MiniDumpIgnoreInaccessibleMemory       = 0x00020000,
    MiniDumpWithTokenInformation           = 0x00040000,
    MiniDumpValidTypeFlags                 = 0x0007ffff,
} MINIDUMP_TYPE;

//
// In addition to the primary flags provided to
// MiniDumpWriteDump there are additional, less
// frequently used options queried via the secondary
// flags callback.
//
// MiniSecondaryWithoutPowerInfo suppresses the minidump
// query that retrieves processor power information for
// MINIDUMP_MISC_INFO.
//

typedef enum _MINIDUMP_SECONDARY_FLAGS
{
    MiniSecondaryWithoutPowerInfo = 0x00000001,

    MiniSecondaryValidFlags       = 0x00000001,
} MINIDUMP_SECONDARY_FLAGS;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI* MINIDUMP_CALLBACK_ROUTINE)(
    __inout PVOID CallbackParam,
    __in    PMINIDUMP_CALLBACK_INPUT CallbackInput,
    __inout PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
);

typedef struct _MINIDUMP_CALLBACK_INFORMATION
{
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    __in HANDLE hProcess,
    __in DWORD ProcessId,
    __in HANDLE hFile,
    __in MINIDUMP_TYPE DumpType,
    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
);

BOOL
WINAPI
MiniDumpReadDumpStream(
    __in PVOID BaseOfDump,
    __in ULONG StreamNumber,
    __deref_out_opt PMINIDUMP_DIRECTORY* Dir,
    __deref_out_opt PVOID* StreamPointer,
    __out_opt ULONG* StreamSize
);

#pragma pack(pop)

#ifdef __cplusplus
}
#endif


#endif // _DBGHELP_


```

`HyperHide/pluginsdk/jansson/jansson.h`:

```h
/*
 * Copyright (c) 2009-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 */

#ifndef JANSSON_H
#define JANSSON_H

#include <stdio.h>
#include <stdlib.h>  /* for size_t */
#include <stdarg.h>

#include "jansson_config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* version */

#define JANSSON_MAJOR_VERSION  2
#define JANSSON_MINOR_VERSION  9
#define JANSSON_MICRO_VERSION  0

/* Micro version is omitted if it's 0 */
#define JANSSON_VERSION  "2.9"

/* Version as a 3-byte hex number, e.g. 0x010201 == 1.2.1. Use this
   for numeric comparisons, e.g. #if JANSSON_VERSION_HEX >= ... */
#define JANSSON_VERSION_HEX  ((JANSSON_MAJOR_VERSION << 16) |   \
                              (JANSSON_MINOR_VERSION << 8)  |   \
                              (JANSSON_MICRO_VERSION << 0))


/* types */

typedef enum
{
    JSON_OBJECT,
    JSON_ARRAY,
    JSON_STRING,
    JSON_INTEGER,
    JSON_REAL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NULL
} json_type;

typedef struct json_t
{
    json_type type;
    size_t refcount;
} json_t;

#ifndef JANSSON_USING_CMAKE /* disabled if using cmake */
#if JSON_INTEGER_IS_LONG_LONG
#ifdef _WIN32
#define JSON_INTEGER_FORMAT "I64d"
#else
#define JSON_INTEGER_FORMAT "lld"
#endif
typedef long long json_int_t;
#else
#define JSON_INTEGER_FORMAT "ld"
typedef long json_int_t;
#endif /* JSON_INTEGER_IS_LONG_LONG */
#endif

#define json_typeof(json)      ((json)->type)
#define json_is_object(json)   ((json) && json_typeof(json) == JSON_OBJECT)
#define json_is_array(json)    ((json) && json_typeof(json) == JSON_ARRAY)
#define json_is_string(json)   ((json) && json_typeof(json) == JSON_STRING)
#define json_is_integer(json)  ((json) && json_typeof(json) == JSON_INTEGER)
#define json_is_real(json)     ((json) && json_typeof(json) == JSON_REAL)
#define json_is_number(json)   (json_is_integer(json) || json_is_real(json))
#define json_is_true(json)     ((json) && json_typeof(json) == JSON_TRUE)
#define json_is_false(json)    ((json) && json_typeof(json) == JSON_FALSE)
#define json_boolean_value     json_is_true
#define json_is_boolean(json)  (json_is_true(json) || json_is_false(json))
#define json_is_null(json)     ((json) && json_typeof(json) == JSON_NULL)

/* construction, destruction, reference counting */

__declspec(dllimport) json_t* json_object(void);
__declspec(dllimport) json_t* json_array(void);
__declspec(dllimport) json_t* json_string(const char* value);
__declspec(dllimport) json_t* json_stringn(const char* value, size_t len);
__declspec(dllimport) json_t* json_string_nocheck(const char* value);
__declspec(dllimport) json_t* json_stringn_nocheck(const char* value, size_t len);
__declspec(dllimport) json_t* json_integer(json_int_t value);
__declspec(dllimport) json_t* json_real(double value);
__declspec(dllimport) json_t* json_true(void);
__declspec(dllimport) json_t* json_false(void);
#define json_boolean(val)      ((val) ? json_true() : json_false())
__declspec(dllimport) json_t* json_null(void);

static JSON_INLINE
json_t* json_incref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1)
        ++json->refcount;
    return json;
}

/* do not call json_delete directly */
__declspec(dllimport) void json_delete(json_t* json);

static JSON_INLINE
void json_decref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1 && --json->refcount == 0)
        json_delete(json);
}

#if defined(__GNUC__) || defined(__clang__)
static JSON_INLINE
void json_decrefp(json_t** json)
{
    if(json)
    {
        json_decref(*json);
        *json = NULL;
    }
}

#define json_auto_t json_t __attribute__((cleanup(json_decrefp)))
#endif


/* error reporting */

#define JSON_ERROR_TEXT_LENGTH    160
#define JSON_ERROR_SOURCE_LENGTH   80

typedef struct
{
    int line;
    int column;
    int position;
    char source[JSON_ERROR_SOURCE_LENGTH];
    char text[JSON_ERROR_TEXT_LENGTH];
} json_error_t;


/* getters, setters, manipulation */

__declspec(dllimport) void json_object_seed(size_t seed);
__declspec(dllimport) size_t json_object_size(const json_t* object);
__declspec(dllimport) json_t* json_object_get(const json_t* object, const char* key);
__declspec(dllimport) int json_object_set_new(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_set_new_nocheck(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_del(json_t* object, const char* key);
__declspec(dllimport) int json_object_clear(json_t* object);
__declspec(dllimport) int json_object_update(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_existing(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_missing(json_t* object, json_t* other);
__declspec(dllimport) void* json_object_iter(json_t* object);
__declspec(dllimport) void* json_object_iter_at(json_t* object, const char* key);
__declspec(dllimport) void* json_object_key_to_iter(const char* key);
__declspec(dllimport) void* json_object_iter_next(json_t* object, void* iter);
__declspec(dllimport) const char* json_object_iter_key(void* iter);
__declspec(dllimport) json_t* json_object_iter_value(void* iter);
__declspec(dllimport) int json_object_iter_set_new(json_t* object, void* iter, json_t* value);

#define json_object_foreach(object, key, value) \
    for(key = json_object_iter_key(json_object_iter(object)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(json_object_iter_next(object, json_object_key_to_iter(key))))

#define json_object_foreach_safe(object, n, key, value)     \
    for(key = json_object_iter_key(json_object_iter(object)), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(n), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)))

#define json_array_foreach(array, index, value) \
    for(index = 0; \
        index < json_array_size(array) && (value = json_array_get(array, index)); \
        index++)

static JSON_INLINE
int json_object_set(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_set_nocheck(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new_nocheck(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_iter_set(json_t* object, void* iter, json_t* value)
{
    return json_object_iter_set_new(object, iter, json_incref(value));
}

__declspec(dllimport) size_t json_array_size(const json_t* array);
__declspec(dllimport) json_t* json_array_get(const json_t* array, size_t index);
__declspec(dllimport) int json_array_set_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_append_new(json_t* array, json_t* value);
__declspec(dllimport) int json_array_insert_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_remove(json_t* array, size_t index);
__declspec(dllimport) int json_array_clear(json_t* array);
__declspec(dllimport) int json_array_extend(json_t* array, json_t* other);

static JSON_INLINE
int json_array_set(json_t* array, size_t ind, json_t* value)
{
    return json_array_set_new(array, ind, json_incref(value));
}

static JSON_INLINE
int json_array_append(json_t* array, json_t* value)
{
    return json_array_append_new(array, json_incref(value));
}

static JSON_INLINE
int json_array_insert(json_t* array, size_t ind, json_t* value)
{
    return json_array_insert_new(array, ind, json_incref(value));
}

__declspec(dllimport) const char* json_string_value(const json_t* string);
__declspec(dllimport) size_t json_string_length(const json_t* string);
__declspec(dllimport) json_int_t json_integer_value(const json_t* integer);
__declspec(dllimport) double json_real_value(const json_t* real);
__declspec(dllimport) double json_number_value(const json_t* json);

__declspec(dllimport) int json_string_set(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_string_set_nocheck(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn_nocheck(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_integer_set(json_t* integer, json_int_t value);
__declspec(dllimport) int json_real_set(json_t* real, double value);

/* pack, unpack */

__declspec(dllimport) json_t* json_pack(const char* fmt, ...);
__declspec(dllimport) json_t* json_pack_ex(json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) json_t* json_vpack_ex(json_error_t* error, size_t flags, const char* fmt, va_list ap);

#define JSON_VALIDATE_ONLY  0x1
#define JSON_STRICT         0x2

__declspec(dllimport) int json_unpack(json_t* root, const char* fmt, ...);
__declspec(dllimport) int json_unpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) int json_vunpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, va_list ap);


/* equality */

__declspec(dllimport) int json_equal(json_t* value1, json_t* value2);


/* copying */

__declspec(dllimport) json_t* json_copy(json_t* value);
__declspec(dllimport) json_t* json_deep_copy(const json_t* value);


/* decoding */

#define JSON_REJECT_DUPLICATES  0x1
#define JSON_DISABLE_EOF_CHECK  0x2
#define JSON_DECODE_ANY         0x4
#define JSON_DECODE_INT_AS_REAL 0x8
#define JSON_ALLOW_NUL          0x10

typedef size_t (*json_load_callback_t)(void* buffer, size_t buflen, void* data);

__declspec(dllimport) json_t* json_loads(const char* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadb(const char* buffer, size_t buflen, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadf(FILE* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_file(const char* path, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_callback(json_load_callback_t callback, void* data, size_t flags, json_error_t* error);


/* encoding */

#define JSON_MAX_INDENT         0x1F
#define JSON_INDENT(n)          ((n) & JSON_MAX_INDENT)
#define JSON_COMPACT            0x20
#define JSON_ENSURE_ASCII       0x40
#define JSON_SORT_KEYS          0x80
#define JSON_PRESERVE_ORDER     0x100
#define JSON_ENCODE_ANY         0x200
#define JSON_ESCAPE_SLASH       0x400
#define JSON_REAL_PRECISION(n)  (((n) & 0x1F) << 11)

typedef int (*json_dump_callback_t)(const char* buffer, size_t size, void* data);

__declspec(dllimport) char* json_dumps(const json_t* json, size_t flags);
__declspec(dllimport) int json_dumpf(const json_t* json, FILE* output, size_t flags);
__declspec(dllimport) int json_dump_file(const json_t* json, const char* path, size_t flags);
__declspec(dllimport) int json_dump_callback(const json_t* json, json_dump_callback_t callback, void* data, size_t flags);

/* custom memory allocation */

typedef void* (*json_malloc_t)(size_t);
typedef void (*json_free_t)(void*);

__declspec(dllimport) void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
__declspec(dllimport) void json_get_alloc_funcs(json_malloc_t* malloc_fn, json_free_t* free_fn);

#ifdef __cplusplus
}
#endif

#endif

```

`HyperHide/pluginsdk/jansson/jansson_config.h`:

```h
/*
 * Copyright (c) 2010-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 *
 *
 * This file specifies a part of the site-specific configuration for
 * Jansson, namely those things that affect the public API in
 * jansson.h.
 *
 * The CMake system will generate the jansson_config.h file and
 * copy it to the build and install directories.
 */

#ifndef JANSSON_CONFIG_H
#define JANSSON_CONFIG_H

/* Define this so that we can disable scattered automake configuration in source files */
#ifndef JANSSON_USING_CMAKE
#define JANSSON_USING_CMAKE
#endif

/* Note: when using cmake, JSON_INTEGER_IS_LONG_LONG is not defined nor used,
 * as we will also check for __int64 etc types.
 * (the definition was used in the automake system) */

/* Bring in the cmake-detected defines */
#define HAVE_STDINT_H 1
/* #undef HAVE_INTTYPES_H */
/* #undef HAVE_SYS_TYPES_H */

/* Include our standard type header for the integer typedef */

#if defined(HAVE_STDINT_H)
#  include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#  include <inttypes.h>
#elif defined(HAVE_SYS_TYPES_H)
#  include <sys/types.h>
#endif


/* If your compiler supports the inline keyword in C, JSON_INLINE is
   defined to `inline', otherwise empty. In C++, the inline is always
   supported. */
#ifdef __cplusplus
#define JSON_INLINE inline
#else
#define JSON_INLINE __inline
#endif


#define json_int_t long long
#define json_strtoint strtoll
#define JSON_INTEGER_FORMAT "I64d"


/* If locale.h and localeconv() are available, define to 1, otherwise to 0. */
#define JSON_HAVE_LOCALECONV 1


/* Maximum recursion depth for parsing JSON input.
   This limits the depth of e.g. array-within-array constructions. */
#define JSON_PARSER_MAX_DEPTH 2048


#endif

```

`HyperHide/pluginsdk/jansson/jansson_x64dbg.h`:

```h
#pragma once

#include "jansson.h"

typedef json_t* JSON;

static JSON_INLINE
json_t* json_hex(unsigned json_int_t value)
{
    char hexvalue[20];
    sprintf_s(hexvalue, "0x%llX", value);
    return json_string(hexvalue);
}

static JSON_INLINE
unsigned json_int_t json_hex_value(const json_t* hex)
{
    unsigned json_int_t ret = 0;
    const char* hexvalue;
    hexvalue = json_string_value(hex);
    if(!hexvalue)
        return 0;
    sscanf_s(hexvalue, "0x%llX", &ret);
    return ret;
}

```

`HyperHide/pluginsdk/lz4/lz4.h`:

```h
/*
   LZ4 - Fast LZ compression algorithm
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4_H
#define _LZ4_H

#if defined (__cplusplus)
extern "C"
{
#endif


/**************************************
   Version
**************************************/
#define LZ4_VERSION_MAJOR    1    /* for major interface/format changes  */
#define LZ4_VERSION_MINOR    1    /* for minor interface/format changes  */
#define LZ4_VERSION_RELEASE  3    /* for tweaks, bug-fixes, or development */


/**************************************
   Compiler Options
**************************************/
#if (defined(__GNUC__) && defined(__STRICT_ANSI__)) || (defined(_MSC_VER) && !defined(__cplusplus))   /* Visual Studio */
#  define inline __inline           /* Visual C is not C99, but supports some kind of inline */
#endif


/**************************************
   Simple Functions
**************************************/

__declspec(dllimport) int LZ4_compress(const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_decompress_safe(const char* source, char* dest, int inputSize, int maxOutputSize);

/*
LZ4_compress() :
    Compresses 'inputSize' bytes from 'source' into 'dest'.
    Destination buffer must be already allocated,
    and must be sized to handle worst cases situations (input data not compressible)
    Worst case size evaluation is provided by function LZ4_compressBound()
    inputSize : Max supported value is LZ4_MAX_INPUT_VALUE
    return : the number of bytes written in buffer dest
             or 0 if the compression fails

LZ4_decompress_safe() :
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function is protected against buffer overflow exploits (never writes outside of output buffer, and never reads outside of input buffer). Therefore, it is protected against malicious data packets
*/


/**************************************
   Advanced Functions
**************************************/
#define LZ4_MAX_INPUT_SIZE        0x7E000000   /* 2 113 929 216 bytes */
#define LZ4_COMPRESSBOUND(isize)  ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)

/*
LZ4_compressBound() :
    Provides the maximum size that LZ4 may output in a "worst case" scenario (input data not compressible)
    primarily useful for memory allocation of output buffer.
    inline function is recommended for the general case,
    macro is also provided when result needs to be evaluated at compilation (such as stack memory allocation).

    isize  : is the input size. Max supported value is LZ4_MAX_INPUT_SIZE
    return : maximum output size in a "worst case" scenario
             or 0, if input size is too large ( > LZ4_MAX_INPUT_SIZE)
*/
__declspec(dllimport) int LZ4_compressBound(int isize);


/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is LZ4_MAX_INPUT_VALUE
    maxOutputSize : is the size of the destination buffer (which must be already allocated)
    return : the number of bytes written in buffer 'dest'
             or 0 if the compression fails
*/
__declspec(dllimport) int LZ4_compress_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);


/*
LZ4_decompress_fast() :
    originalSize : is the original and therefore uncompressed size
    return : the number of bytes read from the source buffer (in other words, the compressed size)
             If the source stream is malformed, the function will stop decoding and return a negative result.
    note : This function is a bit faster than LZ4_decompress_safe()
           This function never writes outside of output buffers, but may read beyond input buffer in case of malicious data packet.
           Use this function preferably into a trusted environment (data to decode comes from a trusted source).
           Destination buffer must be already allocated. Its size must be a minimum of 'outputSize' bytes.
*/
__declspec(dllimport) int LZ4_decompress_fast(const char* source, char* dest, int originalSize);


/*
LZ4_decompress_safe_partial() :
    This function decompress a compressed block of size 'inputSize' at position 'source'
    into output buffer 'dest' of size 'maxOutputSize'.
    The function tries to stop decompressing operation as soon as 'targetOutputSize' has been reached,
    reducing decompression time.
    return : the number of bytes decoded in the destination buffer (necessarily <= maxOutputSize)
       Note : this number can be < 'targetOutputSize' should the compressed block to decode be smaller.
             Always control how many bytes were decoded.
             If the source stream is detected malformed, the function will stop decoding and return a negative result.
             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets
*/
__declspec(dllimport) int LZ4_decompress_safe_partial(const char* source, char* dest, int inputSize, int targetOutputSize, int maxOutputSize);


/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofState();

Note that tables must be aligned on 4-bytes boundaries, otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withState() and LZ4_compress_limitedOutput_withState() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/
__declspec(dllimport) int LZ4_sizeofState(void);
__declspec(dllimport) int LZ4_compress_withState(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compress_limitedOutput_withState(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_create(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compress_continue(void* LZ4_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compress_limitedOutput_continue(void* LZ4_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBuffer(void* LZ4_Data);
__declspec(dllimport) int   LZ4_free(void* LZ4_Data);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4 Data Structure, thanks to the function :

void* LZ4_create (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4 Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compress_continue() or LZ4_compress_limitedOutput_continue().
Their behavior are identical to LZ4_compress() or LZ4_compress_limitedOutput(),
but require the LZ4 Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBuffer(void* LZ4_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compress_continue() or LZ4_compress_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_free() will release the memory used by the LZ4 Data Structure.
*/


__declspec(dllimport) int LZ4_sizeofStreamState(void);
__declspec(dllimport) int LZ4_resetStreamState(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_create (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamState();
Note also that space must be 4-bytes aligned.

Once space is allocated, you must initialize it using : LZ4_resetStreamState(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned on 4-bytes boundaries, and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamState() must be 0 is OK.
Any other value means there was an error (typically, pointer is not aligned on 4-bytes boundaries).
*/


__declspec(dllimport) int LZ4_decompress_safe_withPrefix64k(const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) int LZ4_decompress_fast_withPrefix64k(const char* source, char* dest, int outputSize);

/*
*_withPrefix64k() :
    These decoding functions work the same as their "normal name" versions,
    but can use up to 64KB of data in front of 'char* dest'.
    These functions are necessary to decode inter-dependant blocks.
*/


/**************************************
   Obsolete Functions
**************************************/
/*
These functions are deprecated and should no longer be used.
They are provided here for compatibility with existing user programs.
*/
__declspec(dllimport) int LZ4_uncompress(const char* source, char* dest, int outputSize);
__declspec(dllimport) int LZ4_uncompress_unknownOutputSize(const char* source, char* dest, int isize, int maxOutputSize);


#if defined (__cplusplus)
}
#endif

#endif //_LZ4_H
```

`HyperHide/pluginsdk/lz4/lz4file.h`:

```h
#ifndef _LZ4FILE_H
#define _LZ4FILE_H

typedef enum _LZ4_STATUS
{
    LZ4_SUCCESS,
    LZ4_FAILED_OPEN_INPUT,
    LZ4_FAILED_OPEN_OUTPUT,
    LZ4_NOT_ENOUGH_MEMORY,
    LZ4_INVALID_ARCHIVE,
    LZ4_CORRUPTED_ARCHIVE
} LZ4_STATUS;

#if defined (__cplusplus)
extern "C"
{
#endif

__declspec(dllimport) LZ4_STATUS LZ4_compress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_compress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_file(const char* input_filename, const char* output_filename);
__declspec(dllimport) LZ4_STATUS LZ4_decompress_fileW(const wchar_t* input_filename, const wchar_t* output_filename);

#if defined (__cplusplus)
}
#endif

#endif //_LZ4FILE_H
```

`HyperHide/pluginsdk/lz4/lz4hc.h`:

```h
/*
   LZ4 HC - High Compression Mode of LZ4
   Header File
   Copyright (C) 2011-2014, Yann Collet.
   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the
   distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

   You can contact the author at :
   - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
   - LZ4 source repository : http://code.google.com/p/lz4/
*/
#ifndef _LZ4HC_H
#define _LZ4HC_H

#if defined (__cplusplus)
extern "C"
{
#endif


__declspec(dllimport) int LZ4_compressHC(const char* source, char* dest, int inputSize);
/*
LZ4_compressHC :
    return : the number of bytes in compressed buffer dest
             or 0 if compression fails.
    note : destination buffer must be already allocated.
        To avoid any problem, size it to handle worst cases situations (input data not compressible)
        Worst case size evaluation is provided by function LZ4_compressBound() (see "lz4.h")
*/

__declspec(dllimport) int LZ4_compressHC_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize);
/*
LZ4_compress_limitedOutput() :
    Compress 'inputSize' bytes from 'source' into an output buffer 'dest' of maximum size 'maxOutputSize'.
    If it cannot achieve it, compression will stop, and result of the function will be zero.
    This function never writes outside of provided output buffer.

    inputSize  : Max supported value is 1 GB
    maxOutputSize : is maximum allowed size into the destination buffer (which must be already allocated)
    return : the number of output bytes written in buffer 'dest'
             or 0 if compression fails.
*/


__declspec(dllimport) int LZ4_compressHC2(const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput(const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);
/*
    Same functions as above, but with programmable 'compressionLevel'.
    Recommended values are between 4 and 9, although any value between 0 and 16 will work.
    'compressionLevel'==0 means use default 'compressionLevel' value.
    Values above 16 behave the same as 16.
    Equivalent variants exist for all other compression functions below.
*/

/* Note :
Decompression functions are provided within LZ4 source code (see "lz4.h") (BSD license)
*/


/**************************************
   Using an external allocation
**************************************/
__declspec(dllimport) int LZ4_sizeofStateHC(void);
__declspec(dllimport) int LZ4_compressHC_withStateHC(void* state, const char* source, char* dest, int inputSize);
__declspec(dllimport) int LZ4_compressHC_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize);

__declspec(dllimport) int LZ4_compressHC2_withStateHC(void* state, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int LZ4_compressHC2_limitedOutput_withStateHC(void* state, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions are provided should you prefer to allocate memory for compression tables with your own allocation methods.
To know how much memory must be allocated for the compression tables, use :
int LZ4_sizeofStateHC();

Note that tables must be aligned for pointer (32 or 64 bits), otherwise compression will fail (return code 0).

The allocated memory can be provided to the compressions functions using 'void* state' parameter.
LZ4_compress_withStateHC() and LZ4_compress_limitedOutput_withStateHC() are equivalent to previously described functions.
They just use the externally allocated memory area instead of allocating their own (on stack, or on heap).
*/


/**************************************
   Streaming Functions
**************************************/
__declspec(dllimport) void* LZ4_createHC(const char* inputBuffer);
__declspec(dllimport) int   LZ4_compressHC_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize);
__declspec(dllimport) int   LZ4_compressHC_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize);
__declspec(dllimport) char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
__declspec(dllimport) int   LZ4_freeHC(void* LZ4HC_Data);

__declspec(dllimport) int   LZ4_compressHC2_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int compressionLevel);
__declspec(dllimport) int   LZ4_compressHC2_limitedOutput_continue(void* LZ4HC_Data, const char* source, char* dest, int inputSize, int maxOutputSize, int compressionLevel);

/*
These functions allow the compression of dependent blocks, where each block benefits from prior 64 KB within preceding blocks.
In order to achieve this, it is necessary to start creating the LZ4HC Data Structure, thanks to the function :

void* LZ4_createHC (const char* inputBuffer);
The result of the function is the (void*) pointer on the LZ4HC Data Structure.
This pointer will be needed in all other functions.
If the pointer returned is NULL, then the allocation has failed, and compression must be aborted.
The only parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

All blocks are expected to lay next to each other within the input buffer, starting from 'inputBuffer'.
To compress each block, use either LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue().
Their behavior are identical to LZ4_compressHC() or LZ4_compressHC_limitedOutput(),
but require the LZ4HC Data Structure as their first argument, and check that each block starts right after the previous one.
If next block does not begin immediately after the previous one, the compression will fail (return 0).

When it's no longer possible to lay the next block after the previous one (not enough space left into input buffer), a call to :
char* LZ4_slideInputBufferHC(void* LZ4HC_Data);
must be performed. It will typically copy the latest 64KB of input at the beginning of input buffer.
Note that, for this function to work properly, minimum size of an input buffer must be 192KB.
==> The memory position where the next input data block must start is provided as the result of the function.

Compression can then resume, using LZ4_compressHC_continue() or LZ4_compressHC_limitedOutput_continue(), as usual.

When compression is completed, a call to LZ4_freeHC() will release the memory used by the LZ4HC Data Structure.
*/

__declspec(dllimport) int LZ4_sizeofStreamStateHC(void);
__declspec(dllimport) int LZ4_resetStreamStateHC(void* state, const char* inputBuffer);

/*
These functions achieve the same result as :
void* LZ4_createHC (const char* inputBuffer);

They are provided here to allow the user program to allocate memory using its own routines.

To know how much space must be allocated, use LZ4_sizeofStreamStateHC();
Note also that space must be aligned for pointers (32 or 64 bits).

Once space is allocated, you must initialize it using : LZ4_resetStreamStateHC(void* state, const char* inputBuffer);
void* state is a pointer to the space allocated.
It must be aligned for pointers (32 or 64 bits), and be large enough.
The parameter 'const char* inputBuffer' must, obviously, point at the beginning of input buffer.
The input buffer must be already allocated, and size at least 192KB.
'inputBuffer' will also be the 'const char* source' of the first block.

The same space can be re-used multiple times, just by initializing it each time with LZ4_resetStreamState().
return value of LZ4_resetStreamStateHC() must be 0 is OK.
Any other value means there was an error (typically, state is not aligned for pointers (32 or 64 bits)).
*/


#if defined (__cplusplus)
}
#endif

#endif //_LZ4HC_H

```

`HyperHide/resource.h`:

```h
#pragma once

#define DLG_MAIN											100	
#define IDB_ICON											101
#define IDC_CHK_NTQUERYINFORMATIONPROCESS					1000	
#define IDC_CHK_NTQUERYSYSTEMINFORMATION					1001	
#define IDC_CHK_NTQUERYINFORMATIONTHREAD					1002		
#define IDC_CHK_NTQUERYINFORMATIONJOBOBJECT					1003			
#define IDC_CHK_NTQUERYOBJECT								1004	
#define IDC_CHK_NTQUERYSYSTEMTIME							1005
#define IDC_CHK_NTQUERYPERFORMANCECOUNTER					1006		
#define IDC_CHK_NTCREATEUSERPROCESS							1007			
#define IDC_CHK_NTCREATEPROCESSEX							1008
#define IDC_CHK_NTCREATETHREADEX							1009			
#define IDC_CHK_NTSETCONTEXTTHREAD							1010			
#define IDC_CHK_NTGETCONTEXTTHREAD							1011
#define IDC_CHK_NTOPENPROCESS								1012			
#define IDC_CHK_NTOPENTHREAD							    1013
#define IDC_CHK_NTSETINFORMATIONTHREAD						1014	
#define IDC_CHK_NTSYSTEMDEBUGCONTROL						1015
#define IDC_CHK_NTGETNEXTPROCESS							1016			
#define IDC_CHK_NTYIELDEXECUTION							1017
#define IDC_CHK_NTCREATEFILE								1018	
#define IDC_CHK_NTCONTINUE									1019			
#define IDC_CHK_NTCLOSE										1020	
#define IDC_CHK_NTUSERBUILDHWNDLIST							1021		
#define IDC_CHK_NTUSERFINDWINDOWEX							1022			
#define IDC_CHK_NTUSERQUERYWINDOW							1023
#define IDC_CHK_NTUSERGETFOREGROUNDWINDOW					1024
#define IDC_CHK_KUSER_SHARED_DATA							1025	
#define IDC_CHK_KIEXCEPTIONDISPATCH							1026
#define IDC_CHK_NTSETINFORMATIONPROCESS						1027
#define IDC_CHK_CLEARPEBBEINGDEBUGGED						1028
#define IDC_CHK_CLEARPEBNTGLOBALFLAG						1029
#define IDC_CHK_CLEARHEAPFLAGS								1030
#define IDC_CHK_CLEARKUSERSHAREDDATA						1031
#define IDC_CHK_CLEARHIDEFROMDEBUGGER						1032
#define IDC_CHK_CLEARBYPASSFREEZEFLAG						1033
#define IDC_CHK_CLEARPROCESSBREAKONTERM						1034
#define IDC_CHK_CLEARTHREADBREAKONTERM						1035
#define IDC_CHK_SAVEPROCESSDEBUGFLAGS						1036
#define IDC_CHK_SAVEPROCESSHANDLETRACING					1037
#define IDC_CHK_SELECT_ALL									1038			   
#define IDC_COB_CURRENTPROFILE								2000
#define IDC_BTN_OK										    3000
#define IDC_BTN_CREATENEWPROFILE							3001
#define IDC_TXT_COPYRIGHT							        4000
#define IDC_TXT_CURRENT							            4001

```

`HyperHide/resource.rc`:

```rc
#include <Windows.h>
#include "resource.h"

IDB_ICON            PNG                     "HyperHideIcon.png"

100 DIALOGEX 0, 0, 335, 380, 0
STYLE DS_SETFONT | DS_MODALFRAME | DS_3DLOOK | DS_CONTEXTHELP | WS_POPUPWINDOW | WS_VISIBLE | WS_DLGFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX
EXSTYLE WS_EX_CONTEXTHELP
CAPTION "HyperHide"
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
FONT 8, "MS Shell Dlg"
{
    //LTEXT            "Debugged PID:", 4002, 5, 5, 27, 10, NOT WS_GROUP

    GROUPBOX         "Native Syscalls:", 500, 19, 49, 128, 293
        GROUPBOX         "Win32k Syscalls:", 501, 173, 49, 128, 69
        GROUPBOX         "Time functions:", 502, 173, 119, 128, 42
        GROUPBOX         "Other:", 503, 173, 162, 128, 194
        GROUPBOX         "Profiles", 504, 19, 7, 280, 30
        PUSHBUTTON       "Ok", 3000, 19, 346, 129, 15
        PUSHBUTTON       "Create New Profile", 3001, 210, 17, 79, 13
        AUTOCHECKBOX     "NtQueryInformationProcess", IDC_CHK_NTQUERYINFORMATIONPROCESS, 26, 76, 107, 10
        AUTOCHECKBOX     "NtQuerySystemInformation", IDC_CHK_NTQUERYSYSTEMINFORMATION, 26, 90, 107, 10
        AUTOCHECKBOX     "NtQueryInformationThread", IDC_CHK_NTQUERYINFORMATIONTHREAD, 26, 118, 107, 10
        AUTOCHECKBOX     "NtQueryInformationJobObject", IDC_CHK_NTQUERYINFORMATIONJOBOBJECT, 26, 104, 107, 10
        AUTOCHECKBOX     "NtQueryObject", IDC_CHK_NTQUERYOBJECT, 26, 62, 107, 10
        AUTOCHECKBOX     "NtSetInformationThread", IDC_CHK_NTSETINFORMATIONTHREAD, 26, 132, 107, 10
        AUTOCHECKBOX     "NtSetContextThread", IDC_CHK_NTSETCONTEXTTHREAD, 26, 160, 107, 10
        AUTOCHECKBOX     "NtGetContextThread", IDC_CHK_NTGETCONTEXTTHREAD, 26, 174, 107, 10
        AUTOCHECKBOX     "NtSystemDebugControl", IDC_CHK_NTSYSTEMDEBUGCONTROL, 26, 328, 107, 10
        AUTOCHECKBOX     "NtClose", IDC_CHK_NTCLOSE, 26, 188, 109, 9
        AUTOCHECKBOX     "NtYieldExecution", IDC_CHK_NTYIELDEXECUTION, 26, 202, 107, 10
        AUTOCHECKBOX     "NtCreateThreadEx", IDC_CHK_NTCREATETHREADEX, 26, 216, 107, 10
        AUTOCHECKBOX     "NtCreateFile", IDC_CHK_NTCREATEFILE, 26, 230, 107, 10
        AUTOCHECKBOX     "NtCreateProcessEx", IDC_CHK_NTCREATEPROCESSEX, 26, 258, 107, 10
        AUTOCHECKBOX     "NtCreateUserProcess", IDC_CHK_NTCREATEUSERPROCESS, 26, 272, 107, 10
        AUTOCHECKBOX     "NtGetNextProcess", IDC_CHK_NTGETNEXTPROCESS, 26, 286, 107, 10
        AUTOCHECKBOX     "NtOpenProcess", IDC_CHK_NTOPENPROCESS, 26, 300, 107, 10
        AUTOCHECKBOX     "NtOpenThread", IDC_CHK_NTOPENTHREAD, 26, 314, 107, 10
        AUTOCHECKBOX     "NtUserFindWindowEx", IDC_CHK_NTUSERFINDWINDOWEX, 179, 62, 97, 10
        AUTOCHECKBOX     "NtUserBuildHwndList", IDC_CHK_NTUSERBUILDHWNDLIST, 179, 76, 97, 10
        AUTOCHECKBOX     "NtUserQueryWindow", IDC_CHK_NTUSERQUERYWINDOW, 179, 90, 97, 10
        AUTOCHECKBOX     "NtUserGetForegroundWindow", IDC_CHK_NTUSERGETFOREGROUNDWINDOW, 179, 104, 111, 10
        AUTOCHECKBOX     "KuserSharedData", IDC_CHK_KUSER_SHARED_DATA, 179, 189, 110, 10
        AUTOCHECKBOX     "NtQuerySystemTime", IDC_CHK_NTQUERYSYSTEMTIME, 179, 133, 110, 10
        AUTOCHECKBOX     "NtQueryPerformanceCounter", IDC_CHK_NTQUERYPERFORMANCECOUNTER, 179, 147, 110, 10
        AUTOCHECKBOX     "NtContinue", IDC_CHK_NTCONTINUE, 26, 244, 107, 10
        AUTOCHECKBOX     "NtSetInformationProcess", IDC_CHK_NTSETINFORMATIONPROCESS, 26, 146, 89, 10
        AUTOCHECKBOX     "KiExceptionDispatch", IDC_CHK_KIEXCEPTIONDISPATCH, 179, 175, 110, 10
        AUTOCHECKBOX     "Select All", IDC_CHK_SELECT_ALL, 179, 343, 107, 10
        AUTOCHECKBOX     "Clear Peb BeingDebugged Flag", IDC_CHK_CLEARPEBBEINGDEBUGGED, 179, 203, 115, 10
        AUTOCHECKBOX     "Clear Peb NtGlobalFlag", IDC_CHK_CLEARPEBNTGLOBALFLAG, 179, 217, 115, 10
        AUTOCHECKBOX     "Clear Heap Flags", IDC_CHK_CLEARHEAPFLAGS, 179, 231, 115, 10
        AUTOCHECKBOX     "Clear KUserSharedData", IDC_CHK_CLEARKUSERSHAREDDATA, 179, 245, 97, 10
        AUTOCHECKBOX     "Clear HideFromDebugger Flag", IDC_CHK_CLEARHIDEFROMDEBUGGER, 179, 259, 115, 10
        AUTOCHECKBOX     "Clear BypassProcessFreeze Flag", IDC_CHK_CLEARBYPASSFREEZEFLAG, 179, 273, 115, 10
        AUTOCHECKBOX     "Clear ProcessBreakOnTermination", IDC_CHK_CLEARPROCESSBREAKONTERM, 179, 287, 118, 10
        AUTOCHECKBOX     "Clear TheadBreakOnTermination", IDC_CHK_CLEARTHREADBREAKONTERM, 179, 301, 116, 10
        AUTOCHECKBOX     "Save ProcessDebugFlags", IDC_CHK_SAVEPROCESSDEBUGFLAGS, 179, 329, 102, 10
        AUTOCHECKBOX     "Save ProcessHandleTracing", IDC_CHK_SAVEPROCESSHANDLETRACING, 179, 315, 105, 10
        COMBOBOX         2000, 53, 17, 153, 81, CBS_DROPDOWN | NOT WS_TABSTOP
        LTEXT            "Copyright 2021 by Air", 4000, 1, 370, 78, 10, NOT WS_GROUP
        LTEXT            "Current:", 4001, 26, 20, 27, 10, NOT WS_GROUP
}

```

`HyperHideDrv/ActiveProcessDbgList.c`:

```c
#include "ntddk.h"
typedef struct _DbgPortList{
	LIST_ENTRY PortList;
	ULONG64 DbgPort;
	UINT8 markdbg;
	PEPROCESS Process;
}DbgPortList, *PDbgPortList;
static LIST_ENTRY PortList ;
static KSPIN_LOCK Port_lock = NULL;
VOID InitDbgPortList(){

	InitializeListHead(&PortList);
	KeInitializeSpinLock(&Port_lock);

}
PDbgPortList Port_FindProcessList(PEPROCESS Process ,ULONG64 DbgPort){
	KIRQL OldIrql;
	PLIST_ENTRY Entry;
	DbgPortList *TempItem = NULL;
	DbgPortList* DFind = NULL;
	KeAcquireSpinLock(&Port_lock, &OldIrql);
	Entry = PortList.Flink;
	while (Entry != &PortList)
	{
		TempItem = CONTAINING_RECORD(Entry, DbgPortList, PortList);
		Entry = Entry->Flink;
		if (Process!=NULL)
		{
			//DbgPrint("Port_FindProcessList TempItem->Process:%p Process:%p\n", TempItem->Process, Process);
			if (TempItem->Process == Process)
			{
				//DbgPrint("Port_FindProcessList ok\n");
				DFind = TempItem;
				break;
			}
		}
		
		if (DbgPort != NULL)
		{
			if (TempItem->DbgPort == DbgPort)
			{
				DFind = TempItem;
				break;
			}
		}
	}
	KeReleaseSpinLock(&Port_lock, OldIrql);
	return DFind;
}

PDbgPortList Port_AddProcessToList(PEPROCESS Process,ULONG64 DbgPort){
	PDbgPortList TempItem;
	TempItem = (PDbgPortList)ExAllocatePoolWithTag(NonPagedPool, sizeof(DbgPortList), 'prrp');
	if (!TempItem)
	{
		return FALSE;
	}

	RtlZeroMemory(TempItem, sizeof(DbgPortList));
	TempItem->Process = Process;
	TempItem->DbgPort = DbgPort;
	TempItem->markdbg = FALSE;
	ExInterlockedInsertTailList(&PortList, &TempItem->PortList, &Port_lock);
	if (TempItem != NULL)
	{

		return TempItem;
	}

	return FALSE;
}
BOOLEAN Port_SetPort(PEPROCESS Process, ULONG64 DbgPort){
	PDbgPortList Temp = NULL;
	Temp=Port_AddProcessToList(Process, DbgPort);
	if (Temp != NULL){


		return TRUE;
	}
	return FALSE;
}
BOOLEAN Port_IsPort(PEPROCESS Process){
	PDbgPortList Temp = NULL;
	Temp=Port_FindProcessList(Process, NULL);
	if (Temp!=NULL)
	{
		if (Temp->DbgPort != NULL && Temp->Process == Process){

			return TRUE;
		}
	}
	return FALSE;
}
ULONG64 Port_GetPort(PEPROCESS Process){
	PDbgPortList Temp = NULL;
	Temp = Port_FindProcessList(Process, NULL);
	if (Temp != NULL)
	{
		DbgPrint("Port_GetPort:Temp != NULL\n");
		if (Temp->DbgPort != NULL && Temp->Process == Process){

			DbgPrint("Port_GetPort:%p ok\n", Temp->DbgPort);
			return Temp->DbgPort;
		}
	}
	return FALSE;
}
VOID NTAPI Port_ExFreeItem(PDbgPortList Item)
{
	DbgPrint("Port_ExFreeItem:%p\n", Item);
	KIRQL OldIrql;
	KeAcquireSpinLock(&Port_lock, &OldIrql);
	RemoveEntryList(&Item->PortList);
	KeReleaseSpinLock(&Port_lock, OldIrql);
	ExFreePool(Item);
	return;
}

BOOLEAN Port_RemoveDbgItem(PEPROCESS Process, ULONG64 DbgPort){
	
	PDbgPortList Temp = NULL;
	Temp = Port_FindProcessList(Process, DbgPort);
	if (Temp != NULL)
	{
		if (Process!=NULL)
		{
			if (Temp->Process == Process){
				Port_ExFreeItem(Temp);
				return TRUE;
			}
		}

		if (DbgPort != NULL)
		{
			if (Temp->DbgPort == DbgPort){
				Port_ExFreeItem(Temp);
				return TRUE;
			}
		}
	}
	return FALSE;

}

```

`HyperHideDrv/ActiveProcessDbgList.h`:

```h
#include <ntifs.h>

typedef struct _DbgPortList{
	LIST_ENTRY PortList;
	ULONG64 DbgPort;
	UINT8 markdbg;
	PEPROCESS Process;
}DbgPortList, *PDbgPortList;
VOID InitDbgPortList();
PDbgPortList Port_FindProcessList(PEPROCESS Process, ULONG64 DbgPort);
PDbgPortList Port_AddProcessToList(PEPROCESS Process, ULONG64 DbgPort);
VOID NTAPI Port_ExFreeItem(PDbgPortList Item);
BOOLEAN Port_SetPort(PEPROCESS Process, ULONG64 DbgPort);
BOOLEAN Port_IsPort(PEPROCESS Process);
ULONG64 Port_GetPort(PEPROCESS Process);
BOOLEAN Port_RemoveDbgItem(PEPROCESS Process, ULONG64 DbgPort);
```

`HyperHideDrv/CFunction.cpp`:

```cpp
#pragma once
#include "CFunction.h"
#include "CPeModule.h"
#include "GlobalData.h"

//内存
PVOID RtlAllocMemroy(POOL_TYPE PoolType,ULONG_PTR NumberOfBytes,INT16 FillData)
{
	PVOID Memroy =ExAllocatePool(PoolType, NumberOfBytes);
	if (!Memroy)
	{
		return 0;
	}
	RtlFillMemory(Memroy, NumberOfBytes, FillData);
	return Memroy;
}

// 功能类

PVOID GetKernelAddress(char* FunName)
{
	UNICODE_STRING FunNameUnicode;
	ANSI_STRING  as;
	RtlInitAnsiString(&as, FunName);
	RtlAnsiStringToUnicodeString(&FunNameUnicode, &as, TRUE);
	return MmGetSystemRoutineAddress(&FunNameUnicode);
}
void Sleep(LONG msec)
{
	LARGE_INTEGER li;
	li.QuadPart = -10 * 1000;
	li.QuadPart *= msec;
	KeDelayExecutionThread(KernelMode, 0, &li);
}

UINT8  SetCurrentThreadMode(
	IN PETHREAD EThread, 
	IN UINT8 NewMode)
	{
	    // 保存原先模式
	    UINT8 PreviousMode = *((PUINT8)EThread + g_SystemData.PreviousModeOffset);
	    // 修改为WantedMode
	    *((PUINT8)EThread + g_SystemData.PreviousModeOffset) = NewMode;
	    return PreviousMode;
	}
BOOLEAN IsUnicodeString(
	IN PUNICODE_STRING us)
{
	BOOLEAN bOk = FALSE;

	__try
	{
		if (us->Length > 0 &&
			us->Buffer &&
			MmIsAddressValid(us->Buffer) &&
			MmIsAddressValid(&us->Buffer[us->Length / sizeof(WCHAR) - 1]))
		{
			bOk = TRUE;
		}

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		bOk = FALSE;
	}

	return bOk;
}

ULONG GetSystemStartTime()
{
	LARGE_INTEGER la;
	ULONG MyInc;
	MyInc = KeQueryTimeIncrement(); //返回滴答数
	KeQueryTickCount(&la);
	la.QuadPart *= MyInc;
	la.QuadPart /= 10000;
	return la.LowPart;
}


//NT路径转换DOS路径
BOOLEAN NtFileNameToDosFileName(IN PUNICODE_STRING us, OUT WCHAR* ws)
{//文件被删除则会失败
	
	HANDLE hFile = NULL;
	OBJECT_ATTRIBUTES ObjectAttributes;
	IO_STATUS_BLOCK IoStatusBlock;
	PFILE_OBJECT FileObject = NULL;
	POBJECT_NAME_INFORMATION pObjectNameInfo=0;
	BOOLEAN boole= FALSE;
	
	
	InitializeObjectAttributes(&ObjectAttributes, us, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

	if (NT_SUCCESS(ZwOpenFile(&hFile, FILE_READ_ATTRIBUTES | SYNCHRONIZE, &ObjectAttributes, &IoStatusBlock, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT)))
	{
		if (NT_SUCCESS(ObReferenceObjectByHandle(hFile, FILE_READ_ATTRIBUTES, *IoFileObjectType, KernelMode, (PVOID*)&FileObject, NULL)))
		{
			if (NT_SUCCESS(IoQueryFileDosDeviceName(FileObject, &pObjectNameInfo)))
			{
				wcscpy(ws, pObjectNameInfo->Name.Buffer);
				boole= TRUE;
			}
		}
	}
	if (pObjectNameInfo)
	{
		ExFreePool(pObjectNameInfo);
	}

	if (FileObject)
	{
		ObDereferenceObject(FileObject);
	}

	if (hFile)
	{
		ZwClose(hFile);
	}



	return boole;
}

```

`HyperHideDrv/CFunction.h`:

```h
#pragma once

#include "KernelDbgStruct.h"

PVOID RtlAllocMemroy(POOL_TYPE PoolType, ULONG_PTR NumberOfBytes, INT16 FillData);
PVOID GetKernelAddress(char* FunName);

/*==============================================================================*/
/*                                  判断UNICODE_STRING                          */
/*==============================================================================*/
BOOLEAN IsUnicodeString(
	IN PUNICODE_STRING us);


/*==============================================================================*/
/*                                    延时                                     
/*==============================================================================*/

void Sleep(
	LONG msec);
/*==============================================================================*/
/*                                    获取系统启动毫秒数                       
/*==============================================================================*/

ULONG GetSystemStartTime();

/*==============================================================================*/
/*                                    设置线程模式                            
/*==============================================================================*/
UINT8  SetCurrentThreadMode(
	IN PETHREAD EThread,
	IN UINT8 NewMode);
/*==============================================================================*/
/*                                DOS路径转换NT路径                             */
/*==============================================================================*/
NTSTATUS DosFileNameToNtFileName(
	IN PUNICODE_STRING ustrDosName,
	OUT PUNICODE_STRING ustrDeviceName);
/*==============================================================================*/
/*                                NT路径转换DOS路径                             */
/*==============================================================================*/
BOOLEAN NtFileNameToDosFileName(
	IN PUNICODE_STRING us, 
	OUT WCHAR* ws);







































```

`HyperHideDrv/CKernelDbg.cpp`:

```cpp
#include"Log.h"
#include "CKernelDbg.h"
#include "KernelDbgStruct.h"
#include "dbgk1to2.h"

FAST_MUTEX g_DbgkpProcessDebugPortMutex;
extern "C"  POBJECT_TYPE * g_DbgkDebugObjectType;

POBJECT_TYPE_S g_DbgkDebugObjectType_1 = 0;
PULONG PspNotifyEnableMask;
PVOID* PspSystemDlls;
SYMBOLS_DATA g_SymbolsData;

#define PROCESS_HOOKPORT_OFFSET 0x170
#define PROCESS_PORT_OFFSET 0x1F0
//函数指针
typedef VOID(*PSCALLIMAGENOTIFYROUTINES)(
	IN PUNICODE_STRING ImageName,
	IN HANDLE ProcessId,
	OUT PIMAGE_INFO_EX ImageInfoEx,
	IN PVOID FileObject); PSCALLIMAGENOTIFYROUTINES PsCallImageNotifyRoutines = 0;

typedef PVOID(*OBFASTREFERENCEOBJECTLOCKED)(
	IN PEX_FAST_REF FastRef); OBFASTREFERENCEOBJECTLOCKED ObFastReferenceObjectLocked = 0;
typedef PVOID(*OBFASTREFERENCEOBJECT)(
	IN PEX_FAST_REF FastRef); OBFASTREFERENCEOBJECT ObFastReferenceObject = 0;

typedef VOID(*OBFASTDEREFERENCEOBJECT)(
	IN PEX_FAST_REF FastRef,
	IN PVOID Object); OBFASTDEREFERENCEOBJECT ObFastDereferenceObject = 0;
typedef NTSTATUS(*DBGKPSENDAPIMESSAGELPC)(
	IN OUT PDBGKM_APIMSG ApiMsg,
	IN PVOID Port,
	IN BOOLEAN SuspendProcess); DBGKPSENDAPIMESSAGELPC  DbgkpSendApiMessageLpc = 0;
typedef NTSTATUS(*DBGKPSENDERRORMESSAGE)(
	IN PEXCEPTION_RECORD ExceptionRecord,
	IN ULONG Falge,
	IN PDBGKM_APIMSG	DbgApiMsg); DBGKPSENDERRORMESSAGE DbgkpSendErrorMessage = 0;


typedef NTSTATUS(*KERESUMETHREAD)(
	__inout PETHREAD Thread); KERESUMETHREAD KeResumeThread = 0;


//typedef	NTSTATUS(*DBGKPPOSTMODULEMESSAGES)(
//	IN PEPROCESS Process,
//	IN PETHREAD Thread,
//	IN PVOID DebugObject); DBGKPPOSTMODULEMESSAGES DbgkpPostModuleMessages = 0;


typedef NTSTATUS(*OBDUPLICATEOBJECT)(
	IN PEPROCESS SourceProcess,
	IN HANDLE SourceHandle,
	IN PEPROCESS TargetProcess OPTIONAL,
	OUT PHANDLE TargetHandle OPTIONAL,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	IN ULONG Options,
	IN KPROCESSOR_MODE PreviousMode);
//OBDUPLICATEOBJECT ObDuplicateObject = 0;

//typedef NTSTATUS(*PSSUSPENDTHREAD)(
//	IN PETHREAD Thread,
//	OUT PULONG PreviousSuspendCount OPTIONAL); PSSUSPENDTHREAD PsSuspendThread = 0;


typedef VOID(*KEFREEZEALLTHREADS)(
	VOID
	); KEFREEZEALLTHREADS KeFreezeAllThreads = 0;
typedef VOID(*KETHAWALLTHREADS)(
	VOID
	); KETHAWALLTHREADS KeThawAllThreads = 0;
typedef void (*KICHECKFORKERNELAPCDELIVERY)(); KICHECKFORKERNELAPCDELIVERY KiCheckForKernelApcDelivery = 0;
typedef NTSTATUS(*ZWFLUSHINSTRUCTIONCACHE)(
	__in HANDLE ProcessHandle,
	__in_opt PVOID BaseAddress,
	__in SIZE_T Length
	); ZWFLUSHINSTRUCTIONCACHE ZwFlushInstructionCache = 0;

//函数实现
BOOLEAN HookDbgkDebugObjectType()
{
	//如果是不以原始DbgkDebugObjectType指针来操作，以启动方式时则需要替换PspInsertProcess中的DbgkDebugObjectType
	UNICODE_STRING ObjectTypeName;
	//获取原始DbgkDebugObjectType
	CKernelTable Ssdt;
	PVOID NtCreateDebugObject = Ssdt.GetAddressFromName("NtCreateDebugObject");

	if (!NtCreateDebugObject)
	{
		return FALSE;
	}

	ULONG templong = 0;
	UCHAR tzm[] = { 0x48, 0x8B, 0x15, 0xEC, 0x85, 0x47, 0x00 };

	ULONG64 addr = 0;

	for (PUCHAR i = (PUCHAR)NtCreateDebugObject; i < (PUCHAR)NtCreateDebugObject + 0x100; i++)
	{
		if (*i == 0x48 && *(i + 1) == 0x8B &&
			*(i + 2) == 0x15
			)
		{
			memcpy(&templong, i + 3, 4);
			addr = (ULONG64)((ULONG)templong + (ULONG64)i + 7);
			break;
		}
	}

	g_DbgkDebugObjectType = (POBJECT_TYPE*)addr;
	if (g_DbgkDebugObjectType == 0)
	{
		return FALSE;
	}
	DbgPrint("g_DbgkDebugObjectType:%p\n", g_DbgkDebugObjectType);
	RtlInitUnicodeString(&ObjectTypeName, L"styone");

	OBJECT_TYPE_INITIALIZER_WIN10 ObjectTypeInitializer;
	POBJECT_TYPE* DbgkDebugObjectType = g_DbgkDebugObjectType;

	//参数构造
	//memcpy(&ObjectTypeInitializer, &DbgkDebugObjectType->TypeInfo, sizeof(ObjectTypeInitializer));
	memcpy(&ObjectTypeInitializer, &(*DbgkDebugObjectType)->TypeInfo, sizeof(OBJECT_TYPE_INITIALIZER_WIN10));

	//这里恢复调试权限
	//ObjectTypeInitializer.DeleteProcedure = &DbgkpDeleteObject;
	//ObjectTypeInitializer.CloseProcedure = &DbgkpCloseObject;
	//ObjectTypeInitializer.DeleteProcedure = &proxyDbgkpDeleteObject;
	//ObjectTypeInitializer.CloseProcedure = &proxyDbgkpCloseObject;
	ObjectTypeInitializer.DeleteProcedure = NULL;
	ObjectTypeInitializer.CloseProcedure = NULL;
	ObjectTypeInitializer.GenericMapping.GenericRead = 0x00020001;
	ObjectTypeInitializer.GenericMapping.GenericWrite = 0x00020002;
	ObjectTypeInitializer.GenericMapping.GenericExecute = 0x00120000;
	ObjectTypeInitializer.GenericMapping.GenericAll = 0x001f000f;
	ObjectTypeInitializer.ValidAccessMask = 0x001f000f;

	//创建调试对象类型
	NTSTATUS status = ObCreateObjectType(&ObjectTypeName, &ObjectTypeInitializer, NULL, (PVOID*)g_DbgkDebugObjectType);
	//return FALSE;
	if (!NT_SUCCESS(status))
	{
		if (status == STATUS_OBJECT_NAME_COLLISION)
		{
			DbgPrint("ObCreateObjectType STATUS_OBJECT_NAME_COLLISION\n");
			//对象名已经存在
			PUCHAR j_ObGetObjectType = (PUCHAR)GetKernelAddress("ObGetObjectType");

			if (!j_ObGetObjectType)
			{
				DbgPrint("ObGetObjectType failed\n");
				return FALSE;
			}
			//ULONG uloffset = (ULONG)(*(PUINT32)(j_ObGetObjectType + 31));
			//DbgPrint("uloffset:%x\n", uloffset);
			//ULONG64 baseAddr = (ULONG64)j_ObGetObjectType + 35;
			//DbgPrint("baseAddr:%p\n", baseAddr);
			//POBJECT_TYPE* ObTypeIndexTable = (POBJECT_TYPE*)(baseAddr + uloffset);
			POBJECT_TYPE* ObTypeIndexTable = (POBJECT_TYPE*)(*(PUINT32)(j_ObGetObjectType + 31) + (ULONG64)j_ObGetObjectType + 35);
			if (!ObTypeIndexTable)
			{
				DbgPrint("ObGetObjectType get failed\n");
				return FALSE;
			}
			DbgPrint("ObTypeIndexTable:%p\n", ObTypeIndexTable);
			//DbgPrint("sizeof(_OBJECT_TYPE):%x\n", sizeof(_OBJECT_TYPE));
			DbgPrint("ObTypeIndexTable[2]:%p\n", ObTypeIndexTable[2]);

			ULONG Index = 2;
			while (ObTypeIndexTable[Index])
			{
				DbgPrint("ObTypeIndexTable[Index]:%p\n", ObTypeIndexTable[Index]);
				if (&ObTypeIndexTable[Index]->Name)
				{
					if (ObTypeIndexTable[Index]->Name.Buffer)
					{
						DbgPrint("RtlCompareUnicodeString:%ws %ws\n", ObTypeIndexTable[Index]->Name.Buffer, ObjectTypeName.Buffer);
						if (RtlCompareUnicodeString(&ObTypeIndexTable[Index]->Name, &ObjectTypeName, FALSE) == 0)
						{
							*g_DbgkDebugObjectType = ObTypeIndexTable[Index];
							DbgPrint("ObCreateObjectType already exist *g_DbgkDebugObjectType:%p\n", *g_DbgkDebugObjectType);
							return TRUE;
						}
					}
				}

				Index++;
			}
		}
		else
		{
			DbgPrint("ObCreateObjectType eeor!\n");
			return FALSE;
		}
	}
	DbgPrint("ObCreateObjectType ok g_DbgkDebugObjectType:%p\n", g_DbgkDebugObjectType);
	return TRUE;
}

NTSTATUS(*OriginalDbgkpQueueMessage)(
	IN PEPROCESS_S Process,
	IN  PETHREAD_S Thread,
	IN OUT PDBGKM_APIMSG ApiMsg,
	IN ULONG Flags,
	IN PDEBUG_OBJECT TargetDebugObject);
NTSTATUS DbgkpQueueMessage(
	IN PEPROCESS_S Process,
	IN  PETHREAD_S Thread,
	IN OUT PDBGKM_APIMSG ApiMsg,
	IN ULONG Flags,
	IN PDEBUG_OBJECT TargetDebugObject)
{

	// DbgPrint("DbgkpQueueMessage !\n");

	PDEBUG_EVENT DebugEvent;
	DEBUG_EVENT StaticDebugEvent;
	PDEBUG_OBJECT DebugObject;
	NTSTATUS Status;

	if (Flags & 2)
	{
		DebugEvent = (PDEBUG_EVENT)ExAllocatePoolWithQuotaTag((POOL_TYPE)(NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE), sizeof(DEBUG_EVENT), 'EgbD');//sizeof (DEBUG_EVENT)=0x168
		if (!DebugEvent)
		{
			return  STATUS_INSUFFICIENT_RESOURCES;
		}

		DebugEvent->Flags = Flags | 4;//offset: 0x13
		ObReferenceObject(Thread);
		ObReferenceObject(Process);
		DebugObject = TargetDebugObject;
		DebugEvent->BackoutThread = PsGetCurrentThread();

	}
	else
	{
		DebugEvent = &StaticDebugEvent;
		DebugEvent->Flags = Flags;


		ExAcquireFastMutex(&g_DbgkpProcessDebugPortMutex);

		DebugObject = (PDEBUG_OBJECT)Process->DebugPort;

		if (ApiMsg->ApiNumber == DbgKmCreateThreadApi ||
			ApiMsg->ApiNumber == DbgKmCreateProcessApi) {
			if (*(PULONG)((PUCHAR)Thread + 0x448) & 0x80) {
				DebugObject = NULL;
			}
		}

		//这里Flags&0x40为真可能是表示跳过LoadDll的消息
		if (ApiMsg->ApiNumber == DbgKmLoadDllApi &&
			*(PULONG)((PUCHAR)Thread + 0x448) & 0x80 &&
			Flags & 0x40) {
			DebugObject = NULL;
		}

		//跳过线程或者进程退出的消息
		if (ApiMsg->ApiNumber == DbgKmExitThreadApi ||
			ApiMsg->ApiNumber == DbgKmExitProcessApi) {
			if (*(PULONG)((PUCHAR)Thread + 0x448) & 0x100) {
				DebugObject = NULL;
			}
		}
		KeInitializeEvent(&DebugEvent->ContinueEvent, SynchronizationEvent, FALSE);
	}

	DebugEvent->Process = Process;
	DebugEvent->Thread = Thread;
	DebugEvent->ApiMsg = *ApiMsg;
	DebugEvent->ClientId = Thread->Cid;

	if (DebugObject == NULL)
	{
		Status = STATUS_PORT_NOT_SET;
	}
	else
	{
		ExAcquireFastMutex(&DebugObject->Mutex);



		if ((DebugObject->Flags & 0x1) == 0) {
			InsertTailList(&DebugObject->EventList, &DebugEvent->EventList);

			if ((Flags & 0x2) == 0) {
				KeSetEvent(&DebugObject->EventsPresent, 0, FALSE);
			}
			Status = STATUS_SUCCESS;
		}
		else
		{
			Status = STATUS_DEBUGGER_INACTIVE;
		}

		ExReleaseFastMutex(&DebugObject->Mutex);
	}

	if ((Flags & 0x2) == 0) {
		//这时候释放消息同步，因为这个等待需要耗时，所以我们要在KeWaitForSingleObject函数前调用它
		//而且消息已经顺利的插入调试对象了，所以不存在不安去的因素了
		ExReleaseFastMutex(&g_DbgkpProcessDebugPortMutex);

		if (NT_SUCCESS(Status)) {
			KeWaitForSingleObject(
				&DebugEvent->ContinueEvent,
				Executive,
				KernelMode,
				FALSE,
				NULL);

			//消息完成的话，这里放入了消息完成的状态值，并且作为返回值使用
			Status = DebugEvent->Status;
			//ApiMsg是输出参数
			*ApiMsg = DebugEvent->ApiMsg;
		}
	}
	else {
		if (!NT_SUCCESS(Status)) {
			ObfDereferenceObject(Process);
			ObfDereferenceObject(Thread);
			ExFreePool(DebugEvent);
		}
	}

	return Status;
}

PVOID PsCaptureExceptionPort(
	IN PEPROCESS_S Process)
{
	PKTHREAD_S	Thread;
	PVOID		ExceptionPort;

	ExceptionPort = Process->ExceptionPortData;
	if (ExceptionPort != NULL)
	{
		KeEnterCriticalRegion();
		ExfAcquirePushLockShared((ULONG_PTR)&Process->ProcessLock);
		ExceptionPort = (PVOID)((ULONG_PTR)ExceptionPort & ~0x7);
		ObfReferenceObject(ExceptionPort);
		ExfReleasePushLockShared((ULONG_PTR)&Process->ProcessLock);
		KeLeaveCriticalRegion();
		//这段可能有问题
		PKTHREAD_S CurrentThread = (PKTHREAD_S)KeGetCurrentThread();
		//判断APC链表是否为空
		if (&CurrentThread->ApcState.ApcListHead[0] != CurrentThread->ApcState.ApcListHead[0].Flink)
		{
			//判断APC是否禁用
			if (CurrentThread->SpecialApcDisable != 0)
			{
				//大概看了下是分发APC
				KiCheckForKernelApcDelivery();
			}
		}
	}

	return ExceptionPort;
}

BOOLEAN myDbgkpSuspendProcess(
	VOID
) {
	if ((((PEPROCESS_S)PsGetCurrentProcess())->Flags & 0x8) == 0)
	{
		KeFreezeAllThreads();
		return TRUE;
	}
	return FALSE;
}

NTSTATUS DbgkpSendApiMessage(
	ULONG	Flag,
	PDBGKM_APIMSG ApiMsg) {
	NTSTATUS status;
	BOOLEAN	bIsSuspend;
	PEPROCESS_S	Process = (PEPROCESS_S)PsGetCurrentProcess();
	PETHREAD_S	Thread;

	bIsSuspend = FALSE;

	if (Flag & 0x1)
	{
		bIsSuspend = DbgkpSuspendProcess(Process);
	}

	Thread = (PETHREAD_S)PsGetCurrentThread();
	Process = (PEPROCESS_S)PsGetCurrentProcess();

	ApiMsg->ReturnedStatus = STATUS_PENDING;
	status = DbgkpQueueMessage(
		Process,
		Thread,
		ApiMsg,
		((Flag & 0x2) << 0x5),
		NULL);

	ZwFlushInstructionCache(NtCurrentProcess(), 0, 0);
	if (bIsSuspend)
	{
		KeThawAllThreads();
	}

	return status;
}

//PVOID PsQuerySystemDllInfo(
//	ULONG index)			//这里的index不会大于1
//{
//	PVOID	DllInfo;
//
//	DllInfo = (PVOID)PspSystemDlls[index];	//[DllInfo+0x14]是模块的基地址
//	if (DllInfo != NULL &&
//		*(PVOID*)((char*)DllInfo + 0x28) != 0)
//	{
//		return (PVOID)((ULONG_PTR)DllInfo + 0x10);
//	}
//
//	return NULL;
//}

VOID myDbgkSendSystemDllMessages(
	PETHREAD_S		Thread,
	PDEBUG_OBJECT	DebugObject,
	PDBGKM_APIMSG	ApiMsg
)
{

	NTSTATUS	status;
	HANDLE		FileHandle;
	ULONG		index;
	PTEB		Teb;
	PEPROCESS_S	Process;
	PETHREAD_S	CurrentThread;
	PMODULE_INFO	DllInfo;
	BOOLEAN		bSource;
	KAPC_STATE ApcState;
	PIMAGE_NT_HEADERS NtHeaders;

	IO_STATUS_BLOCK	IoStackBlock;
	OBJECT_ATTRIBUTES	ObjectAttr;

	if (Thread)
	{
		Process = (PEPROCESS_S)Thread->Tcb.Process;
	}
	else {
		Process = (PEPROCESS_S)PsGetCurrentProcess();
	}
	CurrentThread = (PETHREAD_S)PsGetCurrentThread();
	index = 0;
	do
	{
		if (index >= 2)
		{
			break;
		}
		DllInfo = (PMODULE_INFO)PsQuerySystemDllInfo(index);
		if (DllInfo != NULL)
		{
			if (index == 1 && Process->WoW64Process == 0)
			{
				break;
			}

			ApiMsg->u.LoadDll = { 0 };
			Teb = NULL;

			ApiMsg->u.LoadDll.BaseOfDll = DllInfo->BaseOfDll;

			if (Thread && index != 0)
			{
				bSource = TRUE;
				KeStackAttachProcess((PRKPROCESS)Process, &ApcState);
			}
			else
			{
				bSource = FALSE;
			}

			NtHeaders = RtlImageNtHeader(DllInfo->BaseOfDll);
			if (NtHeaders != NULL)
			{
				ApiMsg->u.LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
				ApiMsg->u.LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
			}

			if (Thread == 0)
			{

				if (CurrentThread->Tcb.SystemThread != TRUE &&
					CurrentThread->Tcb.ApcStateIndex != 1)
				{
					Teb = (PTEB)CurrentThread->Tcb.Teb;
				}

				if (Teb)
				{
					RtlStringCbCopyW(Teb->StaticUnicodeBuffer, 261 * sizeof(wchar_t), DllInfo->Buffer);
					Teb->NtTib.ArbitraryUserPointer = Teb->StaticUnicodeBuffer;
					ApiMsg->u.LoadDll.NamePointer = (PVOID)&Teb->NtTib.ArbitraryUserPointer;
				}
			}

			if (bSource == TRUE)
			{
				KeUnstackDetachProcess(&ApcState);
			}

			InitializeObjectAttributes(
				&ObjectAttr,
				&DllInfo->FileName,
				OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
				NULL,
				NULL);

			status = ZwOpenFile(
				&FileHandle,
				GENERIC_READ | SYNCHRONIZE,
				&ObjectAttr,
				&IoStackBlock,
				FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
				FILE_SYNCHRONOUS_IO_NONALERT);
			if (!NT_SUCCESS(status))
			{
				FileHandle = NULL;
			}
			ApiMsg->h.u1.Length = 0x500028;
			ApiMsg->h.u2.ZeroInit = 8;
			ApiMsg->ApiNumber = DbgKmLoadDllApi;
			if (Thread == NULL)
			{
				DbgkpSendApiMessage(0x3, ApiMsg);
				if (FileHandle != NULL)
				{
					ObCloseHandle(FileHandle, KernelMode);
				}
				if (Teb != NULL)
				{
					Teb->NtTib.ArbitraryUserPointer = NULL;

				}
			}
			else {
				status = DbgkpQueueMessage(
					Process,
					Thread,
					ApiMsg,
					0x2,
					DebugObject);
				if (!NT_SUCCESS(status))
				{
					if (FileHandle != NULL)
					{
						ObCloseHandle(FileHandle, KernelMode);
					}
				}
			}
		}
		index++;
	} while (TRUE);
}


EX_PUSH_LOCK MiChangeControlAreaFileLock;
PFILE_OBJECT MiReferenceControlAreaFile(
	PCONTROL_AREA CtrlArea)
{

	PKTHREAD_S	CurrentThread;
	PFILE_OBJECT FileObject;

	CurrentThread = (PKTHREAD_S)PsGetCurrentThread();
	KeEnterCriticalRegion();

	ExfAcquirePushLockShared((ULONG_PTR)&MiChangeControlAreaFileLock);

	//((PETHREAD_S)CurrentThread)->OwnsChangeControlAreaShared = TRUE;
	FileObject = (PFILE_OBJECT)ObFastReferenceObjectLocked(&CtrlArea->FilePointer);
	//((PETHREAD_S)CurrentThread)->OwnsChangeControlAreaShared = FALSE;

	ExfReleasePushLockShared((ULONG_PTR)&MiChangeControlAreaFileLock);

	KeLeaveCriticalRegion();

	return FileObject;
}
NTSTATUS myMmGetFileNameForSection(
	IN PSEGMENT_OBJECT SectionObject,
	OUT POBJECT_NAME_INFORMATION* FileNameInfo
)
{

	ULONG NumberOfBytes;
	ULONG AdditionalLengthNeeded;
	NTSTATUS Status;
	PFILE_OBJECT FileObject;

	NumberOfBytes = 1024;

	*FileNameInfo = NULL;



	if ((((ULONG_PTR)SectionObject->MmSubSectionFlags) & 0x20) == FALSE)
	{
		return STATUS_SECTION_NOT_IMAGE;
	}

	*FileNameInfo = (POBJECT_NAME_INFORMATION)ExAllocatePoolWithTag(PagedPool, NumberOfBytes, '  mM');

	if (*FileNameInfo == NULL) {
		return STATUS_NO_MEMORY;
	}

	FileObject = (PFILE_OBJECT)ObFastReferenceObject(&SectionObject->Subsection->ControlArea->FilePointer);
	if (FileObject == 0)
	{
		FileObject = MiReferenceControlAreaFile(SectionObject->Subsection->ControlArea);
	}


	Status = ObQueryNameString(FileObject,
		*FileNameInfo,
		NumberOfBytes,
		&AdditionalLengthNeeded);

	if (!NT_SUCCESS(Status)) {

		if (Status == STATUS_INFO_LENGTH_MISMATCH) {

			//
			// Our buffer was not large enough, retry just once with a larger
			// one (as specified by ObQuery).  Don't try more than once to
			// prevent broken parse procedures which give back wrong
			// AdditionalLengthNeeded values from causing problems.
			//

			ExFreePool(*FileNameInfo);

			NumberOfBytes += AdditionalLengthNeeded;

			*FileNameInfo = (POBJECT_NAME_INFORMATION)ExAllocatePoolWithTag(PagedPool,
				NumberOfBytes,
				'  mM');

			if (*FileNameInfo == NULL)
			{
				ObDereferenceObjectDeferDelete(FileObject);
				return STATUS_NO_MEMORY;
			}

			Status = ObQueryNameString(FileObject,
				*FileNameInfo,
				NumberOfBytes,
				&AdditionalLengthNeeded);

			if (NT_SUCCESS(Status))
			{
				ObDereferenceObjectDeferDelete(FileObject);
				return STATUS_SUCCESS;
			}
		}

		ObDereferenceObjectDeferDelete(FileObject);
		ExFreePool(*FileNameInfo);
		*FileNameInfo = NULL;
		return Status;
	}
	ObDereferenceObjectDeferDelete(FileObject);
	return STATUS_SUCCESS;
}
HANDLE DbgkpSectionToFileHandle(
	IN PVOID SectionObject) {
	NTSTATUS Status;
	OBJECT_ATTRIBUTES Obja;
	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE Handle;
	POBJECT_NAME_INFORMATION FileNameInfo;

	Status = MmGetFileNameForSection((PSEGMENT_OBJECT)SectionObject, &FileNameInfo);
	if (!NT_SUCCESS(Status)) {
		return NULL;
	}

	InitializeObjectAttributes(
		&Obja,
		&FileNameInfo->Name,
		OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
		NULL,
		NULL
	);

	Status = ZwOpenFile(
		&Handle,
		(ACCESS_MASK)(GENERIC_READ | SYNCHRONIZE),
		&Obja,
		&IoStatusBlock,
		FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
		FILE_SYNCHRONOUS_IO_NONALERT
	);
	ExFreePool(FileNameInfo);
	if (!NT_SUCCESS(Status)) {
		return NULL;
	}
	else {
		return Handle;
	}
}

//NTSTATUS myDbgkpPostFakeThreadMessages(
//	PEPROCESS_S	Process,
//	PDEBUG_OBJECT	DebugObject,
//	PETHREAD_S	StartThread,
//	PETHREAD_S* pFirstThread,
//	PETHREAD_S* pLastThread)
//{
//
//	NTSTATUS status;
//	PETHREAD_S Thread, FirstThread, LastThread, CurrentThread;
//	DBGKM_APIMSG ApiMsg;
//	BOOLEAN First = TRUE;
//	BOOLEAN IsFirstThread;
//	PIMAGE_NT_HEADERS NtHeaders;
//	ULONG Flags;
//	KAPC_STATE ApcState;
//
//	status = STATUS_UNSUCCESSFUL;
//
//	LastThread = FirstThread = NULL;
//
//	CurrentThread = (PETHREAD_S)PsGetCurrentThread();
//
//	if (StartThread == 0)
//	{
//		StartThread = (PETHREAD_S)PsGetNextProcessThread((PEPROCESS)Process, 0);
//		First = TRUE;
//	}
//	else {
//		First = FALSE;
//		FirstThread = StartThread;
//		ObReferenceObject(StartThread);
//	}
//
//	for (Thread = StartThread;
//		Thread != NULL;
//		Thread = (PETHREAD_S)PsGetNextProcessThread((PEPROCESS)Process, (PETHREAD)Thread))
//	{
//
//		Flags = 0x2;
//
//		if (LastThread != 0)
//		{
//			ObDereferenceObject(LastThread);
//		}
//
//		LastThread = Thread;
//		ObReferenceObject(LastThread);
//		if (Thread->Tcb.SystemThread != 0)
//		{
//			continue;
//		}
//
//
//		if (Thread->ThreadInserted == 0)//这里要注意下位操作
//		{
//			//这个涉及的内容也比较多，而且一般也不会进入这里，所以为了简单注释掉好了
//			//PsSynchronizeWithThreadInsertion(Thread,CurrentThread);
//			if (Thread->ThreadInserted == 0)
//			{
//				continue;
//			}
//		}
//
//		if (ExAcquireRundownProtection(&Thread->RundownProtect))
//		{
//			Flags |= 0x8;
//			status = PsSuspendThread((PETHREAD)Thread, 0);
//			if (NT_SUCCESS(status))
//			{
//				Flags |= 0x20;
//			}
//		}
//		else {
//			Flags |= 0x10;
//		}
//
//		//每次构造一个DBGKM_APIMSG结构
//		memset(&ApiMsg, 0, sizeof(DBGKM_APIMSG));
//
//		if (First && (Flags & 0x10) == 0)
//		{
//			//进程的第一个线程才会到这里
//			IsFirstThread = TRUE;
//			ApiMsg.ApiNumber = DbgKmCreateProcessApi;
//			if (Process->SectionObject)
//			{
//				//DbgkpSectionToFileHandle函数是返回一个模块的句柄
//				ApiMsg.u.CreateProcessInfo.FileHandle = DbgkpSectionToFileHandle(Process->SectionObject);
//			}
//			else {
//				ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
//			}
//			ApiMsg.u.CreateProcessInfo.BaseOfImage = Process->SectionBaseAddress;
//
//			KeStackAttachProcess((PRKPROCESS)Process, &ApcState);
//
//			__try {
//				NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
//				if (NtHeaders)
//				{
//					ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress = NULL;
//					ApiMsg.u.CreateProcessInfo.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
//					ApiMsg.u.CreateProcessInfo.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
//				}
//			}_except(EXCEPTION_EXECUTE_HANDLER) {
//				ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress = NULL;
//				ApiMsg.u.CreateProcessInfo.DebugInfoFileOffset = 0;
//				ApiMsg.u.CreateProcessInfo.DebugInfoSize = 0;
//			}
//
//			KeUnstackDetachProcess(&ApcState);
//		}
//		else {
//			IsFirstThread = FALSE;
//			ApiMsg.ApiNumber = DbgKmCreateThreadApi;
//			ApiMsg.u.CreateThread.StartAddress = Thread->StartAddress;//注意偏移
//		}
//
//		status = DbgkpQueueMessage(
//			Process,
//			Thread,
//			&ApiMsg,
//			Flags,
//			DebugObject);
//
//		if (!NT_SUCCESS(status))
//		{
//			if (Flags & 0x20)
//			{
//				KeResumeThread((PETHREAD)Thread);
//			}
//
//			if (Flags & 0x08)
//			{
//				ExReleaseRundownProtection(&Thread->RundownProtect);
//			}
//
//			if (ApiMsg.ApiNumber == DbgKmCreateProcessApi && ApiMsg.u.CreateProcessInfo.FileHandle != NULL)
//			{
//				ObCloseHandle(ApiMsg.u.CreateProcessInfo.FileHandle, KernelMode);
//			}
//
//			ObDereferenceObject(Thread);
//			break;
//
//		}
//		else if (IsFirstThread) {
//			First = FALSE;
//			ObReferenceObject(Thread);
//			FirstThread = Thread;
//
//			DbgkSendSystemDllMessages(Thread, DebugObject, &ApiMsg);
//		}
//	}
//
//	if (!NT_SUCCESS(status)) {
//		if (FirstThread)
//		{
//			ObDereferenceObject(FirstThread);
//		}
//		if (LastThread != NULL)
//		{
//			ObDereferenceObject(LastThread);
//		}
//	}
//	else {
//		if (FirstThread) {
//			*pFirstThread = FirstThread;
//			*pLastThread = LastThread;
//		}
//		else {
//
//			if (LastThread != NULL)
//			{
//				ObDereferenceObject(LastThread);
//			}
//			status = STATUS_UNSUCCESSFUL;
//		}
//	}
//	return status;
//}

//NTSTATUS DbgkpPostFakeProcessCreateMessages(
//	IN PEPROCESS_S Process,
//	IN PDEBUG_OBJECT DebugObject,
//	IN PETHREAD_S* pLastThread)
//{
//
//	NTSTATUS	status;
//	KAPC_STATE	ApcState;
//	PETHREAD_S	StartThread, Thread;
//	PETHREAD_S	LastThread = 0;
//
//	//收集所有线程创建的消息
//	StartThread = 0;
//	//_DbgkpPostFakeThreadMessages DbgkpPostFakeThreadMessages = (_DbgkpPostFakeThreadMessages)0xfffff8000432b360;
//	status = DbgkpPostFakeThreadMessages(Process, DebugObject, StartThread, &Thread, &LastThread);
//
//	if (NT_SUCCESS(status))
//	{
//		KeStackAttachProcess((PRKPROCESS)Process, &ApcState);
//
//		//收集模块创建的消息
//
//
//		DbgkpPostModuleMessages((PEPROCESS)Process, (PETHREAD)Thread, DebugObject);
//
//		KeUnstackDetachProcess(&ApcState);
//
//		ObDereferenceObject(Thread);
//	}
//	else {
//		LastThread = 0;
//	}
//
//	*pLastThread = LastThread;
//	return	status;
//}

VOID DbgkpFreeDebugEvent(
	IN PDEBUG_EVENT DebugEvent)
{
	NTSTATUS Status;

	switch (DebugEvent->ApiMsg.ApiNumber) {
	case DbgKmCreateProcessApi:
		if (DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle != NULL) {
			Status = ObCloseHandle(DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle, KernelMode);
		}
		break;

	case DbgKmLoadDllApi:
		if (DebugEvent->ApiMsg.u.LoadDll.FileHandle != NULL) {
			Status = ObCloseHandle(DebugEvent->ApiMsg.u.LoadDll.FileHandle, KernelMode);
		}
		break;

	}
	ObfDereferenceObject(DebugEvent->Process);
	ObfDereferenceObject(DebugEvent->Thread);
	ExFreePoolWithTag(DebugEvent, 0);
}

VOID DbgkpWakeTarget(
	IN PDEBUG_EVENT DebugEvent)
{
	PETHREAD_S Thread;

	Thread = DebugEvent->Thread;

	if ((DebugEvent->Flags & 0x20) != 0) {
		KeResumeThread((PETHREAD)DebugEvent->Thread);
	}

	if (DebugEvent->Flags & 0x8) {
		ExReleaseRundownProtection(&Thread->RundownProtect);
	}

	if ((DebugEvent->Flags & 0x2) == 0) {
		KeSetEvent(&DebugEvent->ContinueEvent, 0, FALSE);
	}
	else {
		DbgkpFreeDebugEvent(DebugEvent);
	}
}

/**/
VOID DbgkpMarkProcessPeb(PEPROCESS_S Process)
{
	KAPC_STATE ApcState;

	if (ExAcquireRundownProtection(&Process->RundownProtect)) {

		if (Process->Peb != NULL) {
			KeStackAttachProcess((PRKPROCESS)&Process->Pcb, &ApcState);

			ExAcquireFastMutex(&g_DbgkpProcessDebugPortMutex);

			_try{
				//Process->Peb->BeingDebugged = FALSE;
			(BOOLEAN)(Process->DebugPort != NULL ? TRUE : FALSE);
			} _except(EXCEPTION_EXECUTE_HANDLER) {
			}
			ExReleaseFastMutex(&g_DbgkpProcessDebugPortMutex);

			KeUnstackDetachProcess(&ApcState);
		}

		ExReleaseRundownProtection(&Process->RundownProtect);
	}
}

//NTSTATUS DbgkpSetProcessDebugObject(
//	IN PEPROCESS_S Process,
//	IN PDEBUG_OBJECT DebugObject,
//	IN NTSTATUS MsgStatus,
//	IN PETHREAD_S LastThread)
//{
//	NTSTATUS Status;
//	PETHREAD_S ThisThread;
//	LIST_ENTRY TempList;
//	PLIST_ENTRY Entry;
//	PDEBUG_EVENT DebugEvent;
//	BOOLEAN First;
//	PETHREAD_S Thread;
//	BOOLEAN GlobalHeld;
//	PETHREAD_S FirstThread;
//
//	PAGED_CODE();
//
//	ThisThread = (PETHREAD_S)PsGetCurrentThread();
//
//	//初始化链表，这个之后储存消息
//	InitializeListHead(&TempList);
//
//	First = TRUE;
//	GlobalHeld = FALSE;
//
//	if (!NT_SUCCESS(MsgStatus)) {
//		LastThread = NULL;
//		Status = MsgStatus;
//	}
//	else {
//		Status = STATUS_SUCCESS;
//	}
//
//
//	if (NT_SUCCESS(Status)) {
//
//		while (1) {
//
//			GlobalHeld = TRUE;
//
//			ExAcquireFastMutex(&g_DbgkpProcessDebugPortMutex);
//
//			//如果被调试进程的debugport已经设置，那么跳出循环
//			if (Process->DebugPort != NULL) {
//				Status = STATUS_PORT_ALREADY_SET;
//				break;
//			}
//
//			//没有设置debugport，在这里设置
//			Process->DebugPort = DebugObject;
//
//			//增加被调试进程最后一个线程的引用
//			ObfReferenceObject(LastThread);
//
//			//这里如果返回有值，说明在这之间还有线程被创建了，这里也要加入调试消息链表
//			Thread = (PETHREAD_S)PsGetNextProcessThread((PEPROCESS)Process, (PETHREAD)LastThread);
//			if (Thread != NULL) {
//
//				Process->DebugPort = NULL;
//
//				ExReleaseFastMutex(&g_DbgkpProcessDebugPortMutex);
//
//				GlobalHeld = FALSE;
//
//				ObfDereferenceObject(LastThread);
//				//通知线程创建消息
//				Status = DbgkpPostFakeThreadMessages(
//					Process,
//					DebugObject,
//					Thread,
//					&FirstThread,
//					&LastThread);
//				if (!NT_SUCCESS(Status)) {
//					LastThread = NULL;
//					break;
//				}
//				ObfDereferenceObject(FirstThread);
//			}
//			else {
//				break;
//			}
//		}
//	}
//
//	ExAcquireFastMutex(&DebugObject->Mutex);
//
//	if (NT_SUCCESS(Status)) {
//		//看看调试对象是否要求删除
//		if ((DebugObject->Flags & 0x1) == 0) {
//			RtlInterlockedSetBitsDiscardReturn(&Process->Flags, 0x2 | 0x1);
//			ObfReferenceObject(DebugObject);
//		}
//		else {
//			Process->DebugPort = NULL;
//			Status = STATUS_DEBUGGER_INACTIVE;
//		}
//	}
//
//	//通过上面的操作，调试对象的消息链表装满了线程创建的消息(同时也包含模块加载的消息)
//	//
//	for (Entry = DebugObject->EventList.Flink;
//		Entry != &DebugObject->EventList;
//		) {
//		//取出调试事件
//		DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);
//		Entry = Entry->Flink;
//
//		//看看调试事件是否急于处理，如果不是急于处理的，说明在DbgkpQueueMessage函数里面没有得到处理，
//		//那么我们就在这里想办法处理吧(急于处理的已经在DbgkpQueueMessage函数中处理过了，所以这里无需担心)。
//		//并且看看是否是本线程负责通知完成此消息
//		if ((DebugEvent->Flags & 0x4) != 0 && DebugEvent->BackoutThread == (PETHREAD)ThisThread) {
//			Thread = DebugEvent->Thread;
//
//			if (NT_SUCCESS(Status)) {
//				//这里判断之前对线程申请的停止保护是否失败
//				if ((DebugEvent->Flags & 0x10) != 0) {
//					RtlInterlockedSetBitsDiscardReturn(&Thread->CrossThreadFlags,
//						0x100);
//					RemoveEntryList(&DebugEvent->EventList);
//					InsertTailList(&TempList, &DebugEvent->EventList);
//				}
//				else {
//					//这里极有可能是判断是否主线程的创建消息，是主线程的话完成消息
//					if (First) {
//						DebugEvent->Flags &= ~0x4;
//						KeSetEvent(&DebugObject->EventsPresent, 0, FALSE);
//						First = FALSE;
//					}
//					//到这里设置跳过线程创建消息
//					DebugEvent->BackoutThread = NULL;
//					RtlInterlockedSetBitsDiscardReturn(&Thread->CrossThreadFlags,
//						0x80);
//
//				}
//			}
//			else {
//				//很移除消息，并且加入临时链表中
//				RemoveEntryList(&DebugEvent->EventList);
//				InsertTailList(&TempList, &DebugEvent->EventList);
//			}
//			//这里看看是够请求过线程停止保护，是的话释放请求
//			if (DebugEvent->Flags & 0x8) {
//				DebugEvent->Flags &= ~0x8;
//				ExReleaseRundownProtection(&Thread->RundownProtect);
//			}
//
//		}
//	}
//
//	ExReleaseFastMutex(&DebugObject->Mutex);
//
//	if (GlobalHeld) {
//		ExReleaseFastMutex(&g_DbgkpProcessDebugPortMutex);
//	}
//
//	if (LastThread != NULL) {
//		ObDereferenceObject(LastThread);
//	}
//
//	//这里读取临时链表，并且处理里面的每个消息
//	while (!IsListEmpty(&TempList)) {
//		Entry = RemoveHeadList(&TempList);
//		DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);
//		DbgkpWakeTarget(DebugEvent);
//	}
//
//	if (NT_SUCCESS(Status)) {
//		DbgkpMarkProcessPeb(Process);
//	}
//
//	return Status;
//}


NTSTATUS(*OriginalDbgkClearProcessDebugObject)(
	IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT SourceDebugObject);
NTSTATUS  DbgkClearProcessDebugObject(
	IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT SourceDebugObject) {
	NTSTATUS Status;
	PDEBUG_OBJECT DebugObject;
	PDEBUG_EVENT DebugEvent;
	LIST_ENTRY TempList;
	PLIST_ENTRY Entry;

	ExAcquireFastMutex(&g_DbgkpProcessDebugPortMutex);

	DebugObject = (PDEBUG_OBJECT)Process->DebugPort;
	if (DebugObject == NULL || (DebugObject != SourceDebugObject && SourceDebugObject != NULL)) {
		DebugObject = NULL;
		Status = STATUS_PORT_NOT_SET;
	}
	else {
		Process->DebugPort = NULL;
		Status = STATUS_SUCCESS;
	}
	ExReleaseFastMutex(&g_DbgkpProcessDebugPortMutex);

	if (NT_SUCCESS(Status)) {
		DbgkpMarkProcessPeb(Process);
	}

	if (DebugObject) {
		InitializeListHead(&TempList);

		ExAcquireFastMutex(&DebugObject->Mutex);
		for (Entry = DebugObject->EventList.Flink;
			Entry != &DebugObject->EventList;
			) {

			DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);
			Entry = Entry->Flink;
			if (DebugEvent->Process == Process) {
				RemoveEntryList(&DebugEvent->EventList);
				InsertTailList(&TempList, &DebugEvent->EventList);
			}
		}
		ExReleaseFastMutex(&DebugObject->Mutex);

		ObfDereferenceObject(DebugObject);

		while (!IsListEmpty(&TempList)) {
			Entry = RemoveHeadList(&TempList);
			DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);
			DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
			DbgkpWakeTarget(DebugEvent);
		}
	}

	return Status;
}
VOID DbgkpConvertKernelToUserStateChange(
	PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
	PDEBUG_EVENT DebugEvent)
{
	WaitStateChange->AppClientId = DebugEvent->ClientId;
	switch (DebugEvent->ApiMsg.ApiNumber) {
	case DbgKmExceptionApi:
		switch (DebugEvent->ApiMsg.u.Exception.ExceptionRecord.ExceptionCode) {
		case STATUS_BREAKPOINT:
			WaitStateChange->NewState = DbgBreakpointStateChange;
			break;

		case STATUS_SINGLE_STEP:
			WaitStateChange->NewState = DbgSingleStepStateChange;
			break;

		default:
			WaitStateChange->NewState = DbgExceptionStateChange;
			break;
		}
		WaitStateChange->StateInfo.Exception = DebugEvent->ApiMsg.u.Exception;
		break;

	case DbgKmCreateThreadApi:
		WaitStateChange->NewState = DbgCreateThreadStateChange;
		WaitStateChange->StateInfo.CreateThread.NewThread = DebugEvent->ApiMsg.u.CreateThread;
		break;

	case DbgKmCreateProcessApi:
		WaitStateChange->NewState = DbgCreateProcessStateChange;
		WaitStateChange->StateInfo.CreateProcessInfo.NewProcess = DebugEvent->ApiMsg.u.CreateProcessInfo;
		DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
		break;

	case DbgKmExitThreadApi:
		WaitStateChange->NewState = DbgExitThreadStateChange;
		WaitStateChange->StateInfo.ExitThread = DebugEvent->ApiMsg.u.ExitThread;
		break;

	case DbgKmExitProcessApi:
		WaitStateChange->NewState = DbgExitProcessStateChange;
		WaitStateChange->StateInfo.ExitProcess = DebugEvent->ApiMsg.u.ExitProcess;
		break;

	case DbgKmLoadDllApi:
		WaitStateChange->NewState = DbgLoadDllStateChange;
		WaitStateChange->StateInfo.LoadDll = DebugEvent->ApiMsg.u.LoadDll;
		DebugEvent->ApiMsg.u.LoadDll.FileHandle = NULL;
		break;

	case DbgKmUnloadDllApi:
		WaitStateChange->NewState = DbgUnloadDllStateChange;
		WaitStateChange->StateInfo.UnloadDll = DebugEvent->ApiMsg.u.UnloadDll;
		break;

	default:
		ASSERT(FALSE);
	}
}

VOID DbgkpOpenHandles(
	PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
	PEPROCESS_S Process,
	PETHREAD_S Thread)
{
	NTSTATUS Status;
	PEPROCESS_S CurrentProcess;
	HANDLE OldHandle;

	switch (WaitStateChange->NewState) {
	case DbgCreateThreadStateChange:
		Status = ObOpenObjectByPointer(Thread,
			0,
			NULL,
			THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | \
			THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION | THREAD_TERMINATE |
			READ_CONTROL | SYNCHRONIZE,
			*PsThreadType,
			KernelMode,
			&WaitStateChange->StateInfo.CreateThread.HandleToThread);
		if (!NT_SUCCESS(Status)) {
			WaitStateChange->StateInfo.CreateThread.HandleToThread = NULL;
		}
		break;

	case DbgCreateProcessStateChange:

		Status = ObOpenObjectByPointer(Thread,
			0,
			NULL,
			THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | \
			THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION | THREAD_TERMINATE |
			READ_CONTROL | SYNCHRONIZE,
			*PsThreadType,
			KernelMode,
			&WaitStateChange->StateInfo.CreateProcessInfo.HandleToThread);
		if (!NT_SUCCESS(Status)) {
			WaitStateChange->StateInfo.CreateProcessInfo.HandleToThread = NULL;
		}
		Status = ObOpenObjectByPointer(Process,
			0,
			NULL,
			PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION |
			PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION |
			PROCESS_CREATE_THREAD | PROCESS_TERMINATE |
			READ_CONTROL | SYNCHRONIZE,
			*PsProcessType,
			KernelMode,
			&WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess);
		if (!NT_SUCCESS(Status)) {
			WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess = NULL;
		}

		OldHandle = WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle;
		if (OldHandle != NULL) {
			CurrentProcess = (PEPROCESS_S)PsGetCurrentProcess();
			Status = ObDuplicateObject(CurrentProcess,
				OldHandle,
				CurrentProcess,
				&WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle,
				0,
				0,
				DUPLICATE_SAME_ACCESS,
				KernelMode);
			if (!NT_SUCCESS(Status)) {
				WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle = NULL;
			}
			ObCloseHandle(OldHandle, KernelMode);
		}
		break;

	case DbgLoadDllStateChange:

		OldHandle = WaitStateChange->StateInfo.LoadDll.FileHandle;
		if (OldHandle != NULL) {
			CurrentProcess = (PEPROCESS_S)PsGetCurrentProcess();
			Status = ObDuplicateObject(CurrentProcess,
				OldHandle,
				CurrentProcess,
				&WaitStateChange->StateInfo.LoadDll.FileHandle,
				0,
				0,
				DUPLICATE_SAME_ACCESS,
				KernelMode);
			if (!NT_SUCCESS(Status)) {
				WaitStateChange->StateInfo.LoadDll.FileHandle = NULL;
			}
			ObCloseHandle(OldHandle, KernelMode);
		}

		break;

	default:
		break;
	}
}

NTSTATUS(*OriginalNtCreateDebugObject)(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags);
NTSTATUS  NtCreateDebugObject(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags)
{
	NTSTATUS status;
	HANDLE Handle;
	PDEBUG_OBJECT DebugObject;
	KPROCESSOR_MODE	PreviousMode;

	PreviousMode = ExGetPreviousMode();

	//判断用户层句柄地址是否合法
	_try{
		if (PreviousMode != KernelMode) {
			ProbeForWrite(DebugObjectHandle,sizeof(HANDLE),sizeof(UCHAR));
		}
		*DebugObjectHandle = NULL;

	} _except(ExSystemExceptionFilter()) {
		return GetExceptionCode();
	}

	if (Flags & ~0x1) {
		return STATUS_INVALID_PARAMETER;
	}

	//创建调试对象
	status = ObCreateObject(
		PreviousMode,
		*g_DbgkDebugObjectType,
		ObjectAttributes,
		PreviousMode,
		NULL,
		sizeof(DEBUG_OBJECT),
		0,
		0,
		(PVOID*)&DebugObject);

	if (!NT_SUCCESS(status)) {
		return status;
	}
	//初始化调试对象
	ExInitializeFastMutex(&DebugObject->Mutex);
	InitializeListHead(&DebugObject->EventList);
	KeInitializeEvent(&DebugObject->EventsPresent, NotificationEvent, FALSE);

	if (Flags & 0x1) {
		DebugObject->Flags = 0x2;
	}
	else {
		DebugObject->Flags = 0;
	}

	//调试对象插入句柄表
	status = ObInsertObject(
		DebugObject,
		NULL,
		DesiredAccess,
		0,
		NULL,
		&Handle);
	if (!NT_SUCCESS(status)) {
		return status;
	}

	_try{
		*DebugObjectHandle = Handle;
	} _except(ExSystemExceptionFilter()) {
		status = GetExceptionCode();
	}

	return status;
}

NTSTATUS(*OriginalNtDebugActiveProcess)(
	HANDLE ProcessHandle,
	HANDLE DebugObjectHandle);
//NTSTATUS  NtDebugActiveProcess(
//	HANDLE ProcessHandle,
//	HANDLE DebugObjectHandle)
//{
//
//	NTSTATUS status;
//	KAPC_STATE	ApcState;
//	KPROCESSOR_MODE PreviousMode;
//	PDEBUG_OBJECT DebugObject;
//	PEPROCESS_S Process, CurrentProcess;
//	PETHREAD LastThread;
//	PreviousMode = ExGetPreviousMode();
//	//得到被调试进程的eprocess
//	status = ObReferenceObjectByHandle(
//		ProcessHandle,
//		0x800,
//		*PsProcessType,
//		PreviousMode,
//		(PVOID*)&Process,
//		NULL);
//	if (!NT_SUCCESS(status)) {
//		return status;
//	}
//	//判断被调试进程是否自己或者被调试进程是否PsInitialSystemProcess进程，是的话退出
//	if (Process == (PEPROCESS_S)PsGetCurrentProcess() || Process == (PEPROCESS_S)PsInitialSystemProcess) {
//		ObfDereferenceObject(Process);
//		return STATUS_ACCESS_DENIED;
//	}
//
//	CurrentProcess = (PEPROCESS_S)PsGetCurrentProcess();
//
//
//	////判断下模式、当前进程的ProtectedProcess和被调试进程的ProtectedProcess
//	//if (PreviousMode == UserMode &&
//	//	CurrentProcess->ProtectedProcess == 0 &&
//	//	Process->ProtectedProcess)
//	//{
//	//	//这里很奇怪，如果当前进程被保护的那么就到不了这里了。
//	//	//那说明当前进程是受保护的就可以忽视目标进程是否受保护了。
//	//	ObfDereferenceObject_S(Process);
//	//	return STATUS_PROCESS_IS_PROTECTED;
//	//}
//
//	status = ObReferenceObjectByHandle(
//		DebugObjectHandle,
//		0x2,
//		*g_DbgkDebugObjectType,
//		PreviousMode,
//		(PVOID*)&DebugObject,
//		NULL);
//
//	if (NT_SUCCESS(status)) {
//		//进程退出可不好办了，所以在这里还是先调用ExAcquireRundownProtection吧，安全一点儿
//		if (ExAcquireRundownProtection(&Process->RundownProtect))
//		{
//			//发送一个虚拟的进程创建消息....从字面理解是这样的，实际它要达到的效果也是如此
//			status = DbgkpPostFakeProcessCreateMessages(Process, DebugObject, (PETHREAD_S*)&LastThread);
//
//			//注意，DbgkpSetProcessDebugObject函数有个参数是寄存器传参，不分析还很难看出来，
//			//其中一个参数是DbgkpPostFakeProcessCreateMessages函数的返回值，而此参数是通过
//			//eax传递进去的，为了保持和windows的代码一致，我也写成wrk一样的吧。
//			//设置调试对象给被调试的进程
//
//			status = DbgkpSetProcessDebugObject((PEPROCESS_S)Process, DebugObject, status, (PETHREAD_S)LastThread);
//
//			ExReleaseRundownProtection(&Process->RundownProtect);
//		}
//		else {
//			status = STATUS_PROCESS_IS_TERMINATING;
//		}
//
//		ObfDereferenceObject(DebugObject);
//	}
//	ObfDereferenceObject(Process);
//
//	//KdPrint(("NtDebugActiveProcess:%X", status));
//
//	return status;
//}


typedef NTSTATUS(*OriginalNtDebugContinue)(
	IN HANDLE DebugObjectHandle,
	IN PCLIENT_ID ClientId,
	IN NTSTATUS ContinueStatus);
EXTERN_C OriginalNtDebugContinue originalNtDebugContinue;
NTSTATUS  NtDebugContinue(
	IN HANDLE DebugObjectHandle,
	IN PCLIENT_ID ClientId,
	IN NTSTATUS ContinueStatus)
{
	NTSTATUS Status;
	PDEBUG_OBJECT DebugObject;
	PDEBUG_EVENT DebugEvent, FoundDebugEvent;
	KPROCESSOR_MODE PreviousMode;
	CLIENT_ID Clid;
	PLIST_ENTRY Entry;
	BOOLEAN GotEvent;

	PreviousMode = ExGetPreviousMode();

	_try{
		if (PreviousMode != KernelMode) {
			ProbeForRead(ClientId, sizeof(*ClientId), sizeof(UCHAR));
		}
		Clid = *ClientId;

	} _except(ExSystemExceptionFilter()) {
		return GetExceptionCode();
	}

	//判断继续操作的类型，此函数就这里和wrk中的不同而已
	switch (ContinueStatus) {
	case DBG_EXCEPTION_NOT_HANDLED:
	case DBG_CONTINUE:
	case DBG_TERMINATE_PROCESS:
		break;
	default:
		return STATUS_INVALID_PARAMETER;
	}

	//得到调试对象
	Status = ObReferenceObjectByHandle(
		DebugObjectHandle,
		0x1,
		*g_DbgkDebugObjectType,
		PreviousMode,
		(PVOID*)&DebugObject,
		NULL);

	if (!NT_SUCCESS(Status)) {
		return Status;
	}

	//如果获得指定的调试消息就设置为ture，初始化时为false
	GotEvent = FALSE;
	//保存寻找到调试消息的变量
	FoundDebugEvent = NULL;

	//这个锁很重要
	ExAcquireFastMutex(&DebugObject->Mutex);

	for (Entry = DebugObject->EventList.Flink;
		Entry != &DebugObject->EventList;
		Entry = Entry->Flink) {

		DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);

		//这里几个判断就是为了找到指定消息
		if (DebugEvent->ClientId.UniqueProcess == Clid.UniqueProcess) {
			//如果还没有寻找到，进入if
			if (!GotEvent) {
				//这里的DEBUG_EVENT_READ是表示这个消息有没有没读取过，也就是说有没有被处理过。
				//如果被处理过，而且确实是我们要找的消息，那么就从消息链中移除，并保存，然后
				//设置标记说找到了。这里DEBUG_EVENT_READ的意义十分重要，解读它我是逆向了
				//NtWaitForDebugEvent函数才知晓了这个意义
				if (DebugEvent->ClientId.UniqueThread == Clid.UniqueThread &&
					(DebugEvent->Flags & 0x1) != 0) {
					RemoveEntryList(Entry);
					FoundDebugEvent = DebugEvent;
					GotEvent = TRUE;
				}
			}
			else {
				//会进入这里说明我们已经找到了指定的消息，并且此调试事件链表还不是空的，
				//那么这里就设置完成获取的这个事件；注意，这里这样写是非常有意义的，至于
				//为何要等到分析NtWaitForDebugEvent的时候再揭晓
				DebugEvent->Flags &= ~0x4;
				KeSetEvent(&DebugObject->EventsPresent, 0, FALSE);
				break;
			}
		}
	}

	ExReleaseFastMutex(&DebugObject->Mutex);

	ObfDereferenceObject(DebugObject);

	if (GotEvent) {
		//找到的话，这个消息也就算彻底完成任务了。注意这里的DbgkpWakeTarget函数里，一般非阻塞消息
		//是直接释放所占内存的
		FoundDebugEvent->ApiMsg.ReturnedStatus = ContinueStatus;
		FoundDebugEvent->Status = STATUS_SUCCESS;
		DbgkpWakeTarget(FoundDebugEvent);
	}
	else {
		Status = STATUS_INVALID_PARAMETER;
	}

	return Status;
}


typedef NTSTATUS(*OriginalNtWaitForDebugEvent)(
	IN HANDLE DebugObjectHandle,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL,
	OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange
	);
extern "C" OriginalNtWaitForDebugEvent originalNtWaitForDebugEvent;
NTSTATUS  NtWaitForDebugEvent(
	IN HANDLE DebugObjectHandle,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL,
	OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange
)
{


	NTSTATUS Status;
	KPROCESSOR_MODE PreviousMode;
	PDEBUG_OBJECT DebugObject;
	LARGE_INTEGER Tmo = { 0 };
	LARGE_INTEGER StartTime = { 0 };
	DBGUI_WAIT_STATE_CHANGE tWaitStateChange = {};
	PEPROCESS_S Process;
	PETHREAD_S Thread;
	PLIST_ENTRY Entry, Entry2;
	PDEBUG_EVENT DebugEvent, DebugEvent2;
	BOOLEAN GotEvent;

	PreviousMode = ExGetPreviousMode();

	_try{
		if (ARGUMENT_PRESENT(Timeout)) {
			if (PreviousMode != KernelMode) {
				ProbeForRead(Timeout, sizeof(*Timeout), sizeof(UCHAR));
			}
			Tmo = *Timeout;
			Timeout = &Tmo;
			KeQuerySystemTime(&StartTime);
		}
		if (PreviousMode != KernelMode) {
			ProbeForWrite(WaitStateChange, sizeof(*WaitStateChange), sizeof(UCHAR));
		}

	} _except(ExSystemExceptionFilter()) {
		return GetExceptionCode();
	}

	//首先通过句柄获取调试对象
	Status = ObReferenceObjectByHandle(DebugObjectHandle,
		0x1,
		*g_DbgkDebugObjectType,
		PreviousMode,
		(PVOID*)&DebugObject,
		NULL);

	if (!NT_SUCCESS(Status)) {
		return Status;
	}

	Process = NULL;
	Thread = NULL;

	while (1) {
		//在调试对象有事件产生
		Status = KeWaitForSingleObject(&DebugObject->EventsPresent,
			Executive,
			PreviousMode,
			Alertable,
			Timeout);
		if (!NT_SUCCESS(Status) || Status == STATUS_TIMEOUT || Status == STATUS_ALERTED || Status == STATUS_USER_APC) {
			break;
		}

		GotEvent = FALSE;

		DebugEvent = NULL;

		ExAcquireFastMutex(&DebugObject->Mutex);

		//等到有信号后判断是否此调试对象无效了，没有无效那么就进一步处理
		if ((DebugObject->Flags & 0x1) == 0) {

			//在这里遍历调试事件链表
			for (Entry = DebugObject->EventList.Flink;
				Entry != &DebugObject->EventList;
				Entry = Entry->Flink) {

				DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);
				//判断消息是否已经读取过或者是否还不需要处理，否则处理
				if ((DebugEvent->Flags & (0x1 | 0x4)) == 0) {
					GotEvent = TRUE;

					//这里进行第二次遍历事件链表
					for (Entry2 = DebugObject->EventList.Flink;
						Entry2 != Entry;
						Entry2 = Entry2->Flink) {

						DebugEvent2 = CONTAINING_RECORD(Entry2, DEBUG_EVENT, EventList);
						//能进入这个遍历的说明有找到比DebugEvent还早的未处理事件，那么就重新设置下
						//DebugEvent事件标记为待处理状态。实际一般情况是进入不到这个循环里的，因为
						//目前我还能看到处理一个调试事件时，还有比这个调试事件更早的没被处理。或许
						//后面的研究会发现这个问题，那时咱们再详谈。通过这里也可以看出，调试事件是
						//严格按照队列形式来处理的，也就是先来的先处理。
						//
						if (DebugEvent->ClientId.UniqueProcess == DebugEvent2->ClientId.UniqueProcess) {

							DebugEvent->Flags |= 0x4;
							DebugEvent->BackoutThread = NULL;
							GotEvent = FALSE;
							break;
						}
					}
					//找到一个满足条件的事件的话，就退出循环了
					if (GotEvent) {
						break;
					}
				}
			}

			//找到的话，把事件相关的信息转换成用户层可识别的信息，然后设置此事件已读
			if (GotEvent) {
				Process = DebugEvent->Process;
				Thread = DebugEvent->Thread;
				ObfReferenceObject(Thread);
				ObfReferenceObject(Process);
				DbgkpConvertKernelToUserStateChange(&tWaitStateChange, DebugEvent);
				DebugEvent->Flags |= 0x1;
			}
			else {
				//没找到的话设置调试对象没有信号了.....
				KeClearEvent(&DebugObject->EventsPresent);
			}
			Status = STATUS_SUCCESS;

		}
		else {
			Status = STATUS_DEBUGGER_INACTIVE;
		}

		ExReleaseFastMutex(&DebugObject->Mutex);

		if (NT_SUCCESS(Status)) {
			if (GotEvent == FALSE) {

				if (Tmo.QuadPart < 0) {
					LARGE_INTEGER NewTime;
					KeQuerySystemTime(&NewTime);
					Tmo.QuadPart = Tmo.QuadPart + (NewTime.QuadPart - StartTime.QuadPart);
					StartTime = NewTime;
					if (Tmo.QuadPart >= 0) {
						Status = STATUS_TIMEOUT;
						break;
					}
				}
			}
			else {

				DbgkpOpenHandles(&tWaitStateChange, Process, Thread);
				ObfDereferenceObject(Thread);
				ObfDereferenceObject(Process);
				break;
			}
		}
		else {
			break;
		}
	}

	ObfDereferenceObject(DebugObject);

	_try{
		*WaitStateChange = tWaitStateChange;
	} _except(ExSystemExceptionFilter()) {
		Status = GetExceptionCode();
	}
	return Status;
}


NTSTATUS(*OriginalNtRemoveProcessDebug)(
	IN HANDLE ProcessHandle,
	IN HANDLE DebugObjectHandle);
NTSTATUS  NtRemoveProcessDebug(
	IN HANDLE ProcessHandle,
	IN HANDLE DebugObjectHandle)
{
	NTSTATUS	status;
	PEPROCESS_S	Process, CurrentProcess;
	KPROCESSOR_MODE	PreviousMode;
	PDEBUG_OBJECT	DebugObject;
	//可能不会走到这个函数
	DbgPrint("NtRemoveProcessDebug Entry!\n");

	PreviousMode = ExGetPreviousMode();

	status = ObReferenceObjectByHandle(
		ProcessHandle,
		0x800,
		*PsProcessType,
		PreviousMode,
		(PVOID*)&Process,
		NULL);
	if (!NT_SUCCESS(status))
	{
		return status;
	}

	//如果当前进程没有受保护且被调试进程受保护，这里直接返回失败！
	//if (PreviousMode == UserMode)
	//{
	//	CurrentProcess = (PEPROCESS_S)PsGetCurrentProcess();
	//	if (CurrentProcess->ProtectedProcess == FALSE &&
	//		Process->ProtectedProcess == TRUE)
	//	{
	//		ObfDereferenceObject(Process);
	//		return STATUS_PROCESS_IS_PROTECTED;
	//	}
	//}

	status = ObReferenceObjectByHandle(
		DebugObjectHandle,
		0x2,
		*g_DbgkDebugObjectType,
		PreviousMode,
		(PVOID*)&DebugObject,
		NULL);
	if (!NT_SUCCESS(status))
	{
		ObfDereferenceObject(Process);
		return status;
	}

	status = DbgkClearProcessDebugObject(
		Process,
		DebugObject);

	ObfDereferenceObject(DebugObject);
	ObfDereferenceObject(Process);
	return status;
}


VOID(*OriginalDbgkCreateThread)(PETHREAD_S Thread);
//VOID  DbgkCreateThread(PETHREAD_S Thread)
//{
//
//	DBGKM_APIMSG m;
//	PDBGKM_CREATE_THREAD CreateThreadArgs;
//	PDBGKM_CREATE_PROCESS CreateProcessArgs;
//	PEPROCESS_S Process;
//	PDBGKM_LOAD_DLL LoadDllArgs;
//	NTSTATUS status;
//	PIMAGE_NT_HEADERS NtHeaders;
//	ULONG OldFlags;
//
//	ULONG	index;
//	PMODULE_INFO ModuleInfo;
//	PDEBUG_OBJECT DebugObject;
//	PSYSTEM_DLL	SystemDll;
//	PVOID	Object;
//	PFILE_OBJECT FileObject;
//	PKTHREAD_S	CurrentThread;
//
//	Process = (PEPROCESS_S)Thread->Tcb.ApcState.Process;
//
//	OldFlags = RtlInterlockedSetBits(&Process->Flags, 0x400001);
//
//	if ((OldFlags & 0x00400000) == 0 &&
//		(*PspNotifyEnableMask & 0x1))
//	{
//
//		IMAGE_INFO_EX ImageInfoEx;
//		PUNICODE_STRING ImageName;
//		POBJECT_NAME_INFORMATION FileNameInfo;
//
//
//
//		ImageInfoEx.ImageInfo.Properties = 0;
//		ImageInfoEx.ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
//		ImageInfoEx.ImageInfo.ImageBase = Process->SectionBaseAddress;
//		ImageInfoEx.ImageInfo.ImageSize = 0;
//
//		_try{
//			NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
//
//			if (NtHeaders)
//			{
//				ImageInfoEx.ImageInfo.ImageSize = NtHeaders->OptionalHeader.SizeOfImage;
//			}
//		} _except(EXCEPTION_EXECUTE_HANDLER) {
//			ImageInfoEx.ImageInfo.ImageSize = 0;
//		}
//		ImageInfoEx.ImageInfo.ImageSelector = 0;
//		ImageInfoEx.ImageInfo.ImageSectionNumber = 0;
//
//		PsReferenceProcessFilePointer((PEPROCESS)Process, (PVOID*)&FileObject);
//		status = SeLocateProcessImageName((PEPROCESS)Process, &ImageName);
//		if (!NT_SUCCESS(status))
//		{
//			ImageName = NULL;
//		}
//
//		PsCallImageNotifyRoutines(
//			ImageName,
//			Process->UniqueProcessId,
//			&ImageInfoEx,
//			FileObject);
//
//		if (ImageName)
//		{
//			//因为在SeLocateProcessImageName中为ImageName申请了内存，所以要在此处释放掉
//			ExFreePoolWithTag(ImageName, 0);
//		}
//		//PsReferenceProcessFilePointer增加了引用计数
//		ObfDereferenceObject(FileObject);
//
//		index = 0;
//		while (index < 2)
//		{
//			ModuleInfo = (PMODULE_INFO)PsQuerySystemDllInfo(index);
//			if (ModuleInfo != NULL)
//			{
//
//				ImageInfoEx.ImageInfo.Properties = 0;
//				ImageInfoEx.ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
//				ImageInfoEx.ImageInfo.ImageBase = ModuleInfo->BaseOfDll;
//				ImageInfoEx.ImageInfo.ImageSize = 0;
//
//				_try{
//					NtHeaders = RtlImageNtHeader(ModuleInfo->BaseOfDll);
//					if (NtHeaders)
//					{
//						ImageInfoEx.ImageInfo.ImageSize = NtHeaders->OptionalHeader.SizeOfImage;
//					}
//				}_except(EXCEPTION_EXECUTE_HANDLER) {
//					ImageInfoEx.ImageInfo.ImageSize = 0;
//				}
//
//				ImageInfoEx.ImageInfo.ImageSelector = 0;
//				ImageInfoEx.ImageInfo.ImageSectionNumber = 0;
//
//				//实际就是PspSystemDlls
//				SystemDll = (PSYSTEM_DLL)((ULONG_PTR)ModuleInfo - 0x10);
//				Object = ObFastReferenceObject(&SystemDll->FastRef);
//				if (Object == NULL)
//				{
//					KeEnterCriticalRegion();
//
//					ExfAcquirePushLockShared((ULONG_PTR)&SystemDll->Lock);
//
//					Object = ObFastReferenceObjectLocked(&SystemDll->FastRef);
//
//					ExfReleasePushLockShared((ULONG_PTR)&SystemDll->Lock);
//
//					KeLeaveCriticalRegion();
//
//				}
//				//这段可能有问题
//				CurrentThread = (PKTHREAD_S)KeGetCurrentThread();
//				//判断APC链表是否为空
//				if (&CurrentThread->ApcState.ApcListHead[0] != CurrentThread->ApcState.ApcListHead[0].Flink)
//				{
//					//判断APC是否禁用
//					if (CurrentThread->SpecialApcDisable != 0)
//					{
//						KiCheckForKernelApcDelivery();
//					}
//				}
//				//获取文件对象
//				FileObject = (PFILE_OBJECT)ObFastReferenceObject(&((PSEGMENT_OBJECT)Object)->Subsection->ControlArea->FilePointer);
//				if (FileObject == 0)
//				{
//					FileObject = MiReferenceControlAreaFile(((PSEGMENT_OBJECT)Object)->Subsection->ControlArea);
//				}
//				if (Object != NULL)
//				{
//					ObFastDereferenceObject(
//						&SystemDll->FastRef,
//						Object);
//				}
//
//				PsCallImageNotifyRoutines(
//					&SystemDll->ModuleInfo.FileName,
//					Process->UniqueProcessId,
//					&ImageInfoEx,
//					FileObject);
//
//				ObfDereferenceObject(FileObject);
//			}
//
//			index++;
//		}
//	}
//
//	DebugObject = (PDEBUG_OBJECT)Process->DebugPort;
//
//	if (DebugObject == NULL) {
//		return;
//	}
//
//	if ((OldFlags & 0x1) == 0)
//	{
//
//		CreateThreadArgs = &m.u.CreateProcessInfo.InitialThread;
//		CreateThreadArgs->SubSystemKey = 0;
//
//		CreateProcessArgs = &m.u.CreateProcessInfo;
//		CreateProcessArgs->SubSystemKey = 0;
//		CreateProcessArgs->FileHandle = DbgkpSectionToFileHandle(
//			Process->SectionObject
//		);
//		CreateProcessArgs->BaseOfImage = Process->SectionBaseAddress;
//		CreateThreadArgs->StartAddress = NULL;
//		CreateProcessArgs->DebugInfoFileOffset = 0;
//		CreateProcessArgs->DebugInfoSize = 0;
//
//		_try{
//
//			NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
//
//			if (NtHeaders) {
//
//
//				CreateThreadArgs->StartAddress = (PVOID)(NtHeaders->OptionalHeader.ImageBase + NtHeaders->OptionalHeader.AddressOfEntryPoint);
//
//				CreateProcessArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
//				CreateProcessArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
//			}
//		} _except(EXCEPTION_EXECUTE_HANDLER) {
//			CreateThreadArgs->StartAddress = NULL;
//			CreateProcessArgs->DebugInfoFileOffset = 0;
//			CreateProcessArgs->DebugInfoSize = 0;
//		}
//		m.h.u1.Length = 0x600038;
//		m.h.u2.ZeroInit = 8;
//		m.ApiNumber = DbgKmCreateProcessApi;
//
//		DbgkpSendApiMessage(FALSE, &m);
//
//		if (CreateProcessArgs->FileHandle != NULL) {
//			ObCloseHandle(CreateProcessArgs->FileHandle, KernelMode);
//		}
//
//		DbgkSendSystemDllMessages
//		(
//			NULL,
//			NULL,
//			&m);
//	}
//	else {
//
//		CreateThreadArgs = &m.u.CreateThread;
//		CreateThreadArgs->SubSystemKey = 0;
//		CreateThreadArgs->StartAddress = Thread->Win32StartAddress;
//		m.h.u1.Length = 0x400018;
//		m.h.u2.ZeroInit = 8;
//		m.ApiNumber = DbgKmCreateThreadApi;
//		DbgkpSendApiMessage(TRUE, &m);
//	}
//
//	if (Thread->ClonedThread == TRUE)
//	{
//		DbgkpPostModuleMessages(
//			(PEPROCESS)Process,
//			(PETHREAD)Thread,
//			NULL);
//	}
//}

VOID(*OriginalDbgkExitThread)(
	NTSTATUS ExitStatus
	);
VOID  DbgkExitThread(
	NTSTATUS ExitStatus
)
{
	DBGKM_APIMSG ApiMsg;
	PEPROCESS_S	Process = (PEPROCESS_S)PsGetCurrentProcess();
	PETHREAD_S	CurrentThread = (PETHREAD_S)PsGetCurrentThread();

	if (Process->DebugPort != NULL && CurrentThread->ThreadInserted == TRUE)
	{
		ApiMsg.u.ExitThread.ExitStatus = ExitStatus;
		ApiMsg.h.u1.Length = 0x34000C;
		ApiMsg.h.u2.ZeroInit = 8;
		ApiMsg.ApiNumber = DbgKmExitThreadApi;
		DbgkpSendApiMessage(0x1, &ApiMsg);
	}
}


VOID(*OriginalDbgkExitProcess)(
	NTSTATUS ExitStatus
	);
VOID  DbgkExitProcess(
	NTSTATUS ExitStatus
)
{
	DBGKM_APIMSG ApiMsg;
	PEPROCESS_S	Process = (PEPROCESS_S)PsGetCurrentProcess();
	PETHREAD_S	CurrentThread = (PETHREAD_S)PsGetCurrentThread();

	if (Process->DebugPort != NULL && CurrentThread->ThreadInserted == TRUE)
	{
		KeQuerySystemTime(&Process->ExitTime);
		ApiMsg.u.ExitProcess.ExitStatus = ExitStatus;
		ApiMsg.h.u1.Length = 0x34000C;
		ApiMsg.h.u2.ZeroInit = 8;
		ApiMsg.ApiNumber = DbgKmExitProcessApi;
		DbgkpSendApiMessage(FALSE, &ApiMsg);
	}
}


NTSTATUS(*OriginalDbgkCopyProcessDebugPort)(
	IN PEPROCESS_S TargetProcess,
	IN PEPROCESS_S SourceProcess,
	IN PDEBUG_OBJECT DebugObject,
	OUT PBOOLEAN bFlag);
NTSTATUS  DbgkCopyProcessDebugPort(
	IN PEPROCESS_S TargetProcess,
	IN PEPROCESS_S SourceProcess,
	IN PDEBUG_OBJECT DebugObject,
	OUT PBOOLEAN bFlag)
{
	TargetProcess->DebugPort = 0;
	if (DebugObject == NULL)
	{
		if (SourceProcess->DebugPort == NULL)
		{
			*bFlag = FALSE;
			return STATUS_SUCCESS;
		}
		else {
			ExAcquireFastMutex(&g_DbgkpProcessDebugPortMutex);
			DebugObject = (PDEBUG_OBJECT)SourceProcess->DebugPort;
			if (DebugObject)
			{
				if (SourceProcess->Flags & 0x2)
				{
					DebugObject = NULL;
				}
				else {
					ObfReferenceObject(DebugObject);
				}
			}
			ExReleaseFastMutex(&g_DbgkpProcessDebugPortMutex);
		}

	}
	else {
		ObfReferenceObject(DebugObject);
	}

	if (DebugObject == NULL)
	{
		*bFlag = FALSE;
		return STATUS_SUCCESS;
	}

	ExAcquireFastMutex(&DebugObject->Mutex);
	if (DebugObject->Flags & 0x1)	//?
	{
		SourceProcess->Pcb.Header.DebugActive = TRUE;
	}
	else {
		TargetProcess->DebugPort = DebugObject;
	}
	ExReleaseFastMutex(&DebugObject->Mutex);

	if (SourceProcess->Pcb.Header.DebugActive == TRUE)
	{
		ObfDereferenceObject(DebugObject);
		DebugObject = NULL;
	}

	if (DebugObject == NULL)
	{
		*bFlag = FALSE;
	}
	else {
		DbgkpMarkProcessPeb(TargetProcess);
		*bFlag = TRUE;
	}

	return STATUS_SUCCESS;
}

//PVOID PsCaptureExceptionPort(
//	IN PEPROCESS_S Process){
//	PKTHREAD_S	Thread;
//	PVOID		ExceptionPort;
//
//	ExceptionPort = Process->ExceptionPortData;
//	if (ExceptionPort != NULL)
//	{
//		KeEnterCriticalRegion();
//		ExAcquirePushLockShared(&Process->ProcessLock,0);
//		ExceptionPort = (PVOID)((ULONG_PTR)ExceptionPort & ~0x7);
//		ObfReferenceObject(ExceptionPort);
//		ExReleasePushLockShared(&Process->ProcessLock,0);
//		KeLeaveCriticalRegion();
//	}
//
//	return ExceptionPort;
//}



BOOLEAN(*OriginalDbgkForwardException)(
	IN PEXCEPTION_RECORD ExceptionRecord,
	IN BOOLEAN DebugException,
	IN BOOLEAN SecondChance);
BOOLEAN  DbgkForwardException(
	IN PEXCEPTION_RECORD ExceptionRecord,
	IN BOOLEAN DebugException,
	IN BOOLEAN SecondChance)
{
	NTSTATUS		st;
	PEPROCESS_S		Process;
	PVOID			ExceptionPort;
	PDEBUG_OBJECT	DebugObject;
	BOOLEAN			bLpcPort;

	DBGKM_APIMSG m;
	PDBGKM_EXCEPTION args;

	DebugObject = NULL;
	ExceptionPort = NULL;
	bLpcPort = FALSE;

	args = &m.u.Exception;
	m.h.u1.Length = 0xD000A8;
	m.h.u2.ZeroInit = 8;
	m.ApiNumber = DbgKmExceptionApi;

	Process = (PEPROCESS_S)PsGetCurrentProcess();

	if (DebugException == TRUE)
	{
		DebugObject = (PDEBUG_OBJECT)Process->DebugPort;
	}
	else
	{
		ExceptionPort = PsCaptureExceptionPort(Process);
		m.h.u2.ZeroInit = 0x7;
		bLpcPort = TRUE;
	}

	if ((ExceptionPort == NULL && DebugObject == NULL) &&
		DebugException == TRUE)
	{
		return FALSE;
	}

	args->ExceptionRecord = *ExceptionRecord;
	args->FirstChance = !SecondChance;

	if (bLpcPort == FALSE)
	{
		st = DbgkpSendApiMessage(DebugException, &m);
	}
	else if (ExceptionPort) {

		st = DbgkpSendApiMessageLpc(&m, ExceptionPort, DebugException);
		ObfDereferenceObject(ExceptionPort);
	}
	else {
		m.ReturnedStatus = DBG_EXCEPTION_NOT_HANDLED;
		st = STATUS_SUCCESS;
	}

	if (NT_SUCCESS(st))
	{

		st = m.ReturnedStatus;

		if (m.ReturnedStatus == DBG_EXCEPTION_NOT_HANDLED)
		{
			if (DebugException == TRUE)
			{
				return FALSE;
			}

			st = DbgkpSendErrorMessage(ExceptionRecord, 0, &m);
		}


	}

	return NT_SUCCESS(st);
}

BOOLEAN DbgkpSuppressDbgMsg(
	IN PTEB Teb)
{
	BOOLEAN bSuppress;
	_try{
		bSuppress = Teb->SuppressDebugMsg;
	}_except(EXCEPTION_EXECUTE_HANDLER) {
		bSuppress = FALSE;
	}
	return bSuppress;
};


VOID(*OriginalDbgkMapViewOfSection)(
	IN PEPROCESS_S	Process,
	IN PVOID SectionObject,
	IN PVOID BaseAddress

	);
VOID DbgkMapViewOfSection(
	IN PEPROCESS_S	Process,
	IN PVOID SectionObject,
	IN PVOID BaseAddress

)
{

	PTEB	Teb;
	HANDLE	hFile;
	DBGKM_APIMSG ApiMsg;
	PEPROCESS_S	CurrentProcess;
	PETHREAD_S	CurrentThread;
	PIMAGE_NT_HEADERS	pImageHeader;

	hFile = NULL;
	CurrentProcess = (PEPROCESS_S)PsGetCurrentProcess();
	CurrentThread = (PETHREAD_S)PsGetCurrentThread();

	if (ExGetPreviousMode() == KernelMode || Process->DebugPort == NULL)
	{
		return;
	}
	if (CurrentThread->Tcb.SystemThread != TRUE && CurrentThread->Tcb.ApcStateIndex != 0x1)
	{
		Teb = (PTEB)CurrentThread->Tcb.Teb;
	}
	else
	{
		Teb = NULL;
	}

	if (Teb != NULL && Process == CurrentProcess)
	{
		if (!DbgkpSuppressDbgMsg(Teb))
		{
			ApiMsg.u.LoadDll.NamePointer = Teb->NtTib.ArbitraryUserPointer;
		}
		else {
			//暂停调试消息的话就退出
			return;
		}
	}
	else {
		ApiMsg.u.LoadDll.NamePointer = NULL;
	}

	hFile = DbgkpSectionToFileHandle(SectionObject);
	ApiMsg.u.LoadDll.FileHandle = hFile;
	ApiMsg.u.LoadDll.BaseOfDll = BaseAddress;
	ApiMsg.u.LoadDll.DebugInfoFileOffset = 0;
	ApiMsg.u.LoadDll.DebugInfoSize = 0;

	_try{
		pImageHeader = RtlImageNtHeader(BaseAddress);
		if (pImageHeader != NULL)
		{
			ApiMsg.u.LoadDll.DebugInfoFileOffset = pImageHeader->FileHeader.PointerToSymbolTable;
			ApiMsg.u.LoadDll.DebugInfoSize = pImageHeader->FileHeader.NumberOfSymbols;
		}
	}_except(EXCEPTION_EXECUTE_HANDLER) {
		ApiMsg.u.LoadDll.DebugInfoFileOffset = 0;
		ApiMsg.u.LoadDll.DebugInfoSize = 0;
		ApiMsg.u.LoadDll.NamePointer = NULL;
	}
	ApiMsg.h.u1.Length = 0x500028;
	ApiMsg.h.u2.ZeroInit = 8;
	ApiMsg.ApiNumber = DbgKmLoadDllApi;

	DbgkpSendApiMessage(0x1, &ApiMsg);

	if (ApiMsg.u.LoadDll.FileHandle != NULL)
	{
		ObCloseHandle(ApiMsg.u.LoadDll.FileHandle, KernelMode);
	}
}


VOID(*OriginalDbgkUnMapViewOfSection)(
	IN PEPROCESS_S	Process,
	IN PVOID	BaseAddress);
VOID DbgkUnMapViewOfSection(
	IN PEPROCESS_S	Process,
	IN PVOID	BaseAddress)
{
	PTEB	Teb;
	DBGKM_APIMSG ApiMsg;
	PEPROCESS_S	CurrentProcess;
	PETHREAD_S	CurrentThread;

	CurrentProcess = (PEPROCESS_S)PsGetCurrentProcess();
	CurrentThread = (PETHREAD_S)PsGetCurrentThread();

	if (ExGetPreviousMode() == KernelMode || Process->DebugPort == NULL)
	{
		return;
	}
	if (CurrentThread->Tcb.SystemThread != TRUE && CurrentThread->Tcb.ApcStateIndex != 0x1)
	{
		Teb = (PTEB)CurrentThread->Tcb.Teb;
	}
	else
	{
		Teb = NULL;
	}

	if (Teb != NULL && Process == CurrentProcess)
	{
		if (DbgkpSuppressDbgMsg(Teb))
		{
			return;
		}
	}
	ApiMsg.u.UnloadDll.BaseAddress = BaseAddress;
	ApiMsg.h.u1.Length = 0x380010;
	ApiMsg.h.u2.ZeroInit = 8;
	ApiMsg.ApiNumber = DbgKmUnloadDllApi;
	DbgkpSendApiMessage(0x1, &ApiMsg);
}

#include "DRRWE.h"
#include "Txoo.h"

//初始化数据
BOOLEAN CKernelDbg::IniteKernelDbg()
{
	//初始化自建变量
	ExInitializeFastMutex(&g_DbgkpProcessDebugPortMutex);
	ExInitializePushLock((PULONG_PTR)&MiChangeControlAreaFileLock);

	InitListAndLock();
	InitialzeDbgprocessList();

	//获取函数地址
	DbgkpSendApiMessageLpc = (DBGKPSENDAPIMESSAGELPC)g_SymbolsData.DbgkpSendApiMessageLpc;
	DbgkpSendErrorMessage = (DBGKPSENDERRORMESSAGE)g_SymbolsData.DbgkpSendErrorMessage;
	DbgkSendSystemDllMessages = (pfDbgkSendSystemDllMessages)g_SymbolsData.DbgkSendSystemDllMessages;
	DbgkpPostFakeThreadMessages = (DbgkpPostFakeThreadMessagesx)g_SymbolsData.DbgkpPostFakeThreadMessages;
	DbgkpPostFakeProcessCreateMessages = (pfDbgkpPostFakeProcessCreateMessages)g_SymbolsData.DbgkpPostFakeProcessCreateMessages;
	DbgkpSetProcessDebugObject = (pfDbgkpSetProcessDebugObject)g_SymbolsData.DbgkpSetProcessDebugObject;
	originalDbgkpMarkProcessPeb = (pfnDbgkpMarkProcessPeb)g_SymbolsData.DbgkpMarkProcessPeb;
	KeResumeThread = (KERESUMETHREAD)g_SymbolsData.KeResumeThread;
	DbgkpPostModuleMessages = (DbgkpPostModuleMessagesx)g_SymbolsData.DbgkpPostModuleMessages;////
	PsGetNextProcessThread = (PsGetNextProcessThreadx)g_SymbolsData.PsGetNextProcessThread;
	PsQuerySystemDllInfo = (pfPsQuerySystemDllInfo)g_SymbolsData.PsQuerySystemDllInfo;
	//ExAcquireRundownProtection_0 = (pfExAcquireRundownProtection_0)g_SymbolsData.ExAcquireRundownProtection_0;
	//DbgkpWakeTarget_2 = (PfDbgkpFreeDebugEvent)g_SymbolsData.DbgkpFreeDebugEvent;
	DbgkpWakeTarget_2 = (pfDbgkpWakeTarget)g_SymbolsData.DbgkpWakeTarget;
	ObDuplicateObject = (ObDuplicateObject1)g_SymbolsData.ObDuplicateObject;
	PsSuspendThread = (PsSuspendThreadx)g_SymbolsData.PsSuspendThread;
	PsResumeThread = (PsResumeThreadx)g_SymbolsData.PsResumeThread;
	PsSynchronizeWithThreadInsertion = (pfnPsSynchronizeWithThreadInsertion)g_SymbolsData.PsSynchronizeWithThreadInsertion;
	PsCallImageNotifyRoutines = (PSCALLIMAGENOTIFYROUTINES)g_SymbolsData.PsCallImageNotifyRoutines;
	ObFastReferenceObject = (OBFASTREFERENCEOBJECT)g_SymbolsData.ObFastReferenceObject;
	ObFastReferenceObjectLocked = (OBFASTREFERENCEOBJECTLOCKED)g_SymbolsData.ObFastReferenceObjectLocked;
	ObFastDereferenceObject = (OBFASTDEREFERENCEOBJECT)g_SymbolsData.ObFastDereferenceObject;
	KiCheckForKernelApcDelivery = (KICHECKFORKERNELAPCDELIVERY)g_SymbolsData.KiCheckForKernelApcDelivery;
	KeFreezeAllThreads = (KEFREEZEALLTHREADS)g_SymbolsData.KeFreezeAllThreads;
	KeThawAllThreads = (KETHAWALLTHREADS)g_SymbolsData.KeThawAllThreads;
	PsThawProcess = (pfPsThawProcess)g_SymbolsData.PsThawProcess;
	PsFreezeProcess = (pfPsFreezeProcess)g_SymbolsData.PsFreezeProcess;
	ZwFlushInstructionCache = (ZWFLUSHINSTRUCTIONCACHE)g_SymbolsData.ZwFlushInstructionCache;
	MmGetFileNameForSection = (MmGetFileNameForSectionx)g_SymbolsData.MmGetFileNameForSection;

	PsTestProtectedProcessIncompatibility = (pfPsTestProtectedProcessIncompatibility)g_SymbolsData.PsTestProtectedProcessIncompatibility;
	PsRequestDebugSecureProcess = (pfPsRequestDebugSecureProcess)g_SymbolsData.PsRequestDebugSecureProcess;
	LpcRequestWaitReplyPortEx = (pfLpcRequestWaitReplyPortEx)g_SymbolsData.LpcRequestWaitReplyPortEx;
	DbgkpSuspendProcess = (pfDbgkpSuspendProcess)g_SymbolsData.DdbgkpSuspendProcess;

	if (!DbgkpSendApiMessageLpc)
	{
		LogError("get DbgkpSendApiMessageLpc failed");
	}
	if (!DbgkpSendErrorMessage)
	{
		LogError("get DbgkpSendErrorMessage failed");
	}
	if (!DbgkpSendApiMessageLpc || !DbgkpSendErrorMessage ||
		!KeResumeThread || !DbgkpPostModuleMessages || !ObDuplicateObject || !PsSuspendThread ||
		!PsCallImageNotifyRoutines || !ObFastReferenceObject || !ObFastReferenceObjectLocked ||
		!ObFastDereferenceObject || !KiCheckForKernelApcDelivery || !KeFreezeAllThreads ||
		!KeThawAllThreads || !ZwFlushInstructionCache)
	{
		LogError("get unexport function failed");
		return FALSE;
	}

	//获取系统全局变量
	PspNotifyEnableMask = g_SymbolsData.PspNotifyEnableMask;
	if (!HookDbgkDebugObjectType())
	{
		LogError("HookDbgkDebugObjectType failed");
		return FALSE;
	}

	int iret = initDbgk();
	if (iret != 0)//初始化dbgkrnl系统数据
	{
		LogError("initDbgk failed:%d", iret);
		return FALSE;
	}

	return TRUE;
}

//Hook
BOOLEAN SetDebugPort(ULONG DebugPortOffset, BOOLEAN IsHook)
{
	if (IsHook)
	{
		KIRQL Irql = WPOFFx64();
		__try
		{
			//KiDispatchException
			*(PULONG)((ULONG_PTR)g_SymbolsData.KiDispatchException + 0x23C) = DebugPortOffset;
			//PspExitThread
			*(PULONG)((ULONG_PTR)g_SymbolsData.PspExitThread + 0x15A) = DebugPortOffset;
			//PspTerminateAllThreads
			*(PULONG)((ULONG_PTR)g_SymbolsData.PspTerminateAllThreads + 0x13B) = DebugPortOffset;
			//PspProcessDelete
			*(PULONG)((ULONG_PTR)g_SymbolsData.PspProcessDelete + 0xE3) = DebugPortOffset;
			//PspExitThread先设置ExitTime，导致ExitTime有值，使得PspProcessDelete判断有值然后释放debugport计数导致蓝屏,所以把PspExitThread里设置ExitTime改为设置CreateTime的偏移
			*(PULONG)((ULONG_PTR)g_SymbolsData.PspExitThread + 0x4DA) = 0x168;

		}_except(1)
		{
			return FALSE;
		}
		WPONx64(Irql);
	}
	else
	{
		KIRQL Irql = WPOFFx64();
		__try
		{
			//KiDispatchException
			*(PULONG)((ULONG_PTR)g_SymbolsData.KiDispatchException + 0x23C) = DebugPortOffset;
			//PspExitThread
			*(PULONG)((ULONG_PTR)g_SymbolsData.PspExitThread + 0x15A) = DebugPortOffset;
			//PspTerminateAllThreads
			*(PULONG)((ULONG_PTR)g_SymbolsData.PspTerminateAllThreads + 0x13B) = DebugPortOffset;
			//PspProcessDelete
			*(PULONG)((ULONG_PTR)g_SymbolsData.PspProcessDelete + 0xE3) = DebugPortOffset;
			//PspExitThread 恢复设置ExitTime的到CreateTime地方
			*(PULONG)((ULONG_PTR)g_SymbolsData.PspExitThread + 0x4DA) = 0x170;

		}_except(1)
		{
			return FALSE;
		}
		WPONx64(Irql);
	}

	return TRUE;
}

NTSTATUS
(*OriginalDbgkOpenProcessDebugPort)(IN PEPROCESS_S Process,
	IN KPROCESSOR_MODE PreviousMode,
	OUT HANDLE* DebugHandle);

#include "Log.h"
#include "Ssdt.h"
#include "HookHelper.h"
#include "HypervisorGateway.h"
BOOLEAN CKernelDbg::StartKernelDbg()
{
    BOOLEAN boole = TRUE;
	//初始化调试相关数据、函数地址
	if (!IniteKernelDbg())
	{
		LogError("IniteKernelDbg failed");
		return FALSE;
	}
	LogInfo("IniteKernelDbg ok");

	NT_SYSCALL_NUMBERS SyscallNumbers;
	GetNtSyscallNumbers(SyscallNumbers);

	if (SSDT::HookNtSyscall(SyscallNumbers.NtCreateDebugObject, proxyNtCreateDebugObject, (PVOID*)&OriginalNtCreateDebugObject) == FALSE)
	{
		LogError("NtCreateDebugObject hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtDebugContinue, proxyNtDebugContinue, (PVOID*)&originalNtDebugContinue) == FALSE)
	{
		LogError("NtDebugContinue hook failed");
		return FALSE;
	}
	if (SSDT::HookNtSyscall(SyscallNumbers.NtRemoveProcessDebug, proxyNtRemoveProcessDebug, (PVOID*)&OriginalNtRemoveProcessDebug) == FALSE)
	{
		LogError("NtRemoveProcessDebug hook failed");
		return FALSE;
	}
	
	if (!hv::hook_function(g_SymbolsData.DbgkOpenProcessDebugPort, proxyDbgkOpenProcessDebugPort, (PVOID*)&OriginalDbgkOpenProcessDebugPort))//不能退出调试
	{
		LogError("DbgkExitProcess hook failed");
		return FALSE;
	}
	if (!hv::hook_function(g_SymbolsData.DbgkCopyProcessDebugPort, proxyDbgkCopyProcessDebugPort, (PVOID*)&OriginalDbgkCopyProcessDebugPort))//不能退出调试
	{
		LogError("DbgkCopyProcessDebugPort hook failed");
		return FALSE;
	}
	if (!hv::hook_function(g_SymbolsData.DbgkMapViewOfSection, proxyDbgkMapViewOfSection, (PVOID*)&OriginalDbgkMapViewOfSection))//FIX
	{
		LogError("DbgkMapViewOfSection hook failed");
		return FALSE;
	}
	if (!hv::hook_function(g_SymbolsData.DbgkUnMapViewOfSection, proxyDbgkUnMapViewOfSection, (PVOID*)&OriginalDbgkUnMapViewOfSection))//FIX
	{
		LogError("DbgkMapViewOfSection hook failed");
		return FALSE;
	}
	if (!hv::hook_function(g_SymbolsData.DbgkExitProcess, proxyDbgkExitProcess, (PVOID*)&originalproxyDbgkExitProcess))
	{
		LogError("DbgkExitProcess hook failed");
		return FALSE;
	}
	if (!hv::hook_function(g_SymbolsData.DbgkExitThread, &proxyDbgkExitThread, (PVOID*)&OriginalDbgkExitThread))
	{
		boole = FALSE;
		return FALSE;
	}
	//if (!hv::hook_function(g_SymbolsData.PspExitThread, &proxyPspExitThread, (PVOID*)&originalproxyPspExitThread))
	//{
	//	boole = FALSE;
	//	return FALSE;
	//}
	if (!hv::hook_function(g_SymbolsData.DbgkForwardException, proxyDbgkForwardException, (PVOID*)&OriginalDbgkForwardException))
	{
		LogError("DbgkForwardException hook failed");
		return FALSE;
	}


	if (!hv::hook_function(g_SymbolsData.DbgkpSetProcessDebugObject, DbgkpSetProcessDebugObject_2, (PVOID*)&originalDbgkpSetProcessDebugObject))
	{
		LogError("DbgkExitProcess hook failed");
		return FALSE;
	}
	if (!hv::hook_function(g_SymbolsData.DbgkpPostFakeThreadMessages, DbgkpPostFakeThreadMessages_2, (PVOID*)&originalDbgkpPostFakeThreadMessages))
	{
		LogError("DbgkMapViewOfSection hook failed");
		return FALSE;
	}

	if (!hv::hook_function(g_SymbolsData.DbgkpQueueMessage, DbgkpQueueMessage_2, (PVOID*)&OriginalDbgkpQueueMessage))
	{
		LogError("DbgkExitProcess hook failed");
		return FALSE;
	}

	return boole;
}

/**/
void CKernelDbg::StopKernelDbg()
{
	NT_SYSCALL_NUMBERS SyscallNumbers;
	GetNtSyscallNumbers(SyscallNumbers);

	hv::unhook_function((unsigned long long)SyscallNumbers.NtDebugActiveProcess);
	hv::unhook_function((unsigned long long)SyscallNumbers.NtCreateDebugObject);
	hv::unhook_function((unsigned long long)SyscallNumbers.NtRemoveProcessDebug);
	hv::unhook_function((unsigned long long)SyscallNumbers.NtWaitForDebugEvent);
	hv::unhook_function((unsigned long long)SyscallNumbers.NtDebugContinue);


	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkExitProcess);
	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkExitThread);
	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkCopyProcessDebugPort);
	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkForwardException);
	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkMapViewOfSection);
	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkUnMapViewOfSection);
	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkClearProcessDebugObject);
	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkpQueueMessage);
	hv::unhook_function((unsigned long long)g_SymbolsData.DbgkCreateThread);

	return;
}



```

`HyperHideDrv/CKernelDbg.h`:

```h
#pragma once
#include "Header.h"

typedef struct _SYMBOLS_DATA
{
	PVOID  DbgkExitThread;
	PVOID  DbgkClearProcessDebugObject;
	PVOID  DbgkSendSystemDllMessages;
	PVOID  PspExitThread;
	PVOID  PspTerminateAllThreads;
	PVOID  PspProcessDelete;
	PULONG PspNotifyEnableMask;
	PVOID  DbgkExitProcess;
	PVOID  DbgkpPostFakeThreadMessages;
	PVOID  DbgkpPostFakeProcessCreateMessages;
	PVOID  PsCallImageNotifyRoutines;
	PVOID  ObFastReferenceObjectLocked;
	PVOID  ObFastReferenceObject;
	PVOID  ObFastDereferenceObject;
	PVOID  DbgkpSendApiMessageLpc;
	PVOID  DbgkpSendErrorMessage;
	PVOID  DbgkpQueueMessage;
	PVOID  DdbgkpSuspendProcess;
	PVOID  KiDispatchException;
	PVOID  DbgkForwardException;
	PVOID  DbgkMapViewOfSection;
	PVOID  DbgkCreateThread;
	PVOID  DbgkUnMapViewOfSection;
	PVOID  DbgkCopyProcessDebugPort;
	PVOID  DbgkOpenProcessDebugPort;
	PVOID  DbgkpSetProcessDebugObject;
	PVOID  DbgkpMarkProcessPeb;
	PVOID  PsSuspendThread;
	PVOID  PsResumeThread;
	PVOID  KeResumeThread;
	PVOID  PsSynchronizeWithThreadInsertion;
	PVOID  DbgkpPostModuleMessages;
	PVOID  DbgkpFreeDebugEvent;
	PVOID  DbgkpWakeTarget;
	PVOID  ObDuplicateObject;
	PVOID  KiCheckForKernelApcDelivery;
	PVOID  PsQuerySystemDllInfo;
	//PVOID  ExAcquireRundownProtection_0;
	PVOID  PsGetNextProcessThread;
	PVOID  KeFreezeAllThreads;
	PVOID  KeThawAllThreads;
	PVOID  PsThawProcess;
	PVOID  PsFreezeProcess;
	PVOID  ZwFlushInstructionCache;


	//////
	PVOID  PspActiveProcessLock;
	PVOID  ExfAcquirePushLockExclusive;
	PVOID  ExfTryToWakePushLock;
	PVOID  PspRemoveProcessFromJob;
	PVOID  PspDeleteLdt;
	PVOID  PsReturnProcessNonPagedPoolQuota;
	PVOID  AlpcpCleanupProcessViews;
	PVOID  ObDereferenceDeviceMap;
	PVOID  PspDereferenceQuotaBlock;
	PVOID  PsReturnProcessPagedPoolQuota;
	PVOID  ExDestroyHandle;
	PVOID  MmCleanProcessAddressSpace;
	PVOID  MmDeleteProcessAddressSpace;
	PVOID  MmGetFileNameForSection;
	PVOID  PspCidTable;
	PVOID  ObFastReplaceObject;
	PVOID  LpcRequestWaitReplyPortEx;
	PVOID PsTestProtectedProcessIncompatibility;
	PVOID PsRequestDebugSecureProcess;
}SYMBOLS_DATA, * PSYMBOLS_DATA;


class CKernelDbg
{
public:
	
	
	BOOLEAN StartKernelDbg();
	void StopKernelDbg();


	

private:
	BOOLEAN IniteKernelDbg();

	
};


```

`HyperHideDrv/CKernelTable.cpp`:

```cpp
#include "CKernelTable.h"
#include "CPeModule.h"
#include "GlobalData.h"

PServiceDescriptorTableEntry_t g_KeServiceDescriptorTable=0;
PServiceDescriptorTableEntry_t g_KeServiceDescriptorTableShadow = 0;

CKernelTable::CKernelTable()
{

	if (!g_KeServiceDescriptorTable)
	{
		g_KeServiceDescriptorTable = GetKeServiceDescriptorTable();
	}
	if (!g_KeServiceDescriptorTableShadow)
	{
		g_KeServiceDescriptorTableShadow = GetKeServiceDescriptorTableShadow();

	}
	//KdPrint(("KeServiceDescriptorTable:%p\n KeServiceDescriptorTableShadow:%p\n", g_KeServiceDescriptorTable, g_KeServiceDescriptorTableShadow));
}
CKernelTable::~CKernelTable()
{

}





PVOID CKernelTable::GetAddressFromIndex(
	ULONG Index)
{

	PServiceDescriptorTableEntry_t KeServiceDescriptorTable = g_KeServiceDescriptorTable;

	if (!MmIsAddressValid(KeServiceDescriptorTable))
	{
		return 0;
	}
	if (Index > KeServiceDescriptorTable->NumberOfServices)
	{
		return 0;
	}

#ifdef _WIN64

	//(PUCHAR)pSSDT->ServiceTableBase + (((PLONG)pSSDT->ServiceTableBase)[index] >> 4);
	ULONG Offset = KeServiceDescriptorTable->ServiceTableBase[Index] >> 4;
	ULONG64 paddr = (ULONG64)(KeServiceDescriptorTable->ServiceTableBase) + Offset;
	DbgPrint("ServiceTableBase + Offset:%x", (ULONG64)(KeServiceDescriptorTable->ServiceTableBase) + Offset);
	return (PVOID)paddr;//为什么要&0xFFFFFFFF0FFFFFFF

	
#else
	return (PVOID)KeServiceDescriptorTable->ServiceTableBase[Index];
#endif // _WIN64

}

BOOLEAN CKernelTable::GetIndexFromName(
	IN CHAR* FunctionName,
	OUT PUINT32 Index)
{
#ifdef _WIN64

	/* Win7 64bit
	004> u zwopenprocess
	ntdll!ZwOpenProcess:
	00000000`774c1570 4c8bd1          mov     r10,rcx
	00000000`774c1573 b823000000      mov     eax,23h
	00000000`774c1578 0f05            syscall
	00000000`774c157a c3              ret
	00000000`774c157b 0f1f440000      nop     dword ptr [rax+rax]
	*/

	UINT32    Offset_SSDTFunctionIndexInNtdllExportFunctionAddress = 4;

#else

	/* 	Win7 32bit
	kd> u zwopenProcess
	nt!ZwOpenProcess:
	83e9162c b8be000000      mov     eax,0BEh
	83e91631 8d542404        lea     edx,[esp+4]
	83e91635 9c              pushfd
	83e91636 6a08            push    8
	83e91638 e8b1190000      call    nt!KiSystemService (83e92fee)
	83e9163d c21000          ret     10h
	*/

	/* WinXp 32bit
	kd> u zwopenprocess
	nt!ZwOpenProcess:
	804ff720 b87a000000      mov     eax,7Ah
	804ff725 8d542404        lea     edx,[esp+4]
	804ff729 9c              pushfd
	804ff72a 6a08            push    8
	804ff72c e850ed0300      call    nt!KiSystemService (8053e481)
	804ff731 c21000          ret     10h

	*/
	UINT32    Offset_SSDTFunctionIndexInNtdllExportFunctionAddress = 1;

#endif

	// 使用内存映射将Ntdll模块映射到System进程的内存空间进行查找(Ntdll.dll模块的导出表中进行搜索)

	WCHAR					wzFileFullPath[] = L"\\SystemRoot\\System32\\ntdll.dll";
	PVOID					MappingBaseAddress = NULL;
	SIZE_T					MappingViewSize = 0;
	PIMAGE_NT_HEADERS		NtHeader = NULL;
	PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
	PUINT32					AddressOfFunctions = NULL;			// offset
	PUINT32					AddressOfNames = NULL;				// offset
	PUINT16					AddressOfNameOrdinals = NULL;		// Ordinal
	CHAR* szFunctionName = NULL;
	UINT32					FunctionOrdinal = 0;
	UINT_PTR				FunctionAddress = 0;
	BOOLEAN					bOk = FALSE;
	UINT32					i = 0;

	*Index = -1;

	//将Ntdll.dll 当前的空间中

	bOk = CPeModule::MappingFileToKernel(wzFileFullPath, &MappingBaseAddress, &MappingViewSize);
	if (bOk == FALSE)
	{
		return FALSE;
	}

	__try
	{
		NtHeader = RtlImageNtHeader(MappingBaseAddress);		// 转换成ntheader
		if (NtHeader && NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
		{
			ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PUINT8)MappingBaseAddress + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);		// 导出表地址

			AddressOfFunctions = (PUINT32)((PUINT8)MappingBaseAddress + ExportDirectory->AddressOfFunctions);
			AddressOfNames = (PUINT32)((PUINT8)MappingBaseAddress + ExportDirectory->AddressOfNames);
			AddressOfNameOrdinals = (PUINT16)((PUINT8)MappingBaseAddress + ExportDirectory->AddressOfNameOrdinals);

			// 这里不处理转发，ntdll应该不存在转发
			for (i = 0; i < ExportDirectory->NumberOfNames; i++)
			{
				szFunctionName = (CHAR*)((PUINT8)MappingBaseAddress + AddressOfNames[i]);   // 获得函数名称
				if (_stricmp(szFunctionName, FunctionName) == 0)						  // hit !
				{
					FunctionOrdinal = AddressOfNameOrdinals[i];
					FunctionAddress = (UINT_PTR)((PUINT8)MappingBaseAddress + AddressOfFunctions[FunctionOrdinal]);			// (WinXp 32bit 804ff720 ZwOpenProcess)		(Win7 32bit 83e9162c ZwOpenProcess)	(Win7 64bit 00000000`774c1570 ZwOpenProcess)

					// SSDT中函数索引
					*Index = *(PUINT32)(FunctionAddress + Offset_SSDTFunctionIndexInNtdllExportFunctionAddress);	// (WinXp 32bit 804ff721 7Ah)	(Win7 32bit 804ff721 0BEh)		(Win7 64bit 00000000`774c1574 23h)
					break;
				}
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}

	ZwUnmapViewOfSection(NtCurrentProcess(), MappingBaseAddress);


	if (*Index == -1)
	{
		return FALSE;
	}

	return TRUE;
}







PVOID CKernelTable::FindKeServiceDescriptorTable64
(
	PUCHAR StartSearchAddress,
	PUCHAR EndSearchAddress)
{
	UCHAR b1 = 0, b2 = 0, b3 = 0;
	ULONG templong = 0;
	ULONG_PTR KeServiceDescriptorTable = 0;

	//地址效验
	if (MmIsAddressValid((PVOID)StartSearchAddress) == FALSE)return NULL;
	if (MmIsAddressValid((PVOID)EndSearchAddress) == FALSE)return NULL;

	for (PUCHAR i = (PUCHAR)StartSearchAddress; i < (PUCHAR)EndSearchAddress; i++)
	{
		if (MmIsAddressValid((PVOID)i) && MmIsAddressValid(i + 1) && MmIsAddressValid(i + 2))
		{
			b1 = *i;
			b2 = *(i + 1);
			b3 = *(i + 2);
			if (b1 == 0x4c && b2 == 0x8d && b3 == 0x15)  //4c8d15
			{
				memcpy(&templong, i + 3, 4);
				KeServiceDescriptorTable = (ULONGLONG)templong + (ULONGLONG)i + 7;
				return (PVOID)KeServiceDescriptorTable;
				//当前地址 + 长度 + 数值
				//fffff800`03c8c772+7 + 002320c7 = FFFFF80003EBE840
				/*
				fffff800`03c8c772 4c8d15c7202300  lea     r10,[nt!KeServiceDescriptorTable (fffff800`03ebe840)]
				fffff800`03c8c779 4c8d1d00212300  lea     r11,[nt!KeServiceDescriptorTableShadow (fffff800`03ebe880)]
				*/
			}
		}
	}
	return NULL;
}
PServiceDescriptorTableEntry_t CKernelTable::GetKeServiceDescriptorTable()
{
#ifdef _WIN64
	PUCHAR pKiSystemCall64 = (PUCHAR)__readmsr(0xc0000082);  //rdmsr c0000082   //定位KiSystemCall64
	PUCHAR EndSearchAddress = pKiSystemCall64 + 0x500;
	PVOID KeServiceDescriptorTable = 0;


	KeServiceDescriptorTable = FindKeServiceDescriptorTable64(pKiSystemCall64, EndSearchAddress);
	if (KeServiceDescriptorTable)
	{
		return  (PServiceDescriptorTableEntry_t)KeServiceDescriptorTable;
	}

	//msr[0xc0000082]变成了KiSystemCall64Shadow函数
	//原来我们64位搜索KeServiceDescriptorTable是通过msr的0xc0000082获得KiSystemCall64字段, 但是现在msr[0xc0000082]变成了KiSystemCall64Shadow函数, 而且这个函数无法直接搜索到KeServiceDescriptorTable。
	ULONG_PTR KiSystemServiceUser = 0;
	ULONG_PTR templong = 0xffffffffffffffff;
	for (PUCHAR i = (PUCHAR)pKiSystemCall64; i < (PUCHAR)((ULONG_PTR)EndSearchAddress + 0xff); i++)
	{
		if (*(PUCHAR)i == 0xe9 && *(PUCHAR)(i + 5) == 0xc3)
		{
			//fffff803`23733383 e9631ae9ff      jmp     nt!KiSystemServiceUser(fffff803`235c4deb)
			//fffff803`23733388 c3              ret
			RtlCopyMemory(&templong, (PUCHAR)(i + 1), 4);
			KiSystemServiceUser = templong + 5 + (ULONG_PTR)i;//KiSystemServiceUser
			EndSearchAddress = (PUCHAR)(KiSystemServiceUser + 0x500);
			KeServiceDescriptorTable = FindKeServiceDescriptorTable64((PUCHAR)KiSystemServiceUser, EndSearchAddress);
			return (PServiceDescriptorTableEntry_t)KeServiceDescriptorTable;
		}
	}
	return 0;

#else

	return (PServiceDescriptorTableEntry_t)CPeModule::GetProcAddress("KeServiceDescriptorTable");

#endif // _WIN64
}

PServiceDescriptorTableEntry_t CKernelTable::GetKeServiceDescriptorTableShadow()
{
#ifdef _WIN64

	PUCHAR StartSearchAddress = (PUCHAR)__readmsr(0xC0000082);
	PUCHAR EndSearchAddress = StartSearchAddress + 0x500;
	PUCHAR i = NULL;
	UCHAR b1 = 0, b2 = 0, b3 = 0;
	ULONG templong = 0;
	ULONGLONG addr = 0;
	for (i = StartSearchAddress; i < EndSearchAddress; i++)
	{
		if (MmIsAddressValid(i) && MmIsAddressValid(i + 1) && MmIsAddressValid(i + 2))
		{
			b1 = *i;
			b2 = *(i + 1);
			b3 = *(i + 2);
			if (b1 == 0x4c && b2 == 0x8d && b3 == 0x1d) //4c8d1d
			{
				memcpy(&templong, i + 3, 4);
				addr = (ULONGLONG)templong + (ULONGLONG)i + 7;
				return (PServiceDescriptorTableEntry_t)((PUCHAR)addr+ sizeof(ServiceDescriptorTableEntry_t));
			}
		}
	}
	return 0;
#else

	if (g_SystemData.WinVersion == 7601)
	{
		/*nt!KeAddSystemServiceTable + 0x1a:
		83fc5022 8d88002afa83    lea     ecx, nt!KeServiceDescriptorTableShadow(83fa2a00)[eax]
		83fc5028 833900          cmp     dword ptr[ecx], 0*/
		TZM tzm[5] = { {0x8d,-2},{0x88,-1},{0x83,4},{0x39,5},{0x00,6} };
		PVOID find = CMemroy::FindMemory((PVOID)CPeModule::GetProcAddress("KeAddSystemServiceTable"), 0x100, CMemroy::Normal, tzm);
		if (find)
		{
			return (ServiceDescriptorTableEntry_t) (*(PULONG)find+ sizeof(ServiceDescriptorTableEntry_t));
		}
	}
	return 0;


#endif // _WIN64

}


BOOLEAN CKernelTable::GetFunctionNameFromIndex(
	OUT CHAR* FunctionName,
	IN  UINT32 Index
)
{
#ifdef _WIN64

	/* Win7 64bit
	004> u zwopenprocess
	ntdll!ZwOpenProcess:
	00000000`774c1570 4c8bd1          mov     r10,rcx
	00000000`774c1573 b823000000      mov     eax,23h
	00000000`774c1578 0f05            syscall
	00000000`774c157a c3              ret
	00000000`774c157b 0f1f440000      nop     dword ptr [rax+rax]
	*/

	UINT32    Offset_SSDTFunctionIndexInNtdllExportFunctionAddress = 4;

#else

	/* 	Win7 32bit
	kd> u zwopenProcess
	nt!ZwOpenProcess:
	83e9162c b8be000000      mov     eax,0BEh
	83e91631 8d542404        lea     edx,[esp+4]
	83e91635 9c              pushfd
	83e91636 6a08            push    8
	83e91638 e8b1190000      call    nt!KiSystemService (83e92fee)
	83e9163d c21000          ret     10h
	*/

	/* WinXp 32bit
	kd> u zwopenprocess
	nt!ZwOpenProcess:
	804ff720 b87a000000      mov     eax,7Ah
	804ff725 8d542404        lea     edx,[esp+4]
	804ff729 9c              pushfd
	804ff72a 6a08            push    8
	804ff72c e850ed0300      call    nt!KiSystemService (8053e481)
	804ff731 c21000          ret     10h

	*/
	UINT32    Offset_SSDTFunctionIndexInNtdllExportFunctionAddress = 1;

#endif

	// 使用内存映射将Ntdll模块映射到System进程的内存空间进行查找(Ntdll.dll模块的导出表中进行搜索)

	WCHAR					wzFileFullPath[] = L"\\SystemRoot\\System32\\ntdll.dll";
	PVOID					MappingBaseAddress = NULL;
	SIZE_T					MappingViewSize = 0;
	PIMAGE_NT_HEADERS		NtHeader = NULL;
	PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
	PUINT32					AddressOfFunctions = NULL;			// offset
	PUINT32					AddressOfNames = NULL;				// offset
	PUINT16					AddressOfNameOrdinals = NULL;		// Ordinal
	CHAR* szFunctionName = NULL;
	UINT32					FunctionOrdinal = 0;
	UINT_PTR				FunctionAddress = 0;
	BOOLEAN					bOk = FALSE;
	UINT32					i = 0;


	BOOLEAN boole = FALSE;
	//将Ntdll.dll 当前的空间中

	bOk = CPeModule::MappingFileToKernel(wzFileFullPath, &MappingBaseAddress, &MappingViewSize);
	if (bOk == FALSE)
	{
		return FALSE;
	}

	__try
	{
		NtHeader = RtlImageNtHeader(MappingBaseAddress);		// 转换成ntheader
		if (NtHeader && NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
		{
			ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PUINT8)MappingBaseAddress + NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);		// 导出表地址

			AddressOfFunctions = (PUINT32)((PUINT8)MappingBaseAddress + ExportDirectory->AddressOfFunctions);
			AddressOfNames = (PUINT32)((PUINT8)MappingBaseAddress + ExportDirectory->AddressOfNames);
			AddressOfNameOrdinals = (PUINT16)((PUINT8)MappingBaseAddress + ExportDirectory->AddressOfNameOrdinals);

			// 这里不处理转发，ntdll应该不存在转发
			for (i = 0; i < ExportDirectory->NumberOfNames; i++)
			{
				szFunctionName = (CHAR*)((PUINT8)MappingBaseAddress + AddressOfNames[i]);   // 获得函数名称
				FunctionOrdinal = AddressOfNameOrdinals[i];
				FunctionAddress = (UINT_PTR)((PUINT8)MappingBaseAddress + AddressOfFunctions[FunctionOrdinal]);

				if (szFunctionName[0] == 'N' && szFunctionName[1] == 't')
				{
					if (*(PUINT32)(FunctionAddress + Offset_SSDTFunctionIndexInNtdllExportFunctionAddress) == Index)
					{
						strcpy(FunctionName, szFunctionName);
						boole = TRUE;
						break;
					}
				}
			}
			if (!boole)//过滤有些SSDT函数不进入内核，则手动硬编码填充函数名
			{
				szFunctionName = "NtQuerySystemTime";
				strcpy(FunctionName, szFunctionName);
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		boole = FALSE;
		KdPrint(("GetFunctionNameByIndex error!\n"));
	}

	ZwUnmapViewOfSection(NtCurrentProcess(), MappingBaseAddress);


	return boole;
}
BOOLEAN CKernelTable::GetOldAddressFromIndex(
	OUT PVOID* OldFunctionAddress,
	IN UINT32 Index,
	IN PVOID NewImageBass)
{

	PServiceDescriptorTableEntry_t  KeServiceDescriptorTable = g_KeServiceDescriptorTable;
	if (!MmIsAddressValid(KeServiceDescriptorTable) || !NewImageBass || Index > KeServiceDescriptorTable->NumberOfServices)
	{
		return FALSE;
	}
	PULONG_PTR ServiceTableBase = (PULONG_PTR)((ULONG_PTR)KeServiceDescriptorTable->ServiceTableBase - g_SystemData.KernelModuleBass + (ULONG_PTR)NewImageBass);
	PIMAGE_NT_HEADERS NtHeader = RtlImageNtHeader((PVOID)NewImageBass);
	_try
	{
#ifdef _WIN64
		* OldFunctionAddress = (PVOID)(ServiceTableBase[Index] - NtHeader->OptionalHeader.ImageBase + g_SystemData.KernelModuleBass);
#else
		* OldFunctionAddress = (PVOID)KeServiceDescriptorTable->ServiceTableBase[Index];
#endif // _WIN64
	}
		_except(1)
	{
		KdPrint(("ServiceTableBase error!"));
		return FALSE;
	}


	return TRUE;
}

BOOLEAN CKernelTable::GetShadowOldAddressFromIndex(
	OUT PVOID* OldFunctionAddress,
	UINT32 Index,
	IN PVOID NewImageBass, 
	IN PVOID OldBass)
{
	BOOLEAN boole = FALSE;
	PServiceDescriptorTableEntry_t  KeServiceDescriptorTable = g_KeServiceDescriptorTableShadow;
	if (!MmIsAddressValid(KeServiceDescriptorTable) || !NewImageBass || Index > KeServiceDescriptorTable->NumberOfServices)
	{
		return boole;
	}
	PULONG_PTR ServiceTableBase = (PULONG_PTR)((INT_PTR)KeServiceDescriptorTable->ServiceTableBase - (INT_PTR)OldBass + (INT_PTR)NewImageBass);
	PIMAGE_NT_HEADERS NtHeader = RtlImageNtHeader((PVOID)NewImageBass);

	_try
	{
#ifdef _WIN64
		* OldFunctionAddress = (PVOID)(ServiceTableBase[Index] - NtHeader->OptionalHeader.ImageBase + (INT_PTR)OldBass);
#else
		* OldFunctionAddress = (PVOID)KeServiceDescriptorTable->ServiceTableBase[Index];
#endif // _WIN64


	}
		_except(1)
	{

		KdPrint(("ServiceTableBase error!"));
		return FALSE;
	}


	return TRUE;
}


PVOID CKernelTable::GetAddressFromName(CHAR* FunctionName)
{
	UINT32 Index =0;
	if (!GetIndexFromName(FunctionName, &Index))
	{
		return 0;
	}
	DbgPrint("111111111111111:%d\n", Index);
	return GetAddressFromIndex(Index);
}
```

`HyperHideDrv/CKernelTable.h`:

```h
#pragma once
#include "Header.h"

class CKernelTable
{
public:
	CKernelTable();
	~CKernelTable();

	PVOID GetAddressFromIndex(
		ULONG Index);
	BOOLEAN GetIndexFromName(
		IN CHAR* FunctionName,
		OUT PUINT32 Index);
	BOOLEAN GetFunctionNameFromIndex(
		OUT CHAR* FunctionName,
		IN  UINT32 Index
	);
	BOOLEAN GetOldAddressFromIndex(
		OUT PVOID* OldFunctionAddress,
		IN UINT32 Index,
		IN PVOID NewImageBass);
	PVOID CKernelTable::GetShadowAddressFromIndex(
		ULONG Index);
	BOOLEAN GetShadowOldAddressFromIndex(
		OUT PVOID* OldFunctionAddress,
		UINT32 Index,
		IN PVOID NewImageBass,
		IN PVOID OldBass);
	PVOID GetAddressFromName(CHAR* FunctionName);
private:
	PVOID FindKeServiceDescriptorTable64(
		PUCHAR StartSearchAddress,
		PUCHAR EndSearchAddress);
	PServiceDescriptorTableEntry_t GetKeServiceDescriptorTable();
	PServiceDescriptorTableEntry_t GetKeServiceDescriptorTableShadow();
};


```

`HyperHideDrv/CPeModule.cpp`:

```cpp
#include "CPeModule.h"
#include "KernelExportAPI.h"

BOOLEAN CPeModule::MappingFileToKernel
(
	IN WCHAR* FilePath,
	OUT PVOID* MappingBaseAddress,
	OUT ULONG_PTR* MappingViewSize)
{
	UNICODE_STRING    uniFileFullPath = { 0 };
	OBJECT_ATTRIBUTES oa = { 0 };
	NTSTATUS          Status = STATUS_UNSUCCESSFUL;
	IO_STATUS_BLOCK   Iosb = { 0 };
	HANDLE			  FileHandle = NULL;
	HANDLE			  SectionHandle = NULL;

	if (!FilePath || !MappingBaseAddress)
	{
		return FALSE;
	}
	*MappingBaseAddress = 0;
	*MappingViewSize = 0;

	RtlInitUnicodeString(&uniFileFullPath, FilePath);		// 常量指针格式化到unicode
	InitializeObjectAttributes(&oa,									// 初始化 oa
		&uniFileFullPath,											// Dll完整路径
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,					// 不区分大小写 | 内核句柄
		NULL,
		NULL
	);

	Status = IoCreateFile(&FileHandle,								// 获得文件句柄
		GENERIC_READ | SYNCHRONIZE,									// 同步读
		&oa,														// 文件绝对路径
		&Iosb,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ,
		FILE_OPEN,
		FILE_SYNCHRONOUS_IO_NONALERT,
		NULL,
		0,
		CreateFileTypeNone,
		NULL,
		IO_NO_PARAMETER_CHECKING
	);
	if (!NT_SUCCESS(Status))
	{
		return FALSE;
	}

	//	oa.ObjectName = NULL;

	InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

	Status = ZwCreateSection(&SectionHandle,			// 创建节对象,用于后面文件映射 （CreateFileMapping）
		SECTION_QUERY | SECTION_MAP_READ,
		&oa,
		NULL,
		PAGE_WRITECOPY,
		SEC_IMAGE,
		FileHandle
	);

	ZwClose(FileHandle);
	if (!NT_SUCCESS(Status))
	{
		return FALSE;
	}

	Status = ZwMapViewOfSection(
		SectionHandle,
		ZwCurrentProcess(),				// 映射到当前进程的内存空间中 System
		MappingBaseAddress,
		0,
		0,
		0,
		MappingViewSize,
		ViewUnmap,
		0,
		PAGE_WRITECOPY
	);

	ZwClose(SectionHandle);
	if (!NT_SUCCESS(Status))
	{

		KdPrint(("Status: %x", Status));

		return FALSE;
	}

	return TRUE;
}

BOOLEAN CPeModule::GetImageSection(
	IN PVOID KernelModuleBass,
	IN const char* SectionName,
	OUT PULONG SizeOfSection,
	OUT PVOID* SectionAddress
) 
{

	if (!MmIsAddressValid(SizeOfSection) || !MmIsAddressValid(SectionAddress) || !MmIsAddressValid(KernelModuleBass))
	{
		return FALSE;
	}


	//
	// Get the IMAGE_NT_HEADERS.
	//
	PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(KernelModuleBass);
	if (!NtHeaders)
	{
		return FALSE;
	}


	//
	// Walk the PE sections, looking for our target section.
	//
	PIMAGE_SECTION_HEADER SectionHeader = IMAGE_FIRST_SECTION(NtHeaders);
	for (USHORT i = 0; i < NtHeaders->FileHeader.NumberOfSections; ++i, ++SectionHeader)
	{
		if (!_strnicmp((const char*)SectionHeader->Name, SectionName, IMAGE_SIZEOF_SHORT_NAME))
		{
			*SizeOfSection = SectionHeader->SizeOfRawData;
			*SectionAddress = (PVOID)((uintptr_t)KernelModuleBass + SectionHeader->VirtualAddress);
			return TRUE;
		}
	}

	return FALSE;
}

NTSTATUS CPeModule::UnMappingFileToKernel(
	_In_opt_ PVOID BaseAddress
)
{
	return ZwUnmapViewOfSection(ZwCurrentProcess(), BaseAddress);
}

BOOLEAN CPeModule::GetSystemKernelModuleInfo(
	OUT WCHAR** SystemKernelModulePath,
	OUT PULONG_PTR SystemKernelModuleBase,
	OUT PULONG_PTR SystemKernelModuleSize
)
{

	NTSTATUS status;
	ULONG ulSize, i;
	PMODULES pModuleList;
	char* lpszKernelName = NULL;
	ANSI_STRING AnsiKernelModule;
	UNICODE_STRING UnicodeKernelModule;
	BOOLEAN bRet = TRUE;

	__try
	{
		status = ZwQuerySystemInformation(
			11,
			NULL,
			0,
			&ulSize
		);
		if (status != STATUS_INFO_LENGTH_MISMATCH)
		{
			return FALSE;
		}
		pModuleList = (PMODULES)ExAllocatePool(NonPagedPool, ulSize);
		if (pModuleList)
		{
			status = ZwQuerySystemInformation(
				11,
				pModuleList,
				ulSize,
				&ulSize
			);
			if (!NT_SUCCESS(status))
			{
				bRet = FALSE;
			}
		}
		if (!bRet)
		{
			if (pModuleList)
				ExFreePool(pModuleList);
			return FALSE;
		}
		*SystemKernelModulePath = (WCHAR*)ExAllocatePool(NonPagedPool, 260 * 2);
		if (*SystemKernelModulePath == NULL)
		{
			*SystemKernelModuleBase = 0;
			*SystemKernelModuleSize = 0;
			return FALSE;
		}

		lpszKernelName = pModuleList->smi[0].ModuleNameOffset + pModuleList->smi[0].ImageName;
		RtlInitAnsiString(&AnsiKernelModule, lpszKernelName);
		RtlAnsiStringToUnicodeString(&UnicodeKernelModule, &AnsiKernelModule, TRUE);

		RtlZeroMemory(*SystemKernelModulePath, 260 * 2);
		wcscat(*SystemKernelModulePath, L"\\SystemRoot\\system32\\");

		memcpy(
			*SystemKernelModulePath + wcslen(L"\\SystemRoot\\system32\\"),
			UnicodeKernelModule.Buffer,
			UnicodeKernelModule.Length
		);

		*SystemKernelModuleBase = (ULONG_PTR)pModuleList->smi[0].Base;
		*SystemKernelModuleSize = (ULONG_PTR)pModuleList->smi[0].Size;
		ExFreePool(pModuleList);
		RtlFreeUnicodeString(&UnicodeKernelModule);

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

	}
	return TRUE;
}


```

`HyperHideDrv/CPeModule.h`:

```h
#pragma once

#include <ntifs.h>

class CPeModule
{
public:
	/************************************************************************
*  Name : MappingPEFileInKernelSpace
*  Param: FilePath		        PE文件完整NT路径
*  Param: MappingBaseAddress	映射后的基地址 （OUT）
*  Param: MappingViewSize		文件映射大小   （OUT）
*  Ret  : BOOLEAN
*  将PE文件映射到内核空间，使用完成ZwUnmapViewOfSection释放
************************************************************************/
	static BOOLEAN MappingFileToKernel
	(
		IN WCHAR* FilePath,
		OUT PVOID* MappingBaseAddress,
		OUT ULONG_PTR* MappingViewSize);

	static NTSTATUS UnMappingFileToKernel(
		_In_opt_ PVOID BaseAddress
	);
	/************************************************************************
*  Name : GetImageSection
*  Param: KernelModuleBass	模块基址
*  Param: SectionName	    区段名 ".data"
*  Param: SizeOfSection		输出区段大小
*  Param: SectionAddress	输出区段地址
*  Ret  : BOOLEAN
*  获取指定模块区段地址和大小
************************************************************************/
	static BOOLEAN GetImageSection(
		IN PVOID KernelModuleBass,
		IN const char* SectionName,
		OUT PULONG SizeOfSection,
		OUT PVOID* SectionAddress
	);

	/************************************************************************
*  Name : GetSystemKernelModuleInfo
*  Param: SystemKernelModulePath	   输出模块路径
*  Param: SystemKernelModuleBase	   输出模块基址
*  Param: SystemKernelModuleSize	   输出模块大小
*  Ret  : BOOLEAN
*  获取系统模块基址、路径、大小
************************************************************************/
	static BOOLEAN GetSystemKernelModuleInfo(
		OUT WCHAR** SystemKernelModulePath,
		OUT PULONG_PTR SystemKernelModuleBase,
		OUT PULONG_PTR SystemKernelModuleSize










	);
};

#define SEC_IMAGE  0x01000000
```

`HyperHideDrv/DBGTOOL.c`:

```c
#include "ntddk.h"
#include "dbgtool.h"


p_save_handlentry createlist(){
	ULONG i;

	p_save_handlentry phead = (p_save_handlentry)ExAllocatePool(NonPagedPool, sizeof(_save_handlentry));
	p_save_handlentry ptail = phead;
	ptail->next = NULL;
	p_save_handlentry pnew = (p_save_handlentry)ExAllocatePool(NonPagedPool, sizeof(_save_handlentry));

	pnew->dbgProcessId = 0;
	pnew->dbgProcessStruct = 0;
	pnew->head = NULL;
	ptail->next = pnew;
	pnew->next = NULL;
	ptail->head = NULL;
	


	return phead;

}
// 插入链表 
p_save_handlentry insertlist(HANDLE dbgProcessId,
PEPROCESS dbgProcessStruct ,p_save_handlentry phead){


	

	p_save_handlentry p = phead->next;

	while (p != NULL)
	{
		if (p->next == NULL){
			break;
		}
		p = p->next;
	}

	p_save_handlentry pnew = (p_save_handlentry)ExAllocatePool(NonPagedPool, sizeof(_save_handlentry));
	
	pnew->dbgProcessId = dbgProcessId;
	pnew->dbgProcessStruct = dbgProcessStruct;




	p->next = pnew;
	pnew->next = NULL;
	pnew->head = p;

	
	return pnew;
}
p_save_handlentry querylist(p_save_handlentry phead, HANDLE dbgProcessId, PEPROCESS dbgProcessStruct){

	
	p_save_handlentry p = phead->next;
	while (p != NULL)
	{
		if (dbgProcessId!=NULL
			)
		{
			if (p->dbgProcessId == dbgProcessId){
				
				return p;
			}
		}
		
		if (dbgProcessStruct!=NULL
			)
		{
			if (p->dbgProcessStruct == dbgProcessStruct){
			
				return p;
			}

		}
		
		p = p->next;
	}


	return NULL;
}
//删除节点
void deletelist(p_save_handlentry pclid){
	p_save_handlentry p, pp;



	if (pclid->head != NULL){//头部
		p = pclid->head;
		pp = pclid->next;


		if (pp == NULL){//最后节点
			p->next = NULL;
			ExFreePool(pclid);
			
			return;
		}


		p->next = pp;//不是最后节点
		pp->head = p;
		ExFreePool(pclid);

		return;
	}
	

}

```

`HyperHideDrv/DRRWE.c`:

```c
#include "ntddk.h"
typedef  LONG DWORD;
typedef struct _THREAD_dr_List{
	LIST_ENTRY TList;
	DWORD   Dr0;
	DWORD   Dr1;
	DWORD   Dr2;
	DWORD   Dr3;
	DWORD   Dr6;
	DWORD   Dr7;
	DWORD  eflag;
	PETHREAD Thread;

}THREAD_dr_List, *PTHREAD_dr_List;


typedef struct _PROCESS_List{
	LIST_ENTRY PorcessList;
	PEPROCESS Process;
	KSPIN_LOCK loacl_lock;
	LIST_ENTRY ThreadList;
}PROCESS_List, *PPROCESS_List;

static KSPIN_LOCK g_lock;
static LIST_ENTRY DrRwList;
VOID InitListAndLock(){
	InitializeListHead(&DrRwList);
	KeInitializeSpinLock(&g_lock);
}

PPROCESS_List Dr_FindProcessList(PEPROCESS Process){
	KIRQL OldIrql;
	PLIST_ENTRY Entry;
	PROCESS_List *TempItem = NULL;
	PROCESS_List* DFind = NULL;
	KeAcquireSpinLock(&g_lock, &OldIrql);
	Entry = DrRwList.Flink;
	while (Entry!=&DrRwList)
	{
		TempItem = CONTAINING_RECORD(Entry, PROCESS_List, PorcessList);
	
		Entry = Entry->Flink;
		if (TempItem->Process==Process)
		{
			DFind = TempItem;
			break;
		}
	}
	KeReleaseSpinLock(&g_lock, OldIrql);
	return DFind;
}

PPROCESS_List Dr_AddProcessToList(PEPROCESS Process){
	PPROCESS_List TempItem;
	TempItem = (PPROCESS_List)ExAllocatePoolWithTag(NonPagedPool, sizeof(PROCESS_List), 'drrp');
	if (!TempItem)
	{
		return FALSE;
	}

	RtlZeroMemory(TempItem, sizeof(PROCESS_List));
	TempItem->Process = Process;
	InitializeListHead(&TempItem->ThreadList);
	KeInitializeSpinLock(&TempItem->loacl_lock);
	ExInterlockedInsertTailList(&DrRwList,&TempItem->PorcessList,&g_lock);
	if (TempItem != NULL)
	{

		return TempItem;
	}

	return FALSE;
}

VOID NTAPI Dr_ExFreeItem(PPROCESS_List Item)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&g_lock, &OldIrql);
	RemoveEntryList(&Item->PorcessList);
	KeReleaseSpinLock(&g_lock, OldIrql);
	ExFreePool(Item);
	return;


}

PTHREAD_dr_List Dr_AddThreadStructToList(PPROCESS_List DrRwListItem, PTHREAD_dr_List Struct){

	PTHREAD_dr_List TempItem;
	TempItem = (PTHREAD_dr_List)ExAllocatePoolWithTag(NonPagedPool, sizeof(THREAD_dr_List), 'drrt');
	if (!TempItem)
	{
		return FALSE;
	}
	RtlZeroMemory(TempItem, sizeof(THREAD_dr_List));


	TempItem->Dr0 = Struct->Dr0;
	TempItem->Dr1 = Struct->Dr1;
	TempItem->Dr2 = Struct->Dr2;
	TempItem->Dr3 = Struct->Dr3;
	TempItem->Dr6 = Struct->Dr6;
	TempItem->Dr7 = Struct->Dr7;
	TempItem->eflag = Struct->eflag;

	TempItem->Thread = Struct->Thread;


	
	ExInterlockedInsertTailList(&DrRwListItem->ThreadList, &TempItem->TList, &DrRwListItem->loacl_lock);
	if (TempItem != NULL)
	{

		return TempItem;
	}
}

PTHREAD_dr_List Dr_FindThreadContextByThreadList(PPROCESS_List DrRwListItem, PETHREAD Thread){
	KIRQL OldIrql;
	PLIST_ENTRY Entry;
	THREAD_dr_List *TempItem = NULL;
	THREAD_dr_List* DFind = NULL;
	KeAcquireSpinLock(&DrRwListItem->loacl_lock, &OldIrql);
	Entry = DrRwListItem->ThreadList.Flink;
	while (Entry != &DrRwListItem->ThreadList)
	{
		TempItem = CONTAINING_RECORD(Entry, THREAD_dr_List, TList);
		
		Entry = Entry->Flink;
		if (TempItem->Thread == Thread)
		{
			DFind = TempItem;
			break;
		}
	}

	KeReleaseSpinLock(&DrRwListItem->loacl_lock, OldIrql);

	return DFind;

}


PTHREAD_dr_List Dr_UpdataThreadContextByThreadList(PPROCESS_List DrRwListItem, PETHREAD Thread, PTHREAD_dr_List UpData){
	KIRQL OldIrql;
	PLIST_ENTRY Entry;
	THREAD_dr_List *TempItem = NULL;
	THREAD_dr_List* DFind = NULL;
	KeAcquireSpinLock(&DrRwListItem->loacl_lock, &OldIrql);
	Entry = DrRwListItem->ThreadList.Flink;
	while (Entry != &DrRwListItem->ThreadList)
	{
		TempItem = CONTAINING_RECORD(Entry, THREAD_dr_List, TList);
	
		Entry = Entry->Flink;
		if (TempItem->Thread == Thread)
		{
			
			DFind = TempItem;
			DFind->Dr0 = UpData->Dr0;
			DFind->Dr1 = UpData->Dr1;
			DFind->Dr2 = UpData->Dr2;
			DFind->Dr3 = UpData->Dr3;
			DFind->Dr6 = UpData->Dr6;
			DFind->Dr7 = UpData->Dr7;
			DFind->eflag = UpData->eflag;
			

			break;
		}
	}

	KeReleaseSpinLock(&DrRwListItem->loacl_lock, OldIrql);

	return DFind;

}


VOID NTAPI Dr_ExFreeTheadListItem(PPROCESS_List DrRwListItem, PTHREAD_dr_List Struct)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&DrRwListItem->loacl_lock, &OldIrql);

	RemoveEntryList(&Struct->TList);
	KeReleaseSpinLock(&DrRwListItem->loacl_lock, OldIrql);
	ExFreePool(Struct);
	return;


}

```

`HyperHideDrv/DRRWE.h`:

```h
#include <ntifs.h>

//typedef  LONG DWORD;
typedef struct _THREAD_dr_List{
	LIST_ENTRY TList;
	DWORD   Dr0;
	DWORD   Dr1;
	DWORD   Dr2;
	DWORD   Dr3;
	DWORD   Dr6;
	DWORD   Dr7;
	DWORD  eflag;
	PETHREAD Thread;

}THREAD_dr_List, *PTHREAD_dr_List;

#define HIDWORD(a) ((DWORD)((UINT64)(a) >> 32))
#define LODWORD(a) ((DWORD)((UINT64)(a)& 0x0000ffff))
typedef struct _PROCESS_List{
	LIST_ENTRY PorcessList;
	PEPROCESS Process;
	KSPIN_LOCK loacl_lock;
	LIST_ENTRY ThreadList;
}PROCESS_List, *PPROCESS_List;
EXTERN_C VOID InitListAndLock();
PPROCESS_List Dr_FindProcessList(PEPROCESS Process);
PPROCESS_List Dr_AddProcessToList(PEPROCESS Process);
VOID NTAPI Dr_ExFreeItem(PPROCESS_List Item);
PTHREAD_dr_List Dr_AddThreadStructToList(PPROCESS_List DrRwListItem, PTHREAD_dr_List Struct);
VOID NTAPI Dr_ExFreeTheadListItem(PPROCESS_List DrRwListItem, PTHREAD_dr_List Struct);
PTHREAD_dr_List Dr_FindThreadContextByThreadList(PPROCESS_List DrRwListItem, PETHREAD Thread);
PTHREAD_dr_List Dr_UpdataThreadContextByThreadList(PPROCESS_List DrRwListItem, PETHREAD Thread, PTHREAD_dr_List UpData);

```

`HyperHideDrv/DbgIsMyProcess.c`:

```c
#include "ntddk.h"

typedef struct _DbgProcess
{
	LIST_ENTRY64 DbgProcessList;
	PEPROCESS DebugProcess;
	PEPROCESS Process;
	POBJECT_TYPE DebugObject;
	HANDLE DbgHanle;
}DbgProcess, *PDbgProcess;

static LIST_ENTRY64 DbgList;
static KSPIN_LOCK d_lock;

VOID InitialzeDbgprocessList(){

	KeInitializeSpinLock(&d_lock);
	InitializeListHead(&DbgList);
}


PDbgProcess Debug_AddStructToList(PDbgProcess DbgStruct){
	PDbgProcess pstruct = NULL;
	if (MmIsAddressValid(DbgStruct)==TRUE)
	{
		pstruct = (PDbgProcess)ExAllocatePoolWithTag(NonPagedPool, sizeof(DbgProcess), "dbx");

		if (!pstruct)
		{
			return FALSE;
		}
		RtlZeroMemory(pstruct, sizeof(DbgProcess));

		pstruct->DbgHanle = DbgStruct->DbgHanle;
		pstruct->DebugObject = DbgStruct->DebugObject;
		pstruct->DebugProcess = DbgStruct->DebugProcess;
		pstruct->Process = DbgStruct->Process;
		ExInterlockedInsertTailList(&DbgList, &pstruct->DbgProcessList, &d_lock);
		return pstruct;
	}
	return FALSE;


}

VOID NTAPI Debug_ExFreeItem(PDbgProcess Item)
{
	KIRQL OldIrql;
	KeAcquireSpinLock(&d_lock, &OldIrql);
	RemoveEntryList(&Item->DbgProcessList);
	KeReleaseSpinLock(&d_lock, OldIrql);
	ExFreePool(Item);
	return;


}

PDbgProcess Debug_FindMyNeedData(PDbgProcess DbgStruct){
	DbgProcess*Temp = NULL;
	DbgProcess*RetFind = NULL;
	KIRQL irql;
	PLIST_ENTRY64 Entry = NULL;
if (MmIsAddressValid(DbgStruct)==TRUE)
{
	KeAcquireSpinLock(&d_lock, &irql);
	Entry = DbgList.Flink;
	while (Entry != &DbgList){
		Temp = CONTAINING_RECORD(Entry, DbgProcess, DbgProcessList);
		Entry= Entry->Flink;
		if (Temp->DbgHanle==DbgStruct->DbgHanle)
		{
			RetFind = Temp;
			break;
		}
		if (Temp->DebugObject == DbgStruct->DebugObject)
		{
			RetFind = Temp;
			break;
		}
		if (Temp->DebugProcess == DbgStruct->DebugProcess)
		{
			RetFind = Temp;
			break;
		}
		if (Temp->Process == DbgStruct->Process)
		{
			RetFind = Temp;
			break;
		}
		
	}


	KeReleaseSpinLock(&d_lock, irql);
}
return RetFind;

}
```

`HyperHideDrv/Dispatcher.cpp`:

```cpp
#pragma warning( disable : 4201)
//#include <ntddk.h>
#include "Ioctl.h"
#include "Hider.h"
#include "Utils.h"
#include "KuserSharedData.h"
#include "GlobalData.h"
#include "Peb.h"
#include "HypervisorGateway.h"
#include "Log.h"

extern HYPER_HIDE_GLOBAL_DATA g_HyperHide;

#include "CKernelDbg.h"
#define CTL_LOAD_DRIVER        0x800
#define CTL_UNLOAD_DRIVER      0x801
CKernelDbg CreateDebugger;
NTSTATUS DrvIOCTLDispatcher(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);
	NTSTATUS Status = STATUS_SUCCESS;

	switch (Stack->Parameters.DeviceIoControl.IoControlCode)
	{
	case CTL_CODE(FILE_DEVICE_UNKNOWN, CTL_LOAD_DRIVER, METHOD_BUFFERED, FILE_ANY_ACCESS):
	{
		//兜兵晒方象
		extern SYMBOLS_DATA g_SymbolsData;
		__try
		{
			memmove(&g_SymbolsData, Irp->AssociatedIrp.SystemBuffer, sizeof(SYMBOLS_DATA));
			LogInfo("CTL_LOAD_DRIVER:load symbols ok!");

		}_except(1)
		{
			LogInfo("CTL_LOAD_DRIVER:load symbols eeor!");
			break;
		}
		//兜兵晒Hook
		if (!CreateDebugger.StartKernelDbg())
		{
			LogInfo("CTL_LOAD_DRIVER:StartKernelDbg eeror!");
		}
		else
		{
			LogInfo("CTL_LOAD_DRIVER:KernelDebugger Succsess!");
		}

		break;
	}

	case IOCTL_ADD_HIDER_ENTRY:
	{
		ULONG* Pid = (ULONG*)Irp->AssociatedIrp.SystemBuffer;
		if (Hider::CreateEntry(IoGetCurrentProcess(), PidToProcess(*Pid)) == FALSE)
			Status = STATUS_UNSUCCESSFUL;
		else
			g_HyperHide.NumberOfActiveDebuggers++;
		break;
	}

	case IOCTL_REMOVE_HIDER_ENTRY:
	{
		ULONG* Pid = (ULONG*)Irp->AssociatedIrp.SystemBuffer;
		if (Hider::RemoveEntry(PidToProcess(*Pid)) == FALSE)
			Status = STATUS_UNSUCCESSFUL;
		else
			g_HyperHide.NumberOfActiveDebuggers--;
		break;
	}

	case IOCTL_HIDE_FROM_SYSCALL:
	{
		PHIDE_INFO HideInfo = (PHIDE_INFO)Irp->AssociatedIrp.SystemBuffer;

		if (Hider::Hide(HideInfo) == FALSE)
			Status = STATUS_UNSUCCESSFUL;
		break;
	}

	case IOCTL_PROCESS_RESUMED:
	{
		ULONG* Pid = (ULONG*)Irp->AssociatedIrp.SystemBuffer;
		UpdateDelta(PidToProcess(*Pid));
		if (Hider::ResumeCounterForProcess(PidToProcess(*Pid)) == FALSE)
			Status = STATUS_UNSUCCESSFUL;
		break;
	}

	case IOCTL_PROCESS_STOPPED:
	{
		ULONG* Pid = (ULONG*)Irp->AssociatedIrp.SystemBuffer;
		GetBegin(PidToProcess(*Pid));

		if (Hider::StopCounterForProcess(PidToProcess(*Pid)) == FALSE)
			Status = STATUS_UNSUCCESSFUL;
		break;
	}

	case IOCTL_CLEAR_PEB_DEBUGGER_FLAG:
	{
		ULONG* Pid = (ULONG*)Irp->AssociatedIrp.SystemBuffer;

		if (SetPebDeuggerFlag(PidToProcess(*Pid), FALSE) == FALSE)
			Status = STATUS_UNSUCCESSFUL;
		break;
	}

	case IOCTL_SET_PEB_DEBUGGER_FLAG:
	{
		ULONG* Pid = (ULONG*)Irp->AssociatedIrp.SystemBuffer;

		if (SetPebDeuggerFlag(PidToProcess(*Pid), TRUE) == FALSE)
			Status = STATUS_UNSUCCESSFUL;
		break;
	}

	case IOCTL_SET_HYPERVISOR_VISIBILITY:
	{
		BOOLEAN Value = *(BOOLEAN*)Irp->AssociatedIrp.SystemBuffer;
		hv::hypervisor_visible(Value);
		break;
	}

	}

	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Status;
}
```

`HyperHideDrv/Dispatcher.h`:

```h
#pragma once
#include <ntddk.h>
NTSTATUS DrvIOCTLDispatcher(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);
```

`HyperHideDrv/Driver.cpp`:

```cpp
#pragma warning( disable : 4201)

#include <ntifs.h>
#include "Log.h"
#include "Utils.h"
#include "HookedFunctions.h"
#include "GlobalData.h"
#include "HypervisorGateway.h"
#include "Dispatcher.h"
#include "Notifiers.h"
#include "Ssdt.h"
#include "Ntapi.h"
#include <intrin.h>
#include "dbgtool.h"

HYPER_HIDE_GLOBAL_DATA g_HyperHide = { 0 };
SYSTEM_DATA g_SystemData = { 0 };


VOID DrvUnload(PDRIVER_OBJECT  DriverObject)
{
	Hider::Uninitialize();

	LARGE_INTEGER WaitTime;
	WaitTime.QuadPart = -1000000LL; // 100ms
	KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);

	PsRemoveCreateThreadNotifyRoutine(ThreadNotifyRoutine);
	PsSetCreateProcessNotifyRoutine(ProcessNotifyRoutine, TRUE);

	hv::unhook_all_functions();

	KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);

	UNICODE_STRING DosDeviceName;
	RtlInitUnicodeString(&DosDeviceName, L"\\DosDevices\\HyperDbg");
	IoDeleteSymbolicLink(&DosDeviceName);

	IoDeleteDevice(DriverObject->DeviceObject);

	LogInfo("Driver Unloaded");
}

NTSTATUS DrvClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status = STATUS_SUCCESS;

	if (Hider::RemoveEntry(IoGetCurrentProcess()) == FALSE) 
		Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	
	return STATUS_SUCCESS;
}

NTSTATUS DrvCreate(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

extern "C"
NTSTATUS DriverEntry(PDRIVER_OBJECT Driver, PCUNICODE_STRING Reg)
{
	UNREFERENCED_PARAMETER(Reg);
	
	PDEVICE_OBJECT DeviceObject;
	UNICODE_STRING DriverName, DosDeviceName;
	OSVERSIONINFOW OsVersion;

	RtlGetVersion(&OsVersion);
	g_HyperHide.CurrentWindowsBuildNumber = OsVersion.dwBuildNumber;

	__try
	{
		if (hv::test_vmcall() == FALSE)
			return STATUS_UNSUCCESSFUL;
	}
	__except (EXCEPTION_EXECUTE_HANDLER) 
	{
		return STATUS_UNSUCCESSFUL;
	}
	 
	LogInfo("HyperVisor On");

	if (GetOffsets() == FALSE)
		return STATUS_UNSUCCESSFUL;

	LogInfo("Got offsets");

	if (SSDT::FindCodeCaves() == FALSE) 
		return STATUS_UNSUCCESSFUL;

	LogInfo("Got code caves");

	if (SSDT::GetSsdt() == FALSE)
		return STATUS_UNSUCCESSFUL;

	LogInfo("Got Ssdt");

	if (Hider::Initialize() == FALSE) 
		return STATUS_UNSUCCESSFUL;

	LogInfo("Hider Initialized");

	if(NT_SUCCESS(PsSetCreateThreadNotifyRoutine(ThreadNotifyRoutine)) == FALSE)
	{
		Hider::Uninitialize();
		return STATUS_UNSUCCESSFUL;
	}

	LogInfo("PsSetCreateThreadNotifyRoutine succeded");

	if (NT_SUCCESS(PsSetCreateProcessNotifyRoutine(ProcessNotifyRoutine, FALSE)) == FALSE)
	{
		Hider::Uninitialize();
		PsRemoveCreateThreadNotifyRoutine(ThreadNotifyRoutine);
		return STATUS_UNSUCCESSFUL;
	}

	LogInfo("PsSetCreateProcessNotifyRoutine succeded");

	if(HookSyscalls() == FALSE)
	{
		hv::unhook_all_functions();
		PsRemoveCreateThreadNotifyRoutine(ThreadNotifyRoutine);
		PsSetCreateProcessNotifyRoutine(ProcessNotifyRoutine, TRUE);
		Hider::Uninitialize();
		return STATUS_UNSUCCESSFUL;
	}

	LogInfo("Syscalls Hooked");

	RtlInitUnicodeString(&DriverName, L"\\Device\\HyperDbg");
	RtlInitUnicodeString(&DosDeviceName, L"\\DosDevices\\HyperDbg");
	
	IoCreateDevice(Driver, 0, &DriverName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &DeviceObject);

	Driver->MajorFunction[IRP_MJ_CLOSE] = DrvClose;
	Driver->MajorFunction[IRP_MJ_CREATE] = DrvCreate;
	Driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DrvIOCTLDispatcher;

	Driver->DriverUnload = DrvUnload;
	Driver->Flags |= DO_BUFFERED_IO;

	IoCreateSymbolicLink(&DosDeviceName, &DriverName);
	
	LogInfo("Driver initialized");
	
	return STATUS_SUCCESS;
}
```

`HyperHideDrv/GlobalData.h`:

```h
#pragma once
#define KUSER_SHARED_DATA_USERMODE 0x7FFE0000
#define KUSER_SHARED_DATA_KERNELMODE 0xFFFFF78000000000
#define DRIVER_TAG 'dHyH'
#define WINDOWS_7 7600
#define WINDOWS_7_SP1 7601
#define WINDOWS_8 9200
#define WINDOWS_8_1 9600
#define WINDOWS_10_VERSION_THRESHOLD1 10240
#define WINDOWS_10_VERSION_THRESHOLD2 10586
#define WINDOWS_10_VERSION_REDSTONE1 14393
#define WINDOWS_10_VERSION_REDSTONE2 15063
#define WINDOWS_10_VERSION_REDSTONE3 16299
#define WINDOWS_10_VERSION_REDSTONE4 17134
#define WINDOWS_10_VERSION_REDSTONE5 17763
#define WINDOWS_10_VERSION_19H1 18362
#define WINDOWS_10_VERSION_19H2 18363
#define WINDOWS_10_VERSION_20H1 19041
#define WINDOWS_10_VERSION_20H2 19042
#define WINDOWS_10_VERSION_21H1 19043
#define WINDOWS_10_VERSION_21H2 19044
#define WINDOWS_11 22000


typedef struct _HYPER_HIDE_GLOBAL_DATA 
{
	ULONG CurrentWindowsBuildNumber;
	ULONG NumberOfActiveDebuggers;
}HYPER_HIDE_GLOBAL_DATA,*PHYPER_HIDE_GLOBAL_DATA;

typedef struct _SYSTEM_DATA
{

	//模块相关
	WCHAR* KernelModuleName;
	ULONG_PTR     KernelModuleBass;
	ULONG_PTR     KernelModuleSize;


	//线程相关
	ULONG_PTR          PreviousModeOffset;


} SYSTEM_DATA, * PSYSTEM_DATA;
extern SYSTEM_DATA g_SystemData;
```

`HyperHideDrv/Header.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntimage.h>
#include <intrin.h>
#include <ntstrsafe.h>
#include "struct.h"
#include "KernelDbgStruct.h"
#include "KernelExportAPI.h"
#include "KernelApi.h"
#include "CFunction.h"
#include "Memroy.h"
#include "获取汇编指令长度.h"
#include "CKernelTable.h"
#include "CKernelDbg.h"
```

`HyperHideDrv/Heap.cpp`:

```cpp
#pragma warning( disable : 4201 4100 4101 4244 4333 4245 4366)
//#include <ntddk.h>
#include <ntifs.h>
#include "Ntapi.h"
#include "Log.h"
#include "Heap.h"
#include "Peb.h"

#define HEAP_SKIP_VALIDATION_CHECKS 0x10000000  
#define HEAP_VALIDATE_PARAMETERS_ENABLED  0x40000000

BOOLEAN ClearHeapFlags(PEPROCESS TargetProcess)
{
	PPEB Peb = (PPEB)PsGetProcessPeb(TargetProcess);
	PPEB32 Peb32 = (PPEB32)PsGetProcessWow64Process(TargetProcess);

	// https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/heap-flags/
	// In all versions of Windows, the value of the Flags 
	// field is normally set to HEAP_GROWABLE(2), 
	// and the ForceFlags field is normally set to 0

	// 32-bit process.Both of these default values depend on the[subsystem] of its host process
	if (Peb32 != NULL)
	{
		KAPC_STATE State;
		KeStackAttachProcess((PRKPROCESS)TargetProcess, &State);

		__try
		{
			for (size_t i = 0; i < Peb32->NumberOfHeaps; i++)
			{
				ULONG Heap = *(ULONG*)(Peb32->ProcessHeaps + 4 * i);

				// Heap Flags
				*(ULONG*)(Heap + 0x40) &= ~(HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED | HEAP_SKIP_VALIDATION_CHECKS | HEAP_VALIDATE_PARAMETERS_ENABLED);

				// Heap Force Flags
				*(ULONG*)(Heap + 0x44) &= ~(HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED | HEAP_VALIDATE_PARAMETERS_ENABLED);
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER) 
		{
			LogError("Access violation");
			KeUnstackDetachProcess(&State);
			return FALSE;
		}

		KeUnstackDetachProcess(&State);
	}

	if (Peb != NULL)
	{
		KAPC_STATE State;
		KeStackAttachProcess((PRKPROCESS)TargetProcess, &State);

		__try 
		{
			for (size_t i = 0; i < Peb->NumberOfHeaps; i++)
			{
				PHEAP Heap = (PHEAP)Peb->ProcessHeaps;
				Heap->Flags &= ~(HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED | HEAP_SKIP_VALIDATION_CHECKS | HEAP_VALIDATE_PARAMETERS_ENABLED);
				Heap->ForceFlags &= ~(HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED | HEAP_VALIDATE_PARAMETERS_ENABLED);
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			LogError("Access violation");
			KeUnstackDetachProcess(&State);
			return FALSE;
		}

		KeUnstackDetachProcess(&State);
	}
	else
	{
		LogError("Both Peb and Peb32 doesn't exist");
		return FALSE;
	}

	return TRUE;
}
```

`HyperHideDrv/Heap.h`:

```h
#pragma once
#ifndef _NTIFS_H
#define _NTIFS_H
#include <ntifs.h>
#endif // !_NTIFS_H

typedef struct _HEAP_UNPACKED_ENTRY
{
    VOID* PreviousBlockPrivateData;                                         //0x0
    union
    {
        struct
        {
            USHORT Size;                                                    //0x8
            UCHAR Flags;                                                    //0xa
            UCHAR SmallTagIndex;                                            //0xb
        }set1;
        struct
        {
            ULONG SubSegmentCode;                                           //0x8
            USHORT PreviousSize;                                            //0xc
            union
            {
                UCHAR SegmentOffset;                                        //0xe
                UCHAR LFHFlags;                                             //0xe
            };
            UCHAR UnusedBytes;                                              //0xf
        }set2;
        ULONGLONG CompactHeader;                                            //0x8
    };
}HEAP_UNPACKED_ENTRY, * PHEAP_UNPACKED_ENTRY;

typedef struct _HEAP_EXTENDED_ENTRY
{
    VOID* Reserved;                                                         //0x0
    union
    {
        struct
        {
            USHORT FunctionIndex;                                           //0x8
            USHORT ContextValue;                                            //0xa
        };
        ULONG InterceptorValue;                                             //0x8
    };
    USHORT UnusedBytesLength;                                               //0xc
    UCHAR EntryOffset;                                                      //0xe
    UCHAR ExtendedBlockSignature;                                           //0xf
}HEAP_EXTENDED_ENTRY, * PHEAP_EXTENDED_ENTRY;

typedef struct _HEAP_ENTRY
{
    union
    {
        HEAP_UNPACKED_ENTRY UnpackedEntry;                          //0x0
        struct
        {
            VOID* PreviousBlockPrivateData;                                 //0x0
            union
            {
                struct
                {
                    USHORT Size;                                            //0x8
                    UCHAR Flags;                                            //0xa
                    UCHAR SmallTagIndex;                                    //0xb
                };
                struct
                {
                    ULONG SubSegmentCode;                                   //0x8
                    USHORT PreviousSize;                                    //0xc
                    union
                    {
                        UCHAR SegmentOffset;                                //0xe
                        UCHAR LFHFlags;                                     //0xe
                    };
                    UCHAR UnusedBytes;                                      //0xf
                };
                ULONGLONG CompactHeader;                                    //0x8
            };
        };
        HEAP_EXTENDED_ENTRY ExtendedEntry;                          //0x0
        struct
        {
            VOID* Reserved;                                                 //0x0
            union
            {
                struct
                {
                    USHORT FunctionIndex;                                   //0x8
                    USHORT ContextValue;                                    //0xa
                };
                ULONG InterceptorValue;                                     //0x8
            };
            USHORT UnusedBytesLength;                                       //0xc
            UCHAR EntryOffset;                                              //0xe
            UCHAR ExtendedBlockSignature;                                   //0xf
        };
        struct
        {
            VOID* ReservedForAlignment;                                     //0x0
            union
            {
                struct
                {
                    ULONG Code1;                                            //0x8
                    union
                    {
                        struct
                        {
                            USHORT Code2;                                   //0xc
                            UCHAR Code3;                                    //0xe
                            UCHAR Code4;                                    //0xf
                        };
                        ULONG Code234;                                      //0xc
                    };
                };
                ULONGLONG AgregateCode;                                     //0x8
            };
        };
    };
}HEAP_ENTRY, * PHEAP_ENTRY;

typedef struct _HEAP_SEGMENT
{
    HEAP_ENTRY Entry;                                                       //0x0
    ULONG SegmentSignature;                                                 //0x10
    ULONG SegmentFlags;                                                     //0x14
    LIST_ENTRY SegmentListEntry;                                            //0x18
    VOID* Heap;                                                             //0x28
    VOID* BaseAddress;                                                      //0x30
    ULONG NumberOfPages;                                                    //0x38
    HEAP_ENTRY* FirstEntry;                                                 //0x40
    HEAP_ENTRY* LastValidEntry;                                             //0x48
    ULONG NumberOfUnCommittedPages;                                         //0x50
    ULONG NumberOfUnCommittedRanges;                                        //0x54
    USHORT SegmentAllocatorBackTraceIndex;                                  //0x58
    USHORT Reserved;                                                        //0x5a
    LIST_ENTRY UCRSegmentList;                                              //0x60
}HEAP_SEGMENT, * PHEAP_SEGMENT;

typedef struct _HEAP_TAG_ENTRY
{
    ULONG Allocs;                                                           //0x0
    ULONG Frees;                                                            //0x4
    ULONGLONG Size;                                                         //0x8
    USHORT TagIndex;                                                        //0x10
    USHORT CreatorBackTraceIndex;                                           //0x12
    WCHAR TagName[24];                                                      //0x14
}HEAP_TAG_ENTRY, * PHEAP_TAG_ENTRY;

typedef struct _HEAP_PSEUDO_TAG_ENTRY
{
    ULONG Allocs;                                                           //0x0
    ULONG Frees;                                                            //0x4
    ULONGLONG Size;                                                         //0x8
}HEAP_PSEUDO_TAG_ENTRY, * PHEAP_PSEUDO_TAG_ENTRY;

//typedef struct _HEAP_LOCK
//{
//    union
//    {
//        RTL_CRITICAL_SECTION CriticalSection;                       //0x0
//        ERESOURCE Resource;                                         //0x0
//    } Lock;                                                                 //0x0
//}HEAP_LOCK, * PHEAP_LOCK;

//typedef struct _RTL_HEAP_MEMORY_LIMIT_DATA
//{
//    ULONGLONG CommitLimitBytes;                                             //0x0
//    ULONGLONG CommitLimitFailureCode;                                       //0x8
//    ULONGLONG MaxAllocationSizeBytes;                                       //0x10
//    ULONGLONG AllocationLimitFailureCode;                                   //0x18
//}RTL_HEAP_MEMORY_LIMIT_DATA, * PRTL_HEAP_MEMORY_LIMIT_DATA;

typedef struct _HEAP_COUNTERS
{
    ULONGLONG TotalMemoryReserved;                                          //0x0
    ULONGLONG TotalMemoryCommitted;                                         //0x8
    ULONGLONG TotalMemoryLargeUCR;                                          //0x10
    ULONGLONG TotalSizeInVirtualBlocks;                                     //0x18
    ULONG TotalSegments;                                                    //0x20
    ULONG TotalUCRs;                                                        //0x24
    ULONG CommittOps;                                                       //0x28
    ULONG DeCommitOps;                                                      //0x2c
    ULONG LockAcquires;                                                     //0x30
    ULONG LockCollisions;                                                   //0x34
    ULONG CommitRate;                                                       //0x38
    ULONG DecommittRate;                                                    //0x3c
    ULONG CommitFailures;                                                   //0x40
    ULONG InBlockCommitFailures;                                            //0x44
    ULONG PollIntervalCounter;                                              //0x48
    ULONG DecommitsSinceLastCheck;                                          //0x4c
    ULONG HeapPollInterval;                                                 //0x50
    ULONG AllocAndFreeOps;                                                  //0x54
    ULONG AllocationIndicesActive;                                          //0x58
    ULONG InBlockDeccommits;                                                //0x5c
    ULONGLONG InBlockDeccomitSize;                                          //0x60
    ULONGLONG HighWatermarkSize;                                            //0x68
    ULONGLONG LastPolledSize;                                               //0x70
}HEAP_COUNTERS, * PHEAP_COUNTERS;

typedef struct _HEAP_TUNING_PARAMETERS
{
    ULONG CommittThresholdShift;                                            //0x0
    ULONGLONG MaxPreCommittThreshold;                                       //0x8
}HEAP_TUNING_PARAMETERS, * PHEAP_TUNING_PARAMETERS;

typedef struct _HEAP
{
    union
    {
        HEAP_SEGMENT Segment;                                       //0x0
        struct
        {
            HEAP_ENTRY Entry;                                       //0x0
            ULONG SegmentSignature;                                         //0x10 //0x8
            ULONG SegmentFlags;                                             //0x14 //0xC
            LIST_ENTRY SegmentListEntry;                                    //0x18  //0x10
            VOID* Heap;                                                     //0x28  //0x18
            VOID* BaseAddress;                                              //0x30  //0x1c
            ULONG NumberOfPages;                                            //0x38  //0x20
            HEAP_ENTRY* FirstEntry;                                         //0x40  //0x24
            HEAP_ENTRY* LastValidEntry;                                     //0x48  //0x28
            ULONG NumberOfUnCommittedPages;                                 //0x50  //0x2c
            ULONG NumberOfUnCommittedRanges;                                //0x54
            USHORT SegmentAllocatorBackTraceIndex;                          //0x58
            USHORT Reserved;                                                //0x5a
            LIST_ENTRY UCRSegmentList;                                      //0x60
        };
    };
    ULONG Flags;                                                            //0x70
    ULONG ForceFlags;                                                       //0x74
    ULONG CompatibilityFlags;                                               //0x78
    ULONG EncodeFlagMask;                                                   //0x7c
    HEAP_ENTRY Encoding;                                                    //0x80
    ULONG Interceptor;                                                      //0x90
    ULONG VirtualMemoryThreshold;                                           //0x94
    ULONG Signature;                                                        //0x98
    ULONGLONG SegmentReserve;                                               //0xa0
    ULONGLONG SegmentCommit;                                                //0xa8
    ULONGLONG DeCommitFreeBlockThreshold;                                   //0xb0
    ULONGLONG DeCommitTotalFreeThreshold;                                   //0xb8
    ULONGLONG TotalFreeSize;                                                //0xc0
    ULONGLONG MaximumAllocationSize;                                        //0xc8
    USHORT ProcessHeapsListIndex;                                           //0xd0
    USHORT HeaderValidateLength;                                            //0xd2
    VOID* HeaderValidateCopy;                                               //0xd8
    USHORT NextAvailableTagIndex;                                           //0xe0
    USHORT MaximumTagIndex;                                                 //0xe2
    PHEAP_TAG_ENTRY TagEntries;                                     //0xe8
    LIST_ENTRY UCRList;                                             //0xf0
    ULONGLONG AlignRound;                                                   //0x100
    ULONGLONG AlignMask;                                                    //0x108
    LIST_ENTRY VirtualAllocdBlocks;                                 //0x110
    LIST_ENTRY SegmentList;                                         //0x120
    USHORT AllocatorBackTraceIndex;                                         //0x130
    ULONG NonDedicatedListLength;                                           //0x134
    VOID* BlocksIndex;                                                      //0x138
    VOID* UCRIndex;                                                         //0x140
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;                        //0x148
    LIST_ENTRY FreeLists;                                           //0x150
    PVOID LockVariable;                                        //0x160
    LONG(*CommitRoutine)(VOID* arg1, VOID** arg2, ULONGLONG* arg3);        //0x168
    RTL_RUN_ONCE StackTraceInitVar;                                  //0x170
    VOID* CommitLimitData;                     //0x178
    VOID* FrontEndHeap;                                                     //0x198
    USHORT FrontHeapLockCount;                                              //0x1a0
    UCHAR FrontEndHeapType;                                                 //0x1a2
    UCHAR RequestedFrontEndHeapType;                                        //0x1a3
    WCHAR* FrontEndHeapUsageData;                                           //0x1a8
    USHORT FrontEndHeapMaximumIndex;                                        //0x1b0
    volatile UCHAR FrontEndHeapStatusBitmap[129];                           //0x1b2
    HEAP_COUNTERS Counters;                                         //0x238
    HEAP_TUNING_PARAMETERS TuningParameters;                        //0x2b0
}HEAP, * PHEAP;

BOOLEAN ClearHeapFlags(PEPROCESS pProcess);
```

`HyperHideDrv/Hider.cpp`:

```cpp
#pragma warning( disable : 4201)
//#include <ntddk.h>
#include "Utils.h"
#include "Hider.h"
#include "GlobalData.h"
#include "Log.h"
#include "Ntapi.h"
#include "KuserSharedData.h"
#include "Peb.h"
#include "Heap.h"

namespace Hider
{
	KGUARDED_MUTEX HiderMutex;
	LIST_ENTRY HiddenProcessesHead;
	BOOLEAN StopCounterThread = FALSE;
	HANDLE CounterThreadHandle = NULL;

	PWCH HiddenDeviceNames[] =
	{
		L"\\??\\HyperDbg",
		L"\\??\\HyperVisor",
		L"\\??\\ProcmonDebugLogger",
	};
	
	PWCH HiddenWindowNames[] =
	{
		L"x64dbg",
		L"x32dbg",
		L"Process Hacker",
		L"Import reconstructor",
		L"[CPU",
		L"Debug",
		L"scylla",
		L"HyperHide",
		L"disassembly",
		L"ida"
		L"HyperHide"
		L"Sysinternals"
	};

	PWCH HiddenApplicationNames[] =
	{
		L"ollydbg.exe",
		L"ida.exe",
		L"ida64.exe",
		L"idag.exe",
		L"idag64.exe",
		L"idaw.exe",
		L"idaw64.exe",
		L"idaq.exe",
		L"idaq64.exe",
		L"idau.exe",
		L"idau64.exe",
		L"scylla.exe",
		L"scylla_x64.exe",
		L"scylla_x86.exe",
		L"protection_id.exe",
		L"x64dbg.exe",
		L"x32dbg.exe",
		L"reshacker.exe",
		L"ImportREC.exe",
		L"devenv.exe",
		L"ProcessHacker.exe",
		L"tcpview.exe",
		L"autoruns.exe",
		L"autorunsc.exe",
		L"filemon.exe",
		L"procmon.exe",
		L"regmon.exe",
		L"wireshark.exe",
		L"dumpcap.exe",
		L"HookExplorer.exe",
		L"ImportRCE.exe",
		L"PETools.exe",
		L"LordPE.exe",
		L"SysInspector.exe",
		L"proc_analyzer.exe",
		L"sysAnalyzer.exe",
		L"sniff_hit.exe",
		L"joeboxcontrol.exe",
		L"joeboxserver.exe",
		L"ResourceHacker.exe",
		L"fiddler.exe",
		L"httpdebugger.exe",
		L"procexp64.exe",
		L"procexp.exe",
		L"Dbgview.exe",
		L"procmon64.exe"
	};

	PWCH HiddenWindowClassNames[] =
	{
		L"Qt5QWindowIcon" // Ida and x64dbg ClassNames
		L"ObsidianGUI",
		L"idawindow",
		L"tnavbox",
		L"idaview",
		L"tgrzoom"
	};

	VOID DeleteThreadList(PHIDDEN_PROCESS HiddenProcess)
	{
		PLIST_ENTRY CurrentThread = HiddenProcess->HiddenThreads.HiddenThreadList.Flink;
		while (CurrentThread != &HiddenProcess->HiddenThreads.HiddenThreadList)
		{
			PHIDDEN_THREAD HiddenThread = (PHIDDEN_THREAD)CONTAINING_RECORD(CurrentThread, HIDDEN_THREAD, HiddenThreadList);
			RemoveEntryList(CurrentThread);
			CurrentThread = CurrentThread->Flink;
			ExFreePoolWithTag(HiddenThread, DRIVER_TAG);
		}
	}

	//
	// Append and return.If thread struct already exist return it
	//
	PHIDDEN_THREAD AppendThreadList(PEPROCESS TargetProcess, PETHREAD ThreadObject)
	{
		PHIDDEN_THREAD HiddenThread = NULL;
		BOOLEAN Acquired = KeTryToAcquireGuardedMutex(&HiderMutex);
		
		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (HiddenProcess->DebuggedProcess == TargetProcess)
			{
				PLIST_ENTRY CurrentThread = HiddenProcess->HiddenThreads.HiddenThreadList.Flink;

				while (CurrentThread != &HiddenProcess->HiddenThreads.HiddenThreadList)
				{
					HiddenThread = (PHIDDEN_THREAD)CONTAINING_RECORD(CurrentThread, HIDDEN_THREAD, HiddenThreadList);
					CurrentThread = CurrentThread->Flink;
	
					if (HiddenThread->ThreadObject == ThreadObject)
						goto End;
				}

				HiddenThread = (PHIDDEN_THREAD)ExAllocatePoolWithTag(NonPagedPool, sizeof(HIDDEN_THREAD), DRIVER_TAG);
				if (HiddenThread == NULL)
					return NULL;

				RtlSecureZeroMemory(HiddenThread, sizeof(HIDDEN_THREAD));
				HiddenThread->ThreadObject = ThreadObject;

				InsertTailList(&HiddenProcess->HiddenThreads.HiddenThreadList, &HiddenThread->HiddenThreadList);
				break;
			}
		}

	End:
		if(Acquired == TRUE)
			KeReleaseGuardedMutex(&HiderMutex);

		return HiddenThread;
	}

	VOID TruncateThreadList(PEPROCESS TargetProcess, PETHREAD ThreadObject)
	{
		KeAcquireGuardedMutex(&HiderMutex);
		
		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (HiddenProcess->DebuggedProcess == TargetProcess)
			{
				PLIST_ENTRY CurrentThread = HiddenProcess->HiddenThreads.HiddenThreadList.Flink;
				while (CurrentThread != &HiddenProcess->HiddenThreads.HiddenThreadList)
				{
					PHIDDEN_THREAD HiddenThread = (PHIDDEN_THREAD)CONTAINING_RECORD(CurrentThread, HIDDEN_THREAD, HiddenThreadList);
					CurrentThread = CurrentThread->Flink;

					if (HiddenThread->ThreadObject == ThreadObject)
					{
						RemoveEntryList(&HiddenThread->HiddenThreadList);
						ExFreePoolWithTag(HiddenThread, DRIVER_TAG);

						goto End;
					}
				}
			}
		}

	End:
		KeReleaseGuardedMutex(&HiderMutex);
	}

	PHIDDEN_PROCESS QueryHiddenProcess(PEPROCESS TargetProcess)
	{
		KeAcquireGuardedMutex(&HiderMutex);

		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (HiddenProcess->DebuggedProcess == TargetProcess)
			{
				KeReleaseGuardedMutex(&HiderMutex);
				return HiddenProcess;
			}
		}

		KeReleaseGuardedMutex(&HiderMutex);
		return NULL;
	}

	BOOLEAN StopCounterForProcess(PEPROCESS TargetProcess)
	{
		BOOLEAN Status = FALSE;

		if (TargetProcess == NULL)
		{
			LogError("Debugger process equal null");
			return Status;
		}

		KeAcquireGuardedMutex(&HiderMutex);
		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (TargetProcess == HiddenProcess->DebuggedProcess)
			{
				Status = HiddenProcess->ProcessPaused = TRUE;
				break;
			}
		}

		KeReleaseGuardedMutex(&HiderMutex);
		return Status;
	}

	BOOLEAN ResumeCounterForProcess(PEPROCESS TargetProcess)
	{
		BOOLEAN Status = FALSE;
		if (TargetProcess == NULL)
		{
			LogError("Debugger process equal null");
			return Status;
		}

		KeAcquireGuardedMutex(&HiderMutex);
		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (TargetProcess == HiddenProcess->DebuggedProcess)
			{
				HiddenProcess->ProcessPaused = FALSE;
				Status = TRUE;
				break;
			}
		}

		KeReleaseGuardedMutex(&HiderMutex);
		return Status;
	}

	BOOLEAN Initialize()
	{
		InitializeListHead(&HiddenProcessesHead);
		KeInitializeGuardedMutex(&HiderMutex);

		if (GetPfnDatabase() == FALSE)
		{
			LogError("Couldn't get pfn database");
			return FALSE;
		}

		if (NT_SUCCESS(PsCreateSystemThread(&CounterThreadHandle, 0, 0, 0, 0, CounterUpdater, NULL)) == FALSE)
		{
			LogError("Couldn't create system thread");
			return FALSE;
		}

		return TRUE;
	}

	VOID Uninitialize()
	{
		PETHREAD CounterThread;
		ObReferenceObjectByHandle(CounterThreadHandle, NULL, *PsThreadType, KernelMode, (PVOID*)&CounterThread, NULL);
		StopCounterThread = TRUE;
		KeWaitForSingleObject(CounterThread, Executive, KernelMode, FALSE, NULL);
		ObDereferenceObject(CounterThread);
		ZwClose(CounterThreadHandle);

		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (HiddenProcess->HiddenThreads.HiddenThreadList.Flink != NULL)
			{
				if (HiddenProcess->HideTypes[HIDE_KUSER_SHARED_DATA] == TRUE)
				{
					HiddenProcess->Kusd.PteKuserSharedData->Fields.PhysicalAddress = HiddenProcess->Kusd.OriginalKuserSharedDataPfn;
					MmFreeContiguousMemory(HiddenProcess->Kusd.KuserSharedData);
				}

				PLIST_ENTRY CurrentThread = HiddenProcess->HiddenThreads.HiddenThreadList.Flink;
				while (CurrentThread != &HiddenProcess->HiddenThreads.HiddenThreadList)
				{
					PHIDDEN_THREAD HiddenThread = (PHIDDEN_THREAD)CONTAINING_RECORD(CurrentThread, HIDDEN_THREAD, HiddenThreadList);
					CurrentThread = CurrentThread->Flink;
					ExFreePoolWithTag(HiddenThread, DRIVER_TAG);
				}
			}

			ExFreePoolWithTag(HiddenProcess, DRIVER_TAG);
		}

	}

	BOOLEAN CreateEntry(PEPROCESS DebuggerProcess, PEPROCESS DebuggedProcess)
	{
		PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)ExAllocatePoolWithTag(NonPagedPool, sizeof(HIDDEN_PROCESS), DRIVER_TAG);
		if (HiddenProcess == NULL)
		{
			LogError("Allocation failed");
			return FALSE;
		}
		RtlSecureZeroMemory(HiddenProcess, sizeof(HIDDEN_PROCESS));

		HiddenProcess->DebuggedProcess = DebuggedProcess;
		HiddenProcess->DebuggerProcess = DebuggerProcess;

		KeAcquireGuardedMutex(&HiderMutex);
		InsertTailList(&HiddenProcessesHead, &HiddenProcess->HiddenProcessesList);
		InitializeListHead(&HiddenProcess->HiddenThreads.HiddenThreadList);
		KeReleaseGuardedMutex(&HiderMutex);

		return TRUE;
	}

	BOOLEAN RemoveEntry(PEPROCESS TargetProcess)
	{
		if (TargetProcess == NULL)
		{
			LogError("Target process equal null");
			return FALSE;
		}

		KeAcquireGuardedMutex(&HiderMutex);

		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (HiddenProcess->DebuggedProcess == TargetProcess || HiddenProcess->DebuggerProcess == TargetProcess)
			{
				DeleteThreadList(HiddenProcess);

				RemoveEntryList(Current->Blink);

				if (HiddenProcess->Kusd.KuserSharedData != NULL)
				{
					UnHookKuserSharedData(HiddenProcess);
				}

				ExFreePoolWithTag(HiddenProcess, DRIVER_TAG);
			}
		}

		KeReleaseGuardedMutex(&HiderMutex);
		return TRUE;
	}

	BOOLEAN IsDebuggerProcess(PEPROCESS TargetProcess)
	{
		BOOLEAN Status = FALSE;
		if (TargetProcess == NULL)
		{
			LogError("Target process equal null");
			return Status;
		}

		KeAcquireGuardedMutex(&HiderMutex);

		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (HiddenProcess->DebuggerProcess == TargetProcess)
			{
				Status = TRUE;
				break;
			}
		}

		KeReleaseGuardedMutex(&HiderMutex);
		return Status;
	}

	BOOLEAN IsHidden(PEPROCESS TargetProcess, HIDE_TYPE HideType)
	{
		BOOLEAN Status = FALSE;
		if (HideType >= HIDE_LAST)
		{
			LogError("Wrong hide type");
			return Status;
		}

		KeAcquireGuardedMutex(&HiderMutex);

		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (HiddenProcess->DebuggedProcess == TargetProcess)
			{
				Status = HiddenProcess->HideTypes[HideType];
				break;
			}
		}

		KeReleaseGuardedMutex(&HiderMutex);
		return Status;
	}

	BOOLEAN Hide(PHIDE_INFO HideInfo)
	{
		PEPROCESS TargetProcess = PidToProcess(HideInfo->Pid);

		if (TargetProcess == NULL)
		{
			LogError("Process with pid: %d doesn't exist", HideInfo->Pid);
			return FALSE;
		}

		KeAcquireGuardedMutex(&HiderMutex);

		PLIST_ENTRY Current = HiddenProcessesHead.Flink;
		while (Current != &HiddenProcessesHead)
		{
			PHIDDEN_PROCESS HiddenProcess = (PHIDDEN_PROCESS)CONTAINING_RECORD(Current, HIDDEN_PROCESS, HiddenProcessesList);
			Current = Current->Flink;

			if (HiddenProcess->DebuggedProcess == TargetProcess)
			{
				if (HideInfo->HookKuserSharedData == TRUE && HiddenProcess->HideTypes[HIDE_KUSER_SHARED_DATA] == FALSE)
					HookKuserSharedData(HiddenProcess);

				else if (HideInfo->HookKuserSharedData == FALSE && HiddenProcess->HideTypes[HIDE_KUSER_SHARED_DATA] == TRUE)
					UnHookKuserSharedData(HiddenProcess);

				if (HideInfo->HookNtSetInformationThread == TRUE && HiddenProcess->HideTypes[HIDE_NT_SET_INFORMATION_THREAD] == FALSE)
					InitializeListHead(&HiddenProcess->HiddenThreads.HiddenThreadList);

				if (HideInfo->ClearHideFromDebuggerFlag == TRUE && HiddenProcess->HideFromDebuggerFlagCleared == FALSE) 
				{
					ClearThreadHideFromDebuggerFlag(HiddenProcess->DebuggedProcess);
					HiddenProcess->HideFromDebuggerFlagCleared = TRUE;
				}

				if (HideInfo->ClearBypassProcessFreeze == TRUE && HiddenProcess->BypassProcessFreezeFlagCleared == FALSE) 
				{
					ClearBypassProcessFreezeFlag(HiddenProcess->DebuggedProcess);
					HiddenProcess->BypassProcessFreezeFlagCleared = TRUE;
				}

				if (HideInfo->ClearPebBeingDebugged == TRUE && HiddenProcess->PebBeingDebuggedCleared == FALSE)
				{
					SetPebDeuggerFlag(HiddenProcess->DebuggedProcess, FALSE);
					HiddenProcess->PebBeingDebuggedCleared = TRUE;
				}

				if (HideInfo->ClearPebNtGlobalFlag == TRUE && HiddenProcess->PebNtGlobalFlagCleared == FALSE)
				{
					ClearPebNtGlobalFlag(HiddenProcess->DebuggedProcess);
					HiddenProcess->PebNtGlobalFlagCleared = TRUE;
				}

				if (HideInfo->ClearHeapFlags == TRUE && HiddenProcess->HeapFlagsCleared == FALSE)
				{
					ClearHeapFlags(HiddenProcess->DebuggedProcess);
					HiddenProcess->HeapFlagsCleared = TRUE;
				}

				if (HideInfo->ClearKuserSharedData == TRUE && HiddenProcess->KUserSharedDataCleared == FALSE)
				{
					if (HiddenProcess->Kusd.KuserSharedData != NULL)
					{
						HiddenProcess->Kusd.KuserSharedData->KdDebuggerEnabled = 0;
						HiddenProcess->KUserSharedDataCleared = TRUE;
					}
				}

				if (HideInfo->ClearProcessBreakOnTerminationFlag == TRUE && HiddenProcess->ProcessBreakOnTerminationCleared == FALSE)
				{
					ClearProcessBreakOnTerminationFlag(HiddenProcess);
					HiddenProcess->ProcessBreakOnTerminationCleared = TRUE;
				}

				if (HideInfo->ClearThreadBreakOnTerminationFlag == TRUE && HiddenProcess->ThreadBreakOnTerminationCleared == FALSE)
				{
					ClearThreadBreakOnTerminationFlags(HiddenProcess->DebuggedProcess);
					HiddenProcess->ThreadBreakOnTerminationCleared = TRUE;
				}

				if (HideInfo->SaveProcessDebugFlags == TRUE && HiddenProcess->ProcessDebugFlagsSaved == FALSE)
				{
					SaveProcessDebugFlags(HiddenProcess);
					HiddenProcess->ProcessDebugFlagsSaved = TRUE;
				}

				if (HideInfo->SaveProcessHandleTracing == TRUE && HiddenProcess->ProcessHandleTracingSaved == FALSE)
				{
					SaveProcessHandleTracing(HiddenProcess);
					HiddenProcess->ProcessHandleTracingSaved = TRUE;
				}

				RtlCopyBytes(&HiddenProcess->HideTypes[0], &HideInfo->HookNtQueryInformationProcess, HIDE_LAST);

				KeReleaseGuardedMutex(&HiderMutex);
				return TRUE;
			}
		}

		LogError("Process with pid %d isn't in list", HideInfo->Pid);
		KeReleaseGuardedMutex(&HiderMutex);
		return FALSE;
	}

	BOOLEAN IsDriverHandleHidden(PUNICODE_STRING SymLink)
	{
		if (SymLink->Buffer == NULL || SymLink->Length == NULL)
			return FALSE;

		UNICODE_STRING ForbiddenSymLink;

		for (ULONG64 i = 0; i < sizeof(HiddenDeviceNames) / sizeof(HiddenDeviceNames[0]); i++)
		{
			RtlInitUnicodeString(&ForbiddenSymLink, HiddenDeviceNames[i]);
			if (RtlCompareUnicodeString(&ForbiddenSymLink, SymLink, TRUE) == 0)
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	BOOLEAN IsProcessNameBad(PUNICODE_STRING ProcessName)
	{
		if (ProcessName->Buffer == NULL || ProcessName->Length == NULL)
			return FALSE;

		UNICODE_STRING CurrentProcessName = PsQueryFullProcessImageName(IoGetCurrentProcess());
		if (RtlCompareUnicodeString(ProcessName, &CurrentProcessName, FALSE) == 0)
			return FALSE;

		UNICODE_STRING ForbiddenProcessName;
		for (ULONG64 i = 0; i < sizeof(HiddenApplicationNames) / sizeof(HiddenApplicationNames[0]); i++)
		{
			RtlInitUnicodeString(&ForbiddenProcessName, HiddenApplicationNames[i]);
			if (RtlCompareUnicodeString(&ForbiddenProcessName, ProcessName, TRUE) == 0)
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	BOOLEAN IsProcessWindowBad(PUNICODE_STRING WindowName)
	{
		if (WindowName->Buffer == NULL || WindowName->Length == NULL)
			return FALSE;

		UNICODE_STRING ForbiddenWindowName;
		for (ULONG64 i = 0; i < sizeof(HiddenWindowNames) / sizeof(HiddenWindowNames[0]); i++)
		{
			RtlInitUnicodeString(&ForbiddenWindowName, HiddenWindowNames[i]);
			if (RtlUnicodeStringContains(WindowName, &ForbiddenWindowName, TRUE) == 0)
				return TRUE;
		}

		return FALSE;
	}

	BOOLEAN IsProcessWindowClassBad(PUNICODE_STRING WindowClassName)
	{
		if (WindowClassName->Buffer == NULL || WindowClassName->Length == NULL)
			return FALSE;

		UNICODE_STRING ForbbidenWindowClassName;

		for (ULONG64 i = 0; i < sizeof(HiddenWindowClassNames) / sizeof(HiddenWindowClassNames[0]); i++)
		{
			RtlInitUnicodeString(&ForbbidenWindowClassName, HiddenWindowClassNames[i]);
			if (RtlCompareUnicodeString(WindowClassName, &ForbbidenWindowClassName, FALSE) == 0)
				return TRUE;
		}

		return FALSE;
	}
}
```

`HyperHideDrv/Hider.h`:

```h
#pragma once
#include "Pte.h"

#ifndef _NTIFS_H
#define _NTIFS_H
#include <ntifs.h>
#endif // !_NTIFS_H

enum HIDE_TYPE
{
	HIDE_NT_QUERY_INFORMATION_PROCESS,		
	HIDE_NT_QUERY_SYSTEM_INFORMATION,
	HIDE_NT_QUERY_INFORMATION_THREAD,
	HIDE_NT_QUERY_INFORMATION_JOB_OBJECT,
	HIDE_NT_QUERY_OBJECT,
	HIDE_NT_QUERY_SYSTEM_TIME,
	HIDE_NT_QUERY_PERFORMANCE_COUNTER,
	HIDE_NT_CREATE_USER_PROCESS,
	HIDE_NT_CREATE_PROCESS_EX,
	HIDE_NT_CREATE_THREAD_EX,
	HIDE_NT_SET_CONTEXT_THREAD,
	HIDE_NT_GET_CONTEXT_THREAD,
	HIDE_NT_OPEN_PROCESS,
	HIDE_NT_OPEN_THREAD,
	HIDE_NT_SET_INFORMATION_THREAD,
	HIDE_NT_SYSTEM_DEBUG_CONTROL,	
	HIDE_NT_GET_NEXT_PROCESS,
	HIDE_NT_YIELD_EXECUTION,
	HIDE_NT_CREATE_FILE,
	HIDE_NT_CONTINUE,
	HIDE_NT_CLOSE,
	HIDE_NT_USER_BUILD_HWND_LIST,							  
	HIDE_NT_USER_FIND_WINDOW_EX,							  
	HIDE_NT_USER_QUERY_WINDOW,		
	HIDE_NT_USER_GET_FOREGROUND_WINDOW,
    HIDE_KUSER_SHARED_DATA,
	HIDE_KI_EXCEPTION_DISPATCH,
	HIDE_NT_SET_INFORMATION_PROCESS,
	HIDE_LAST
};

typedef struct _HIDE_INFO
{
	ULONG Pid;
	BOOLEAN HookNtQueryInformationProcess;
	BOOLEAN HookNtQuerySystemInformation;
	BOOLEAN HookNtQueryInformationThread;
	BOOLEAN HookNtQueryInformationJobObject;
	BOOLEAN HookNtQueryObject;
	BOOLEAN HookNtQuerySystemTime;
	BOOLEAN HookNtQueryPerformanceCounter;
	BOOLEAN HookNtCreateUserProcess;
	BOOLEAN HookNtCreateProcessEx;
	BOOLEAN HookNtCreateThreadEx;
	BOOLEAN HookNtSetContextThread;
	BOOLEAN HookNtGetContextThread;
	BOOLEAN HookNtOpenProcess;
	BOOLEAN HookNtOpenThread;
	BOOLEAN HookNtSetInformationThread;
	BOOLEAN HookNtSystemDebugControl;
	BOOLEAN HookNtGetNextProcess;
	BOOLEAN HookNtYieldExecution;
	BOOLEAN HookNtCreateFile;
	BOOLEAN HookNtContinue;
	BOOLEAN HookNtClose;
	BOOLEAN HookNtUserBuildHwndList;
	BOOLEAN HookNtUserFindWindowEx;
	BOOLEAN HookNtUserQueryWindow;
	BOOLEAN HookNtUserGetForegroundWindow;
	BOOLEAN HookKuserSharedData;
	BOOLEAN HookKiDispatchException;
	BOOLEAN HookNtSetInformationProcess;
	BOOLEAN ClearPebBeingDebugged;
	BOOLEAN ClearPebNtGlobalFlag;
	BOOLEAN ClearHeapFlags;
	BOOLEAN ClearKuserSharedData;
	BOOLEAN ClearHideFromDebuggerFlag;
	BOOLEAN ClearBypassProcessFreeze;
	BOOLEAN ClearProcessBreakOnTerminationFlag;
	BOOLEAN ClearThreadBreakOnTerminationFlag;
	BOOLEAN SaveProcessDebugFlags;
	BOOLEAN SaveProcessHandleTracing;
}HIDE_INFO, * PHIDE_INFO;

namespace Hider
{
	extern BOOLEAN StopCounterThread;
	extern LIST_ENTRY HiddenProcessesHead;
	extern KGUARDED_MUTEX HiderMutex;

	typedef struct _DEBUG_CONTEXT 
	{
		ULONG64 DR0;
		ULONG64 DR1;
		ULONG64 DR2;
		ULONG64 DR3;
		ULONG64 DR6;
		ULONG64 DR7;

		ULONG64 DebugControl;
		ULONG64 LastBranchFromRip;
		ULONG64 LastBranchToRip;
		ULONG64 LastExceptionFromRip;
		ULONG64 LastExceptionToRip;
	}DEBUG_CONTEXT,* PDEBUG_CONTEXT;

	typedef struct _WOW64_DEBUG_CONTEXT
	{
		ULONG DR0;
		ULONG DR1;
		ULONG DR2;
		ULONG DR3;
		ULONG DR6;
		ULONG DR7;
	}WOW64_DEBUG_CONTEXT,*PWOW64_DEBUG_CONTEXT;

	typedef struct _KUSD
	{
		// Pointer to new KuserSharedData
		PKUSER_SHARED_DATA KuserSharedData;

		// Pte of virtual page number 7FFE0
		PTE* PteKuserSharedData;

		// Page frame number of original KuserSharedData
		ULONG OriginalKuserSharedDataPfn;

		// Begin
		ULONG64 BeginInterruptTime;
		ULONG64 BeginSystemTime;
		ULONG BeginLastSystemRITEventTickCount;
		ULONG64 BeginTickCount;
		ULONG64 BeginTimeUpdateLock;
		ULONG64 BeginBaselineSystemQpc;

		// Delta
		ULONG64 DeltaInterruptTime;
		ULONG64 DeltaSystemTime;
		ULONG DeltaLastSystemRITEventTickCount;
		ULONG64 DeltaTickCount;
		ULONG64 DeltaTimeUpdateLock;
		ULONG64 DeltaBaselineSystemQpc;
	}KUSD, * PKUSD;

	typedef struct _HIDDEN_THREAD
	{
		LIST_ENTRY HiddenThreadList;
		PETHREAD ThreadObject;
		WOW64_DEBUG_CONTEXT FakeWow64DebugContext;
		DEBUG_CONTEXT FakeDebugContext;
		BOOLEAN IsThreadHidden;
		BOOLEAN BreakOnTermination;
	}HIDDEN_THREAD, * PHIDDEN_THREAD;

	typedef struct _HIDDEN_PROCESS
	{
		LIST_ENTRY HiddenProcessesList;
		
		HIDDEN_THREAD HiddenThreads;

		PEPROCESS DebuggerProcess;
		PEPROCESS DebuggedProcess;

		LARGE_INTEGER FakePerformanceCounter;
		LARGE_INTEGER FakeSystemTime;

		BOOLEAN HideTypes[HIDE_LAST];

		BOOLEAN ProcessPaused;

		BOOLEAN PebBeingDebuggedCleared;
		BOOLEAN HeapFlagsCleared;
		BOOLEAN PebNtGlobalFlagCleared;
		BOOLEAN KUserSharedDataCleared;
		BOOLEAN HideFromDebuggerFlagCleared;
		BOOLEAN BypassProcessFreezeFlagCleared;
		BOOLEAN ProcessHandleTracingEnabled;
		BOOLEAN ProcessBreakOnTerminationCleared;
		BOOLEAN ThreadBreakOnTerminationCleared;

		BOOLEAN ProcessDebugFlagsSaved;
		BOOLEAN ProcessHandleTracingSaved;

		BOOLEAN ValueProcessBreakOnTermination;
		BOOLEAN ValueProcessDebugFlags;

		KUSD Kusd;
	}HIDDEN_PROCESS, * PHIDDEN_PROCESS;

	PHIDDEN_PROCESS QueryHiddenProcess(PEPROCESS DebuggedProcess);

	PHIDDEN_THREAD AppendThreadList(PEPROCESS InterceptedProcess, PETHREAD ThreadObject);

	BOOLEAN CreateEntry(PEPROCESS DebuggerProcess, PEPROCESS DebuggedProcess);

	BOOLEAN RemoveEntry(PEPROCESS DebuggerProcess);

	BOOLEAN IsHidden(PEPROCESS Process, HIDE_TYPE HideType);

	BOOLEAN Hide(PHIDE_INFO HideInfo);

	BOOLEAN IsDriverHandleHidden(PUNICODE_STRING SymLink);

	BOOLEAN Initialize();

	BOOLEAN StopCounterForProcess(PEPROCESS DebuggedProcess);

	BOOLEAN ResumeCounterForProcess(PEPROCESS DebuggedProcess);

	BOOLEAN IsDebuggerProcess(PEPROCESS DebuggerProcess);

	BOOLEAN IsProcessNameBad(PUNICODE_STRING ProcessName);

	BOOLEAN IsProcessWindowBad(PUNICODE_STRING WindowName);

	BOOLEAN IsProcessWindowClassBad(PUNICODE_STRING WindowClassName);

	VOID DeleteThreadList(PHIDDEN_PROCESS HiddenProcess);

	VOID TruncateThreadList(PEPROCESS InterceptedProcess, PETHREAD ThreadObject);

	VOID Uninitialize();
}
```

`HyperHideDrv/HookHelper.cpp`:

```cpp
#pragma warning(disable : 4267 4201)

//#include <ntddk.h>
#include <ntifs.h>
#include "Utils.h"
#include "HookHelper.h"
#include "GlobalData.h"
#include "HypervisorGateway.h"
#include "Log.h"
#include "Ntenums.h"
#include <intrin.h>

extern HYPER_HIDE_GLOBAL_DATA g_HyperHide;

extern HANDLE(NTAPI* OriginalNtUserQueryWindow)(HANDLE hWnd, WINDOWINFOCLASS WindowInfo);

VOID FilterProcesses(PSYSTEM_PROCESS_INFO ProcessInfo)
{
	//
	// First process is always system so there won't be a case when forbidden process is first
	//
	PSYSTEM_PROCESS_INFO PrevProcessInfo = NULL;

	while (PrevProcessInfo != ProcessInfo)
	{
		ULONG Offset = ProcessInfo->NextEntryOffset;

		if (Hider::IsProcessNameBad(&ProcessInfo->ImageName) == TRUE)
		{
			if (ProcessInfo->NextEntryOffset == NULL)
				PrevProcessInfo->NextEntryOffset = NULL;

			else
				PrevProcessInfo->NextEntryOffset += ProcessInfo->NextEntryOffset;
				
			RtlSecureZeroMemory(ProcessInfo, sizeof(SYSTEM_PROCESS_INFO) + ProcessInfo->NumberOfThreads * sizeof(SYSTEM_THREAD_INFORMATION) - sizeof(SYSTEM_THREAD_INFORMATION));
		}

		else
		{
			PrevProcessInfo = ProcessInfo;
		}

		ProcessInfo = (PSYSTEM_PROCESS_INFO)((UCHAR*)ProcessInfo + Offset);
	}
}

VOID FilterHandlesEx(PSYSTEM_HANDLE_INFORMATION_EX HandleInfoEx)
{
	ULONG TotalDeletedHandles = 0;
	BOOLEAN Found;

	do
	{
		ULONG FirstHandlePosition = 0;
		Found = FALSE;

		for (ULONG i = 0; i < HandleInfoEx->NumberOfHandles; i++)
		{
			PEPROCESS OriginalProcess = PidToProcess(HandleInfoEx->Handles[i].UniqueProcessId);
			if (OriginalProcess != NULL)
			{
				UNICODE_STRING ProcessName = PsQueryFullProcessImageName(OriginalProcess);

				if (Found == FALSE && Hider::IsProcessNameBad(&ProcessName) == TRUE)
				{
					FirstHandlePosition = i;
					Found = TRUE;
				}

				else if (Found == TRUE && Hider::IsProcessNameBad(&ProcessName) == FALSE)
				{
					RtlCopyBytes(&HandleInfoEx->Handles[FirstHandlePosition], &HandleInfoEx->Handles[i], sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * (HandleInfoEx->NumberOfHandles - i));
					HandleInfoEx->NumberOfHandles = HandleInfoEx->NumberOfHandles - (i - FirstHandlePosition);
					TotalDeletedHandles += (i - FirstHandlePosition);
					break;
				}

				if (i + 1 == HandleInfoEx->NumberOfHandles && Found == TRUE)
				{
					RtlSecureZeroMemory(&HandleInfoEx->Handles[FirstHandlePosition], sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * (i - FirstHandlePosition));
					HandleInfoEx->NumberOfHandles = HandleInfoEx->NumberOfHandles - (i - FirstHandlePosition);
					TotalDeletedHandles += (i - FirstHandlePosition);
				}
			}
		}
	} while (Found == TRUE);

	
	RtlSecureZeroMemory(&HandleInfoEx->Handles[HandleInfoEx->NumberOfHandles], sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * TotalDeletedHandles);
}

VOID FilterHandles(PSYSTEM_HANDLE_INFORMATION HandleInfo)
{
	ULONG TotalDeletedHandles = 0;
	BOOLEAN Found;

	do
	{
		ULONG FirstHandlePosition = 0;
		Found = FALSE;

		for (ULONG i = 0; i < HandleInfo->NumberOfHandles; i++)
		{
			PEPROCESS OriginalProcess = PidToProcess(HandleInfo->Handles[i].UniqueProcessId);
			if (OriginalProcess != NULL)
			{
				UNICODE_STRING ProcessName = PsQueryFullProcessImageName(OriginalProcess);

				if (Found == FALSE && Hider::IsProcessNameBad(&ProcessName) == TRUE)
				{
					FirstHandlePosition = i;
					Found = TRUE;
				}

				else if (Found == TRUE && Hider::IsProcessNameBad(&ProcessName) == FALSE)
				{
					RtlCopyBytes(&HandleInfo->Handles[FirstHandlePosition], &HandleInfo->Handles[i], sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * (HandleInfo->NumberOfHandles - i));
					HandleInfo->NumberOfHandles = HandleInfo->NumberOfHandles - (i - FirstHandlePosition);
					TotalDeletedHandles += (i - FirstHandlePosition);
					break;
				}

				if (i + 1 == HandleInfo->NumberOfHandles && Found == TRUE)
				{
					RtlSecureZeroMemory(&HandleInfo->Handles[FirstHandlePosition], sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * (i - FirstHandlePosition));
					HandleInfo->NumberOfHandles = HandleInfo->NumberOfHandles - (i - FirstHandlePosition);
					TotalDeletedHandles += (i - FirstHandlePosition);
				}
			}
		}
	} while (Found == TRUE);


	RtlSecureZeroMemory(&HandleInfo->Handles[HandleInfo->NumberOfHandles], sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * TotalDeletedHandles);
}

BOOLEAN IsWindowBad(HANDLE hWnd)
{
	PEPROCESS WindProcess = PidToProcess(OriginalNtUserQueryWindow(hWnd, WindowProcess));
	if (WindProcess == IoGetCurrentProcess())
		return FALSE;

	UNICODE_STRING WindowProcessName = PsQueryFullProcessImageName(WindProcess);

	return Hider::IsProcessNameBad(&WindowProcessName);
}

BOOLEAN HookKiDispatchException(PVOID HookedKiDispatchException, PVOID* OriginalKiDispatchException)
{
	PVOID KernelSectionBase = 0;
	ULONG64 KernelSectionSize = 0;
	CHAR* Pattern = g_HyperHide.CurrentWindowsBuildNumber >= WINDOWS_11 ? "\x24\x00\x00\x41\xB1\x01\x48\x8D\x4C\x24\x00\xE8" : "\x8B\x00\x50\x00\x8B\x00\x58\x48\x8D\x4D\x00\xE8\x00\x00\x00\xFF\x8B\x55";
	CHAR* Mask = g_HyperHide.CurrentWindowsBuildNumber >= WINDOWS_11 ? "x??xxxxxxx?x" : "x?x?x?xxxx?x???xxx";
	CHAR* Section = g_HyperHide.CurrentWindowsBuildNumber >= WINDOWS_11 ? "PAGE" : ".text";

	if (GetSectionData("ntoskrnl.exe", Section, KernelSectionSize, KernelSectionBase) == FALSE)
		return FALSE;

	PVOID KiDispatchExceptionAddress = FindSignature(KernelSectionBase, KernelSectionSize, Pattern, Mask);
	if ((ULONG64)KiDispatchExceptionAddress >= (ULONG64)KernelSectionBase && (ULONG64)KiDispatchExceptionAddress <= (ULONG64)KernelSectionBase + KernelSectionSize)
	{
		KiDispatchExceptionAddress = (PVOID)(*(LONG*)((ULONG64)KiDispatchExceptionAddress + 12) + (LONGLONG)((ULONG64)KiDispatchExceptionAddress + 16));

		LogInfo("KiDispatchException address: 0x%llx", KiDispatchExceptionAddress);

		return hv::hook_function(KiDispatchExceptionAddress, HookedKiDispatchException, OriginalKiDispatchException);
	}

	return FALSE;
}

VOID GetNtSyscallNumbers(NT_SYSCALL_NUMBERS &SyscallNumbers)
{
	if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_11)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1c8;
		SyscallNumbers.NtSetContextThread = 0x194;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xf7;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xC5;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0xa3;
		SyscallNumbers.NtQueryInformationJobObject = 0x150;
		SyscallNumbers.NtCreateUserProcess = 0xcd;
		SyscallNumbers.NtGetNextProcess = 0xfc;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x134;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;

	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_20H2 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_20H1 || 
		g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_21H1 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_21H2)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1bd;
		SyscallNumbers.NtSetContextThread = 0x18b;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xf2;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xc1;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0xa1;
		SyscallNumbers.NtQueryInformationJobObject = 0x14a;
		SyscallNumbers.NtCreateUserProcess = 0xc8;
		SyscallNumbers.NtGetNextProcess = 0xf7;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x12e;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtDebugActiveProcess = 0xcd;
		SyscallNumbers.NtCreateDebugObject = 0xa5;
		SyscallNumbers.NtRemoveProcessDebug = 0x171;
		SyscallNumbers.NtWaitForDebugEvent = 0x1D1;
		SyscallNumbers.NtDebugContinue = 0xCE;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_19H2 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_19H1)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1b7;
		SyscallNumbers.NtSetContextThread = 0x185;
		SyscallNumbers.NtQuerySystemInformation = 0x36; 
		SyscallNumbers.NtGetContextThread = 0xed;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xbd;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0x43;
		SyscallNumbers.NtQueryInformationJobObject = 0x144;
		SyscallNumbers.NtCreateUserProcess = 0xc4;
		SyscallNumbers.NtGetNextProcess = 0xf2;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x129;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtDebugActiveProcess = 0xcd;
		SyscallNumbers.NtCreateDebugObject = 0xa5;
		SyscallNumbers.NtRemoveProcessDebug = 0x171;
		SyscallNumbers.NtWaitForDebugEvent = 0x1D1;
		SyscallNumbers.NtDebugContinue = 0xCE;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE5)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1b6;
		SyscallNumbers.NtSetContextThread = 0x184;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xec;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xbc;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0x43;
		SyscallNumbers.NtQueryInformationJobObject = 0x143;
		SyscallNumbers.NtCreateUserProcess = 0xc3;
		SyscallNumbers.NtGetNextProcess = 0xf1;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x128;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtDebugActiveProcess = 0xcd;
		SyscallNumbers.NtCreateDebugObject = 0xa5;
		SyscallNumbers.NtRemoveProcessDebug = 0x171;
		SyscallNumbers.NtWaitForDebugEvent = 0x1D1;
		SyscallNumbers.NtDebugContinue = 0xCE;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE4)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1b5;
		SyscallNumbers.NtSetContextThread = 0x183;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xeb;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xbb;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0x43;
		SyscallNumbers.NtQueryInformationJobObject = 0x142;
		SyscallNumbers.NtCreateUserProcess = 0xc2;
		SyscallNumbers.NtGetNextProcess = 0xf0;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x127;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtDebugActiveProcess = 0xcd;
		SyscallNumbers.NtCreateDebugObject = 0xa5;
		SyscallNumbers.NtRemoveProcessDebug = 0x171;
		SyscallNumbers.NtWaitForDebugEvent = 0x1D1;
		SyscallNumbers.NtDebugContinue = 0xCE;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE3)
	{
		// Native
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1b3;
		SyscallNumbers.NtSetContextThread = 0x181;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xea;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xba;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0x43;
		SyscallNumbers.NtQueryInformationJobObject = 0x140;
		SyscallNumbers.NtCreateUserProcess = 0xc1;
		SyscallNumbers.NtGetNextProcess = 0xef;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x125;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtDebugActiveProcess = 0xcd;
		SyscallNumbers.NtCreateDebugObject = 0xa5;
		SyscallNumbers.NtRemoveProcessDebug = 0x171;
		SyscallNumbers.NtWaitForDebugEvent = 0x1D1;
		SyscallNumbers.NtDebugContinue = 0xCE;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE2)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1b0;
		SyscallNumbers.NtSetContextThread = 0x17e;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xe9;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xb9;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0x43;
		SyscallNumbers.NtQueryInformationJobObject = 0x13d;
		SyscallNumbers.NtCreateUserProcess = 0xc0;
		SyscallNumbers.NtGetNextProcess = 0xee;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x123;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtDebugActiveProcess = 0xcd;
		SyscallNumbers.NtCreateDebugObject = 0xa5;
		SyscallNumbers.NtRemoveProcessDebug = 0x171;
		SyscallNumbers.NtWaitForDebugEvent = 0x1D1;
		SyscallNumbers.NtDebugContinue = 0xCE;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE1)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1aa;
		SyscallNumbers.NtSetContextThread = 0x178;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xe6;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xb6;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0x43;
		SyscallNumbers.NtQueryInformationJobObject = 0x137;
		SyscallNumbers.NtCreateUserProcess = 0xbd;
		SyscallNumbers.NtGetNextProcess = 0xeb;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x11f;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtDebugActiveProcess = 0xcd;
		SyscallNumbers.NtCreateDebugObject = 0xa5;
		SyscallNumbers.NtRemoveProcessDebug = 0x171;
		SyscallNumbers.NtWaitForDebugEvent = 0x1D1;
		SyscallNumbers.NtDebugContinue = 0xCE;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_THRESHOLD2)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1a4;
		SyscallNumbers.NtSetContextThread = 0x172;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xe4;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xb4;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0x43;
		SyscallNumbers.NtQueryInformationJobObject = 0x134;
		SyscallNumbers.NtCreateUserProcess = 0xbb;
		SyscallNumbers.NtGetNextProcess = 0xe9;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x11c;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtDebugActiveProcess = 0xcd;
		SyscallNumbers.NtCreateDebugObject = 0xa5;
		SyscallNumbers.NtRemoveProcessDebug = 0x171;
		SyscallNumbers.NtWaitForDebugEvent = 0x1D1;
		SyscallNumbers.NtDebugContinue = 0xCE;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_THRESHOLD1)
	{
		SyscallNumbers.NtSetInformationThread = 0xd;
		SyscallNumbers.NtQueryInformationProcess = 0x19;
		SyscallNumbers.NtQueryObject = 0x10;
		SyscallNumbers.NtSystemDebugControl = 0x1a1;
		SyscallNumbers.NtSetContextThread = 0x16f;
		SyscallNumbers.NtQuerySystemInformation = 0x36;
		SyscallNumbers.NtGetContextThread = 0xe3;
		SyscallNumbers.NtClose = 0xf;
		SyscallNumbers.NtQueryInformationThread = 0x25;
		SyscallNumbers.NtCreateThreadEx = 0xb3;
		SyscallNumbers.NtCreateFile = 0x55;
		SyscallNumbers.NtCreateProcessEx = 0x4d;
		SyscallNumbers.NtYieldExecution = 0x46;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x31;
		SyscallNumbers.NtContinue = 0x43;
		SyscallNumbers.NtQueryInformationJobObject = 0x131;
		SyscallNumbers.NtCreateUserProcess = 0xba;
		SyscallNumbers.NtGetNextProcess = 0xe8;
		SyscallNumbers.NtOpenProcess = 0x26;
		SyscallNumbers.NtOpenThread = 0x119;
		SyscallNumbers.NtSetInformationProcess = 0x1c;
		SyscallNumbers.NtReadVirtualMemory = 0x3F;
		SyscallNumbers.NtWriteVirtualMemory = 0x3a;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_8_1)
	{
		SyscallNumbers.NtSetInformationThread = 0xc;
		SyscallNumbers.NtQueryInformationProcess = 0x18;
		SyscallNumbers.NtQueryObject = 0xf;
		SyscallNumbers.NtSystemDebugControl = 0x199;
		SyscallNumbers.NtSetContextThread = 0x168;
		SyscallNumbers.NtQuerySystemInformation = 0x35;
		SyscallNumbers.NtGetContextThread = 0xe0;
		SyscallNumbers.NtClose = 0xe;
		SyscallNumbers.NtQueryInformationThread = 0x24;
		SyscallNumbers.NtCreateThreadEx = 0xb0;
		SyscallNumbers.NtCreateFile = 0x54;
		SyscallNumbers.NtCreateProcessEx = 0x4c;
		SyscallNumbers.NtYieldExecution = 0x45;
		SyscallNumbers.NtQuerySystemTime = 0x59;
		SyscallNumbers.NtQuerySystemTime = 0x5a;
		SyscallNumbers.NtQueryPerformanceCounter = 0x30;
		SyscallNumbers.NtContinue = 0x42;
		SyscallNumbers.NtQueryInformationJobObject = 0x12b;
		SyscallNumbers.NtCreateUserProcess = 0xb7;
		SyscallNumbers.NtGetNextProcess = 0xe4;
		SyscallNumbers.NtOpenProcess = 0x25;
		SyscallNumbers.NtOpenThread = 0x113;
		SyscallNumbers.NtSetInformationProcess = 0x1b;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_8)
	{
		SyscallNumbers.NtSetInformationThread = 0xb;
		SyscallNumbers.NtQueryInformationProcess = 0x17;
		SyscallNumbers.NtQueryObject = 0xe;
		SyscallNumbers.NtSystemDebugControl = 0x194;
		SyscallNumbers.NtSetContextThread = 0x165;
		SyscallNumbers.NtQuerySystemInformation = 0x34;
		SyscallNumbers.NtGetContextThread = 0xdd;
		SyscallNumbers.NtClose = 0xd;
		SyscallNumbers.NtQueryInformationThread = 0x23;
		SyscallNumbers.NtCreateThreadEx = 0xaf;
		SyscallNumbers.NtCreateFile = 0x53;
		SyscallNumbers.NtCreateProcessEx = 0x4b;
		SyscallNumbers.NtYieldExecution = 0x44;
		SyscallNumbers.NtQuerySystemTime = 0x58;
		SyscallNumbers.NtQueryPerformanceCounter = 0x2f;
		SyscallNumbers.NtContinue = 0x41;
		SyscallNumbers.NtQueryInformationJobObject = 0x128;
		SyscallNumbers.NtCreateUserProcess = 0xb5;
		SyscallNumbers.NtGetNextProcess = 0xe1;
		SyscallNumbers.NtOpenProcess = 0x24;
		SyscallNumbers.NtOpenThread = 0x110;
		SyscallNumbers.NtSetInformationProcess = 0x1a;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_7_SP1 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_7)
	{
		SyscallNumbers.NtSetInformationThread = 0xa;
		SyscallNumbers.NtQueryInformationProcess = 0x16;
		SyscallNumbers.NtQueryObject = 0xd;
		SyscallNumbers.NtSystemDebugControl = 0x17c;
		SyscallNumbers.NtSetContextThread = 0x150;
		SyscallNumbers.NtQuerySystemInformation = 0x33;
		SyscallNumbers.NtGetContextThread = 0xca;
		SyscallNumbers.NtClose = 0xc;
		SyscallNumbers.NtQueryInformationThread = 0x22;
		SyscallNumbers.NtCreateThreadEx = 0xa5;
		SyscallNumbers.NtCreateFile = 0x52;
		SyscallNumbers.NtCreateProcessEx = 0x4a;
		SyscallNumbers.NtYieldExecution = 0x43;
		SyscallNumbers.NtQuerySystemTime = 0x57;
		SyscallNumbers.NtQueryPerformanceCounter = 0x2e;
		SyscallNumbers.NtContinue = 0x40;
		SyscallNumbers.NtQueryInformationJobObject = 0x116;
		SyscallNumbers.NtCreateUserProcess = 0xaa;
		SyscallNumbers.NtGetNextProcess = 0xce;
		SyscallNumbers.NtOpenProcess = 0x23;
		SyscallNumbers.NtOpenThread = 0xfe;
		SyscallNumbers.NtSetInformationProcess = 0x19;
	}
}

VOID GetWin32kSyscallNumbers(WIN32K_SYSCALL_NUMBERS& SyscallNumbers)
{
	if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_11)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x67;
		SyscallNumbers.NtUserBuildHwndList = 0x1a;
		SyscallNumbers.NtUserQueryWindow = 0xe;
		SyscallNumbers.NtUserGetForegroundWindow = 0x37;
		SyscallNumbers.NtUserGetThreadState = 0x0;
		SyscallNumbers.NtUserInternalGetWindowText = 0x5D;
		SyscallNumbers.NtUserGetClassName = 0x74;
	}

	if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_20H2 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_20H1 || 
		g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_21H1 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_21H2)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6c;
		SyscallNumbers.NtUserBuildHwndList = 0x1c;
		SyscallNumbers.NtUserQueryWindow = 0x10;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3c;
		SyscallNumbers.NtUserGetThreadState = 0x0;
		SyscallNumbers.NtUserInternalGetWindowText = 0x62;
		SyscallNumbers.NtUserGetClassName = 0x79;

	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_19H2 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_19H1)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6f;
		SyscallNumbers.NtUserBuildHwndList = 0x1f;
		SyscallNumbers.NtUserQueryWindow = 0x13;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3f;
		SyscallNumbers.NtUserGetThreadState = 0x3;
		SyscallNumbers.NtUserInternalGetWindowText = 0x65;
		SyscallNumbers.NtUserGetClassName = 0x7c;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE5)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6f;
		SyscallNumbers.NtUserBuildHwndList = 0x1f;
		SyscallNumbers.NtUserQueryWindow = 0x13;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3f;
		SyscallNumbers.NtUserGetThreadState = 0x3;
		SyscallNumbers.NtUserInternalGetWindowText = 0x65;
		SyscallNumbers.NtUserGetClassName = 0x7c;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE4)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6f;
		SyscallNumbers.NtUserBuildHwndList = 0x1f;
		SyscallNumbers.NtUserQueryWindow = 0x13;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3f;
		SyscallNumbers.NtUserGetThreadState = 0x3;
		SyscallNumbers.NtUserInternalGetWindowText = 0x65;
		SyscallNumbers.NtUserGetClassName = 0x7c;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE3)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6f;
		SyscallNumbers.NtUserBuildHwndList = 0x1f;
		SyscallNumbers.NtUserQueryWindow = 0x13;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3f;
		SyscallNumbers.NtUserGetThreadState = 0x3;
		SyscallNumbers.NtUserInternalGetWindowText = 0x65;
		SyscallNumbers.NtUserGetClassName = 0x7c;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE2)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6f;
		SyscallNumbers.NtUserBuildHwndList = 0x1f;
		SyscallNumbers.NtUserQueryWindow = 0x13;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3f;
		SyscallNumbers.NtUserGetThreadState = 0x3;
		SyscallNumbers.NtUserInternalGetWindowText = 0x65;
		SyscallNumbers.NtUserGetClassName = 0x7c;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE1)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x70;
		SyscallNumbers.NtUserBuildHwndList = 0x1f;
		SyscallNumbers.NtUserQueryWindow = 0x13;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3f;
		SyscallNumbers.NtUserGetThreadState = 0x3;
		SyscallNumbers.NtUserInternalGetWindowText = 0x65;
		SyscallNumbers.NtUserGetClassName = 0x7d;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_THRESHOLD2)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x70;
		SyscallNumbers.NtUserBuildHwndList = 0x1f;
		SyscallNumbers.NtUserQueryWindow = 0x13;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3f;
		SyscallNumbers.NtUserGetThreadState = 0x3;
		SyscallNumbers.NtUserInternalGetWindowText = 0x65;
		SyscallNumbers.NtUserGetClassName = 0x7d;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_THRESHOLD1)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x70;
		SyscallNumbers.NtUserBuildHwndList = 0x1f;
		SyscallNumbers.NtUserQueryWindow = 0x13;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3f;
		SyscallNumbers.NtUserGetThreadState = 0x3;
		SyscallNumbers.NtUserInternalGetWindowText = 0x65;
		SyscallNumbers.NtUserGetClassName = 0x7d;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_8_1)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6f;
		SyscallNumbers.NtUserBuildHwndList = 0x1e;
		SyscallNumbers.NtUserQueryWindow = 0x12;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3e;
		SyscallNumbers.NtUserGetThreadState = 0x2;
		SyscallNumbers.NtUserInternalGetWindowText = 0x64;
		SyscallNumbers.NtUserGetClassName = 0x7c;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_8)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6e;
		SyscallNumbers.NtUserBuildHwndList = 0x1d;
		SyscallNumbers.NtUserQueryWindow = 0x11;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3d;
		SyscallNumbers.NtUserGetThreadState = 0x1;
		SyscallNumbers.NtUserInternalGetWindowText = 0x63;
		SyscallNumbers.NtUserGetClassName = 0x7b;
	}
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_7_SP1 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_7)
	{
		SyscallNumbers.NtUserFindWindowEx = 0x6e;
		SyscallNumbers.NtUserBuildHwndList = 0x1c;
		SyscallNumbers.NtUserQueryWindow = 0x10;
		SyscallNumbers.NtUserGetForegroundWindow = 0x3c;
		SyscallNumbers.NtUserGetThreadState = 0x0;
		SyscallNumbers.NtUserInternalGetWindowText = 0x63;
		SyscallNumbers.NtUserGetClassName = 0x7b;
	}
}
```

`HyperHideDrv/HookHelper.h`:

```h
#pragma once
#include <ntifs.h>
#include "Ntstructs.h"

typedef struct _NT_SYSCALL_NUMBERS
{
	SHORT NtSetInformationThread;
	SHORT NtQueryInformationProcess;
	SHORT NtQueryObject;
	SHORT NtSystemDebugControl;
	SHORT NtSetContextThread;
	SHORT NtQuerySystemInformation;
	SHORT NtGetContextThread;
	SHORT NtClose;
	SHORT NtQueryInformationThread;
	SHORT NtCreateThreadEx;
	SHORT NtCreateFile;
	SHORT NtCreateProcessEx;
	SHORT NtYieldExecution;
	SHORT NtQuerySystemTime;
	SHORT NtQueryPerformanceCounter;
	SHORT NtContinue;
	SHORT NtQueryInformationJobObject;
	SHORT NtCreateUserProcess;
	SHORT NtGetNextProcess;
	SHORT NtOpenProcess;
	SHORT NtOpenThread;
	SHORT NtSetInformationProcess;
	SHORT NtDebugActiveProcess;
	SHORT NtCreateDebugObject;
	SHORT NtRemoveProcessDebug;
	SHORT NtWaitForDebugEvent;
	SHORT NtDebugContinue;
	SHORT NtReadVirtualMemory;
	SHORT NtWriteVirtualMemory;

}NT_SYSCALL_NUMBERS;

typedef struct _WIN32K_SYSCALL_NUMBERS
{
	SHORT NtUserFindWindowEx;
	SHORT NtUserBuildHwndList;
	SHORT NtUserQueryWindow;
	SHORT NtUserGetForegroundWindow;
	SHORT NtUserGetThreadState;
	SHORT NtUserGetClassName;
	SHORT NtUserInternalGetWindowText;
	
}WIN32K_SYSCALL_NUMBERS;

VOID GetNtSyscallNumbers(NT_SYSCALL_NUMBERS& SyscallNumbers);

VOID GetWin32kSyscallNumbers(WIN32K_SYSCALL_NUMBERS& SyscallNumbers);

BOOLEAN IsWindowBad(HANDLE hWnd);

VOID FilterProcesses(PSYSTEM_PROCESS_INFO ProcessInfo);

VOID FilterHandlesEx(PSYSTEM_HANDLE_INFORMATION_EX HandleInfoEx);

VOID FilterHandles(PSYSTEM_HANDLE_INFORMATION HandleInfo);

BOOLEAN HookKiDispatchException(PVOID HookedKiDispatchException, PVOID* OriginalKiDispatchException);;
```

`HyperHideDrv/HookedFunctions.cpp`:

```cpp
#pragma warning( disable : 4201)
//#include <ntddk.h>
#include <intrin.h>
#include "Ntstructs.h"
#include "GlobalData.h"
#include "Log.h"
#include "Utils.h"
#include "Hider.h"
#include "Ntapi.h"
#include "HookHelper.h"
#include "Ssdt.h"
#include "HookedFunctions.h"

CONST PKUSER_SHARED_DATA KuserSharedData = (PKUSER_SHARED_DATA)KUSER_SHARED_DATA_USERMODE;

KMUTEX NtCloseMutex;

HANDLE(NTAPI* NtUserGetThreadState)(ULONG Routine);
ULONG64 KiUserExceptionDispatcherAddress = 0;

extern HYPER_HIDE_GLOBAL_DATA g_HyperHide;

NTSTATUS(NTAPI* OriginalNtQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtQueryInformationProcess(
	HANDLE           ProcessHandle,
	PROCESSINFOCLASS ProcessInformationClass,
	PVOID            ProcessInformation,
	ULONG            ProcessInformationLength,
	PULONG           ReturnLength
)
{
	if (ExGetPreviousMode() == UserMode &&
		Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_QUERY_INFORMATION_PROCESS) == TRUE &&
		(ProcessInformationClass == ProcessDebugObjectHandle || ProcessInformationClass == ProcessDebugPort ||
			ProcessInformationClass == ProcessDebugFlags || ProcessInformationClass == ProcessBreakOnTermination ||
			ProcessInformationClass == ProcessBasicInformation || ProcessInformationClass == ProcessIoCounters ||
			ProcessInformationClass == ProcessHandleTracing)
		)
	{
		if (ProcessInformationLength != 0)
		{
			__try
			{
				ProbeForRead(ProcessInformation, ProcessInformationLength, 4);
				if (ReturnLength != 0)
					ProbeForWrite(ReturnLength, 4, 1);
			}

			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				return GetExceptionCode();
			}
		}

		if (ProcessInformationClass == ProcessDebugObjectHandle)
		{
			if (ProcessInformationLength != sizeof(ULONG64))
				return STATUS_INFO_LENGTH_MISMATCH;

			PEPROCESS TargetProcess;
			NTSTATUS Status = ObReferenceObjectByHandle(ProcessHandle, PROCESS_QUERY_INFORMATION, *PsProcessType, UserMode, (PVOID*)&TargetProcess, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(TargetProcess, HIDE_NT_QUERY_INFORMATION_PROCESS) == TRUE)
				{
					__try
					{
						*(ULONG64*)ProcessInformation = NULL;
						if (ReturnLength != NULL) *ReturnLength = sizeof(ULONG64);

						Status = STATUS_PORT_NOT_SET;
					}

					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetProcess);
					return Status;
				}

				ObDereferenceObject(TargetProcess);
				return OriginalNtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
			}

			return Status;
		}

		else if (ProcessInformationClass == ProcessDebugPort)
		{
			if (ProcessInformationLength != sizeof(ULONG64))
				return STATUS_INFO_LENGTH_MISMATCH;

			PEPROCESS TargetProcess;
			NTSTATUS Status = ObReferenceObjectByHandle(ProcessHandle, PROCESS_QUERY_INFORMATION, *PsProcessType, UserMode, (PVOID*)&TargetProcess, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(TargetProcess, HIDE_NT_QUERY_INFORMATION_PROCESS) == TRUE)
				{
					__try
					{
						*(ULONG64*)ProcessInformation = 0;
						if (ReturnLength != 0)
							*ReturnLength = sizeof(ULONG64);
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetProcess);
					return Status;
				}

				ObDereferenceObject(TargetProcess);
				return OriginalNtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
			}

			return Status;
		}

		else if (ProcessInformationClass == ProcessDebugFlags)
		{
			if (ProcessInformationLength != 4)
				return STATUS_INFO_LENGTH_MISMATCH;

			PEPROCESS TargetProcess;
			NTSTATUS Status = ObReferenceObjectByHandle(ProcessHandle, PROCESS_QUERY_INFORMATION, *PsProcessType, UserMode, (PVOID*)&TargetProcess, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(TargetProcess, HIDE_NT_QUERY_INFORMATION_PROCESS) == TRUE)
				{
					__try
					{
						*(ULONG*)ProcessInformation = (Hider::QueryHiddenProcess(TargetProcess)->ValueProcessDebugFlags == 0) ? PROCESS_DEBUG_INHERIT : 0;
						if (ReturnLength != 0)
							*ReturnLength = sizeof(ULONG);
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetProcess);
					return Status;
				}

				ObDereferenceObject(TargetProcess);
				return OriginalNtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
			}

			return Status;
		}

		else if (ProcessInformationClass == ProcessBreakOnTermination)
		{
			if (ProcessInformationLength != 4)
				return STATUS_INFO_LENGTH_MISMATCH;

			PEPROCESS TargetProcess;
			NTSTATUS Status = ObReferenceObjectByHandle(ProcessHandle, 0x1000, *PsProcessType, UserMode, (PVOID*)&TargetProcess, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(TargetProcess, HIDE_NT_QUERY_INFORMATION_PROCESS) == TRUE)
				{
					__try
					{
						*(ULONG*)ProcessInformation = Hider::QueryHiddenProcess(TargetProcess)->ValueProcessBreakOnTermination;
						if (ReturnLength != 0)
							*ReturnLength = sizeof(ULONG);
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetProcess);
					return Status;
				}

				ObDereferenceObject(TargetProcess);
				return OriginalNtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
			}

			return Status;
		}

		NTSTATUS Status = OriginalNtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
		if (NT_SUCCESS(Status) == TRUE)
		{
			PEPROCESS TargetProcess;
			NTSTATUS ObStatus = ObReferenceObjectByHandle(ProcessHandle, 0, *PsProcessType, KernelMode, (PVOID*)&TargetProcess, NULL);

			if (NT_SUCCESS(ObStatus) == TRUE)
			{
				ObDereferenceObject(TargetProcess);

				if (Hider::IsHidden(TargetProcess, HIDE_NT_QUERY_INFORMATION_PROCESS) == TRUE)
				{
					Hider::PHIDDEN_PROCESS HiddenProcess = Hider::QueryHiddenProcess(TargetProcess);

					if (HiddenProcess != NULL)
					{
						if (ProcessInformationClass == ProcessBasicInformation)
						{
							BACKUP_RETURNLENGTH();
							PEPROCESS ExplorerProcess = GetProcessByName(L"explorer.exe");
							if (ExplorerProcess != NULL)
								((PPROCESS_BASIC_INFORMATION)ProcessInformation)->InheritedFromUniqueProcessId = (ULONG_PTR)PsGetProcessId(ExplorerProcess);
							RESTORE_RETURNLENGTH();
							return Status;
						}

						else if (ProcessInformationClass == ProcessIoCounters)
						{
							BACKUP_RETURNLENGTH();
							((PIO_COUNTERS)ProcessInformation)->OtherOperationCount = 1;
							RESTORE_RETURNLENGTH();
							return Status;
						}

						else if (ProcessInformationClass == ProcessHandleTracing)
						{
							return HiddenProcess->ProcessHandleTracingEnabled ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
						}
					}
				}
			}
		}

		return Status;
	}

	return OriginalNtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
}

NTSTATUS(NTAPI* OriginalNtSetInformationThread)(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);
NTSTATUS NTAPI HookedNtSetInformationThread(
	HANDLE ThreadHandle,
	THREADINFOCLASS ThreadInformationClass,
	PVOID ThreadInformation,
	ULONG ThreadInformationLength
)
{
	PEPROCESS CurrentProcess = IoGetCurrentProcess();
	if (Hider::IsHidden(CurrentProcess, HIDE_NT_SET_INFORMATION_THREAD) == TRUE &&
		ExGetPreviousMode() == UserMode &&
		(ThreadInformationClass == ThreadHideFromDebugger || ThreadInformationClass == ThreadWow64Context ||
			ThreadInformationClass == ThreadBreakOnTermination))
	{
		if (ThreadInformationLength != 0)
		{
			__try
			{
				ProbeForRead(ThreadInformation, ThreadInformationLength, sizeof(ULONG));
			}

			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				return GetExceptionCode();
			}
		}

		if (ThreadInformationClass == ThreadHideFromDebugger)
		{
			if (ThreadInformationLength != 0)
				return STATUS_INFO_LENGTH_MISMATCH;

			PETHREAD Thread;
			NTSTATUS Status = ObReferenceObjectByHandle(ThreadHandle, THREAD_SET_INFORMATION, *PsThreadType, UserMode, (PVOID*)&Thread, NULL);

			if (NT_SUCCESS(Status) == TRUE)
			{
				PEPROCESS TargetThreadProcess = IoThreadToProcess(Thread);
				if (Hider::IsHidden(TargetThreadProcess, HIDE_NT_SET_INFORMATION_THREAD) == TRUE)
				{
					Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(TargetThreadProcess, Thread);

					HiddenThread->IsThreadHidden = TRUE;

					ObDereferenceObject(Thread);
					return Status;
				}

				ObDereferenceObject(Thread);
				return OriginalNtSetInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
			}

			return Status;
		}

		else if (ThreadInformationClass == ThreadWow64Context)
		{
			PETHREAD TargetThread;
			NTSTATUS Status = ObReferenceObjectByHandle(ThreadHandle, THREAD_SET_CONTEXT, *PsThreadType, UserMode, (PVOID*)&TargetThread, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				PEPROCESS TargetProcess = IoThreadToProcess(TargetThread);
				if (Hider::IsHidden(TargetProcess, HIDE_NT_SET_INFORMATION_THREAD) == TRUE)
				{
					if (ThreadInformationLength != sizeof(WOW64_CONTEXT))
					{
						ObDereferenceObject(TargetThread);
						return STATUS_INFO_LENGTH_MISMATCH;
					}

					PVOID WoW64Process = PsGetCurrentProcessWow64Process();
					if (WoW64Process == 0)
					{
						ObDereferenceObject(TargetThread);
						return STATUS_INVALID_PARAMETER;
					}

					__try
					{
						PWOW64_CONTEXT Wow64Context = (PWOW64_CONTEXT)ThreadInformation;
						ULONG OriginalFlags = Wow64Context->ContextFlags;

						Wow64Context->ContextFlags &= ~0x10;

						Status = OriginalNtSetInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);

						if (OriginalFlags & 0x10)
						{
							Wow64Context->ContextFlags |= 0x10;
							Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(IoThreadToProcess(TargetThread), TargetThread);
							if (HiddenThread != NULL)
								RtlCopyBytes(&HiddenThread->FakeWow64DebugContext, &Wow64Context->Dr0, sizeof(ULONG) * 6);
						}
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetThread);
					return Status;
				}

				ObDereferenceObject(TargetThread);
				return OriginalNtSetInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
			}

			return Status;
		}

		else if (ThreadInformationClass == ThreadBreakOnTermination)
		{
			if (ThreadInformationLength != sizeof(ULONG))
				return STATUS_INFO_LENGTH_MISMATCH;

			__try
			{
				volatile ULONG Touch = *(ULONG*)ThreadInformation;
				UNREFERENCED_PARAMETER(Touch);
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				return GetExceptionCode();
			}

			LUID PrivilageValue;
			PrivilageValue.LowPart = SE_DEBUG_PRIVILEGE;
			if (SeSinglePrivilegeCheck(PrivilageValue, UserMode) == FALSE)
				return STATUS_PRIVILEGE_NOT_HELD;

			PETHREAD ThreadObject;
			NTSTATUS Status = ObReferenceObjectByHandle(ThreadHandle, THREAD_SET_INFORMATION, *PsThreadType, ExGetPreviousMode(), (PVOID*)&ThreadObject, NULL);

			if (NT_SUCCESS(Status) == TRUE)
			{
				PEPROCESS TargetProcess = IoThreadToProcess(ThreadObject);
				if (Hider::IsHidden(TargetProcess, HIDE_NT_SET_INFORMATION_THREAD) == TRUE)
				{
					Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(TargetProcess, ThreadObject);
					if (HiddenThread != NULL)
						HiddenThread->BreakOnTermination = *(ULONG*)ThreadInformation ? TRUE : FALSE;

					ObDereferenceObject(ThreadHandle);
					return Status;
				}

				ObDereferenceObject(ThreadHandle);
				return OriginalNtSetInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
			}

			return Status;
		}
	}

	return OriginalNtSetInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
}

NTSTATUS(NTAPI* OriginalNtSetInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);
NTSTATUS NTAPI HookedNtSetInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength)
{
	if (ExGetPreviousMode() == UserMode &&
		Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_SET_INFORMATION_PROCESS) == TRUE &&
		(ProcessInformationClass == ProcessBreakOnTermination || ProcessInformationClass == ProcessDebugFlags ||
			ProcessInformationClass == ProcessHandleTracing))
	{
		if (ProcessInformationLength != 0)
		{
			__try
			{
				ProbeForRead(ProcessInformation, ProcessInformationLength, 4);
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				return GetExceptionCode();
			}
		}

		if (ProcessInformationClass == ProcessBreakOnTermination)
		{
			if (ProcessInformationLength != sizeof(ULONG))
				return STATUS_INFO_LENGTH_MISMATCH;

			__try
			{
				volatile ULONG Touch = *(ULONG*)ProcessInformation;
				UNREFERENCED_PARAMETER(Touch);
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				return GetExceptionCode();
			}

			LUID PrivilageValue;
			PrivilageValue.LowPart = SE_DEBUG_PRIVILEGE;
			if (SeSinglePrivilegeCheck(PrivilageValue, UserMode) == FALSE)
				return STATUS_PRIVILEGE_NOT_HELD;

			PEPROCESS TargetProcess;
			NTSTATUS Status = ObReferenceObjectByHandle(ProcessHandle, 0x200, *PsProcessType, UserMode, (PVOID*)&TargetProcess, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(TargetProcess, HIDE_NT_SET_INFORMATION_PROCESS) == TRUE)
				{
					Hider::PHIDDEN_PROCESS HiddenProcess = Hider::QueryHiddenProcess(TargetProcess);
					if (HiddenProcess != NULL)
						HiddenProcess->ValueProcessBreakOnTermination = *(ULONG*)ProcessInformation & 1;

					ObDereferenceObject(TargetProcess);
					return Status;
				}

				ObDereferenceObject(TargetProcess);
				return OriginalNtSetInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
			}
			return Status;
		}

		else if (ProcessInformationClass == ProcessDebugFlags)
		{
			if (ProcessInformationLength != sizeof(ULONG))
				return STATUS_INFO_LENGTH_MISMATCH;

			PEPROCESS TargetProcess;
			NTSTATUS Status = ObReferenceObjectByHandle(ProcessHandle, 0x200, *PsProcessType, UserMode, (PVOID*)&TargetProcess, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(TargetProcess, HIDE_NT_SET_INFORMATION_PROCESS) == TRUE)
				{
					__try
					{
						ULONG Flags = *(ULONG*)ProcessInformation;
						if ((Flags & ~PROCESS_DEBUG_INHERIT) != 0)
						{
							ObDereferenceObject(TargetProcess);
							return STATUS_INVALID_PARAMETER;
						}

						Hider::PHIDDEN_PROCESS HiddenProcess = Hider::QueryHiddenProcess(TargetProcess);

						if ((Flags & PROCESS_DEBUG_INHERIT) != 0)
							HiddenProcess->ValueProcessDebugFlags = 0;

						else
							HiddenProcess->ValueProcessDebugFlags = TRUE;

						Status = STATUS_SUCCESS;
					}

					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetProcess);
					return Status;
				}

				ObDereferenceObject(TargetProcess);
				return OriginalNtSetInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
			}

			return Status;
		}

		else if (ProcessInformationClass == ProcessHandleTracing)
		{
			BOOLEAN Enable = ProcessInformationLength != 0;
			if (Enable == TRUE)
			{
				if (ProcessInformationLength != sizeof(ULONG) && ProcessInformationLength != sizeof(ULONG64))
					return STATUS_INFO_LENGTH_MISMATCH;

				__try
				{
					PPROCESS_HANDLE_TRACING_ENABLE_EX ProcessHandleTracing = (PPROCESS_HANDLE_TRACING_ENABLE_EX)ProcessInformation;
					if (ProcessHandleTracing->Flags != 0)
						return STATUS_INVALID_PARAMETER;
				}

				__except (EXCEPTION_EXECUTE_HANDLER)
				{
					return GetExceptionCode();
				}
			}

			PEPROCESS TargetProcess;
			NTSTATUS Status = ObReferenceObjectByHandle(ProcessHandle, 0x200, *PsProcessType, UserMode, (PVOID*)&TargetProcess, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(TargetProcess, HIDE_NT_SET_INFORMATION_PROCESS) == TRUE)
				{
					Hider::PHIDDEN_PROCESS HiddenProcess = Hider::QueryHiddenProcess(TargetProcess);
					if (HiddenProcess != NULL)
						HiddenProcess->ProcessHandleTracingEnabled = Enable;

					ObDereferenceObject(TargetProcess);
					return Status;
				}

				ObDereferenceObject(TargetProcess);
				return OriginalNtSetInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
			}

			return Status;
		}
	}
	return OriginalNtSetInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
}

NTSTATUS(NTAPI* OriginalNtQueryObject)(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtQueryObject(
	HANDLE                   Handle,
	OBJECT_INFORMATION_CLASS ObjectInformationClass,
	PVOID                    ObjectInformation,
	ULONG                    ObjectInformationLength,
	PULONG                   ReturnLength
)
{
	NTSTATUS Status = OriginalNtQueryObject(Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength, ReturnLength);
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_QUERY_OBJECT) == TRUE &&
		NT_SUCCESS(Status) == TRUE &&
		ExGetPreviousMode() == UserMode &&
		ObjectInformation != NULL)
	{

		if (ObjectInformationClass == ObjectTypeInformation)
		{
			UNICODE_STRING DebugObject;
			RtlInitUnicodeString(&DebugObject, L"DebugObject");
			POBJECT_TYPE_INFORMATION Type = (POBJECT_TYPE_INFORMATION)ObjectInformation;

			if (RtlEqualUnicodeString(&Type->TypeName, &DebugObject, FALSE) == TRUE)
			{
				BACKUP_RETURNLENGTH();
				Type->TotalNumberOfObjects -= g_HyperHide.NumberOfActiveDebuggers;
				Type->TotalNumberOfHandles -= g_HyperHide.NumberOfActiveDebuggers;
				RESTORE_RETURNLENGTH();
			}

			return Status;
		}

		else if (ObjectInformationClass == ObjectTypesInformation)
		{
			UNICODE_STRING DebugObject;
			RtlInitUnicodeString(&DebugObject, L"DebugObject");
			POBJECT_ALL_INFORMATION ObjectAllInfo = (POBJECT_ALL_INFORMATION)ObjectInformation;
			UCHAR* ObjInfoLocation = (UCHAR*)ObjectAllInfo->ObjectTypeInformation;
			ULONG TotalObjects = ObjectAllInfo->NumberOfObjectsTypes;

			BACKUP_RETURNLENGTH();
			for (ULONG i = 0; i < TotalObjects; i++)
			{
				POBJECT_TYPE_INFORMATION ObjectTypeInfo = (POBJECT_TYPE_INFORMATION)ObjInfoLocation;
				if (RtlEqualUnicodeString(&ObjectTypeInfo->TypeName, &DebugObject, FALSE) == TRUE)
				{
					ObjectTypeInfo->TotalNumberOfObjects = 0;
					ObjectTypeInfo->TotalNumberOfHandles = 0;
				}
				ObjInfoLocation = (UCHAR*)ObjectTypeInfo->TypeName.Buffer;
				ObjInfoLocation += ObjectTypeInfo->TypeName.MaximumLength;
				ULONG64 Tmp = ((ULONG64)ObjInfoLocation) & -(LONG64)sizeof(PVOID);
				if ((ULONG64)Tmp != (ULONG64)ObjInfoLocation)
					Tmp += sizeof(PVOID);
				ObjInfoLocation = ((UCHAR*)Tmp);
			}
			RESTORE_RETURNLENGTH();
			return Status;
		}
	}

	return Status;
}

NTSTATUS(NTAPI* OriginalNtSystemDebugControl)(SYSDBG_COMMAND Command, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtSystemDebugControl(
	SYSDBG_COMMAND       Command,
	PVOID                InputBuffer,
	ULONG                InputBufferLength,
	PVOID               OutputBuffer,
	ULONG                OutputBufferLength,
	PULONG              ReturnLength)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_SYSTEM_DEBUG_CONTROL) == TRUE)
	{
		if (Command == SysDbgGetTriageDump)
			return STATUS_INFO_LENGTH_MISMATCH;
		return STATUS_DEBUGGER_INACTIVE;
	}
	return OriginalNtSystemDebugControl(Command, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, ReturnLength);
}

NTSTATUS(NTAPI* OriginalNtClose)(HANDLE Handle);
NTSTATUS NTAPI HookedNtClose(HANDLE Handle)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_CLOSE) == TRUE)
	{
		KeWaitForSingleObject(&NtCloseMutex, Executive, KernelMode, FALSE, NULL);

		OBJECT_HANDLE_ATTRIBUTE_INFORMATION ObjAttributeInfo;

		NTSTATUS Status = ZwQueryObject(Handle, (OBJECT_INFORMATION_CLASS)4 /*ObjectDataInformation*/, &ObjAttributeInfo, sizeof(OBJECT_HANDLE_ATTRIBUTE_INFORMATION), NULL);

		if (Status == STATUS_INVALID_HANDLE)
		{
			KeReleaseMutex(&NtCloseMutex, FALSE);
			return STATUS_INVALID_HANDLE;
		}

		if (NT_SUCCESS(Status) == TRUE)
		{
			if (ObjAttributeInfo.ProtectFromClose == TRUE)
			{
				KeReleaseMutex(&NtCloseMutex, FALSE);
				return STATUS_HANDLE_NOT_CLOSABLE;
			}
		}

		KeReleaseMutex(&NtCloseMutex, FALSE);
	}

	return OriginalNtClose(Handle);
}

NTSTATUS(NTAPI* OriginalNtGetNextProcess)(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle);
NTSTATUS NTAPI HookedNtGetNextProcess(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Flags, PHANDLE NewProcessHandle)
{
	NTSTATUS Status = OriginalNtGetNextProcess(ProcessHandle, DesiredAccess, HandleAttributes, Flags, NewProcessHandle);
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_GET_NEXT_PROCESS) == TRUE &&
		ExGetPreviousMode() == UserMode &&
		NT_SUCCESS(Status) == TRUE)
	{
		PEPROCESS NewProcess;
		NTSTATUS ObStatus = ObReferenceObjectByHandle(*NewProcessHandle, NULL, *PsProcessType, KernelMode, (PVOID*)&NewProcess, NULL);
		if (NT_SUCCESS(ObStatus) == TRUE)
		{
			UNICODE_STRING ProcessImageName = PsQueryFullProcessImageName(NewProcess);
			if (Hider::IsProcessNameBad(&ProcessImageName) == TRUE)
			{
				HANDLE OldHandleValue = *NewProcessHandle;

				Status = HookedNtGetNextProcess(*NewProcessHandle, DesiredAccess, HandleAttributes, Flags, NewProcessHandle);
				ObCloseHandle(OldHandleValue, UserMode);
			}

			ObDereferenceObject(NewProcess);
			return Status;
		}

		return Status;
	}

	return OriginalNtGetNextProcess(ProcessHandle, DesiredAccess, HandleAttributes, Flags, NewProcessHandle);
}

NTSTATUS(NTAPI* OriginalNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength)
{
	NTSTATUS Status = OriginalNtQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
	PEPROCESS CurrentProcess = IoGetCurrentProcess();

	if (ExGetPreviousMode() == UserMode &&
		Hider::IsHidden(CurrentProcess, HIDE_NT_QUERY_SYSTEM_INFORMATION) == TRUE &&
		NT_SUCCESS(Status) == TRUE
		)
	{
		if (SystemInformationClass == SystemKernelDebuggerInformation)
		{
			PSYSTEM_KERNEL_DEBUGGER_INFORMATION DebuggerInfo = (PSYSTEM_KERNEL_DEBUGGER_INFORMATION)SystemInformation;

			BACKUP_RETURNLENGTH();
			DebuggerInfo->DebuggerEnabled = 0;
			DebuggerInfo->DebuggerNotPresent = 1;
			RESTORE_RETURNLENGTH();
		}

		else if (SystemInformationClass == SystemProcessInformation ||
			SystemInformationClass == SystemSessionProcessInformation ||
			SystemInformationClass == SystemExtendedProcessInformation ||
			SystemInformationClass == SystemFullProcessInformation)
		{
			PSYSTEM_PROCESS_INFO ProcessInfo = (PSYSTEM_PROCESS_INFO)SystemInformation;
			if (SystemInformationClass == SystemSessionProcessInformation)
				ProcessInfo = (PSYSTEM_PROCESS_INFO)((PSYSTEM_SESSION_PROCESS_INFORMATION)SystemInformation)->Buffer;

			BACKUP_RETURNLENGTH();
			DbgPrint("FilterProcesses\n");
			FilterProcesses(ProcessInfo);

			for (PSYSTEM_PROCESS_INFO Entry = ProcessInfo; Entry->NextEntryOffset != NULL; Entry = (PSYSTEM_PROCESS_INFO)((UCHAR*)Entry + Entry->NextEntryOffset))
			{
				if (Hider::IsHidden(PidToProcess(Entry->ProcessId), HIDE_NT_QUERY_SYSTEM_INFORMATION) == TRUE)
				{
					PEPROCESS ExplorerProcess = GetProcessByName(L"explorer.exe");
					if (ExplorerProcess != NULL)
						Entry->InheritedFromProcessId = PsGetProcessId(ExplorerProcess);

					Entry->OtherOperationCount.QuadPart = 1;
				}
			}
			RESTORE_RETURNLENGTH();
		}

		else if (SystemInformationClass == SystemCodeIntegrityInformation)
		{
			BACKUP_RETURNLENGTH();
			((PSYSTEM_CODEINTEGRITY_INFORMATION)SystemInformation)->CodeIntegrityOptions = 0x1; // CODEINTEGRITY_OPTION_ENABLED
			RESTORE_RETURNLENGTH();
		}

		else if (SystemInformationClass == SystemKernelDebuggerInformationEx)
		{
			BACKUP_RETURNLENGTH();
			((PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)SystemInformation)->DebuggerAllowed = FALSE;
			((PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)SystemInformation)->DebuggerEnabled = FALSE;
			((PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)SystemInformation)->DebuggerPresent = FALSE;
			RESTORE_RETURNLENGTH();
		}

		else if (SystemInformationClass == SystemKernelDebuggerFlags)
		{
			BACKUP_RETURNLENGTH();
			*(UCHAR*)SystemInformation = NULL;
			RESTORE_RETURNLENGTH();
		}

		else if (SystemInformationClass == SystemExtendedHandleInformation)
		{
			PSYSTEM_HANDLE_INFORMATION_EX HandleInfoEx = (PSYSTEM_HANDLE_INFORMATION_EX)SystemInformation;

			BACKUP_RETURNLENGTH();
			FilterHandlesEx(HandleInfoEx);
			RESTORE_RETURNLENGTH();
		}

		else if (SystemInformationClass == SystemHandleInformation)
		{
			PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)SystemInformation;

			BACKUP_RETURNLENGTH();
			FilterHandles(HandleInfo);
			RESTORE_RETURNLENGTH();
		}
	}

	return Status;
}

NTSTATUS(NTAPI* OriginalNtSetContextThread)(HANDLE ThreadHandle, PCONTEXT Context);
NTSTATUS NTAPI HookedNtSetContextThread(HANDLE ThreadHandle, PCONTEXT Context)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_SET_CONTEXT_THREAD) == TRUE &&
		ExGetPreviousMode() == UserMode)
	{
		PETHREAD TargethThread;
		NTSTATUS Status = ObReferenceObjectByHandle(ThreadHandle, THREAD_SET_CONTEXT, *PsThreadType, UserMode, (PVOID*)&TargethThread, 0);
		if (NT_SUCCESS(Status) == TRUE)
		{
			PEPROCESS TargetProcess = IoThreadToProcess(TargethThread);
			if (Hider::IsHidden(TargetProcess, HIDE_NT_SET_CONTEXT_THREAD) == TRUE)
			{
				if (IsSetThreadContextRestricted(TargetProcess) == TRUE && IoThreadToProcess(PsGetCurrentThread()) == TargetProcess)
				{
					ObDereferenceObject(TargethThread);
					return STATUS_SET_CONTEXT_DENIED;
				}

				// If it is a system thread or pico process thread return STATUS_INVALID_HANDLE
				if (IoIsSystemThread(TargethThread) == TRUE || IsPicoContextNull(TargethThread) == FALSE)
				{
					ObDereferenceObject(TargethThread);
					return STATUS_INVALID_HANDLE;
				}

				__try
				{
					ULONG OriginalFlags = Context->ContextFlags;

					Context->ContextFlags &= ~0x10;

					Status = OriginalNtSetContextThread(ThreadHandle, Context);

					if (OriginalFlags & 0x10)
					{
						Context->ContextFlags |= 0x10;

						Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(TargetProcess, TargethThread);
						if (HiddenThread != 0)
						{
							RtlCopyBytes(&HiddenThread->FakeDebugContext.DR0, &Context->Dr0, sizeof(ULONG64) * 6);
							RtlCopyBytes(&HiddenThread->FakeDebugContext.DebugControl, &Context->DebugControl, sizeof(ULONG64) * 5);
						}
					}
				}
				__except (EXCEPTION_EXECUTE_HANDLER)
				{
					Status = GetExceptionCode();
				}

				ObDereferenceObject(TargethThread);
				return Status;
			}

			ObDereferenceObject(TargethThread);
			return OriginalNtSetContextThread(ThreadHandle, Context);
		}

		return Status;
	}

	return OriginalNtSetContextThread(ThreadHandle, Context);
}

NTSTATUS(NTAPI* OriginalNtGetContextThread)(IN HANDLE ThreadHandle, IN OUT PCONTEXT Context);
NTSTATUS NTAPI HookedNtGetContextThread(IN HANDLE ThreadHandle, IN OUT PCONTEXT Context)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_GET_CONTEXT_THREAD) == TRUE &&
		ExGetPreviousMode() == UserMode
		)
	{
		PETHREAD ThreadObject;
		NTSTATUS Status = ObReferenceObjectByHandle(ThreadHandle, THREAD_SET_CONTEXT, *PsThreadType, UserMode, (PVOID*)&ThreadObject, 0);
		if (NT_SUCCESS(Status) == TRUE)
		{
			// If it is a system thread return STATUS_INVALID_HANDLE
			if (IoIsSystemThread(ThreadObject) == TRUE)
			{
				ObDereferenceObject(ThreadObject);
				return STATUS_INVALID_HANDLE;
			}

			// Check if thread object belongs to any hidden process
			if (Hider::IsHidden(IoThreadToProcess(ThreadObject), HIDE_NT_SET_CONTEXT_THREAD) == TRUE)
			{
				__try
				{
					ULONG OriginalFlags = Context->ContextFlags;

					Context->ContextFlags &= ~0x10;

					Status = OriginalNtGetContextThread(ThreadHandle, Context);

					if (OriginalFlags & 0x10)
					{
						Context->ContextFlags |= 0x10;

						Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(IoThreadToProcess(ThreadObject), ThreadObject);
						if (HiddenThread != NULL)
						{
							RtlCopyBytes(&Context->Dr0, &HiddenThread->FakeDebugContext.DR0, sizeof(ULONG64) * 6);
							RtlCopyBytes(&Context->DebugControl, &HiddenThread->FakeDebugContext.DebugControl, sizeof(ULONG64) * 5);
						}
						else
						{
							RtlSecureZeroMemory(&Context->Dr0, sizeof(ULONG64) * 6);
							RtlSecureZeroMemory(&Context->DebugControl, sizeof(ULONG64) * 5);
						}
					}
				}
				__except (EXCEPTION_EXECUTE_HANDLER)
				{
					Status = GetExceptionCode();
				}

				ObDereferenceObject(ThreadObject);
				return Status;
			}

			ObDereferenceObject(ThreadObject);
			return OriginalNtGetContextThread(ThreadHandle, Context);
		}

		return Status;
	}

	return OriginalNtGetContextThread(ThreadHandle, Context);
}

NTSTATUS(NTAPI* OriginalNtQueryInformationThread)(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength)
{
	PEPROCESS CurrentProcess = IoGetCurrentProcess();
	if (Hider::IsHidden(CurrentProcess, HIDE_NT_QUERY_INFORMATION_THREAD) == TRUE &&
		ExGetPreviousMode() == UserMode && (ThreadInformationClass == ThreadHideFromDebugger ||
			ThreadInformationClass == ThreadBreakOnTermination || ThreadInformationClass == ThreadWow64Context))
	{
		if (ThreadInformationLength != 0)
		{
			__try
			{
				ProbeForRead(ThreadInformation, ThreadInformationLength, 4);
				if (ReturnLength != 0)
					ProbeForWrite(ReturnLength, 4, 1);

			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				return GetExceptionCode();
			}
		}

		if (ThreadInformationClass == ThreadHideFromDebugger)
		{
			if (ThreadInformationLength != 1)
				return STATUS_INFO_LENGTH_MISMATCH;

			PETHREAD TargetThread;
			NTSTATUS Status = ObReferenceObjectByHandle(ThreadHandle, 0x40, *PsThreadType, UserMode, (PVOID*)&TargetThread, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(IoThreadToProcess(TargetThread), HIDE_NT_QUERY_INFORMATION_THREAD) == TRUE)
				{
					__try
					{
						*(BOOLEAN*)ThreadInformation = Hider::AppendThreadList(IoThreadToProcess(TargetThread), TargetThread)->IsThreadHidden;

						if (ReturnLength != 0) *ReturnLength = 1;
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetThread);
					return Status;
				}

				ObDereferenceObject(TargetThread);
				return OriginalNtQueryInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);
			}

			return Status;
		}

		if (ThreadInformationClass == ThreadBreakOnTermination)
		{
			if (ThreadInformationLength != 4)
				return STATUS_INFO_LENGTH_MISMATCH;

			PETHREAD TargetThread;
			NTSTATUS Status = ObReferenceObjectByHandle(ThreadHandle, 0x40, *PsThreadType, UserMode, (PVOID*)&TargetThread, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(IoThreadToProcess(TargetThread), HIDE_NT_QUERY_INFORMATION_THREAD) == TRUE)
				{
					__try
					{
						*(ULONG*)ThreadInformation = Hider::AppendThreadList(IoThreadToProcess(TargetThread), TargetThread)->BreakOnTermination;

						if (ReturnLength != NULL) *ReturnLength = 4;
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetThread);
					return Status;
				}

				ObDereferenceObject(TargetThread);
				return OriginalNtQueryInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);
			}

			return Status;
		}

		if (ThreadInformationClass == ThreadWow64Context)
		{
			PETHREAD TargetThread;
			NTSTATUS Status = ObReferenceObjectByHandle(ThreadHandle, THREAD_GET_CONTEXT, *PsThreadType, UserMode, (PVOID*)&TargetThread, NULL);
			if (NT_SUCCESS(Status) == TRUE)
			{
				if (Hider::IsHidden(IoThreadToProcess(TargetThread), HIDE_NT_QUERY_INFORMATION_THREAD) == TRUE)
				{
					if (ThreadInformationLength != sizeof(WOW64_CONTEXT))
					{
						ObDereferenceObject(TargetThread);
						return STATUS_INFO_LENGTH_MISMATCH;
					}

					PVOID WoW64Process = PsGetCurrentProcessWow64Process();
					if (WoW64Process == 0)
					{
						ObDereferenceObject(TargetThread);
						return STATUS_INVALID_PARAMETER;
					}

					__try
					{
						PWOW64_CONTEXT Context = (PWOW64_CONTEXT)ThreadInformation;
						ULONG OriginalFlags = Context->ContextFlags;

						Context->ContextFlags &= ~0x10;

						Status = OriginalNtQueryInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);

						if (OriginalFlags & 0x10)
						{
							Context->ContextFlags |= 0x10;

							Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(IoThreadToProcess(TargetThread), TargetThread);

							if (HiddenThread != NULL)
								RtlCopyBytes(&Context->Dr0, &HiddenThread->FakeWow64DebugContext, sizeof(ULONG) * 6);

							else
								RtlSecureZeroMemory(&Context->Dr0, sizeof(ULONG) * 6);
						}
					}
					__except (EXCEPTION_EXECUTE_HANDLER)
					{
						Status = GetExceptionCode();
					}

					ObDereferenceObject(TargetThread);
					return Status;
				}

				ObDereferenceObject(TargetThread);
				return OriginalNtQueryInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);
			}

			return Status;
		}
	}

	return OriginalNtQueryInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);
}

NTSTATUS(NTAPI* OriginalNtOpenProcess)(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
NTSTATUS NTAPI HookedNtOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_OPEN_PROCESS) == TRUE &&
		ExGetPreviousMode() == UserMode)
	{
		__try
		{
			ProbeForWrite(ProcessHandle, 4, 1);
			ProbeForWrite(ObjectAttributes, 28, 4);
		}

		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			return GetExceptionCode();
		}

		if (ClientId != NULL)
		{
			__try
			{
				ProbeForRead(ClientId, 1, 4);
				volatile ULONG64 Touch = (ULONG64)ClientId->UniqueProcess;
				Touch = (ULONG64)ClientId->UniqueThread;
			}

			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				return GetExceptionCode();
			}

			if (ClientId->UniqueProcess == NULL)
				return OriginalNtOpenProcess(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);

			PEPROCESS TargetProcess = PidToProcess(ClientId->UniqueProcess);
			UNICODE_STRING ProcessImageName = PsQueryFullProcessImageName(TargetProcess);

			if (Hider::IsProcessNameBad(&ProcessImageName) == TRUE)
			{
				HANDLE OldPid = ClientId->UniqueProcess;

				ClientId->UniqueProcess = UlongToHandle(0xFFFFFFFC);

				NTSTATUS Status = OriginalNtOpenProcess(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);

				ClientId->UniqueProcess = OldPid;

				return Status;
			}
		}
	}
	return OriginalNtOpenProcess(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);
}

NTSTATUS(NTAPI* OriginalNtOpenThread)(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
NTSTATUS NTAPI HookedNtOpenThread(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_OPEN_THREAD) == TRUE &&
		ExGetPreviousMode() == UserMode)
	{
		__try
		{
			ProbeForWrite(ProcessHandle, 4, 1);
			ProbeForWrite(ObjectAttributes, 28, 4);
		}

		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			return GetExceptionCode();
		}

		if (ClientId != NULL)
		{
			__try
			{
				ProbeForRead(ClientId, 1, 4);
				volatile ULONG64 Touch = (ULONG64)ClientId->UniqueProcess;
				Touch = (ULONG64)ClientId->UniqueThread;
			}

			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				return GetExceptionCode();
			}

			if (ClientId->UniqueThread == NULL)
				return OriginalNtOpenThread(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);

			PETHREAD TargetThread;
			PsLookupThreadByThreadId(ClientId->UniqueThread, &TargetThread);
			if (TargetThread != NULL)
			{
				PEPROCESS TargetProcess = IoThreadToProcess(TargetThread);
				UNICODE_STRING ProcessImageName = PsQueryFullProcessImageName(TargetProcess);

				if (Hider::IsProcessNameBad(&ProcessImageName) == TRUE)
				{
					HANDLE OriginalTID = ClientId->UniqueThread;
					ClientId->UniqueThread = UlongToHandle(0xFFFFFFFC);

					NTSTATUS Status = OriginalNtOpenThread(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);

					ClientId->UniqueThread = OriginalTID;

					return Status;
				}
			}
		}
	}
	return OriginalNtOpenThread(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);
}

NTSTATUS(NTAPI* OriginalNtCreateFile)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes,
	PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes,
	ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
NTSTATUS NTAPI HookedNtCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes,
	PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes,
	ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_CREATE_FILE) == TRUE &&
		ExGetPreviousMode() == UserMode
		)
	{
		NTSTATUS Status = OriginalNtCreateFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);

		if (NT_SUCCESS(Status) == TRUE)
		{
			__try
			{
				UNICODE_STRING SymLink;
				RtlInitUnicodeString(&SymLink, ObjectAttributes->ObjectName->Buffer);

				if (Hider::IsDriverHandleHidden(&SymLink) == TRUE)
				{
					ObCloseHandle(*FileHandle, UserMode);
					*FileHandle = INVALID_HANDLE_VALUE;
					Status = STATUS_OBJECT_NAME_NOT_FOUND;
				}
			}

			__except (EXCEPTION_EXECUTE_HANDLER)
			{
			}
		}

		return Status;
	}

	return OriginalNtCreateFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);
}

NTSTATUS(NTAPI* OriginalNtCreateThreadEx)
(
	PHANDLE ThreadHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	HANDLE ProcessHandle,
	PVOID StartRoutine,
	PVOID Argument,
	ULONG CreateFlags,
	SIZE_T ZeroBits,
	SIZE_T StackSize,
	SIZE_T MaximumStackSize,
	PVOID AttributeList
	);
NTSTATUS NTAPI HookedNtCreateThreadEx
(
	PHANDLE ThreadHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	HANDLE ProcessHandle,
	PVOID StartRoutine,
	PVOID Argument,
	ULONG CreateFlags,
	SIZE_T ZeroBits,
	SIZE_T StackSize,
	SIZE_T MaximumStackSize,
	PVOID AttributeList
)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_CREATE_THREAD_EX) == TRUE &&
		(CreateFlags & THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER ||
			CreateFlags & THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE))
	{
		NTSTATUS Status;
		ULONG OriginalFlags = CreateFlags;

		if (g_HyperHide.CurrentWindowsBuildNumber >= WINDOWS_10_VERSION_19H1)
			Status = OriginalNtCreateThreadEx(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags & ~(THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER | THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE), ZeroBits, StackSize, MaximumStackSize, AttributeList);

		else
			Status = OriginalNtCreateThreadEx(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags & ~(THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER), ZeroBits, StackSize, MaximumStackSize, AttributeList);

		if (NT_SUCCESS(Status) == TRUE)
		{
			PETHREAD NewThread;
			NTSTATUS ObStatus = ObReferenceObjectByHandle(*ThreadHandle, NULL, *PsThreadType, KernelMode, (PVOID*)&NewThread, NULL);

			if (NT_SUCCESS(ObStatus) == TRUE)
			{
				PEPROCESS TargetProcess;
				ObStatus = ObReferenceObjectByHandle(ProcessHandle, NULL, *PsProcessType, KernelMode, (PVOID*)&TargetProcess, NULL);

				if (NT_SUCCESS(ObStatus) == TRUE)
				{
					if (Hider::IsHidden(TargetProcess, HIDE_NT_CREATE_THREAD_EX) == TRUE)
					{
						Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(TargetProcess, NewThread);
						if (HiddenThread != NULL)
							HiddenThread->IsThreadHidden = OriginalFlags & THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER;
					}
					ObDereferenceObject(TargetProcess);
				}
				ObDereferenceObject(NewThread);
			}
		}

		return Status;
	}

	return OriginalNtCreateThreadEx(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize, AttributeList);
}

NTSTATUS(NTAPI* OriginalNtCreateProcessEx)
(
	OUT PHANDLE     ProcessHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes  OPTIONAL,
	IN HANDLE   ParentProcess,
	IN ULONG    Flags,
	IN HANDLE SectionHandle     OPTIONAL,
	IN HANDLE DebugPort     OPTIONAL,
	IN HANDLE ExceptionPort     OPTIONAL,
	IN ULONG  JobMemberLevel
	);
NTSTATUS NTAPI HookedNtCreateProcessEx
(
	OUT PHANDLE     ProcessHandle,
	IN ACCESS_MASK  DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes  OPTIONAL,
	IN HANDLE   ParentProcess,
	IN ULONG    Flags,
	IN HANDLE SectionHandle     OPTIONAL,
	IN HANDLE DebugPort     OPTIONAL,
	IN HANDLE ExceptionPort     OPTIONAL,
	IN ULONG  JobMemberLevel
)
{
	NTSTATUS Status = OriginalNtCreateProcessEx(ProcessHandle, DesiredAccess, ObjectAttributes, ParentProcess, Flags, SectionHandle, DebugPort, ExceptionPort, JobMemberLevel);
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_CREATE_PROCESS_EX) == TRUE &&
		NT_SUCCESS(Status) == TRUE)
	{
		PEPROCESS NewProcess;
		NTSTATUS ObStatus = ObReferenceObjectByHandle(*ProcessHandle, NULL, *PsProcessType, KernelMode, (PVOID*)&NewProcess, NULL);
		if (NT_SUCCESS(ObStatus) == TRUE)
		{
			Hider::PHIDDEN_PROCESS HiddenProcess = Hider::QueryHiddenProcess(IoGetCurrentProcess());
			Hider::CreateEntry(HiddenProcess->DebuggerProcess, NewProcess);

			HIDE_INFO HideInfo = { 0 };

			RtlFillBytes(&HideInfo.HookNtQueryInformationProcess, 1, sizeof(HideInfo) - 4);
			HideInfo.Pid = HandleToUlong(PsGetProcessId(NewProcess));

			Hider::Hide(&HideInfo);
			ObDereferenceObject(NewProcess);
		}
	}
	return Status;
}

NTSTATUS(NTAPI* OriginalNtCreateUserProcess)
(
	PHANDLE ProcessHandle,
	PHANDLE ThreadHandle,
	ACCESS_MASK ProcessDesiredAccess,
	ACCESS_MASK ThreadDesiredAccess,
	POBJECT_ATTRIBUTES ProcessObjectAttributes,
	POBJECT_ATTRIBUTES ThreadObjectAttributes,
	ULONG ProcessFlags,
	ULONG ThreadFlags,
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
	PVOID CreateInfo, // PPS_CREATE_INFO
	PVOID AttributeList // PPS_ATTRIBUTE_LIST
	);

NTSTATUS NTAPI HookedNtCreateUserProcess
(
	PHANDLE ProcessHandle,
	PHANDLE ThreadHandle,
	ACCESS_MASK ProcessDesiredAccess,
	ACCESS_MASK ThreadDesiredAccess,
	POBJECT_ATTRIBUTES ProcessObjectAttributes,
	POBJECT_ATTRIBUTES ThreadObjectAttributes,
	ULONG ProcessFlags,
	ULONG ThreadFlags,
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
	PVOID CreateInfo, // PPS_CREATE_INFO
	PVOID AttributeList // PPS_ATTRIBUTE_LIST
)
{
	NTSTATUS Status = OriginalNtCreateUserProcess
	(
		ProcessHandle, ThreadHandle,
		ProcessDesiredAccess, ThreadDesiredAccess,
		ProcessObjectAttributes, ThreadObjectAttributes,
		ProcessFlags, ThreadFlags,
		ProcessParameters, CreateInfo, AttributeList
	);

	PEPROCESS CurrentProcess = IoGetCurrentProcess();
	if (Hider::IsHidden(CurrentProcess, HIDE_NT_CREATE_PROCESS_EX) == TRUE &&
		ExGetPreviousMode() == UserMode &&
		NT_SUCCESS(Status) == TRUE)
	{
		PEPROCESS NewProcess;
		NTSTATUS ObStatus = ObReferenceObjectByHandle(*ProcessHandle, NULL, *PsProcessType, KernelMode, (PVOID*)&NewProcess, NULL);
		if (NT_SUCCESS(ObStatus) == TRUE)
		{
			Hider::PHIDDEN_PROCESS HiddenProcess = Hider::QueryHiddenProcess(CurrentProcess);
			if (HiddenProcess != NULL)
			{
				HIDE_INFO HideInfo = { 0 };

				Hider::CreateEntry(HiddenProcess->DebuggerProcess, NewProcess);

				RtlFillBytes(&HideInfo.HookNtQueryInformationProcess, 1, sizeof(HideInfo) - 4);
				HideInfo.Pid = HandleToUlong(PsGetProcessId(NewProcess));

				Hider::Hide(&HideInfo);
			}

			ObDereferenceObject(NewProcess);
		}
	}


	return Status;
}

NTSTATUS(NTAPI* OriginalNtYieldExecution)();
NTSTATUS NTAPI HookedNtYieldExecution()
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_YIELD_EXECUTION) == TRUE)
	{
		OriginalNtYieldExecution();
		return STATUS_SUCCESS;
	}

	return OriginalNtYieldExecution();
}

NTSTATUS(NTAPI* OriginalNtQuerySystemTime)(PLARGE_INTEGER SystemTime);
NTSTATUS NTAPI HookedNtQuerySystemTime(PLARGE_INTEGER SystemTime)
{
	PEPROCESS Current = IoGetCurrentProcess();

	if (Hider::IsHidden(Current, HIDE_NT_QUERY_SYSTEM_TIME) == TRUE &&
		ExGetPreviousMode() == UserMode)
	{
		__try
		{
			ProbeForWrite(SystemTime, sizeof(ULONG64), 4);

			Hider::PHIDDEN_PROCESS HiddenProcess = Hider::QueryHiddenProcess(Current);
			if (HiddenProcess != NULL)
			{
				if (Hider::IsHidden(Current, HIDE_KUSER_SHARED_DATA) == TRUE)
					SystemTime->QuadPart = *(ULONG64*)&HiddenProcess->Kusd.KuserSharedData->SystemTime;

				else
				{
					if (HiddenProcess->FakeSystemTime.QuadPart == NULL)
						KeQuerySystemTime(&HiddenProcess->FakeSystemTime);

					SystemTime->QuadPart = HiddenProcess->FakeSystemTime.QuadPart;
					HiddenProcess->FakeSystemTime.QuadPart += 1;
				}

				return STATUS_SUCCESS;
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			return GetExceptionCode();
		}
	}

	return OriginalNtQuerySystemTime(SystemTime);
}

NTSTATUS(NTAPI* OriginalNtQueryPerformanceCounter)(PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);
NTSTATUS NTAPI HookedNtQueryPerformanceCounter(PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency)
{
	PEPROCESS Current = IoGetCurrentProcess();

	if (Hider::IsHidden(Current, HIDE_NT_QUERY_SYSTEM_TIME) == TRUE &&
		ExGetPreviousMode() == UserMode
		)
	{
		__try
		{
			ProbeForWrite(PerformanceCounter, sizeof(ULONG64), 4);
			if (PerformanceFrequency != NULL)
			{
				ProbeForWrite(PerformanceFrequency, sizeof(ULONG64), 4);
			}

			Hider::PHIDDEN_PROCESS HiddenProcess = Hider::QueryHiddenProcess(Current);
			if (HiddenProcess != NULL)
			{
				if (Hider::IsHidden(Current, HIDE_KUSER_SHARED_DATA) == TRUE)
					PerformanceCounter->QuadPart = HiddenProcess->Kusd.KuserSharedData->BaselineSystemTimeQpc;

				else
				{
					if (HiddenProcess->FakePerformanceCounter.QuadPart == NULL)
						HiddenProcess->FakePerformanceCounter = KeQueryPerformanceCounter(NULL);

					PerformanceCounter->QuadPart = HiddenProcess->FakePerformanceCounter.QuadPart;
					HiddenProcess->FakePerformanceCounter.QuadPart += 1;
				}

				if (PerformanceFrequency != NULL)
					PerformanceFrequency->QuadPart = KuserSharedData->QpcFrequency;

				return STATUS_SUCCESS;
			}
		}

		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			return GetExceptionCode();
		}
	}

	return OriginalNtQueryPerformanceCounter(PerformanceCounter, PerformanceFrequency);
}

NTSTATUS(NTAPI* OriginalNtContinue)(PCONTEXT Context, ULONG64 TestAlert);
NTSTATUS NTAPI HookedNtContinue(PCONTEXT Context, ULONG64 TestAlert)
{
	PEPROCESS CurrentProcess = IoGetCurrentProcess();
	if (Hider::IsHidden(CurrentProcess, HIDE_NT_CONTINUE) == TRUE &&
		ExGetPreviousMode() == UserMode)
	{
		__try
		{
			ProbeForRead(Context, 1, 16);

			Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(CurrentProcess, (PETHREAD)KeGetCurrentThread());

			if ((Context->Dr0 != __readdr(0) && Context->Dr1 != __readdr(1) &&
				Context->Dr2 != __readdr(2) && Context->Dr3 != __readdr(3) &&
				Context->ContextFlags & 0x10 && HiddenThread != NULL) == TRUE)
			{
				RtlCopyBytes(&HiddenThread->FakeDebugContext.DR0, &Context->Dr0, sizeof(ULONG64) * 6);
				RtlCopyBytes(&HiddenThread->FakeDebugContext.DebugControl, &Context->DebugControl, sizeof(ULONG64) * 5);
			}

			Context->ContextFlags &= ~0x10;

			return OriginalNtContinue(Context, TestAlert);
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			return GetExceptionCode();
		}
	}

	return OriginalNtContinue(Context, TestAlert);
}

NTSTATUS(NTAPI* OriginalNtQueryInformationJobObject)(HANDLE JobHandle, JOBOBJECTINFOCLASS JobInformationClass, PVOID JobInformation, ULONG JobInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtQueryInformationJobObject(HANDLE JobHandle, JOBOBJECTINFOCLASS JobInformationClass, PVOID JobInformation, ULONG JobInformationLength, PULONG ReturnLength)
{
	NTSTATUS Status = OriginalNtQueryInformationJobObject(JobHandle, JobInformationClass, JobInformation, JobInformationLength, ReturnLength);
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_QUERY_INFORMATION_JOB_OBJECT) == TRUE &&
		JobInformationClass == JobObjectBasicProcessIdList &&
		NT_SUCCESS(Status) == TRUE)
	{
		BACKUP_RETURNLENGTH();

		PJOBOBJECT_BASIC_PROCESS_ID_LIST JobProcessIdList = (PJOBOBJECT_BASIC_PROCESS_ID_LIST)JobInformation;
		for (size_t i = 0; i < JobProcessIdList->NumberOfAssignedProcesses; i++)
		{
			if (Hider::IsDebuggerProcess(PidToProcess(JobProcessIdList->ProcessIdList[i])) == TRUE)
			{
				if (i == JobProcessIdList->NumberOfAssignedProcesses - 1)
					JobProcessIdList->ProcessIdList[i] = NULL;

				else
				{
					for (size_t j = i + 1; j < JobProcessIdList->NumberOfAssignedProcesses; j++)
					{
						JobProcessIdList->ProcessIdList[j - 1] = JobProcessIdList->ProcessIdList[j];
						JobProcessIdList->ProcessIdList[j] = 0;
					}
				}

				JobProcessIdList->NumberOfAssignedProcesses--;
				JobProcessIdList->NumberOfProcessIdsInList--;
			}
		}

		RESTORE_RETURNLENGTH();
	}
	return Status;
}

// Win32k Syscalls

HANDLE(NTAPI* OriginalNtUserQueryWindow)(HANDLE hWnd, WINDOWINFOCLASS WindowInfo);
HANDLE NTAPI HookedNtUserQueryWindow(HANDLE hWnd, WINDOWINFOCLASS WindowInfo)
{
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_USER_QUERY_WINDOW) == TRUE &&
		(WindowInfo == WindowProcess || WindowInfo == WindowThread) &&
		IsWindowBad(hWnd))
	{
		if (WindowInfo == WindowProcess)
			return PsGetCurrentProcessId();

		if (WindowInfo == WindowThread)
			return PsGetCurrentProcessId();
	}
	return OriginalNtUserQueryWindow(hWnd, WindowInfo);
}

NTSTATUS(NTAPI* OriginalNtUserBuildHwndList)(HANDLE hDesktop, HANDLE hwndParent, BOOLEAN bChildren, BOOLEAN bUnknownFlag, ULONG dwThreadId, ULONG lParam, PHANDLE pWnd, PULONG pBufSize);
NTSTATUS NTAPI HookedNtUserBuildHwndList(HANDLE hDesktop, HANDLE hwndParent, BOOLEAN bChildren, BOOLEAN bUnknownFlag, ULONG dwThreadId, ULONG lParam, PHANDLE pWnd, PULONG pBufSize)
{
	NTSTATUS Status = OriginalNtUserBuildHwndList(hDesktop, hwndParent, bChildren, bUnknownFlag, dwThreadId, lParam, pWnd, pBufSize);
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_USER_BUILD_HWND_LIST) == TRUE &&
		NT_SUCCESS(Status) == TRUE &&
		pWnd != NULL &&
		pBufSize != NULL)
	{
		for (size_t i = 0; i < *pBufSize; i++)
		{
			if (pWnd[i] != NULL && IsWindowBad(pWnd[i]) == TRUE)
			{
				if (i == *pBufSize - 1)
				{
					pWnd[i] = NULL;
					*pBufSize -= 1;
					continue;
				}

				for (size_t j = i + 1; j < *pBufSize; j++)
				{
					pWnd[i] = pWnd[j];
				}

				pWnd[*pBufSize - 1] = NULL;
				*pBufSize -= 1;
				continue;
			}
		}
	}

	return Status;
}

NTSTATUS(NTAPI* OriginalNtUserBuildHwndListSeven)(HANDLE hDesktop, HANDLE hwndParent, BOOLEAN bChildren, ULONG dwThreadId, ULONG lParam, PHANDLE pWnd, PULONG pBufSize);
NTSTATUS NTAPI HookedNtUserBuildHwndListSeven(HANDLE hDesktop, HANDLE hwndParent, BOOLEAN bChildren, ULONG dwThreadId, ULONG lParam, PHANDLE pWnd, PULONG pBufSize)
{
	NTSTATUS Status = OriginalNtUserBuildHwndListSeven(hDesktop, hwndParent, bChildren, dwThreadId, lParam, pWnd, pBufSize);

	PEPROCESS Current = IoGetCurrentProcess();
	if (Hider::IsHidden(Current, HIDE_NT_USER_BUILD_HWND_LIST) == TRUE &&
		NT_SUCCESS(Status) == TRUE &&
		pWnd != NULL &&
		pBufSize != NULL)
	{
		for (size_t i = 0; i < *pBufSize; i++)
		{
			if (pWnd[i] != NULL && IsWindowBad(pWnd[i]) == TRUE)
			{
				if (i == *pBufSize - 1)
				{
					pWnd[i] = NULL;
					*pBufSize -= 1;
					break;
				}

				for (size_t j = i + 1; j < *pBufSize; j++)
				{
					pWnd[i] = pWnd[j];
				}

				pWnd[*pBufSize - 1] = NULL;
				*pBufSize -= 1;
				break;
			}
		}
	}

	return Status;
}

HANDLE(NTAPI* OriginalNtUserFindWindowEx)(PVOID hwndParent, PVOID hwndChild, PUNICODE_STRING ClassName, PUNICODE_STRING WindowName, ULONG Type);
HANDLE NTAPI HookedNtUserFindWindowEx(PVOID hwndParent, PVOID hwndChild, PUNICODE_STRING ClassName, PUNICODE_STRING WindowName, ULONG Type)
{
	HANDLE hWnd = OriginalNtUserFindWindowEx(hwndParent, hwndChild, ClassName, WindowName, Type);
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_USER_FIND_WINDOW_EX) == TRUE &&
		hWnd != NULL)
	{
		if (Hider::IsProcessWindowBad(WindowName) == TRUE || Hider::IsProcessWindowClassBad(ClassName) == TRUE)
			return 0;
	}

	return hWnd;
}

HANDLE(NTAPI* OriginalNtUserGetForegroundWindow)();
HANDLE NTAPI HookedNtUserGetForegroundWindow()
{
	HANDLE hWnd = OriginalNtUserGetForegroundWindow();
	if (Hider::IsHidden(IoGetCurrentProcess(), HIDE_NT_USER_GET_FOREGROUND_WINDOW) == TRUE &&
		hWnd != NULL && IsWindowBad(hWnd) == TRUE)
	{
		hWnd = NtUserGetThreadState(THREADSTATE_ACTIVEWINDOW);
	}

	return hWnd;
}

VOID(NTAPI* OriginalKiDispatchException)(PEXCEPTION_RECORD ExceptionRecord, PKEXCEPTION_FRAME ExceptionFrame, PKTRAP_FRAME TrapFrame, KPROCESSOR_MODE PreviousMode, BOOLEAN FirstChance);
VOID NTAPI HookedKiDispatchException(PEXCEPTION_RECORD ExceptionRecord, PKEXCEPTION_FRAME ExceptionFrame, PKTRAP_FRAME TrapFrame, KPROCESSOR_MODE PreviousMode, BOOLEAN FirstChance)
{
	OriginalKiDispatchException(ExceptionRecord, ExceptionFrame, TrapFrame, PreviousMode, FirstChance);

	PEPROCESS CurrentProcess = IoGetCurrentProcess();//!!!!!!!
	if (PreviousMode == UserMode && TrapFrame->Rip == KiUserExceptionDispatcherAddress && Hider::IsHidden(CurrentProcess, HIDE_KI_EXCEPTION_DISPATCH) == TRUE)
	{
		PETHREAD CurentThread = (PETHREAD)KeGetCurrentThread();
		Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(CurrentProcess, CurentThread);

		PCONTEXT UserModeContext = (PCONTEXT)TrapFrame->Rsp;

		if (HiddenThread != NULL)
		{
			if (PsGetProcessWow64Process(CurrentProcess) == NULL)
			{
				RtlCopyBytes(&UserModeContext->Dr0, &HiddenThread->FakeDebugContext.DR0, sizeof(ULONG64) * 6);
				RtlCopyBytes(&UserModeContext->DebugControl, &HiddenThread->FakeDebugContext.DebugControl, sizeof(ULONG64) * 5);
				DbgPrint("RtlCopyBytes \n");
			}

			else
			{
				UserModeContext->Dr0 = HiddenThread->FakeWow64DebugContext.DR0;
				UserModeContext->Dr1 = HiddenThread->FakeWow64DebugContext.DR1;
				UserModeContext->Dr2 = HiddenThread->FakeWow64DebugContext.DR2;
				UserModeContext->Dr3 = HiddenThread->FakeWow64DebugContext.DR3;
				UserModeContext->Dr6 = HiddenThread->FakeWow64DebugContext.DR6;
				UserModeContext->Dr7 = HiddenThread->FakeWow64DebugContext.DR7;

				RtlSecureZeroMemory(&TrapFrame->DebugControl, sizeof(ULONG64) * 5);
				DbgPrint("RtlSecureZeroMemory \n");
			}
		}
	}
}


NTSTATUS   KeReadMemory(IN HANDLE ProcessHandle, IN PVOID AddressToRead, IN ULONG LenthToRead, IN OUT PVOID BufferToRecviveData)
{
	NTSTATUS    status = STATUS_UNSUCCESSFUL;
	PEPROCESS   ProcessPointer = NULL;
	BOOLEAN     IsAttached = FALSE;
	__try
	{

		status = ObReferenceObjectByHandle((HANDLE)ProcessHandle,
			PROCESS_VM_READ,
			*PsProcessType,
			KernelMode,
			(PVOID*)&ProcessPointer,
			NULL);
		if (!NT_SUCCESS(status))
		{
			__leave;
		}
		ObDereferenceObject(ProcessPointer);
		IsAttached = TRUE;

		KeAttachProcess((PRKPROCESS)ProcessPointer);
		if (!MmIsAddressValid(AddressToRead))
			status = STATUS_INVALID_PARAMETER;
		else
			RtlCopyMemory(BufferToRecviveData, (PVOID)AddressToRead, LenthToRead);

	}
	__finally
	{
		if (IsAttached)
		{
			KeDetachProcess();
			IsAttached = FALSE;
		}
	}
	return status;
}

#define ProbeForWriteUlong_ptr(Address) {                                    \
    if ((Address) >= (ULONG_PTR * const)MM_USER_PROBE_ADDRESS) {             \
        *(volatile ULONG_PTR * const)MM_USER_PROBE_ADDRESS = 0;              \
    }                                                                        \
                                                                             \
    *(volatile ULONG_PTR *)(Address) = *(volatile ULONG_PTR *)(Address);     \
}

NTSTATUS
myNtReadVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	OUT PVOID Buffer,
	IN ULONG BufferSize,
	OUT PULONG NumberOfBytesRead OPTIONAL
)
{
	SIZE_T BytesCopied = 0;
	KPROCESSOR_MODE PreviousMode;
	PEPROCESS Process;
	NTSTATUS Status;

	PAGED_CODE();

	PreviousMode = ExGetPreviousMode();
	if (PreviousMode != KernelMode) {
		if (((PCHAR)BaseAddress + BufferSize < (PCHAR)BaseAddress) ||
			((PCHAR)Buffer + BufferSize < (PCHAR)Buffer) ||
			((PVOID)((PCHAR)BaseAddress + BufferSize) > MM_HIGHEST_USER_ADDRESS) ||
			((PVOID)((PCHAR)Buffer + BufferSize) > MM_HIGHEST_USER_ADDRESS)) {

			return STATUS_ACCESS_VIOLATION;
		}

		if (ARGUMENT_PRESENT(NumberOfBytesRead)) {
			__try {
				ProbeForWriteUlong_ptr((PULONG_PTR)NumberOfBytesRead);

			}
			__except (EXCEPTION_EXECUTE_HANDLER) {
				return GetExceptionCode();
			}
		}
	}

	BytesCopied = 0;
	Status = STATUS_SUCCESS;
	if (BufferSize != 0) {

		Status = ObReferenceObjectByHandle(ProcessHandle,
			PROCESS_VM_READ,
			*PsProcessType,
			PreviousMode,
			(PVOID*)&Process,
			NULL);

		if (Status == STATUS_SUCCESS) {
			Status = MmCopyVirtualMemory(Process,
				BaseAddress,
				PsGetCurrentProcess(),
				Buffer,
				BufferSize,
				PreviousMode,
				&BytesCopied);

			ObDereferenceObject(Process);
		}
	}

	if (ARGUMENT_PRESENT(NumberOfBytesRead)) {
		__try {
			*NumberOfBytesRead = BytesCopied;
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			NOTHING;
		}
	}

	return Status;
}

NTSTATUS myNtReadVirtualMemory1(IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	OUT PVOID Buffer,
	IN ULONG NumberOfBytesToRead,
	OUT PULONG NumberOfBytesRead)
{
	NTSTATUS Status;
	PMDL Mdl;
	PVOID SystemAddress;
	PEPROCESS Process;

	DbgPrint("NtReadVirtualMemory(ProcessHandle %x, BaseAddress %x, "
		"Buffer %x, NumberOfBytesToRead %d)\n", ProcessHandle, BaseAddress,
		Buffer, NumberOfBytesToRead);

	Status = ObReferenceObjectByHandle(ProcessHandle,
		PROCESS_VM_WRITE,
		NULL,
		UserMode,
		(PVOID*)(&Process),
		NULL);

	if (Status != STATUS_SUCCESS)
	{
		return(Status);
	}

	Mdl = MmCreateMdl(NULL, Buffer, NumberOfBytesToRead);
	MmProbeAndLockPages(Mdl, UserMode, IoWriteAccess);
	KeAttachProcess(Process);
	SystemAddress = MmGetSystemAddressForMdl(Mdl);
	memcpy(SystemAddress, BaseAddress, NumberOfBytesToRead);
	KeDetachProcess();
	if (Mdl->MappedSystemVa != NULL)
	{
		MmUnmapLockedPages(Mdl->MappedSystemVa, Mdl);
	}
	MmUnlockPages(Mdl);
	ExFreePool(Mdl);

	ObDereferenceObject(Process);

	memcpy(Buffer, BaseAddress, NumberOfBytesToRead);
	*NumberOfBytesRead = NumberOfBytesToRead;
	return(STATUS_SUCCESS);
}


//VOID KeAttachProcess(PEPROCESS Process)
//{
//	KIRQL oldlvl;
//	PETHREAD_S CurrentThread;
//	PULONG AttachedProcessPageDir;
//	ULONG PageDir;
//
//	DbgPrint("KeAttachProcess(Process %x)\n", Process);
//
//	CurrentThread = PsGetCurrentThread();
//
//	if (CurrentThread->OldProcess != NULL)
//	{
//		DbgPrint("Invalid attach (thread is already attached)\n");
//		KeBugCheck(0);
//	}
//
//	KeRaiseIrql(DISPATCH_LEVEL, &oldlvl);
//
//	KiSwapApcEnvironment(&CurrentThread->Tcb, &Process->Pcb);
//	/* The stack of the current process may be located in a page which is
//		 not present in the page directory of the process we're attaching to.
//		 That would lead to a page fault when this function returns. However,
//		 since the processor can't call the page fault handler 'cause it can't
//		 push EIP on the stack, this will show up as a stack fault which will
//		 crash the entire system.
//		 To prevent this, make sure the page directory of the process we're
//		 attaching to is up-to-date. */
//
//	AttachedProcessPageDir = ExAllocatePageWithPhysPage(Process->Pcb.DirectoryTableBase);
//	MmUpdateStackPageDir(AttachedProcessPageDir, &CurrentThread->Tcb);
//	ExUnmapPage(AttachedProcessPageDir);
//	CurrentThread->OldProcess = PsGetCurrentProcess();
//	CurrentThread->ThreadsProcess = Process;
//	PageDir = Process->Pcb.DirectoryTableBase.u.LowPart;
//	DbgPrint("Switching process context to %x\n", PageDir);
//	Ke386SetPageTableDirectory(PageDir);
//	KeLowerIrql(oldlvl);
//}

typedef NTSTATUS(*NtReadVirtualMemory_t)(
	IN HANDLE               ProcessHandle,
	IN PVOID                BaseAddress,
	IN PVOID                Buffer,
	IN ULONG                NumberOfBytesToRead,
	OUT PULONG              NumberOfBytesReaded OPTIONAL);
NtReadVirtualMemory_t orignal_NtReadVirtualMemory;
NTSTATUS NTAPI HookNtReadVirtualMemory(IN HANDLE ProcessHandle, IN PVOID BaseAddress, OUT PVOID Buffer, IN ULONG NumberOfBytesToRead, PULONG NumberOfBytesReaded)
{
	NTSTATUS ret = myNtReadVirtualMemory(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToRead, NumberOfBytesReaded);
	if (NT_SUCCESS(ret))
	{
		return STATUS_SUCCESS;
	}
	else
	{
		DbgPrint("NtReadVirtualMemory failed:%x(ProcessHandle: %p, BaseAddress: %p, "
			"Buffer: %p, NumberOfBytesToRead %d)\n", ProcessHandle, BaseAddress,
			Buffer, NumberOfBytesToRead, ret);

		return ret;
	}




	//if (ProcessHandle == (HANDLE)-1)
	//{
	//	DbgPrint("ProcessHandle = -1 \n");
	//	return orignal_NtReadVirtualMemory(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToRead, NumberOfBytesReaded);
	//}

	//PEPROCESS pTargetProcess;
	//if (NT_SUCCESS(ObReferenceObjectByHandle(ProcessHandle, PROCESS_VM_READ, *PsProcessType, ExGetPreviousMode(), (PVOID*)&pTargetProcess, nullptr)));
	//{
	//	if (IoGetCurrentProcess() == pTargetProcess)
	//	{
	//		DbgPrint("EProcess equal\n");
	//		return orignal_NtReadVirtualMemory(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToRead, NumberOfBytesReaded);
	//	}
	//}

	PEPROCESS currProcess;
	NTSTATUS status = PsLookupProcessByProcessId(PsGetCurrentProcessId(), &currProcess);
	if (NT_SUCCESS(status))
	{
		CHAR* Name = (char*)PsGetProcessImageFileName(currProcess);
		//if (_stricmp(Name, "ce32.exe") == 0 || _stricmp(Name, "ce64.exe") == 0 || _stricmp(Name, "ce.exe") == 0
			//|| _stricmp(Name, "x64dbg.exe") == 0)
			//if(PsGetCurrentProcessId() == (HANDLE)3712)
		{
			CHAR* psname = (char*)GetProcessNameFromProcessHandle(ProcessHandle);
			if (psname)
			{
				//if (_stricmp(psname, "tslgame.exe") == 0)
				{
					PEPROCESS popenProcess;
					if (NT_SUCCESS(ObReferenceObjectByHandle(ProcessHandle, PROCESS_VM_READ, *PsProcessType, ExGetPreviousMode(), (PVOID*)&popenProcess, nullptr)))
					{
						//if (NumberOfBytesReaded)
						//{
						//	SIZE_T  BytesCopied = 0;
						//	NTSTATUS ret = MmCopyVirtualMemory(popenProcess, BaseAddress, currProcess, Buffer, NumberOfBytesToRead, ExGetPreviousMode(), (PSIZE_T)&BytesCopied);
						//	if (NT_SUCCESS(ret))
						//	{
						//		//DbgPrint("MmCopyVirtualMemory ok \n");
						//	}
						//	ObDereferenceObject(popenProcess);
						//	ObDereferenceObject(currProcess);
						//	*NumberOfBytesReaded = BytesCopied;
						//	return ret;
						//}
						if (NumberOfBytesReaded)
						{
							SIZE_T size = NumberOfBytesToRead;
							BOOLEAN ret = MyReadMemory(BaseAddress, Buffer, size, NumberOfBytesReaded, popenProcess,0);
							if (ret)
							{
								//DbgPrint("HookNtReadVirtualMemory:MyReadMemory:%d \n", NumberOfBytesToRead);
								//KeStackAttachProcess(PsGetCurrentProcess(), &apc);
								*NumberOfBytesReaded = NumberOfBytesToRead;
								//KeUnstackDetachProcess(&apc);
								ObDereferenceObject(popenProcess);
								return STATUS_SUCCESS;
							}
							else
							{
								DbgPrint("currpid:%p HookNtReadVirtualMemory:MyReadMemory:failed \n", PsGetCurrentProcessId());
								return ret;
							}
						}
						ObDereferenceObject(popenProcess);
					}
					else
					{
						DbgPrint("HookNtReadVirtualMemory:ObReferenceObjectByHandle failed\n");
					}
				}
			}
		}
	}
	//DbgPrint("NumberOfBytesToRead:%lu NumberOfBytesReaded:%lu \n", NumberOfBytesToRead, *NumberOfBytesReaded);
	//return orignal_NtReadVirtualMemory(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToRead, NumberOfBytesReaded);

	//NTSTATUS ntsat = orignal_NtReadVirtualMemory(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToRead, NumberOfBytesReaded);
	//DbgPrint("orignal_NtReadVirtualMemory:NumberOfBytesToRead:%lu NumberOfBytesReaded:%lu\n", NumberOfBytesToRead, *NumberOfBytesReaded);
	//return ntsat;

}

typedef NTSTATUS(*NtWriteVirtualMemory_t)(
	IN HANDLE               ProcessHandle,
	IN PVOID                BaseAddress,
	IN PVOID                Buffer,
	IN ULONG                NumberOfBytesToWrite,
	OUT PULONG              NumberOfBytesWritten OPTIONAL);
NtWriteVirtualMemory_t orignal_NtWriteVirtualMemory;
NTSTATUS NTAPI HookNtWriteVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten)
{
	PEPROCESS ps;
	NTSTATUS status = PsLookupProcessByProcessId(PsGetCurrentProcessId(), &ps);
	if (NT_SUCCESS(status))
	{
		char* Name = (char*)PsGetProcessImageFileName(ps);
		if (_stricmp(Name, "ce32.exe") == 0 || _stricmp(Name, "ce64.exe") == 0 || _stricmp(Name, "ce.exe") == 0
			|| _stricmp(Name, "x64dbg.exe") == 0)
		{
			PEPROCESS popenProcess;
			if (NT_SUCCESS(ObReferenceObjectByHandle(ProcessHandle, 0, *PsProcessType, ExGetPreviousMode(), (PVOID*)&popenProcess, nullptr)))
			{
				ObDereferenceObject(popenProcess);
				MyWriteMemory(BaseAddress, Buffer, NumberOfBytesToWrite, ps);
				*NumberOfBytesWritten = NumberOfBytesToWrite;
				return STATUS_SUCCESS;
			}
		}
	}


	/*
	if (g_startDebug)
	{
		ULONG pid = (ULONG)(ULONG_PTR)PsGetCurrentProcessId();
		if (g_DbgPid == pid)
		{
			if (GetProcessIDFromProcessHandle(ProcessHandle) == g_GamePid)
			{
				return pfn_NtWriteVirtualMemory(g_GameHandle, BaseAddress, Buffer, NumberOfBytesToWrite, NumberOfBytesWritten);
			}
		}
	}
	*/
	return orignal_NtWriteVirtualMemory(ProcessHandle, BaseAddress, Buffer, NumberOfBytesToWrite, NumberOfBytesWritten);
}

BOOLEAN HookSyscalls()
{
	NT_SYSCALL_NUMBERS SyscallNumbers;
	WIN32K_SYSCALL_NUMBERS Win32KSyscallNumbers;

	KeInitializeMutex(&NtCloseMutex, 0);
	GetNtSyscallNumbers(SyscallNumbers);
	GetWin32kSyscallNumbers(Win32KSyscallNumbers);

	PEPROCESS CsrssProcess = GetCsrssProcess();
	PVOID NtDllAddress = GetUserModeModule(CsrssProcess, L"ntdll.dll", FALSE);

	KiUserExceptionDispatcherAddress = (ULONG64)GetExportedFunctionAddress(CsrssProcess, NtDllAddress, "KiUserExceptionDispatcher");
	if (KiUserExceptionDispatcherAddress == NULL)
	{
		LogError("Couldn't get KiUserExceptionDispatcher address");
		return FALSE;
	}

	LogInfo("KiUserExceptionDispatcher address: 0x%llx", KiUserExceptionDispatcherAddress);

	NtUserGetThreadState = (HANDLE(NTAPI*)(ULONG))SSDT::GetWin32KFunctionAddress("NtUserGetThreadState", Win32KSyscallNumbers.NtUserGetThreadState);
	if (NtUserGetThreadState == NULL)
	{
		LogError("Couldn't get NtUserGetThreadState address");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtContinue, HookedNtContinue, (PVOID*)&OriginalNtContinue) == FALSE)
	{
		LogError("NtContinue hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtSetInformationThread, HookedNtSetInformationThread, (PVOID*)&OriginalNtSetInformationThread) == FALSE)
	{
		LogError("NtSetInformationThread hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtQueryInformationProcess, HookedNtQueryInformationProcess, (PVOID*)&OriginalNtQueryInformationProcess) == FALSE)
	{
		LogError("NtQueryInformationProcess hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtQueryObject, HookedNtQueryObject, (PVOID*)&OriginalNtQueryObject) == FALSE)
	{
		LogError("NtQueryObject hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtSystemDebugControl, HookedNtSystemDebugControl, (PVOID*)&OriginalNtSystemDebugControl) == FALSE)
	{
		LogError("NtSystemDebugControl hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtClose, HookedNtClose, (PVOID*)&OriginalNtClose) == FALSE)
	{
		LogError("NtClose hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtSetContextThread, HookedNtSetContextThread, (PVOID*)&OriginalNtSetContextThread) == FALSE)
	{
		LogError("NtSetContextThread hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtQuerySystemInformation, HookedNtQuerySystemInformation, (PVOID*)&OriginalNtQuerySystemInformation) == FALSE)
	{
		LogError("NtQuerySystemInformation hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtGetContextThread, HookedNtGetContextThread, (PVOID*)&OriginalNtGetContextThread) == FALSE)
	{
		LogError("NtGetContextThread hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtQueryInformationThread, HookedNtQueryInformationThread, (PVOID*)&OriginalNtQueryInformationThread) == FALSE)
	{
		LogError("NtQueryInformationThread hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtCreateThreadEx, HookedNtCreateThreadEx, (PVOID*)&OriginalNtCreateThreadEx) == FALSE)
	{
		LogError("NtCreateThreadEx hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtCreateFile, HookedNtCreateFile, (PVOID*)&OriginalNtCreateFile) == FALSE)
	{
		LogError("NtCreateFile hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtCreateUserProcess, HookedNtCreateUserProcess, (PVOID*)&OriginalNtCreateUserProcess) == FALSE)
	{
		LogError("NtCreateUserProcess hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtCreateProcessEx, HookedNtCreateProcessEx, (PVOID*)&OriginalNtCreateProcessEx) == FALSE)
	{
		LogError("NtCreateProcessEx hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtYieldExecution, HookedNtYieldExecution, (PVOID*)&OriginalNtYieldExecution) == FALSE)
	{
		LogError("NtYieldExecution hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtQuerySystemTime, HookedNtQuerySystemTime, (PVOID*)&OriginalNtQuerySystemTime) == FALSE)
	{
		LogError("NtQuerySystemTime hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtQueryPerformanceCounter, HookedNtQueryPerformanceCounter, (PVOID*)&OriginalNtQueryPerformanceCounter) == FALSE)
	{
		LogError("NtQueryPerformanceCounter hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtQueryInformationJobObject, HookedNtQueryInformationJobObject, (PVOID*)&OriginalNtQueryInformationJobObject) == FALSE)
	{
		LogError("NtQueryInformationJobObject hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtGetNextProcess, HookedNtGetNextProcess, (PVOID*)&OriginalNtGetNextProcess) == FALSE)
	{
		LogError("NtGetNextProcess hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtOpenProcess, HookedNtOpenProcess, (PVOID*)&OriginalNtOpenProcess) == FALSE)
	{
		LogError("NtOpenProcess hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtOpenThread, HookedNtOpenThread, (PVOID*)&OriginalNtOpenThread) == FALSE)
	{
		LogError("NtOpenThread hook failed");
		return FALSE;
	}

	if (SSDT::HookNtSyscall(SyscallNumbers.NtSetInformationProcess, HookedNtSetInformationProcess, (PVOID*)&OriginalNtSetInformationProcess) == FALSE)
	{
		LogError("NtSetInformationProcess hook failed");
		return FALSE;
	}

	//if (SSDT::HookNtSyscall(SyscallNumbers.NtReadVirtualMemory, HookNtReadVirtualMemory, (PVOID*)&orignal_NtReadVirtualMemory) == FALSE)
	//{
	//	LogError("NtReadVirtualMemory hook failed");
	//	return FALSE;
	//}

	//if (SSDT::HookNtSyscall(SyscallNumbers.NtWriteVirtualMemory, HookNtWriteVirtualMemory, (PVOID*)&orignal_NtWriteVirtualMemory) == FALSE)
	//{
	//	LogError("NtWriteVirtualMemory hook failed");
	//	return FALSE;
	//}

	if (SSDT::HookWin32kSyscall("NtUserFindWindowEx", Win32KSyscallNumbers.NtUserFindWindowEx, HookedNtUserFindWindowEx, (PVOID*)&OriginalNtUserFindWindowEx) == FALSE)
	{
		LogError("NtUserFindWindowEx hook failed");
		return FALSE;
	}

	if (SSDT::HookWin32kSyscall("NtUserGetForegroundWindow", Win32KSyscallNumbers.NtUserGetForegroundWindow, HookedNtUserGetForegroundWindow, (PVOID*)&OriginalNtUserGetForegroundWindow) == FALSE)
	{
		LogError("NtUserGetForegroundWindow hook failed");
		return FALSE;
	}

	if (SSDT::HookWin32kSyscall("NtUserQueryWindow", Win32KSyscallNumbers.NtUserQueryWindow, HookedNtUserQueryWindow, (PVOID*)&OriginalNtUserQueryWindow) == FALSE)
	{
		LogError("NtUserQueryWindow hook failed");
		return FALSE;
	}

	if (g_HyperHide.CurrentWindowsBuildNumber <= WINDOWS_7_SP1)
	{
		if (SSDT::HookWin32kSyscall("NtUserBuildHwndList", Win32KSyscallNumbers.NtUserBuildHwndList, HookedNtUserBuildHwndListSeven, (PVOID*)&OriginalNtUserBuildHwndListSeven) == FALSE)
		{
			LogError("NtUserBuildHwndListSeven hook failed");
			return FALSE;
		}
	}

	else
	{
		if (SSDT::HookWin32kSyscall("NtUserBuildHwndList", Win32KSyscallNumbers.NtUserBuildHwndList, HookedNtUserBuildHwndList, (PVOID*)&OriginalNtUserBuildHwndList) == FALSE)
		{
			LogError("NtUserBuildHwndList hook failed");
			return FALSE;
		}
	}
	if (HookKiDispatchException(HookedKiDispatchException, (PVOID*)&OriginalKiDispatchException) == FALSE)
	{
		LogError("KiDispatchException hook failed");
		return FALSE;
	}


	return TRUE;
}
```

`HyperHideDrv/HookedFunctions.h`:

```h
#pragma once
#include <ntddk.h>

#define ObjectTypesInformation 3
#define THREAD_CREATE_FLAGS_BYPASS_PROCESS_FREEZE 0x40
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x4
#define PROCESS_DEBUG_INHERIT 0x00000001 // default for a non-debugged process
#define PROCESS_NO_DEBUG_INHERIT 0x00000002 // default for a debugged process
#define PROCESS_QUERY_INFORMATION   0x0400
#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)

#define BACKUP_RETURNLENGTH() \
    ULONG TempReturnLength = 0; \
    if(ARGUMENT_PRESENT(ReturnLength)) \
        TempReturnLength = *ReturnLength

#define RESTORE_RETURNLENGTH() \
    if(ARGUMENT_PRESENT(ReturnLength)) \
        (*ReturnLength) = TempReturnLength

BOOLEAN HookSyscalls();
```

`HyperHideDrv/HyperHideDrv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1B2A7FD5-27DE-4C1E-B1CA-9B732A690671}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>HyperHideDrv</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.18362.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfLdr.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfDriverEntry.lib</AdditionalDependencies>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfLdr.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfDriverEntry.lib</AdditionalDependencies>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ActiveProcessDbgList.c" />
    <ClCompile Include="CFunction.cpp" />
    <ClCompile Include="CKernelDbg.cpp" />
    <ClCompile Include="CKernelTable.cpp" />
    <ClCompile Include="CPeModule.cpp" />
    <ClCompile Include="DbgIsMyProcess.c" />
    <ClCompile Include="dbgk1to2.c" />
    <ClCompile Include="DBGTOOL.c" />
    <ClCompile Include="Dispatcher.cpp" />
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="DRRWE.c" />
    <ClCompile Include="Heap.cpp" />
    <ClCompile Include="Hider.cpp" />
    <ClCompile Include="HookHelper.cpp" />
    <ClCompile Include="HypervisorGateway.cpp" />
    <ClCompile Include="KernelApi.cpp" />
    <ClCompile Include="KuserSharedData.cpp" />
    <ClCompile Include="Log.cpp" />
    <ClCompile Include="Memroy.cpp" />
    <ClCompile Include="Notifiers.cpp" />
    <ClCompile Include="Peb.cpp" />
    <ClCompile Include="HookedFunctions.cpp" />
    <ClCompile Include="RWNoAttach.cpp" />
    <ClCompile Include="Ssdt.cpp" />
    <ClCompile Include="Utils.cpp" />
    <ClCompile Include="wrRegstry.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ActiveProcessDbgList.h" />
    <ClInclude Include="CFunction.h" />
    <ClInclude Include="CKernelDbg.h" />
    <ClInclude Include="CKernelTable.h" />
    <ClInclude Include="CPeModule.h" />
    <ClInclude Include="dbgk1to2.h" />
    <ClInclude Include="dbgtool.h" />
    <ClInclude Include="DRRWE.h" />
    <ClInclude Include="Header.h" />
    <ClInclude Include="Ioctl.h" />
    <ClInclude Include="Dispatcher.h" />
    <ClInclude Include="GlobalData.h" />
    <ClInclude Include="Heap.h" />
    <ClInclude Include="Hider.h" />
    <ClInclude Include="HookHelper.h" />
    <ClInclude Include="HypervisorGateway.h" />
    <ClInclude Include="KernelApi.h" />
    <ClInclude Include="KernelDbgStruct.h" />
    <ClInclude Include="KernelExportAPI.h" />
    <ClInclude Include="KernelStruct.h" />
    <ClInclude Include="KernelStruct1.h" />
    <ClInclude Include="KuserSharedData.h" />
    <ClInclude Include="Log.h" />
    <ClInclude Include="Memroy.h" />
    <ClInclude Include="Notifiers.h" />
    <ClInclude Include="Ntapi.h" />
    <ClInclude Include="Ntenums.h" />
    <ClInclude Include="Ntstructs.h" />
    <ClInclude Include="Peb.h" />
    <ClInclude Include="HookedFunctions.h" />
    <ClInclude Include="Pte.h" />
    <ClInclude Include="Ssdt.h" />
    <ClInclude Include="struct.h" />
    <ClInclude Include="Txoo.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="vmintrin.h" />
    <ClInclude Include="wrRegstry.h" />
    <ClInclude Include="获取汇编指令长度.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="vmintrin.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`HyperHideDrv/HyperHideDrv.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Source Files\antiAntidbg">
      <UniqueIdentifier>{5d68671c-7415-4fb6-ab20-e5ed4ab3cb62}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\anantidbg1">
      <UniqueIdentifier>{019e931b-5b32-4be4-9f2b-571998043dec}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\WR">
      <UniqueIdentifier>{cbbcf8dc-3055-45a9-a134-4a6ab5822ef0}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Heap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HookedFunctions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Peb.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hider.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HypervisorGateway.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KuserSharedData.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HookHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Dispatcher.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Notifiers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Ssdt.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CKernelDbg.cpp">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClCompile>
    <ClCompile Include="CFunction.cpp">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClCompile>
    <ClCompile Include="KernelApi.cpp">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClCompile>
    <ClCompile Include="Memroy.cpp">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClCompile>
    <ClCompile Include="CKernelTable.cpp">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClCompile>
    <ClCompile Include="CPeModule.cpp">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClCompile>
    <ClCompile Include="ActiveProcessDbgList.c">
      <Filter>Source Files\anantidbg1</Filter>
    </ClCompile>
    <ClCompile Include="dbgk1to2.c">
      <Filter>Source Files\anantidbg1</Filter>
    </ClCompile>
    <ClCompile Include="DRRWE.c">
      <Filter>Source Files\anantidbg1</Filter>
    </ClCompile>
    <ClCompile Include="DBGTOOL.c">
      <Filter>Source Files\anantidbg1</Filter>
    </ClCompile>
    <ClCompile Include="DbgIsMyProcess.c">
      <Filter>Source Files\anantidbg1</Filter>
    </ClCompile>
    <ClCompile Include="wrRegstry.c">
      <Filter>Source Files\WR</Filter>
    </ClCompile>
    <ClCompile Include="RWNoAttach.cpp">
      <Filter>Source Files\WR</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Ioctl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Ntstructs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Ntapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vmintrin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Heap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HookedFunctions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Peb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HypervisorGateway.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GlobalData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="KuserSharedData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HookHelper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dispatcher.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Notifiers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Ssdt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Pte.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Ntenums.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="KernelDbgStruct.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="获取汇编指令长度.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="Hider.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Header.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="KernelExportAPI.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="KernelStruct.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="struct.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="CFunction.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="KernelApi.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="Memroy.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="CKernelTable.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="CKernelDbg.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="CPeModule.h">
      <Filter>Source Files\antiAntidbg</Filter>
    </ClInclude>
    <ClInclude Include="ActiveProcessDbgList.h">
      <Filter>Source Files\anantidbg1</Filter>
    </ClInclude>
    <ClInclude Include="dbgtool.h">
      <Filter>Source Files\anantidbg1</Filter>
    </ClInclude>
    <ClInclude Include="DRRWE.h">
      <Filter>Source Files\anantidbg1</Filter>
    </ClInclude>
    <ClInclude Include="Txoo.h">
      <Filter>Source Files\anantidbg1</Filter>
    </ClInclude>
    <ClInclude Include="dbgk1to2.h">
      <Filter>Source Files\anantidbg1</Filter>
    </ClInclude>
    <ClInclude Include="KernelStruct1.h">
      <Filter>Source Files\anantidbg1</Filter>
    </ClInclude>
    <ClInclude Include="wrRegstry.h">
      <Filter>Source Files\WR</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="vmintrin.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`HyperHideDrv/HyperHideDrv.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`HyperHideDrv/HypervisorGateway.cpp`:

```cpp
#pragma warning( disable : 4201)
//#include <ntddk.h>
#include "vmintrin.h"
#include "Ntapi.h"
#include "Log.h"

#define IOCTL_POOL_MANAGER_ALLOCATE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

enum vm_call_reasons
{
	VMCALL_TEST,
	VMCALL_VMXOFF,
	VMCALL_EPT_HOOK_FUNCTION,
	VMCALL_EPT_UNHOOK_FUNCTION,
	VMCALL_INVEPT_CONTEXT,
	VMCALL_DUMP_POOL_MANAGER,
	VMCALL_DUMP_VMCS_STATE,
	VMCALL_HIDE_HV_PRESENCE,
	VMCALL_UNHIDE_HV_PRESENCE
};

enum invept_type
{
	INVEPT_SINGLE_CONTEXT = 1,
	INVEPT_ALL_CONTEXTS = 2
};

namespace hv
{
	void broadcast_vmoff(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(DeferredContext);
		UNREFERENCED_PARAMETER(Dpc);

		__vm_call(VMCALL_VMXOFF, 0, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	void broadcast_invept_all_contexts(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(DeferredContext);
		UNREFERENCED_PARAMETER(Dpc); 
		
		__vm_call(VMCALL_INVEPT_CONTEXT, true, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	void broadcast_invept_single_context(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(DeferredContext);
		UNREFERENCED_PARAMETER(Dpc); 
		
		__vm_call(VMCALL_INVEPT_CONTEXT, false, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	/// <summary>
	/// Turn off virtual machine
	/// </summary>
	void vmoff()
	{
		KeGenericCallDpc(broadcast_vmoff, NULL);
	}

	/// <summary>
	/// Unhook all pages
	/// </summary>
	/// <returns> status </returns>
	bool unhook_all_functions()
	{
		return __vm_call(VMCALL_EPT_UNHOOK_FUNCTION, true, 0, 0);
	}

	/// <summary>
	/// Unhook single page
	/// </summary>
	/// <param name="page_physcial_address"></param>
	/// <returns> status </returns>
	bool unhook_function(unsigned __int64 function_address)
	{
		return __vm_call(VMCALL_EPT_UNHOOK_FUNCTION, false, function_address, 0);
	}

	/// <summary>
	/// invalidate ept entries in tlb
	/// </summary>
	/// <param name="invept_all"> If true invalidates all contexts otherway invalidate only single context (currently hv doesn't use more than 1 context)</param>
	void invept(bool invept_all)
	{
		if (invept_all == true) KeGenericCallDpc(broadcast_invept_all_contexts, NULL);
		else KeGenericCallDpc(broadcast_invept_single_context, NULL);
	}

	/// <summary>
	/// Set/Unset presence of hypervisor
	/// </summary>
	/// <param name="value"> If false, hypervisor is not visible via cpuid interface, If true, it become visible</param>
	void hypervisor_visible(bool value)
	{
		if (value == true)
			__vm_call(VMCALL_UNHIDE_HV_PRESENCE, 0, 0, 0);
		else
			__vm_call(VMCALL_HIDE_HV_PRESENCE, 0, 0, 0);
	}

	/// <summary>
	/// Hook function via ept and invalidate ept entries in tlb
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="trampoline_address">Address of some memory which isn't used with size at least 13 and withing 2GB range of target function
	/// Use only if you can function you want to hook use relative offeset in first 13 bytes of it. For example if you want hook NtYieldExecution which
	/// size is 15 bytes you have to find a codecave witihn ntoskrnl.exe image with size atleast 13 bytes and pass it there</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void* trampoline_address, void** origin_function)
	{
		bool status = __vm_call_ex(VMCALL_EPT_HOOK_FUNCTION, (unsigned __int64)target_address, (unsigned __int64)hook_function, (unsigned __int64)trampoline_address, (unsigned __int64)origin_function, 0, 0, 0, 0, 0);
		invept(false);

		return status;
	}

	/// <summary>
	/// Hook function via ept and invalidate ept entries in tlb
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void** origin_function)
	{
		bool status = __vm_call_ex(VMCALL_EPT_HOOK_FUNCTION, (unsigned __int64)target_address, (unsigned __int64)hook_function, 0, (unsigned __int64)origin_function, 0, 0, 0, 0, 0);
		invept(false);

		return status;
	}

	/// <summary>
	/// Check if we can communicate with hypervisor
	/// </summary>
	/// <returns> status </returns>
	bool test_vmcall()
	{
		return __vm_call(VMCALL_TEST, 0, 0, 0);
	}

	bool send_irp_perform_allocation()
	{
		PDEVICE_OBJECT airhv_device_object;
		NTSTATUS status;
		KEVENT event;
		PIRP irp;
		IO_STATUS_BLOCK io_status = { 0 };
		UNICODE_STRING airhv_name;
		PFILE_OBJECT file_object;

		RtlInitUnicodeString(&airhv_name, L"\\Device\\HyperVisor");

		status = IoGetDeviceObjectPointer(&airhv_name, 0, &file_object, &airhv_device_object);

		ObReferenceObjectByPointer(airhv_device_object, FILE_ALL_ACCESS, 0, KernelMode);

		// We don't need this so we instantly dereference file object
		ObDereferenceObject(file_object);

		if (NT_SUCCESS(status) == false)
		{
			LogError("Couldn't get hypervisor device object pointer");
			return false;
		}

		KeInitializeEvent(&event, NotificationEvent, 0);
		irp = IoBuildDeviceIoControlRequest(IOCTL_POOL_MANAGER_ALLOCATE, airhv_device_object, 0, 0, 0, 0, 0, &event, &io_status);

		if (irp == NULL)
		{
			LogError("Couldn't create Irp");
			ObDereferenceObject(airhv_device_object);
			return false;
		}

		else
		{
			status = IofCallDriver(airhv_device_object, irp);

			if (status == STATUS_PENDING)
				KeWaitForSingleObject(&event, Executive, KernelMode, 0, 0);

			ObDereferenceObject(airhv_device_object);
			return true;
		}
	}
}
```

`HyperHideDrv/HypervisorGateway.h`:

```h
#pragma once

namespace hv
{
	bool hook_function(void* target_address, void* hook_function, void* trampoline, void** origin_function);

	bool hook_function(void* target_address, void* hook_function, void** origin_function);

	void hypervisor_visible(bool value);

	bool test_vmcall();

	bool unhook_all_functions();

	bool unhook_function(unsigned __int64 function_address);

	bool send_irp_perform_allocation();
}
```

`HyperHideDrv/Ioctl.h`:

```h
#pragma once

#ifndef _NTIFS_H
#define _NTIFS_H
#include <ntifs.h>
#endif // !_NTIFS_H


#define IOCTL_ADD_HIDER_ENTRY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_CLEAR_PEB_DEBUGGER_FLAG CTL_CODE(FILE_DEVICE_UNKNOWN, 0x901, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_SET_PEB_DEBUGGER_FLAG CTL_CODE(FILE_DEVICE_UNKNOWN, 0x902, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_HIDE_FROM_SYSCALL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x903, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_HIDE_PROCESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x904, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_REMOVE_HIDER_ENTRY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x905, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_PROCESS_STOPPED CTL_CODE(FILE_DEVICE_UNKNOWN, 0x906, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_PROCESS_RESUMED CTL_CODE(FILE_DEVICE_UNKNOWN, 0x907, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_SET_HYPERVISOR_VISIBILITY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x908, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
```

`HyperHideDrv/KernelApi.cpp`:

```cpp
#include "KernelApi.h"
typedef PETHREAD(_fastcall* PSGETNEXTPROCESSTHREAD)(
	IN PEPROCESS Process,
	IN PETHREAD Thread
	);PSGETNEXTPROCESSTHREAD m_PsGetNextProcessThread = 0;
typedef NTSTATUS(_stdcall* NTOPENDIRECTORYOBJECT)(
	__out PHANDLE DirectoryHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes); NTOPENDIRECTORYOBJECT m_NtOpenDirectoryObject = 0;


PETHREAD myPsGetNextProcessThread
(
	IN PEPROCESS Process,
	IN PETHREAD Thread)
{
	if (!m_PsGetNextProcessThread)
	{

		PUCHAR p = (PUCHAR)GetKernelAddress("PsResumeProcess");
#ifdef _WIN64
		/* nt!PsResumeProcess + 0x64:
		 fffff800`042b8c64 488bce          mov     rcx, rsi
		 fffff800`042b8c67 e8ac7bbeff      call    nt!KeResumeThread(fffff800`03ea0818)
		 fffff800`042b8c6c 488bd6          mov     rdx, rsi
		 fffff800`042b8c6f 488bcd          mov     rcx, rbp
		 fffff800`042b8c72 e869f2eaff      call    nt!PsGetNextProcessThread(fffff800`04167ee0)*/

		if (!p)
		{
			return 0;
		}

		for (size_t i = 0; i < 0x100; i++)
		{
			if (*(p + 1) == 0x8b &&
				*(p + 2) == 0xd6 &&
				*(p + 4) == 0x8b &&
				*(p + 5) == 0xcd &&
				*(p + 6) == 0xe8)
			{
				INT offset = *(INT*)(p + 7);
				m_PsGetNextProcessThread=(PSGETNEXTPROCESSTHREAD)(offset + (INT_PTR)p + 11);
			}
			p++;
		}	
#else
		if (g_SystemData.WinVersion == 7601)
		{
			/*nt!PsResumeProcess + 0x4c:
			84117820 8b4508          mov     eax, dword ptr[ebp + 8]
			84117823 e8c059f5ff      call    nt!PsGetNextProcessThread(8406d1e8)
			84117828 8bd8            mov     ebx, eax
			8411782a 85db            test    ebx, ebx
			8411782c 75ea            jne     nt!PsResumeProcess + 0x44 (84117818)  Branch*/

			TZM tzm[5] = { {0xe8,0},{0x8b,-3},{0x45,-2},{0x08,-1} ,{0x8b,5} };
			m_PsGetNextProcessThread=(PSGETNEXTPROCESSTHREAD)FindMemory(p, 0x100, CMemroy::Call, tzm);
		}
#endif // _WIN64
		if (!m_PsGetNextProcessThread)
		{
			DbgPrint("Call PsGetNextProcessThread eeor\n");
			return 0;
		}
	}

#ifdef _WIN64
	return m_PsGetNextProcessThread(Process, Thread);
#else
	PETHREAD j_Thread;
	_asm
	{
		push Thread
		mov eax, Process
		call g_SystemData.PsGetNextProcessThread
		mov  j_Thread, eax
	}
	return j_Thread;
#endif // _WIN64

}

NTSTATUS  NtOpenDirectoryObject
(
	__out PHANDLE DirectoryHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes)
{

	if (!m_NtOpenDirectoryObject)
	{
		CKernelTable SSDT;
		m_NtOpenDirectoryObject =(NTOPENDIRECTORYOBJECT)SSDT.GetAddressFromName("NtOpenDirectoryObject");
		if (!m_NtOpenDirectoryObject)
		{
			DbgPrint("Call NtOpenDirectoryObject eeor\n");
			return STATUS_UNSUCCESSFUL;
		}
	}
	return m_NtOpenDirectoryObject(DirectoryHandle, DesiredAccess, ObjectAttributes);
}


```

`HyperHideDrv/KernelApi.h`:

```h
#pragma once
#include "Header.h"

//PETHREAD PsGetNextProcessThread(
//	IN PEPROCESS Process,
//	IN PETHREAD Thread
//);

NTSTATUS  NtOpenDirectoryObject(
	__out PHANDLE DirectoryHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);


```

`HyperHideDrv/KernelDbgStruct.h`:

```h
#pragma once

#include <ntifs.h>

typedef struct _KERNEL_STACK_SEGMENT // 5 elements, 0x28 bytes (sizeof)
{
	/*0x000*/     UINT64       StackBase;
	/*0x008*/     UINT64       StackLimit;
	/*0x010*/     UINT64       KernelStack;
	/*0x018*/     UINT64       InitialStack;
	/*0x020*/     UINT64       ActualLimit;
}KERNEL_STACK_SEGMENT, * PKERNEL_STACK_SEGMENT;

typedef struct _KERNEL_STACK_CONTROL       // 2 elements, 0x50 bytes (sizeof)
{
	/*0x000*/     struct _KERNEL_STACK_SEGMENT Current;  // 5 elements, 0x28 bytes (sizeof)
	/*0x028*/     struct _KERNEL_STACK_SEGMENT Previous; // 5 elements, 0x28 bytes (sizeof)
}KERNEL_STACK_CONTROL, * PKERNEL_STACK_CONTROL;

#ifndef _EX_FAST_REF_
#define _EX_FAST_REF_
typedef struct _EX_FAST_REF      // 3 elements, 0x8 bytes (sizeof)
{
	union                        // 3 elements, 0x8 bytes (sizeof)
	{
		/*0x000*/         VOID* Object;
		/*0x000*/         UINT64       RefCnt : 4; // 0 BitPosition
		/*0x000*/         UINT64       Value;
	};
}EX_FAST_REF, * PEX_FAST_REF;
#endif // !_EX_FAST_REF_

#ifndef _KWAIT_STATUS_REGISTER_
#define _KWAIT_STATUS_REGISTER_
typedef union _KWAIT_STATUS_REGISTER // 8 elements, 0x1 bytes (sizeof) 
{
	/*0x000*/     UINT8        Flags;
	struct                           // 7 elements, 0x1 bytes (sizeof) 
	{
		/*0x000*/         UINT8        State : 2;      // 0 BitPosition                  
		/*0x000*/         UINT8        Affinity : 1;   // 2 BitPosition                  
		/*0x000*/         UINT8        Priority : 1;   // 3 BitPosition                  
		/*0x000*/         UINT8        Apc : 1;        // 4 BitPosition                  
		/*0x000*/         UINT8        UserApc : 1;    // 5 BitPosition                  
		/*0x000*/         UINT8        Alert : 1;      // 6 BitPosition                  
		/*0x000*/         UINT8        Unused : 1;     // 7 BitPosition                  
	};
}KWAIT_STATUS_REGISTER, * PKWAIT_STATUS_REGISTER;
#endif // !_KWAIT_STATUS_REGISTER_

#ifndef _PS_CLIENT_SECURITY_CONTEXT_
#define _PS_CLIENT_SECURITY_CONTEXT_
typedef union _PS_CLIENT_SECURITY_CONTEXT    // 4 elements, 0x4 bytes (sizeof) 
{
	/*0x000*/     ULONG_PTR      ImpersonationData;
	/*0x000*/     VOID* ImpersonationToken;
	struct                                   // 2 elements, 0x4 bytes (sizeof) 
	{
		/*0x000*/         ULONG_PTR      ImpersonationLevel : 2; // 0 BitPosition                  
		/*0x000*/         ULONG_PTR      EffectiveOnly : 1;      // 2 BitPosition                  
	};
}PS_CLIENT_SECURITY_CONTEXT, * PPS_CLIENT_SECURITY_CONTEXT;
#endif // !_PS_CLIENT_SECURITY_CONTEXT_

#ifndef _EX_PUSH_LOCK_
#define _EX_PUSH_LOCK_
typedef struct _EX_PUSH_LOCK                 // 7 elements, 0x8 bytes (sizeof)
{
	union                                    // 3 elements, 0x8 bytes (sizeof)
	{
		struct                               // 5 elements, 0x8 bytes (sizeof)
		{
			/*0x000*/             UINT64       Locked : 1;         // 0 BitPosition
			/*0x000*/             UINT64       Waiting : 1;        // 1 BitPosition
			/*0x000*/             UINT64       Waking : 1;         // 2 BitPosition
			/*0x000*/             UINT64       MultipleShared : 1; // 3 BitPosition
			/*0x000*/             UINT64       Shared : 60;        // 4 BitPosition
		};
		/*0x000*/         UINT64       Value;
		/*0x000*/         VOID* Ptr;
	};
}/*EX_PUSH_LOCK, *PEX_PUSH_LOCK*/;
#endif // !_EX_PUSH_LOCK_


#ifndef _KTHREAD_S_
#define _KTHREAD_S_
typedef struct _RTL_RB_TREE
{
	/* 0x0000 */ struct _RTL_BALANCED_NODE* Root;
	union
	{
		/* 0x0008 */ unsigned char Encoded : 1; /* bit position: 0 */
		/* 0x0008 */ struct _RTL_BALANCED_NODE* Min;
	}; /* size: 0x0008 */
} RTL_RB_TREE, * PRTL_RB_TREE; /* size: 0x0010 */

typedef union _KLOCK_ENTRY_BOOST_BITMAP
{
	union
	{
		/* 0x0000 */ unsigned long AllFields;
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned long AllBoosts : 17; /* bit position: 0 */
			/* 0x0000 */ unsigned long Reserved : 15; /* bit position: 17 */
		}; /* bitfield */
		struct
		{
			struct /* bitfield */
			{
				/* 0x0000 */ unsigned short CpuBoostsBitmap : 15; /* bit position: 0 */
				/* 0x0000 */ unsigned short IoBoost : 1; /* bit position: 15 */
			}; /* bitfield */
			struct /* bitfield */
			{
				/* 0x0002 */ unsigned short IoQoSBoost : 1; /* bit position: 0 */
				/* 0x0002 */ unsigned short IoNormalPriorityWaiterCount : 8; /* bit position: 1 */
				/* 0x0002 */ unsigned short IoQoSWaiterCount : 7; /* bit position: 9 */
			}; /* bitfield */
		}; /* size: 0x0004 */
	}; /* size: 0x0004 */
} KLOCK_ENTRY_BOOST_BITMAP, * PKLOCK_ENTRY_BOOST_BITMAP; /* size: 0x0004 */

typedef struct _KLOCK_ENTRY_LOCK_STATE
{
	union
	{
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned __int64 CrossThreadReleasable : 1; /* bit position: 0 */
			/* 0x0000 */ unsigned __int64 Busy : 1; /* bit position: 1 */
			/* 0x0000 */ unsigned __int64 Reserved : 61; /* bit position: 2 */
			/* 0x0000 */ unsigned __int64 InTree : 1; /* bit position: 63 */
		}; /* bitfield */
		/* 0x0000 */ void* LockState;
	}; /* size: 0x0008 */
	union
	{
		/* 0x0008 */ void* SessionState;
		struct
		{
			/* 0x0008 */ unsigned long SessionId;
			/* 0x000c */ unsigned long SessionPad;
		}; /* size: 0x0008 */
	}; /* size: 0x0008 */
} KLOCK_ENTRY_LOCK_STATE, * PKLOCK_ENTRY_LOCK_STATE; /* size: 0x0010 */

typedef struct _KLOCK_ENTRY
{
	union
	{
		/* 0x0000 */ struct _RTL_BALANCED_NODE TreeNode;
		/* 0x0000 */ struct _SINGLE_LIST_ENTRY FreeListEntry;
	}; /* size: 0x0018 */
	union
	{
		/* 0x0018 */ unsigned long EntryFlags;
		struct
		{
			/* 0x0018 */ unsigned char EntryOffset;
			union
			{
				/* 0x0019 */ unsigned char ThreadLocalFlags;
				struct
				{
					struct /* bitfield */
					{
						/* 0x0019 */ unsigned char WaitingBit : 1; /* bit position: 0 */
						/* 0x0019 */ unsigned char Spare0 : 7; /* bit position: 1 */
					}; /* bitfield */
					union
					{
						/* 0x001a */ unsigned char AcquiredByte;
						struct
						{
							/* 0x001a */ unsigned char AcquiredBit : 1; /* bit position: 0 */
							union
							{
								/* 0x001b */ unsigned char CrossThreadFlags;
								struct /* bitfield */
								{
									/* 0x001b */ unsigned char HeadNodeBit : 1; /* bit position: 0 */
									/* 0x001b */ unsigned char IoPriorityBit : 1; /* bit position: 1 */
									/* 0x001b */ unsigned char IoQoSWaiter : 1; /* bit position: 2 */
									/* 0x001b */ unsigned char Spare1 : 5; /* bit position: 3 */
								}; /* bitfield */
							}; /* size: 0x0001 */
						}; /* size: 0x0002 */
					}; /* size: 0x0002 */
				}; /* size: 0x0003 */
			}; /* size: 0x0003 */
		}; /* size: 0x0004 */
		struct /* bitfield */
		{
			/* 0x0018 */ unsigned long StaticState : 8; /* bit position: 0 */
			/* 0x0018 */ unsigned long AllFlags : 24; /* bit position: 8 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x001c */ unsigned long SpareFlags;
	union
	{
		/* 0x0020 */ struct _KLOCK_ENTRY_LOCK_STATE LockState;
		/* 0x0020 */ void* volatile LockUnsafe;
		struct
		{
			/* 0x0020 */ volatile unsigned char CrossThreadReleasableAndBusyByte;
			/* 0x0021 */ unsigned char Reserved[6];
			/* 0x0027 */ volatile unsigned char InTreeByte;
			union
			{
				/* 0x0028 */ void* SessionState;
				struct
				{
					/* 0x0028 */ unsigned long SessionId;
					/* 0x002c */ unsigned long SessionPad;
				}; /* size: 0x0008 */
			}; /* size: 0x0008 */
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	union
	{
		struct
		{
			/* 0x0030 */ struct _RTL_RB_TREE OwnerTree;
			/* 0x0040 */ struct _RTL_RB_TREE WaiterTree;
		}; /* size: 0x0020 */
		/* 0x0030 */ char CpuPriorityKey;
	}; /* size: 0x0020 */
	/* 0x0050 */ unsigned __int64 EntryLock;
	/* 0x0058 */ union _KLOCK_ENTRY_BOOST_BITMAP BoostBitmap;
	/* 0x005c */ unsigned long SparePad;
} KLOCK_ENTRY, * PKLOCK_ENTRY; /* size: 0x0060 */

typedef struct _PS_PROPERTY_SET
{
	/* 0x0000 */ struct _LIST_ENTRY ListHead;
	/* 0x0010 */ unsigned __int64 Lock;
} PS_PROPERTY_SET, * PPS_PROPERTY_SET; /* size: 0x0018 */

typedef struct _KTHREAD_S
{
	/* 0x0000 */ struct _DISPATCHER_HEADER Header;
	/* 0x0018 */ void* SListFaultAddress;
	/* 0x0020 */ unsigned __int64 QuantumTarget;
	/* 0x0028 */ void* InitialStack;
	/* 0x0030 */ void* volatile StackLimit;
	/* 0x0038 */ void* StackBase;
	/* 0x0040 */ unsigned __int64 ThreadLock;
	/* 0x0048 */ volatile unsigned __int64 CycleTime;
	/* 0x0050 */ unsigned long CurrentRunTime;
	/* 0x0054 */ unsigned long ExpectedRunTime;
	/* 0x0058 */ void* KernelStack;
	/* 0x0060 */ struct _XSAVE_FORMAT* StateSaveArea;
	/* 0x0068 */ struct _KSCHEDULING_GROUP* volatile SchedulingGroup;
	/* 0x0070 */ union _KWAIT_STATUS_REGISTER WaitRegister;
	/* 0x0071 */ volatile unsigned char Running;
	/* 0x0072 */ unsigned char Alerted[2];
	union
	{
		struct /* bitfield */
		{
			/* 0x0074 */ unsigned long AutoBoostActive : 1; /* bit position: 0 */
			/* 0x0074 */ unsigned long ReadyTransition : 1; /* bit position: 1 */
			/* 0x0074 */ unsigned long WaitNext : 1; /* bit position: 2 */
			/* 0x0074 */ unsigned long SystemAffinityActive : 1; /* bit position: 3 */
			/* 0x0074 */ unsigned long Alertable : 1; /* bit position: 4 */
			/* 0x0074 */ unsigned long UserStackWalkActive : 1; /* bit position: 5 */
			/* 0x0074 */ unsigned long ApcInterruptRequest : 1; /* bit position: 6 */
			/* 0x0074 */ unsigned long QuantumEndMigrate : 1; /* bit position: 7 */
			/* 0x0074 */ unsigned long UmsDirectedSwitchEnable : 1; /* bit position: 8 */
			/* 0x0074 */ unsigned long TimerActive : 1; /* bit position: 9 */
			/* 0x0074 */ unsigned long SystemThread : 1; /* bit position: 10 */
			/* 0x0074 */ unsigned long ProcessDetachActive : 1; /* bit position: 11 */
			/* 0x0074 */ unsigned long CalloutActive : 1; /* bit position: 12 */
			/* 0x0074 */ unsigned long ScbReadyQueue : 1; /* bit position: 13 */
			/* 0x0074 */ unsigned long ApcQueueable : 1; /* bit position: 14 */
			/* 0x0074 */ unsigned long ReservedStackInUse : 1; /* bit position: 15 */
			/* 0x0074 */ unsigned long UmsPerformingSyscall : 1; /* bit position: 16 */
			/* 0x0074 */ unsigned long TimerSuspended : 1; /* bit position: 17 */
			/* 0x0074 */ unsigned long SuspendedWaitMode : 1; /* bit position: 18 */
			/* 0x0074 */ unsigned long SuspendSchedulerApcWait : 1; /* bit position: 19 */
			/* 0x0074 */ unsigned long CetUserShadowStack : 1; /* bit position: 20 */
			/* 0x0074 */ unsigned long BypassProcessFreeze : 1; /* bit position: 21 */
			/* 0x0074 */ unsigned long Reserved : 10; /* bit position: 22 */
		}; /* bitfield */
		/* 0x0074 */ long MiscFlags;
	}; /* size: 0x0004 */
	union
	{
		struct /* bitfield */
		{
			/* 0x0078 */ unsigned long ThreadFlagsSpare : 2; /* bit position: 0 */
			/* 0x0078 */ unsigned long AutoAlignment : 1; /* bit position: 2 */
			/* 0x0078 */ unsigned long DisableBoost : 1; /* bit position: 3 */
			/* 0x0078 */ unsigned long AlertedByThreadId : 1; /* bit position: 4 */
			/* 0x0078 */ unsigned long QuantumDonation : 1; /* bit position: 5 */
			/* 0x0078 */ unsigned long EnableStackSwap : 1; /* bit position: 6 */
			/* 0x0078 */ unsigned long GuiThread : 1; /* bit position: 7 */
			/* 0x0078 */ unsigned long DisableQuantum : 1; /* bit position: 8 */
			/* 0x0078 */ unsigned long ChargeOnlySchedulingGroup : 1; /* bit position: 9 */
			/* 0x0078 */ unsigned long DeferPreemption : 1; /* bit position: 10 */
			/* 0x0078 */ unsigned long QueueDeferPreemption : 1; /* bit position: 11 */
			/* 0x0078 */ unsigned long ForceDeferSchedule : 1; /* bit position: 12 */
			/* 0x0078 */ unsigned long SharedReadyQueueAffinity : 1; /* bit position: 13 */
			/* 0x0078 */ unsigned long FreezeCount : 1; /* bit position: 14 */
			/* 0x0078 */ unsigned long TerminationApcRequest : 1; /* bit position: 15 */
			/* 0x0078 */ unsigned long AutoBoostEntriesExhausted : 1; /* bit position: 16 */
			/* 0x0078 */ unsigned long KernelStackResident : 1; /* bit position: 17 */
			/* 0x0078 */ unsigned long TerminateRequestReason : 2; /* bit position: 18 */
			/* 0x0078 */ unsigned long ProcessStackCountDecremented : 1; /* bit position: 20 */
			/* 0x0078 */ unsigned long RestrictedGuiThread : 1; /* bit position: 21 */
			/* 0x0078 */ unsigned long VpBackingThread : 1; /* bit position: 22 */
			/* 0x0078 */ unsigned long ThreadFlagsSpare2 : 1; /* bit position: 23 */
			/* 0x0078 */ unsigned long EtwStackTraceApcInserted : 8; /* bit position: 24 */
		}; /* bitfield */
		/* 0x0078 */ volatile long ThreadFlags;
	}; /* size: 0x0004 */
	/* 0x007c */ volatile unsigned char Tag;
	/* 0x007d */ unsigned char SystemHeteroCpuPolicy;
	struct /* bitfield */
	{
		/* 0x007e */ unsigned char UserHeteroCpuPolicy : 7; /* bit position: 0 */
		/* 0x007e */ unsigned char ExplicitSystemHeteroCpuPolicy : 1; /* bit position: 7 */
	}; /* bitfield */
	union
	{
		struct /* bitfield */
		{
			/* 0x007f */ unsigned char RunningNonRetpolineCode : 1; /* bit position: 0 */
			/* 0x007f */ unsigned char SpecCtrlSpare : 7; /* bit position: 1 */
		}; /* bitfield */
		/* 0x007f */ unsigned char SpecCtrl;
	}; /* size: 0x0001 */
	/* 0x0080 */ unsigned long SystemCallNumber;
	/* 0x0084 */ unsigned long ReadyTime;
	/* 0x0088 */ void* FirstArgument;
	/* 0x0090 */ struct _KTRAP_FRAME* TrapFrame;
	union
	{
		/* 0x0098 */ struct _KAPC_STATE ApcState;
		struct
		{
			/* 0x0098 */ unsigned char ApcStateFill[43];
			/* 0x00c3 */ char Priority;
			/* 0x00c4 */ unsigned long UserIdealProcessor;
		}; /* size: 0x0030 */
	}; /* size: 0x0030 */
	/* 0x00c8 */ volatile __int64 WaitStatus;
	/* 0x00d0 */ struct _KWAIT_BLOCK* WaitBlockList;
	union
	{
		/* 0x00d8 */ struct _LIST_ENTRY WaitListEntry;
		/* 0x00d8 */ struct _SINGLE_LIST_ENTRY SwapListEntry;
	}; /* size: 0x0010 */
	/* 0x00e8 */ struct _DISPATCHER_HEADER* volatile Queue;
	/* 0x00f0 */ void* Teb;
	/* 0x00f8 */ unsigned __int64 RelativeTimerBias;
	/* 0x0100 */ struct _KTIMER Timer;
	union
	{
		/* 0x0140 */ struct _KWAIT_BLOCK WaitBlock[4];
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill4[20];
			/* 0x0154 */ unsigned long ContextSwitches;
		}; /* size: 0x0018 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill5[68];
			/* 0x0184 */ volatile unsigned char State;
			/* 0x0185 */ char Spare13;
			/* 0x0186 */ unsigned char WaitIrql;
			/* 0x0187 */ char WaitMode;
		}; /* size: 0x0048 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill6[116];
			/* 0x01b4 */ unsigned long WaitTime;
		}; /* size: 0x0078 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill7[164];
			union
			{
				struct
				{
					/* 0x01e4 */ short KernelApcDisable;
					/* 0x01e6 */ short SpecialApcDisable;
				}; /* size: 0x0004 */
				/* 0x01e4 */ unsigned long CombinedApcDisable;
			}; /* size: 0x0004 */
		}; /* size: 0x00a8 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill8[40];
			/* 0x0168 */ struct _KTHREAD_COUNTERS* ThreadCounters;
		}; /* size: 0x0030 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill9[88];
			/* 0x0198 */ struct _XSTATE_SAVE* XStateSave;
		}; /* size: 0x0060 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill10[136];
			/* 0x01c8 */ void* volatile Win32Thread;
		}; /* size: 0x0090 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill11[176];
			/* 0x01f0 */ struct _UMS_CONTROL_BLOCK* Ucb;
			/* 0x01f8 */ struct _KUMS_CONTEXT_HEADER* volatile Uch;
		}; /* size: 0x00c0 */
	}; /* size: 0x00c0 */
	union
	{
		/* 0x0200 */ volatile long ThreadFlags2;
		struct /* bitfield */
		{
			/* 0x0200 */ unsigned long BamQosLevel : 8; /* bit position: 0 */
			/* 0x0200 */ unsigned long ThreadFlags2Reserved : 24; /* bit position: 8 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0204 */ unsigned long Spare21;
	/* 0x0208 */ struct _LIST_ENTRY QueueListEntry;
	union
	{
		/* 0x0218 */ volatile unsigned long NextProcessor;
		struct /* bitfield */
		{
			/* 0x0218 */ unsigned long NextProcessorNumber : 31; /* bit position: 0 */
			/* 0x0218 */ unsigned long SharedReadyQueue : 1; /* bit position: 31 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x021c */ long QueuePriority;
	/* 0x0220 */ struct _KPROCESS* Process;
	union
	{
		/* 0x0228 */ struct _GROUP_AFFINITY UserAffinity;
		struct
		{
			/* 0x0228 */ unsigned char UserAffinityFill[10];
			/* 0x0232 */ char PreviousMode;
			/* 0x0233 */ char BasePriority;
			union
			{
				/* 0x0234 */ char PriorityDecrement;
				struct /* bitfield */
				{
					/* 0x0234 */ unsigned char ForegroundBoost : 4; /* bit position: 0 */
					/* 0x0234 */ unsigned char UnusualBoost : 4; /* bit position: 4 */
				}; /* bitfield */
			}; /* size: 0x0001 */
			/* 0x0235 */ unsigned char Preempted;
			/* 0x0236 */ unsigned char AdjustReason;
			/* 0x0237 */ char AdjustIncrement;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0238 */ unsigned __int64 AffinityVersion;
	union
	{
		/* 0x0240 */ struct _GROUP_AFFINITY Affinity;
		struct
		{
			/* 0x0240 */ unsigned char AffinityFill[10];
			/* 0x024a */ unsigned char ApcStateIndex;
			/* 0x024b */ unsigned char WaitBlockCount;
			/* 0x024c */ unsigned long IdealProcessor;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0250 */ unsigned __int64 NpxState;
	union
	{
		/* 0x0258 */ struct _KAPC_STATE SavedApcState;
		struct
		{
			/* 0x0258 */ unsigned char SavedApcStateFill[43];
			/* 0x0283 */ unsigned char WaitReason;
			/* 0x0284 */ char SuspendCount;
			/* 0x0285 */ char Saturation;
			/* 0x0286 */ unsigned short SListFaultCount;
		}; /* size: 0x0030 */
	}; /* size: 0x0030 */
	union
	{
		/* 0x0288 */ struct _KAPC SchedulerApc;
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill0[1];
			/* 0x0289 */ unsigned char ResourceIndex;
		}; /* size: 0x0002 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill1[3];
			/* 0x028b */ unsigned char QuantumReset;
		}; /* size: 0x0004 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill2[4];
			/* 0x028c */ unsigned long KernelTime;
		}; /* size: 0x0008 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill3[64];
			/* 0x02c8 */ struct _KPRCB* volatile WaitPrcb;
		}; /* size: 0x0048 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill4[72];
			/* 0x02d0 */ void* LegoData;
		}; /* size: 0x0050 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill5[83];
			/* 0x02db */ unsigned char CallbackNestingLevel;
			/* 0x02dc */ unsigned long UserTime;
		}; /* size: 0x0058 */
	}; /* size: 0x0058 */
	/* 0x02e0 */ struct _KEVENT SuspendEvent;
	/* 0x02f8 */ struct _LIST_ENTRY ThreadListEntry;
	/* 0x0308 */ struct _LIST_ENTRY MutantListHead;
	/* 0x0318 */ unsigned char AbEntrySummary;
	/* 0x0319 */ unsigned char AbWaitEntryCount;
	/* 0x031a */ unsigned char AbAllocationRegionCount;
	/* 0x031b */ char SystemPriority;
	/* 0x031c */ unsigned long SecureThreadCookie;
	/* 0x0320 */ struct _KLOCK_ENTRY* LockEntries;
	/* 0x0328 */ struct _SINGLE_LIST_ENTRY PropagateBoostsEntry;
	/* 0x0330 */ struct _SINGLE_LIST_ENTRY IoSelfBoostsEntry;
	/* 0x0338 */ unsigned char PriorityFloorCounts[16];
	/* 0x0348 */ unsigned char PriorityFloorCountsReserved[16];
	/* 0x0358 */ unsigned long PriorityFloorSummary;
	/* 0x035c */ volatile long AbCompletedIoBoostCount;
	/* 0x0360 */ volatile long AbCompletedIoQoSBoostCount;
	/* 0x0364 */ volatile short KeReferenceCount;
	/* 0x0366 */ unsigned char AbOrphanedEntrySummary;
	/* 0x0367 */ unsigned char AbOwnedEntryCount;
	/* 0x0368 */ unsigned long ForegroundLossTime;
	/* 0x036c */ long Padding_0;
	union
	{
		/* 0x0370 */ struct _LIST_ENTRY GlobalForegroundListEntry;
		struct
		{
			/* 0x0370 */ struct _SINGLE_LIST_ENTRY ForegroundDpcStackListEntry;
			/* 0x0378 */ unsigned __int64 InGlobalForegroundList;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0380 */ __int64 ReadOperationCount;
	/* 0x0388 */ __int64 WriteOperationCount;
	/* 0x0390 */ __int64 OtherOperationCount;
	/* 0x0398 */ __int64 ReadTransferCount;
	/* 0x03a0 */ __int64 WriteTransferCount;
	/* 0x03a8 */ __int64 OtherTransferCount;
	/* 0x03b0 */ struct _KSCB* QueuedScb;
	/* 0x03b8 */ volatile unsigned long ThreadTimerDelay;
	union
	{
		/* 0x03bc */ volatile long ThreadFlags3;
		struct /* bitfield */
		{
			/* 0x03bc */ unsigned long ThreadFlags3Reserved : 8; /* bit position: 0 */
			/* 0x03bc */ unsigned long PpmPolicy : 2; /* bit position: 8 */
			/* 0x03bc */ unsigned long ThreadFlags3Reserved2 : 22; /* bit position: 10 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x03c0 */ unsigned __int64 TracingPrivate[1];
	/* 0x03c8 */ void* SchedulerAssist;
	/* 0x03d0 */ void* volatile AbWaitObject;
	/* 0x03d8 */ unsigned long ReservedPreviousReadyTimeValue;
	/* 0x03dc */ long Padding_1;
	/* 0x03e0 */ unsigned __int64 KernelWaitTime;
	/* 0x03e8 */ unsigned __int64 UserWaitTime;
	union
	{
		/* 0x03f0 */ struct _LIST_ENTRY GlobalUpdateVpThreadPriorityListEntry;
		struct
		{
			/* 0x03f0 */ struct _SINGLE_LIST_ENTRY UpdateVpThreadPriorityDpcStackListEntry;
			/* 0x03f8 */ unsigned __int64 InGlobalUpdateVpThreadPriorityList;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0400 */ long SchedulerAssistPriorityFloor;
	/* 0x0404 */ unsigned long Spare28;
	/* 0x0408 */ unsigned __int64 EndPadding[5];
} KTHREAD_S, * PKTHREAD_S; /* size: 0x0430 */

typedef struct _ETHREAD_S
{
	/* 0x0000 */ struct _KTHREAD_S Tcb;
	/* 0x0430 */ union _LARGE_INTEGER CreateTime;
	union
	{
		/* 0x0438 */ union _LARGE_INTEGER ExitTime;
		/* 0x0438 */ struct _LIST_ENTRY KeyedWaitChain;
	}; /* size: 0x0010 */
	union
	{
		/* 0x0448 */ struct _LIST_ENTRY PostBlockList;
		struct
		{
			/* 0x0448 */ void* ForwardLinkShadow;
			/* 0x0450 */ void* StartAddress;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	union
	{
		/* 0x0458 */ struct _TERMINATION_PORT* TerminationPort;
		/* 0x0458 */ struct _ETHREAD* ReaperLink;
		/* 0x0458 */ void* KeyedWaitValue;
	}; /* size: 0x0008 */
	/* 0x0460 */ unsigned __int64 ActiveTimerListLock;
	/* 0x0468 */ struct _LIST_ENTRY ActiveTimerListHead;
	/* 0x0478 */ struct _CLIENT_ID Cid;
	union
	{
		/* 0x0488 */ struct _KSEMAPHORE KeyedWaitSemaphore;
		/* 0x0488 */ struct _KSEMAPHORE AlpcWaitSemaphore;
	}; /* size: 0x0020 */
	/* 0x04a8 */ union _PS_CLIENT_SECURITY_CONTEXT ClientSecurity;
	/* 0x04b0 */ struct _LIST_ENTRY IrpList;
	/* 0x04c0 */ unsigned __int64 TopLevelIrp;
	/* 0x04c8 */ struct _DEVICE_OBJECT* DeviceToVerify;
	/* 0x04d0 */ void* Win32StartAddress;
	/* 0x04d8 */ void* ChargeOnlySession;
	/* 0x04e0 */ void* LegacyPowerObject;
	/* 0x04e8 */ struct _LIST_ENTRY ThreadListEntry;
	/* 0x04f8 */ struct _EX_RUNDOWN_REF RundownProtect;
	/* 0x0500 */ struct _EX_PUSH_LOCK ThreadLock;
	/* 0x0508 */ unsigned long ReadClusterSize;
	/* 0x050c */ volatile long MmLockOrdering;
	union
	{
		/* 0x0510 */ unsigned long CrossThreadFlags;
		struct /* bitfield */
		{
			/* 0x0510 */ unsigned long Terminated : 1; /* bit position: 0 */
			/* 0x0510 */ unsigned long ThreadInserted : 1; /* bit position: 1 */
			/* 0x0510 */ unsigned long HideFromDebugger : 1; /* bit position: 2 */
			/* 0x0510 */ unsigned long ActiveImpersonationInfo : 1; /* bit position: 3 */
			/* 0x0510 */ unsigned long HardErrorsAreDisabled : 1; /* bit position: 4 */
			/* 0x0510 */ unsigned long BreakOnTermination : 1; /* bit position: 5 */
			/* 0x0510 */ unsigned long SkipCreationMsg : 1; /* bit position: 6 */
			/* 0x0510 */ unsigned long SkipTerminationMsg : 1; /* bit position: 7 */
			/* 0x0510 */ unsigned long CopyTokenOnOpen : 1; /* bit position: 8 */
			/* 0x0510 */ unsigned long ThreadIoPriority : 3; /* bit position: 9 */
			/* 0x0510 */ unsigned long ThreadPagePriority : 3; /* bit position: 12 */
			/* 0x0510 */ unsigned long RundownFail : 1; /* bit position: 15 */
			/* 0x0510 */ unsigned long UmsForceQueueTermination : 1; /* bit position: 16 */
			/* 0x0510 */ unsigned long IndirectCpuSets : 1; /* bit position: 17 */
			/* 0x0510 */ unsigned long DisableDynamicCodeOptOut : 1; /* bit position: 18 */
			/* 0x0510 */ unsigned long ExplicitCaseSensitivity : 1; /* bit position: 19 */
			/* 0x0510 */ unsigned long PicoNotifyExit : 1; /* bit position: 20 */
			/* 0x0510 */ unsigned long DbgWerUserReportActive : 1; /* bit position: 21 */
			/* 0x0510 */ unsigned long ForcedSelfTrimActive : 1; /* bit position: 22 */
			/* 0x0510 */ unsigned long SamplingCoverage : 1; /* bit position: 23 */
			/* 0x0510 */ unsigned long ReservedCrossThreadFlags : 8; /* bit position: 24 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	union
	{
		/* 0x0514 */ unsigned long SameThreadPassiveFlags;
		struct /* bitfield */
		{
			/* 0x0514 */ unsigned long ActiveExWorker : 1; /* bit position: 0 */
			/* 0x0514 */ unsigned long MemoryMaker : 1; /* bit position: 1 */
			/* 0x0514 */ unsigned long StoreLockThread : 2; /* bit position: 2 */
			/* 0x0514 */ unsigned long ClonedThread : 1; /* bit position: 4 */
			/* 0x0514 */ unsigned long KeyedEventInUse : 1; /* bit position: 5 */
			/* 0x0514 */ unsigned long SelfTerminate : 1; /* bit position: 6 */
			/* 0x0514 */ unsigned long RespectIoPriority : 1; /* bit position: 7 */
			/* 0x0514 */ unsigned long ActivePageLists : 1; /* bit position: 8 */
			/* 0x0514 */ unsigned long SecureContext : 1; /* bit position: 9 */
			/* 0x0514 */ unsigned long ZeroPageThread : 1; /* bit position: 10 */
			/* 0x0514 */ unsigned long WorkloadClass : 1; /* bit position: 11 */
			/* 0x0514 */ unsigned long ReservedSameThreadPassiveFlags : 20; /* bit position: 12 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	union
	{
		/* 0x0518 */ unsigned long SameThreadApcFlags;
		struct
		{
			struct /* bitfield */
			{
				/* 0x0518 */ unsigned char OwnsProcessAddressSpaceExclusive : 1; /* bit position: 0 */
				/* 0x0518 */ unsigned char OwnsProcessAddressSpaceShared : 1; /* bit position: 1 */
				/* 0x0518 */ unsigned char HardFaultBehavior : 1; /* bit position: 2 */
				/* 0x0518 */ volatile unsigned char StartAddressInvalid : 1; /* bit position: 3 */
				/* 0x0518 */ unsigned char EtwCalloutActive : 1; /* bit position: 4 */
				/* 0x0518 */ unsigned char SuppressSymbolLoad : 1; /* bit position: 5 */
				/* 0x0518 */ unsigned char Prefetching : 1; /* bit position: 6 */
				/* 0x0518 */ unsigned char OwnsVadExclusive : 1; /* bit position: 7 */
			}; /* bitfield */
			struct /* bitfield */
			{
				/* 0x0519 */ unsigned char SystemPagePriorityActive : 1; /* bit position: 0 */
				/* 0x0519 */ unsigned char SystemPagePriority : 3; /* bit position: 1 */
				/* 0x0519 */ unsigned char AllowUserWritesToExecutableMemory : 1; /* bit position: 4 */
				/* 0x0519 */ unsigned char AllowKernelWritesToExecutableMemory : 1; /* bit position: 5 */
				/* 0x0519 */ unsigned char OwnsVadShared : 1; /* bit position: 6 */
			}; /* bitfield */
		}; /* size: 0x0002 */
	}; /* size: 0x0004 */
	/* 0x051c */ unsigned char CacheManagerActive;
	/* 0x051d */ unsigned char DisablePageFaultClustering;
	/* 0x051e */ unsigned char ActiveFaultCount;
	/* 0x051f */ unsigned char LockOrderState;
	/* 0x0520 */ unsigned long PerformanceCountLowReserved;
	/* 0x0524 */ long PerformanceCountHighReserved;
	/* 0x0528 */ unsigned __int64 AlpcMessageId;
	union
	{
		/* 0x0530 */ void* AlpcMessage;
		/* 0x0530 */ unsigned long AlpcReceiveAttributeSet;
	}; /* size: 0x0008 */
	/* 0x0538 */ struct _LIST_ENTRY AlpcWaitListEntry;
	/* 0x0548 */ long ExitStatus;
	/* 0x054c */ unsigned long CacheManagerCount;
	/* 0x0550 */ unsigned long IoBoostCount;
	/* 0x0554 */ unsigned long IoQoSBoostCount;
	/* 0x0558 */ unsigned long IoQoSThrottleCount;
	/* 0x055c */ unsigned long KernelStackReference;
	/* 0x0560 */ struct _LIST_ENTRY BoostList;
	/* 0x0570 */ struct _LIST_ENTRY DeboostList;
	/* 0x0580 */ unsigned __int64 BoostListLock;
	/* 0x0588 */ unsigned __int64 IrpListLock;
	/* 0x0590 */ void* ReservedForSynchTracking;
	/* 0x0598 */ struct _SINGLE_LIST_ENTRY CmCallbackListHead;
	/* 0x05a0 */ const struct _GUID* ActivityId;
	/* 0x05a8 */ struct _SINGLE_LIST_ENTRY SeLearningModeListHead;
	/* 0x05b0 */ void* VerifierContext;
	/* 0x05b8 */ void* AdjustedClientToken;
	/* 0x05c0 */ void* WorkOnBehalfThread;
	/* 0x05c8 */ struct _PS_PROPERTY_SET PropertySet;
	/* 0x05e0 */ void* PicoContext;
	/* 0x05e8 */ unsigned __int64 UserFsBase;
	/* 0x05f0 */ unsigned __int64 UserGsBase;
	/* 0x05f8 */ struct _THREAD_ENERGY_VALUES* EnergyValues;
	union
	{
		/* 0x0600 */ unsigned __int64 SelectedCpuSets;
		/* 0x0600 */ unsigned __int64* SelectedCpuSetsIndirect;
	}; /* size: 0x0008 */
	/* 0x0608 */ struct _EJOB* Silo;
	/* 0x0610 */ struct _UNICODE_STRING* ThreadName;
	/* 0x0618 */ struct _CONTEXT* SetContextState;
	/* 0x0620 */ unsigned long LastExpectedRunTime;
	/* 0x0624 */ unsigned long HeapData;
	/* 0x0628 */ struct _LIST_ENTRY OwnerEntryListHead;
	/* 0x0638 */ unsigned __int64 DisownedOwnerEntryListLock;
	/* 0x0640 */ struct _LIST_ENTRY DisownedOwnerEntryListHead;
	/* 0x0650 */ struct _KLOCK_ENTRY LockEntries[6];
	/* 0x0890 */ void* CmDbgInfo;
} ETHREAD_S, * PETHREAD_S; /* size: 0x0898 */
#endif // !_KTHREAD_S_


#define DEBUG_OBJECT_DELETE_PENDING			(0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE			(0x2) // Kill all debugged processes on close
#define DEBUG_KILL_ON_CLOSE					(0x01)
#define DEBUG_EVENT_READ					(0x01)  // Event had been seen by win32 app
#define DEBUG_EVENT_NOWAIT					(0x02)  // No waiter one this. Just free the pool
#define DEBUG_EVENT_INACTIVE				(0x04)  // The message is in inactive. It may be activated or deleted later
#define DEBUG_EVENT_RELEASE					(0x08)  // Release rundown protection on this thread
#define DEBUG_EVENT_PROTECT_FAILED			(0x10)  // Rundown protection failed to be acquired on this thread
#define DEBUG_EVENT_SUSPEND					(0x20)  // Resume thread on continue

//
// Define debug object access types. No security is present on this object.
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
	DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

//一些内核其他定义声明

//
// Used to signify that the delete APC has been queued or the
// thread has called PspExitThread itself.
//
#define PS_CROSS_THREAD_FLAGS_TERMINATED           0x00000001UL
//
// Thread create failed
//
#define PS_CROSS_THREAD_FLAGS_DEADTHREAD           0x00000002UL
//
// Debugger isn't shown this thread
//
#define PS_CROSS_THREAD_FLAGS_HIDEFROMDBG          0x00000004UL
//
// Thread is impersonating
//
#define PS_CROSS_THREAD_FLAGS_IMPERSONATING        0x00000008UL
//
// This is a system thread
//
#define PS_CROSS_THREAD_FLAGS_SYSTEM               0x00000010UL
//
// Hard errors are disabled for this thread
//
#define PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED 0x00000020UL
//
// We should break in when this thread is terminated
//
#define PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION 0x00000040UL
//
// This thread should skip sending its create thread message
//
#define PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG    0x00000080UL
//
// This thread should skip sending its final thread termination message
//
#define PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG 0x00000100UL

#define IS_SYSTEM_THREAD(Thread)  (((Thread)->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SYSTEM) != 0)

#define PS_PROCESS_FLAGS_CREATE_REPORTED        0x00000001UL // Create process debug call has occurred
#define PS_PROCESS_FLAGS_NO_DEBUG_INHERIT       0x00000002UL // Don't inherit debug port
#define PS_PROCESS_FLAGS_PROCESS_EXITING        0x00000004UL // PspExitProcess entered
#define PS_PROCESS_FLAGS_PROCESS_DELETE         0x00000008UL // Delete process has been issued
#define PS_PROCESS_FLAGS_WOW64_SPLIT_PAGES      0x00000010UL // Wow64 split pages
#define PS_PROCESS_FLAGS_VM_DELETED             0x00000020UL // VM is deleted
#define PS_PROCESS_FLAGS_OUTSWAP_ENABLED        0x00000040UL // Outswap enabled
#define PS_PROCESS_FLAGS_OUTSWAPPED             0x00000080UL // Outswapped
#define PS_PROCESS_FLAGS_FORK_FAILED            0x00000100UL // Fork status
#define PS_PROCESS_FLAGS_WOW64_4GB_VA_SPACE     0x00000200UL // Wow64 process with 4gb virtual address space
#define PS_PROCESS_FLAGS_ADDRESS_SPACE1         0x00000400UL // Addr space state1
#define PS_PROCESS_FLAGS_ADDRESS_SPACE2         0x00000800UL // Addr space state2
#define PS_PROCESS_FLAGS_SET_TIMER_RESOLUTION   0x00001000UL // SetTimerResolution has been called
#define PS_PROCESS_FLAGS_BREAK_ON_TERMINATION   0x00002000UL // Break on process termination
#define PS_PROCESS_FLAGS_CREATING_SESSION       0x00004000UL // Process is creating a session
#define PS_PROCESS_FLAGS_USING_WRITE_WATCH      0x00008000UL // Process is using the write watch APIs
#define PS_PROCESS_FLAGS_IN_SESSION             0x00010000UL // Process is in a session
#define PS_PROCESS_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00020000UL // Process must use native address space (Win64 only)
#define PS_PROCESS_FLAGS_HAS_ADDRESS_SPACE      0x00040000UL // This process has an address space
#define PS_PROCESS_FLAGS_LAUNCH_PREFETCHED      0x00080000UL // Process launch was prefetched
#define PS_PROCESS_INJECT_INPAGE_ERRORS         0x00100000UL // Process should be given inpage errors - hardcoded in trap.asm too
#define PS_PROCESS_FLAGS_VM_TOP_DOWN            0x00200000UL // Process memory allocations default to top-down
#define PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE      0x00400000UL // We have sent a message for this image
#define PS_PROCESS_FLAGS_PDE_UPDATE_NEEDED      0x00800000UL // The system PDEs need updating for this process (NT32 only)
#define PS_PROCESS_FLAGS_VDM_ALLOWED            0x01000000UL // Process allowed to invoke NTVDM support
#define PS_PROCESS_FLAGS_SMAP_ALLOWED           0x02000000UL // Process allowed to invoke SMAP support
#define PS_PROCESS_FLAGS_CREATE_FAILED          0x04000000UL // Process create failed

#define PS_PROCESS_FLAGS_DEFAULT_IO_PRIORITY    0x38000000UL // The default I/O priority for created threads. (3 bits)

#define PS_PROCESS_FLAGS_PRIORITY_SHIFT         27

#define PS_PROCESS_FLAGS_EXECUTE_SPARE1         0x40000000UL //
#define PS_PROCESS_FLAGS_EXECUTE_SPARE2         0x80000000UL //


#define THREAD_TERMINATE						(0x0001)  
#define THREAD_SUSPEND_RESUME					(0x0002)  
#define THREAD_GET_CONTEXT						(0x0008)  
#define THREAD_SET_CONTEXT						(0x0010)  
#define THREAD_QUERY_INFORMATION				(0x0040)  
#define THREAD_SET_INFORMATION					(0x0020)  
#define THREAD_SET_THREAD_TOKEN					(0x0080)
#define THREAD_IMPERSONATE						(0x0100)
#define THREAD_DIRECT_IMPERSONATION				(0x0200)

#define PROCESS_TERMINATE						(0x0001)  
#define PROCESS_CREATE_THREAD					(0x0002)  
#define PROCESS_SET_SESSIONID					(0x0004)  
#define PROCESS_VM_OPERATION					(0x0008)  
#define PROCESS_VM_READ							(0x0010)  
#define PROCESS_VM_WRITE						(0x0020)  
#define PROCESS_DUP_HANDLE						(0x0040)  
#define PROCESS_CREATE_PROCESS					(0x0080)  
#define PROCESS_SET_QUOTA						(0x0100)  
#define PROCESS_SET_INFORMATION					(0x0200)  
#define PROCESS_QUERY_INFORMATION				(0x0400)  
#define PROCESS_SUSPEND_RESUME					(0x0800)  
#define PROCESS_QUERY_LIMITED_INFORMATION		(0x1000)  
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)


#define LPC_REQUEST								1
#define LPC_REPLY								2
#define LPC_DATAGRAM							3
#define LPC_LOST_REPLY							4
#define LPC_PORT_CLOSED							5
#define LPC_CLIENT_DIED							6
#define LPC_EXCEPTION							7
#define LPC_DEBUG_EVENT							8
#define LPC_ERROR_EVENT							9
#define LPC_CONNECTION_REQUEST					10
#define DBGK_KILL_PROCESS_ON_EXIT         (0x1)
#define DBGK_ALL_FLAGS                    (DBGK_KILL_PROCESS_ON_EXIT)

typedef struct _OBJECT_TYPE_INITIALIZER_S                                                                                                                                      // 25 elements, 0x70 bytes (sizeof)
{
	/*0x000*/     UINT16       Length;
	union                                                                                                                                                                       // 2 elements, 0x1 bytes (sizeof)
	{
		/*0x002*/         UINT16        ObjectTypeFlags;
		struct                                                                                                                                                                  // 7 elements, 0x1 bytes (sizeof)
		{
			/*0x002*/             UINT8        CaseInsensitive : 1;                                                                                                                                   // 0 BitPosition
			/*0x002*/             UINT8        UnnamedObjectsOnly : 1;                                                                                                                                // 1 BitPosition
			/*0x002*/             UINT8        UseDefaultObject : 1;                                                                                                                                  // 2 BitPosition
			/*0x002*/             UINT8        SecurityRequired : 1;                                                                                                                                  // 3 BitPosition
			/*0x002*/             UINT8        MaintainHandleCount : 1;                                                                                                                               // 4 BitPosition
			/*0x002*/             UINT8        MaintainTypeList : 1;                                                                                                                                  // 5 BitPosition
			/*0x002*/             UINT8        SupportsObjectCallbacks : 1;                                                                                                                           // 6 BitPosition
		};
	};
	/*0x004*/     ULONG32      ObjectTypeCode;
	/*0x008*/     ULONG32      InvalidAttributes;
	/*0x00C*/     struct _GENERIC_MAPPING GenericMapping;                                                                                                                                     // 4 elements, 0x10 bytes (sizeof)
	/*0x01C*/     ULONG32      ValidAccessMask;
	/*0x020*/     ULONG32      RetainAccess;
	/*0x024*/     enum _POOL_TYPE PoolType;
	/*0x028*/     ULONG32      DefaultPagedPoolCharge;
	/*0x02C*/     ULONG32      DefaultNonPagedPoolCharge;
	/*0x030*/     PVOID DumpProcedure;
	/*0x038*/     PVOID OpenProcedure;
	/*0x040*/     PVOID CloseProcedure;
	/*0x048*/     PVOID DeleteProcedure;
	/*0x050*/     PVOID ParseProcedure;
	/*0x058*/     PVOID SecurityProcedure;
	/*0x060*/     PVOID QueryNameProcedure;
	/*0x068*/     PVOID OkayToCloseProcedure;
}OBJECT_TYPE_INITIALIZER_S, * POBJECT_TYPE_INITIALIZER_S;

/*
+0x000 Length           : Uint2B
+ 0x002 ObjectTypeFlags : Uint2B
+ 0x002 CaseInsensitive : Pos 0, 1 Bit
+ 0x002 UnnamedObjectsOnly : Pos 1, 1 Bit
+ 0x002 UseDefaultObject : Pos 2, 1 Bit
+ 0x002 SecurityRequired : Pos 3, 1 Bit
+ 0x002 MaintainHandleCount : Pos 4, 1 Bit
+ 0x002 MaintainTypeList : Pos 5, 1 Bit
+ 0x002 SupportsObjectCallbacks : Pos 6, 1 Bit
+ 0x002 CacheAligned : Pos 7, 1 Bit
+ 0x003 UseExtendedParameters : Pos 0, 1 Bit
+ 0x003 Reserved : Pos 1, 7 Bits
+ 0x004 ObjectTypeCode : Uint4B
+ 0x008 InvalidAttributes : Uint4B
+ 0x00c GenericMapping : _GENERIC_MAPPING
+ 0x01c ValidAccessMask : Uint4B
+ 0x020 RetainAccess : Uint4B
+ 0x024 PoolType : _POOL_TYPE
+ 0x028 DefaultPagedPoolCharge : Uint4B
+ 0x02c DefaultNonPagedPoolCharge : Uint4B
+ 0x030 DumpProcedure : Ptr64     void
+ 0x038 OpenProcedure : Ptr64     long
+ 0x040 CloseProcedure : Ptr64     void
+ 0x048 DeleteProcedure : Ptr64     void
+ 0x050 ParseProcedure : Ptr64     long
+ 0x050 ParseProcedureEx : Ptr64     long
+ 0x058 SecurityProcedure : Ptr64     long
+ 0x060 QueryNameProcedure : Ptr64     long
+ 0x068 OkayToCloseProcedure : Ptr64     unsigned char
+ 0x070 WaitObjectFlagMask : Uint4B
+ 0x074 WaitObjectFlagOffset : Uint2B
+ 0x076 WaitObjectPointerOffset : Uint2B
*/

typedef struct _OBJECT_TYPE_S                    // 12 elements, 0xD0 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY TypeList;              // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _UNICODE_STRING Name;              // 3 elements, 0x10 bytes (sizeof)
	/*0x020*/     VOID* DefaultObject;
	/*0x028*/     UINT8        Index;
	/*0x02C*/     ULONG32      TotalNumberOfObjects;
	/*0x030*/     ULONG32      TotalNumberOfHandles;
	/*0x034*/     ULONG32      HighWaterNumberOfObjects;
	/*0x038*/     ULONG32      HighWaterNumberOfHandles;
	/*0x040*/     struct _OBJECT_TYPE_INITIALIZER_S TypeInfo; // 25 elements, 0x70 bytes (sizeof)
	/*0x0B8*/     struct _EX_PUSH_LOCK TypeLock;            // 7 elements, 0x8 bytes (sizeof)
	/*0x0C0*/     ULONG32      Key;
	/*0x0C8*/     struct _LIST_ENTRY CallbackList;          // 2 elements, 0x10 bytes (sizeof)
}OBJECT_TYPE_S, * POBJECT_TYPE_S;

/*
+0x000 TypeList         : _LIST_ENTRY
+ 0x010 Name : _UNICODE_STRING
+ 0x020 DefaultObject : Ptr64 Void
+ 0x028 Index : UChar
+ 0x02c TotalNumberOfObjects : Uint4B
+ 0x030 TotalNumberOfHandles : Uint4B
+ 0x034 HighWaterNumberOfObjects : Uint4B
+ 0x038 HighWaterNumberOfHandles : Uint4B
+ 0x040 TypeInfo : _OBJECT_TYPE_INITIALIZER
+ 0x0b8 TypeLock : _EX_PUSH_LOCK
+ 0x0c0 Key : Uint4B
+ 0x0c8 CallbackList : _LIST_ENTRY
*/

#ifndef _MODULE_INFO_
#define _MODULE_INFO_
typedef struct _MODULE_INFO
{
	ULONG64			UnKown1;
	UNICODE_STRING	FileName;		//+0x4
	PVOID			BaseOfDll;		//+0xC
	wchar_t* Buffer;			//+0x10
	//...
}MODULE_INFO, * PMODULE_INFO;
#endif // !_MODULE_INFO_

#ifndef _SYSTEM_DLL_
#define _SYSTEM_DLL_
typedef struct _SYSTEM_DLL
{
	EX_FAST_REF		FastRef;
	EX_PUSH_LOCK	Lock;
	MODULE_INFO		ModuleInfo;
}SYSTEM_DLL, * PSYSTEM_DLL;
#endif // !_SYSTEM_DLL_

typedef NTSTATUS
(*OBCREATEOBJECTTYPE)(
	PUNICODE_STRING usTypeName,
	POBJECT_TYPE_INITIALIZER_S ObjectTypeInit,
	PVOID	Reserved,
	POBJECT_TYPE* ObjectType);

#ifndef _KAFFINITY_EX_
#define _KAFFINITY_EX_
typedef struct _KAFFINITY_EX // 4 elements, 0x28 bytes (sizeof)
{
	/*0x000*/     UINT16       Count;
	/*0x002*/     UINT16       Size;
	/*0x004*/     ULONG32      Reserved;
	/*0x008*/     UINT64       Bitmap[4];
}KAFFINITY_EX, * PKAFFINITY_EX;
#endif // !_KAFFINITY_EX_

typedef struct _KGUARDED_MUTEX64              // 7 elements, 0x38 bytes (sizeof)
{
	/*0x000*/     LONG32       Count;
	/*0x004*/     UINT8        _PADDING0_[0x4];
	/*0x008*/     ULONG64 Owner;
	/*0x010*/     ULONG32      Contention;
	/*0x014*/     UINT8        _PADDING1_[0x4];
	/*0x018*/     struct _KGATE Gate;                     // 1 elements, 0x18 bytes (sizeof)
	union                                   // 2 elements, 0x8 bytes (sizeof)
	{
		struct                              // 2 elements, 0x8 bytes (sizeof)
		{
			/*0x030*/             INT16        KernelApcDisable;
			/*0x032*/             INT16        SpecialApcDisable;
			/*0x034*/             UINT8        _PADDING2_[0x4];
		};
		/*0x030*/         ULONG32      CombinedApcDisable;
	};
}KGUARDED_MUTEX64, * PKGUARDED_MUTEX64;

typedef union _KGDTENTRY64 {
	struct {
		USHORT  LimitLow;
		USHORT  BaseLow;
		union {
			struct {
				UCHAR   BaseMiddle;
				UCHAR   Flags1;
				UCHAR   Flags2;
				UCHAR   BaseHigh;
			} Bytes;

			struct {
				ULONG   BaseMiddle : 8;
				ULONG   Type : 5;//把S位包含进去了，也就是是否为系统段描述符的位。
				ULONG   Dpl : 2;
				ULONG   Present : 1;
				ULONG   LimitHigh : 4;
				ULONG   System : 1;//即AVL，系统软件自定义的。
				ULONG   LongMode : 1;
				ULONG   DefaultBig : 1;//即INTEL的D/B (default operation size/default stack pointer size and/or upper bound) flag。
				ULONG   Granularity : 1;
				ULONG   BaseHigh : 8;
			} Bits;
		};

		ULONG BaseUpper;
		ULONG MustBeZero;
	};

	ULONG64 Alignment;
} KGDTENTRY64, * PKGDTENTRY64;

typedef struct _PS_PER_CPU_QUOTA_CACHE_AWARE // 5 elements, 0x40 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY SortedListEntry;      // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _LIST_ENTRY IdleOnlyListHead;     // 2 elements, 0x10 bytes (sizeof)
	/*0x020*/     UINT64       CycleBaseAllowance;
	/*0x028*/     INT64        CyclesRemaining;
	/*0x030*/     ULONG32      CurrentGeneration;
	/*0x034*/     UINT8        _PADDING0_[0xC];
}PS_PER_CPU_QUOTA_CACHE_AWARE, * PPS_PER_CPU_QUOTA_CACHE_AWARE;

#ifndef _MMADDRESS_NODE_
#define _MMADDRESS_NODE_
typedef struct _MMADDRESS_NODE          // 5 elements, 0x28 bytes (sizeof)
{
	union                               // 2 elements, 0x8 bytes (sizeof)
	{
		/*0x000*/         INT64        Balance : 2;       // 0 BitPosition
		/*0x000*/         struct _MMADDRESS_NODE* Parent;
	}u1;
	/*0x008*/     struct _MMADDRESS_NODE* LeftChild;
	/*0x010*/     struct _MMADDRESS_NODE* RightChild;
	/*0x018*/     UINT64       StartingVpn;
	/*0x020*/     UINT64       EndingVpn;
}MMADDRESS_NODE, * PMMADDRESS_NODE;
#endif // !_MMADDRESS_NODE_

typedef struct _MM_AVL_TABLE                          // 6 elements, 0x40 bytes (sizeof)
{
	/*0x000*/     struct _MMADDRESS_NODE BalancedRoot;              // 5 elements, 0x28 bytes (sizeof)
	struct                                            // 3 elements, 0x8 bytes (sizeof)
	{
		/*0x028*/         UINT64       DepthOfTree : 5;                 // 0 BitPosition
		/*0x028*/         UINT64       Unused : 3;                      // 5 BitPosition
		/*0x028*/         UINT64       NumberGenericTableElements : 56; // 8 BitPosition
	};
	/*0x030*/     VOID* NodeHint;
	/*0x038*/     VOID* NodeFreeHint;
}MM_AVL_TABLE, * PMM_AVL_TABLE;

typedef struct _PS_CPU_QUOTA_BLOCK                                        // 14 elements, 0x4080 bytes (sizeof)
{
	union                                                                 // 2 elements, 0x40 bytes (sizeof)
	{
		struct                                                            // 5 elements, 0x40 bytes (sizeof)
		{
			/*0x000*/             struct _LIST_ENTRY ListEntry;                                 // 2 elements, 0x10 bytes (sizeof)
			/*0x010*/             ULONG32      SessionId;
			/*0x014*/             ULONG32      CpuShareWeight;
			/*0x018*/             CHAR CapturedWeightData[0x8]; // 3 elements, 0x8 bytes (sizeof)
			union                                                         // 2 elements, 0x4 bytes (sizeof)
			{
				struct                                                    // 2 elements, 0x4 bytes (sizeof)
				{
					/*0x020*/                     ULONG32      DuplicateInputMarker : 1;                // 0 BitPosition
					/*0x020*/                     ULONG32      Reserved : 31;                           // 1 BitPosition
				};
				/*0x020*/                 LONG32       MiscFlags;
			};
		};
		struct                                                            // 2 elements, 0x40 bytes (sizeof)
		{
			/*0x000*/             UINT64       BlockCurrentGenerationLock;
			/*0x008*/             UINT64       CyclesAccumulated;
			/*0x010*/             UINT8        _PADDING0_[0x30];
		};
	};
	/*0x040*/     UINT64       CycleCredit;
	/*0x048*/     ULONG32      BlockCurrentGeneration;
	/*0x04C*/     ULONG32      CpuCyclePercent;
	/*0x050*/     UINT8        CyclesFinishedForCurrentGeneration;
	/*0x051*/     UINT8        _PADDING1_[0x2F];
	/*0x080*/     struct _PS_PER_CPU_QUOTA_CACHE_AWARE Cpu[256];
}PS_CPU_QUOTA_BLOCK, * PPS_CPU_QUOTA_BLOCK;

typedef struct _EJOB                                // 42 elements, 0x1C8 bytes (sizeof)
{
	/*0x000*/     struct _KEVENT Event;                           // 1 elements, 0x18 bytes (sizeof)
	/*0x018*/     struct _LIST_ENTRY JobLinks;                    // 2 elements, 0x10 bytes (sizeof)
	/*0x028*/     struct _LIST_ENTRY ProcessListHead;             // 2 elements, 0x10 bytes (sizeof)
	/*0x038*/     struct _ERESOURCE JobLock;                      // 15 elements, 0x68 bytes (sizeof)
	/*0x0A0*/     union _LARGE_INTEGER TotalUserTime;             // 4 elements, 0x8 bytes (sizeof)
	/*0x0A8*/     union _LARGE_INTEGER TotalKernelTime;           // 4 elements, 0x8 bytes (sizeof)
	/*0x0B0*/     union _LARGE_INTEGER ThisPeriodTotalUserTime;   // 4 elements, 0x8 bytes (sizeof)
	/*0x0B8*/     union _LARGE_INTEGER ThisPeriodTotalKernelTime; // 4 elements, 0x8 bytes (sizeof)
	/*0x0C0*/     ULONG32      TotalPageFaultCount;
	/*0x0C4*/     ULONG32      TotalProcesses;
	/*0x0C8*/     ULONG32      ActiveProcesses;
	/*0x0CC*/     ULONG32      TotalTerminatedProcesses;
	/*0x0D0*/     union _LARGE_INTEGER PerProcessUserTimeLimit;   // 4 elements, 0x8 bytes (sizeof)
	/*0x0D8*/     union _LARGE_INTEGER PerJobUserTimeLimit;       // 4 elements, 0x8 bytes (sizeof)
	/*0x0E0*/     UINT64       MinimumWorkingSetSize;
	/*0x0E8*/     UINT64       MaximumWorkingSetSize;
	/*0x0F0*/     ULONG32      LimitFlags;
	/*0x0F4*/     ULONG32      ActiveProcessLimit;
	/*0x0F8*/     struct _KAFFINITY_EX Affinity;                  // 4 elements, 0x28 bytes (sizeof)
	/*0x120*/     UINT8        PriorityClass;
	/*0x121*/     UINT8        _PADDING0_[0x7];
	/*0x128*/     ULONG64 AccessState;
	/*0x130*/     ULONG32      UIRestrictionsClass;
	/*0x134*/     ULONG32      EndOfJobTimeAction;
	/*0x138*/     VOID* CompletionPort;
	/*0x140*/     VOID* CompletionKey;
	/*0x148*/     ULONG32      SessionId;
	/*0x14C*/     ULONG32      SchedulingClass;
	/*0x150*/     UINT64       ReadOperationCount;
	/*0x158*/     UINT64       WriteOperationCount;
	/*0x160*/     UINT64       OtherOperationCount;
	/*0x168*/     UINT64       ReadTransferCount;
	/*0x170*/     UINT64       WriteTransferCount;
	/*0x178*/     UINT64       OtherTransferCount;
	/*0x180*/     UINT64       ProcessMemoryLimit;
	/*0x188*/     UINT64       JobMemoryLimit;
	/*0x190*/     UINT64       PeakProcessMemoryUsed;
	/*0x198*/     UINT64       PeakJobMemoryUsed;
	/*0x1A0*/     UINT64       CurrentJobMemoryUsed;
	/*0x1A8*/     struct _EX_PUSH_LOCK MemoryLimitsLock;          // 7 elements, 0x8 bytes (sizeof)
	/*0x1B0*/     struct _LIST_ENTRY JobSetLinks;                 // 2 elements, 0x10 bytes (sizeof)
	/*0x1C0*/     ULONG32      MemberLevel;
	/*0x1C4*/     ULONG32      JobFlags;
}EJOB, * PEJOB;

typedef struct _HARDWARE_PTE
{
	ULONG64 Valid : 1;
	ULONG64 Write : 1;
	ULONG64 Owner : 1;
	ULONG64 WriteThrough : 1;
	ULONG64 CacheDisable : 1;
	ULONG64 Accessed : 1;
	ULONG64 Dirty : 1;
	ULONG64 LargePage : 1;
	ULONG64 Global : 1;
	ULONG64 CopyOnWrite : 1;
	ULONG64 Prototype : 1;
	ULONG64 reserved0 : 1;
	ULONG64 PageFrameNumber : 28;
	ULONG64 reserved1 : 12;
	ULONG64 SoftwareWsIndex : 11;
	ULONG64 NoExecute : 1;
} HARDWARE_PTE, * PHARDWARE_PTE;

typedef struct _MMWSLE_NONDIRECT_HASH // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     VOID* Key;
	/*0x008*/     ULONG32      Index;
	/*0x00C*/     UINT8        _PADDING0_[0x4];
}MMWSLE_NONDIRECT_HASH, * PMMWSLE_NONDIRECT_HASH;

typedef struct _MMWSLENTRY               // 7 elements, 0x8 bytes (sizeof)
{
	/*0x000*/     UINT64       Valid : 1;              // 0 BitPosition
	/*0x000*/     UINT64       Spare : 1;              // 1 BitPosition
	/*0x000*/     UINT64       Hashed : 1;             // 2 BitPosition
	/*0x000*/     UINT64       Direct : 1;             // 3 BitPosition
	/*0x000*/     UINT64       Protection : 5;         // 4 BitPosition
	/*0x000*/     UINT64       Age : 3;                // 9 BitPosition
	/*0x000*/     UINT64       VirtualPageNumber : 52; // 12 BitPosition
}MMWSLENTRY, * PMMWSLENTRY;

typedef struct _MMWSLE_FREE_ENTRY   // 3 elements, 0x8 bytes (sizeof)
{
	/*0x000*/     UINT64       MustBeZero : 1;    // 0 BitPosition
	/*0x000*/     UINT64       PreviousFree : 31; // 1 BitPosition
	/*0x000*/     UINT64       NextFree : 32;     // 32 BitPosition
}MMWSLE_FREE_ENTRY, * PMMWSLE_FREE_ENTRY;

typedef struct _MMWSLE                // 1 elements, 0x8 bytes (sizeof)
{
	union                             // 4 elements, 0x8 bytes (sizeof)
	{
		/*0x000*/         VOID* VirtualAddress;
		/*0x000*/         UINT64       Long;
		/*0x000*/         struct _MMWSLENTRY e1;        // 7 elements, 0x8 bytes (sizeof)
		/*0x000*/         struct _MMWSLE_FREE_ENTRY e2; // 3 elements, 0x8 bytes (sizeof)
	}u1;
}MMWSLE, * PMMWSLE;

typedef struct _MMWSLE_HASH // 1 elements, 0x4 bytes (sizeof)
{
	/*0x000*/     ULONG32      Index;
}MMWSLE_HASH, * PMMWSLE_HASH;

typedef struct _MMWSL                                   // 25 elements, 0x488 bytes (sizeof)
{
	/*0x000*/     ULONG32      FirstFree;
	/*0x004*/     ULONG32      FirstDynamic;
	/*0x008*/     ULONG32      LastEntry;
	/*0x00C*/     ULONG32      NextSlot;
	/*0x010*/     struct _MMWSLE* Wsle;
	/*0x018*/     VOID* LowestPagableAddress;
	/*0x020*/     ULONG32      LastInitializedWsle;
	/*0x024*/     ULONG32      NextAgingSlot;
	/*0x028*/     ULONG32      NumberOfCommittedPageTables;
	/*0x02C*/     ULONG32      VadBitMapHint;
	/*0x030*/     ULONG32      NonDirectCount;
	/*0x034*/     ULONG32      LastVadBit;
	/*0x038*/     ULONG32      MaximumLastVadBit;
	/*0x03C*/     ULONG32      LastAllocationSizeHint;
	/*0x040*/     ULONG32      LastAllocationSize;
	/*0x044*/     UINT8        _PADDING0_[0x4];
	/*0x048*/     struct _MMWSLE_NONDIRECT_HASH* NonDirectHash;
	/*0x050*/     struct _MMWSLE_HASH* HashTableStart;
	/*0x058*/     struct _MMWSLE_HASH* HighestPermittedHashAddress;
	/*0x060*/     ULONG32      MaximumUserPageTablePages;
	/*0x064*/     ULONG32      MaximumUserPageDirectoryPages;
	/*0x068*/     ULONG32* CommittedPageTables;
	/*0x070*/     ULONG32      NumberOfCommittedPageDirectories;
	/*0x074*/     UINT8        _PADDING1_[0x4];
	/*0x078*/     UINT64       CommittedPageDirectories[128];
	/*0x478*/     ULONG32      NumberOfCommittedPageDirectoryParents;
	/*0x47C*/     UINT8        _PADDING2_[0x4];
	/*0x480*/     UINT64       CommittedPageDirectoryParents[1];
}MMWSL, * PMMWSL;

typedef struct _MMSUPPORT_FLAGS                 // 15 elements, 0x4 bytes (sizeof)
{
	struct                                      // 6 elements, 0x1 bytes (sizeof)
	{
		/*0x000*/         UINT8        WorkingSetType : 3;        // 0 BitPosition
		/*0x000*/         UINT8        ModwriterAttached : 1;     // 3 BitPosition
		/*0x000*/         UINT8        TrimHard : 1;              // 4 BitPosition
		/*0x000*/         UINT8        MaximumWorkingSetHard : 1; // 5 BitPosition
		/*0x000*/         UINT8        ForceTrim : 1;             // 6 BitPosition
		/*0x000*/         UINT8        MinimumWorkingSetHard : 1; // 7 BitPosition
	};
	struct                                      // 4 elements, 0x1 bytes (sizeof)
	{
		/*0x001*/         UINT8        SessionMaster : 1;         // 0 BitPosition
		/*0x001*/         UINT8        TrimmerState : 2;          // 1 BitPosition
		/*0x001*/         UINT8        Reserved : 1;              // 3 BitPosition
		/*0x001*/         UINT8        PageStealers : 4;          // 4 BitPosition
	};
	/*0x002*/     UINT8        MemoryPriority : 8;            // 0 BitPosition
	struct                                      // 4 elements, 0x1 bytes (sizeof)
	{
		/*0x003*/         UINT8        WsleDeleted : 1;           // 0 BitPosition
		/*0x003*/         UINT8        VmExiting : 1;             // 1 BitPosition
		/*0x003*/         UINT8        ExpansionFailed : 1;       // 2 BitPosition
		/*0x003*/         UINT8        Available : 5;             // 3 BitPosition
	};
}MMSUPPORT_FLAGS, * PMMSUPPORT_FLAGS;

typedef struct _MMSUPPORT                        // 21 elements, 0x88 bytes (sizeof)
{
	/*0x000*/     struct _EX_PUSH_LOCK WorkingSetMutex;        // 7 elements, 0x8 bytes (sizeof)
	/*0x008*/     struct _KGATE* ExitGate;
	/*0x010*/     VOID* AccessLog;
	/*0x018*/     struct _LIST_ENTRY WorkingSetExpansionLinks; // 2 elements, 0x10 bytes (sizeof)
	/*0x028*/     ULONG32      AgeDistribution[7];
	/*0x044*/     ULONG32      MinimumWorkingSetSize;
	/*0x048*/     ULONG32      WorkingSetSize;
	/*0x04C*/     ULONG32      WorkingSetPrivateSize;
	/*0x050*/     ULONG32      MaximumWorkingSetSize;
	/*0x054*/     ULONG32      ChargedWslePages;
	/*0x058*/     ULONG32      ActualWslePages;
	/*0x05C*/     ULONG32      WorkingSetSizeOverhead;
	/*0x060*/     ULONG32      PeakWorkingSetSize;
	/*0x064*/     ULONG32      HardFaultCount;
	/*0x068*/     struct _MMWSL* VmWorkingSetList;
	/*0x070*/     UINT16       NextPageColor;
	/*0x072*/     UINT16       LastTrimStamp;
	/*0x074*/     ULONG32      PageFaultCount;
	/*0x078*/     ULONG32      RepurposeCount;
	/*0x07C*/     ULONG32      Spare[2];
	/*0x084*/     struct _MMSUPPORT_FLAGS Flags;               // 15 elements, 0x4 bytes (sizeof)
}MMSUPPORT, * PMMSUPPORT;

typedef struct _SE_AUDIT_PROCESS_CREATION_INFO      // 1 elements, 0x8 bytes (sizeof)
{
	/*0x000*/     struct _OBJECT_NAME_INFORMATION* ImageFileName;
}SE_AUDIT_PROCESS_CREATION_INFO, * PSE_AUDIT_PROCESS_CREATION_INFO;

typedef struct _ALPC_PROCESS_CONTEXT  // 3 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     struct _EX_PUSH_LOCK Lock;        // 7 elements, 0x8 bytes (sizeof)
	/*0x008*/     struct _LIST_ENTRY ViewListHead;  // 2 elements, 0x10 bytes (sizeof)
	/*0x018*/     UINT64       PagedPoolQuotaCache;
}ALPC_PROCESS_CONTEXT, * PALPC_PROCESS_CONTEXT;

typedef struct _PO_DIAG_STACK_RECORD // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     ULONG32      StackDepth;
	/*0x004*/     UINT8        _PADDING0_[0x4];
	/*0x008*/     VOID* Stack[1];
}PO_DIAG_STACK_RECORD, * PPO_DIAG_STACK_RECORD;

typedef union _KEXECUTE_OPTIONS                           // 9 elements, 0x1 bytes (sizeof) 
{
	struct                                                // 8 elements, 0x1 bytes (sizeof) 
	{
		/*0x000*/         UINT8        ExecuteDisable : 1;                  // 0 BitPosition                  
		/*0x000*/         UINT8        ExecuteEnable : 1;                   // 1 BitPosition                  
		/*0x000*/         UINT8        DisableThunkEmulation : 1;           // 2 BitPosition                  
		/*0x000*/         UINT8        Permanent : 1;                       // 3 BitPosition                  
		/*0x000*/         UINT8        ExecuteDispatchEnable : 1;           // 4 BitPosition                  
		/*0x000*/         UINT8        ImageDispatchEnable : 1;             // 5 BitPosition                  
		/*0x000*/         UINT8        DisableExceptionChainValidation : 1; // 6 BitPosition                  
		/*0x000*/         UINT8        Spare : 1;                           // 7 BitPosition                  
	};
	/*0x000*/     UINT8        ExecuteOptions;
}KEXECUTE_OPTIONS, * PKEXECUTE_OPTIONS;

typedef union _KSTACK_COUNT           // 3 elements, 0x4 bytes (sizeof) 
{
	/*0x000*/     LONG32       Value;
	struct                            // 2 elements, 0x4 bytes (sizeof) 
	{
		/*0x000*/         ULONG32      State : 3;       // 0 BitPosition                  
		/*0x000*/         ULONG32      StackCount : 29; // 3 BitPosition                  
	};
}KSTACK_COUNT, * PKSTACK_COUNT;

#pragma pack(push) //保存对齐状态
#pragma pack(1)//设定为4字节对齐
typedef struct _KPROCESS
{
	/* 0x0000 */ struct _DISPATCHER_HEADER Header;
	/* 0x0018 */ struct _LIST_ENTRY ProfileListHead;
	/* 0x0028 */ unsigned __int64 DirectoryTableBase;
	/* 0x0030 */ struct _LIST_ENTRY ThreadListHead;
	/* 0x0040 */ unsigned long ProcessLock;
	/* 0x0044 */ unsigned long ProcessTimerDelay;
	/* 0x0048 */ unsigned __int64 DeepFreezeStartTime;
	/* 0x0050 */ struct _KAFFINITY_EX Affinity;
	/* 0x00f8 */ unsigned __int64 AffinityPadding[12];
	/* 0x0158 */ struct _LIST_ENTRY ReadyListHead;
	/* 0x0168 */ struct _SINGLE_LIST_ENTRY SwapListEntry;
	/* 0x0170 */ volatile struct _KAFFINITY_EX ActiveProcessors;
	/* 0x0218 */ unsigned __int64 ActiveProcessorsPadding[12];
	union
	{
		struct /* bitfield */
		{
			/* 0x0278 */ unsigned long AutoAlignment : 1; /* bit position: 0 */
			/* 0x0278 */ unsigned long DisableBoost : 1; /* bit position: 1 */
			/* 0x0278 */ unsigned long DisableQuantum : 1; /* bit position: 2 */
			/* 0x0278 */ unsigned long DeepFreeze : 1; /* bit position: 3 */
			/* 0x0278 */ unsigned long TimerVirtualization : 1; /* bit position: 4 */
			/* 0x0278 */ unsigned long CheckStackExtents : 1; /* bit position: 5 */
			/* 0x0278 */ unsigned long CacheIsolationEnabled : 1; /* bit position: 6 */
			/* 0x0278 */ unsigned long PpmPolicy : 3; /* bit position: 7 */
			/* 0x0278 */ unsigned long VaSpaceDeleted : 1; /* bit position: 10 */
			/* 0x0278 */ unsigned long ReservedFlags : 21; /* bit position: 11 */
		}; /* bitfield */
		/* 0x0278 */ volatile long ProcessFlags;
	}; /* size: 0x0004 */
	/* 0x027c */ unsigned long ActiveGroupsMask;
	/* 0x0280 */ char BasePriority;
	/* 0x0281 */ char QuantumReset;
	/* 0x0282 */ char Visited;
	/* 0x0283 */ union _KEXECUTE_OPTIONS Flags;
	/* 0x0284 */ unsigned short ThreadSeed[20];
	/* 0x02ac */ unsigned short ThreadSeedPadding[12];
	/* 0x02c4 */ unsigned short IdealProcessor[20];
	/* 0x02ec */ unsigned short IdealProcessorPadding[12];
	/* 0x0304 */ unsigned short IdealNode[20];
	/* 0x032c */ unsigned short IdealNodePadding[12];
	/* 0x0344 */ unsigned short IdealGlobalNode;
	/* 0x0346 */ unsigned short Spare1;
	/* 0x0348 */ volatile union _KSTACK_COUNT StackCount;
	/* 0x034c */ long Padding_0;
	/* 0x0350 */ struct _LIST_ENTRY ProcessListEntry;
	/* 0x0360 */ unsigned __int64 CycleTime;
	/* 0x0368 */ unsigned __int64 ContextSwitches;
	/* 0x0370 */ struct _KSCHEDULING_GROUP* SchedulingGroup;
	/* 0x0378 */ unsigned long FreezeCount;
	/* 0x037c */ unsigned long KernelTime;
	/* 0x0380 */ unsigned long UserTime;
	/* 0x0384 */ unsigned long ReadyTime;
	/* 0x0388 */ unsigned __int64 UserDirectoryTableBase;
	/* 0x0390 */ unsigned char AddressPolicy;
	/* 0x0391 */ unsigned char Spare2[71];
	/* 0x03d8 */ void* InstrumentationCallback;
	union
	{
		union
		{
			/* 0x03e0 */ unsigned __int64 SecureHandle;
			struct
			{
				struct /* bitfield */
				{
					/* 0x03e0 */ unsigned __int64 SecureProcess : 1; /* bit position: 0 */
					/* 0x03e0 */ unsigned __int64 Unused : 1; /* bit position: 1 */
				}; /* bitfield */
			} /* size: 0x0008 */ Flags;
		}; /* size: 0x0008 */
	} /* size: 0x0008 */ SecureState;
	/* 0x03e8 */ unsigned __int64 KernelWaitTime;
	/* 0x03f0 */ unsigned __int64 UserWaitTime;
	/* 0x03f8 */ unsigned __int64 EndPadding[8];
} KPROCESS, * PKPROCESS; /* size: 0x0438 */
#pragma pack(pop)//恢复对齐状态

typedef struct _RTL_UMS_CONTEXT                       // 28 elements, 0x540 bytes (sizeof)
{
	/*0x000*/     struct _SINGLE_LIST_ENTRY Link;                   // 1 elements, 0x8 bytes (sizeof)
	/*0x008*/     UINT8        _PADDING0_[0x8];
	/*0x010*/     struct _CONTEXT Context;                          // 64 elements, 0x4D0 bytes (sizeof)
	/*0x4E0*/     VOID* Teb;
	/*0x4E8*/     VOID* UserContext;
	union                                             // 2 elements, 0x8 bytes (sizeof)
	{
		struct                                        // 11 elements, 0x4 bytes (sizeof)
		{
			/*0x4F0*/             ULONG32      ScheduledThread : 1;         // 0 BitPosition
			/*0x4F0*/             ULONG32      HasQuantumReq : 1;           // 1 BitPosition
			/*0x4F0*/             ULONG32      HasAffinityReq : 1;          // 2 BitPosition
			/*0x4F0*/             ULONG32      HasPriorityReq : 1;          // 3 BitPosition
			/*0x4F0*/             ULONG32      Suspended : 1;               // 4 BitPosition
			/*0x4F0*/             ULONG32      VolatileContext : 1;         // 5 BitPosition
			/*0x4F0*/             ULONG32      Terminated : 1;              // 6 BitPosition
			/*0x4F0*/             ULONG32      DebugActive : 1;             // 7 BitPosition
			/*0x4F0*/             ULONG32      RunningOnSelfThread : 1;     // 8 BitPosition
			/*0x4F0*/             ULONG32      DenyRunningOnSelfThread : 1; // 9 BitPosition
			/*0x4F0*/             ULONG32      ReservedFlags : 22;          // 10 BitPosition
		};
		/*0x4F0*/         LONG32       Flags;
	};
	union                                             // 2 elements, 0x8 bytes (sizeof)
	{
		struct                                        // 3 elements, 0x8 bytes (sizeof)
		{
			/*0x4F8*/             UINT64       KernelUpdateLock : 1;        // 0 BitPosition
			/*0x4F8*/             UINT64       Reserved : 1;                // 1 BitPosition
			/*0x4F8*/             UINT64       PrimaryClientID : 62;        // 2 BitPosition
		};
		/*0x4F8*/         UINT64       ContextLock;
	};
	/*0x500*/     UINT64       QuantumValue;
	/*0x508*/     struct _GROUP_AFFINITY AffinityMask;              // 3 elements, 0x10 bytes (sizeof)
	/*0x518*/     LONG32       Priority;
	/*0x51C*/     UINT8        _PADDING1_[0x4];
	/*0x520*/     struct _RTL_UMS_CONTEXT* PrimaryUmsContext;
	/*0x528*/     ULONG32      SwitchCount;
	/*0x52C*/     ULONG32      KernelYieldCount;
	/*0x530*/     ULONG32      MixedYieldCount;
	/*0x534*/     ULONG32      YieldCount;
	/*0x538*/     UINT8        _PADDING2_[0x8];
}RTL_UMS_CONTEXT, * PRTL_UMS_CONTEXT;

typedef struct _UMS_CONTROL_BLOCK                                // 22 elements, 0x98 bytes (sizeof)
{
	/*0x000*/     struct _RTL_UMS_CONTEXT* UmsContext;
	/*0x008*/     struct _SINGLE_LIST_ENTRY* CompletionListEntry;
	/*0x010*/     struct _KEVENT* CompletionListEvent;
	/*0x018*/     ULONG32      ServiceSequenceNumber;
	/*0x01C*/     UINT8        _PADDING0_[0x4];
	union                                                        // 2 elements, 0x6C bytes (sizeof)
	{
		struct                                                   // 6 elements, 0x6C bytes (sizeof)
		{
			/*0x020*/             struct _KQUEUE UmsQueue;                             // 5 elements, 0x40 bytes (sizeof)
			/*0x060*/             struct _LIST_ENTRY QueueEntry;                       // 2 elements, 0x10 bytes (sizeof)
			/*0x070*/             struct _RTL_UMS_CONTEXT* YieldingUmsContext;
			/*0x078*/             VOID* YieldingParam;
			/*0x080*/             VOID* UmsTeb;
			union                                                // 2 elements, 0x4 bytes (sizeof)
			{
				/*0x088*/                 ULONG32      PrimaryFlags;
				/*0x088*/                 ULONG32      UmsContextHeaderReady : 1;          // 0 BitPosition
			};
		};
		struct                                                   // 6 elements, 0x6C bytes (sizeof)
		{
			/*0x020*/             struct _KQUEUE* UmsAssociatedQueue;
			/*0x028*/             struct _LIST_ENTRY* UmsQueueListEntry;
			/*0x030*/             struct _KUMS_CONTEXT_HEADER* UmsContextHeader;
			/*0x038*/             struct _KGATE UmsWaitGate;                           // 1 elements, 0x18 bytes (sizeof)
			/*0x050*/             VOID* StagingArea;
			union                                                // 2 elements, 0x4 bytes (sizeof)
			{
				/*0x058*/                 LONG32       Flags;
				struct                                           // 4 elements, 0x4 bytes (sizeof)
				{
					/*0x058*/                     ULONG32      UmsForceQueueTermination : 1;   // 0 BitPosition
					/*0x058*/                     ULONG32      UmsAssociatedQueueUsed : 1;     // 1 BitPosition
					/*0x058*/                     ULONG32      UmsThreadParked : 1;            // 2 BitPosition
					/*0x058*/                     ULONG32      UmsPrimaryDeliveredContext : 1; // 3 BitPosition
				};
			};
		};
	};
	/*0x090*/     UINT16       TebSelector;
	/*0x092*/     UINT8        _PADDING1_[0x6];
}UMS_CONTROL_BLOCK, * PUMS_CONTROL_BLOCK;

typedef struct _KDESCRIPTOR // 3 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     UINT16       Pad[3];
	/*0x006*/     UINT16       Limit;
	/*0x008*/     VOID* Base;
}KDESCRIPTOR, * PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS     // 27 elements, 0xD8 bytes (sizeof)
{
	/*0x000*/     UINT64       Cr0;
	/*0x008*/     UINT64       Cr2;
	/*0x010*/     UINT64       Cr3;
	/*0x018*/     UINT64       Cr4;
	/*0x020*/     UINT64       KernelDr0;
	/*0x028*/     UINT64       KernelDr1;
	/*0x030*/     UINT64       KernelDr2;
	/*0x038*/     UINT64       KernelDr3;
	/*0x040*/     UINT64       KernelDr6;
	/*0x048*/     UINT64       KernelDr7;
	/*0x050*/     struct _KDESCRIPTOR Gdtr;          // 3 elements, 0x10 bytes (sizeof)
	/*0x060*/     struct _KDESCRIPTOR Idtr;          // 3 elements, 0x10 bytes (sizeof)
	/*0x070*/     UINT16       Tr;
	/*0x072*/     UINT16       Ldtr;
	/*0x074*/     ULONG32      MxCsr;
	/*0x078*/     UINT64       DebugControl;
	/*0x080*/     UINT64       LastBranchToRip;
	/*0x088*/     UINT64       LastBranchFromRip;
	/*0x090*/     UINT64       LastExceptionToRip;
	/*0x098*/     UINT64       LastExceptionFromRip;
	/*0x0A0*/     UINT64       Cr8;
	/*0x0A8*/     UINT64       MsrGsBase;
	/*0x0B0*/     UINT64       MsrGsSwap;
	/*0x0B8*/     UINT64       MsrStar;
	/*0x0C0*/     UINT64       MsrLStar;
	/*0x0C8*/     UINT64       MsrCStar;
	/*0x0D0*/     UINT64       MsrSyscallMask;
}KSPECIAL_REGISTERS, * PKSPECIAL_REGISTERS;

typedef struct _KPROCESSOR_STATE                 // 2 elements, 0x5B0 bytes (sizeof)
{
	/*0x000*/     struct _KSPECIAL_REGISTERS SpecialRegisters; // 27 elements, 0xD8 bytes (sizeof)
	/*0x0D8*/     UINT8        _PADDING0_[0x8];
	/*0x0E0*/     struct _CONTEXT ContextFrame;                // 64 elements, 0x4D0 bytes (sizeof)
}KPROCESSOR_STATE, * PKPROCESSOR_STATE;

typedef struct _PP_LOOKASIDE_LIST // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     struct _GENERAL_LOOKASIDE* P;
	/*0x008*/     struct _GENERAL_LOOKASIDE* L;
}PP_LOOKASIDE_LIST, * PPP_LOOKASIDE_LIST;

typedef struct _KDPC_DATA           // 4 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY DpcListHead; // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     UINT64       DpcLock;
	/*0x018*/     LONG32       DpcQueueDepth;
	/*0x01C*/     ULONG32      DpcCount;
}KDPC_DATA, * PKDPC_DATA;

typedef struct _KTIMER_TABLE_ENTRY // 3 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     UINT64       Lock;
	/*0x008*/     struct _LIST_ENTRY Entry;      // 2 elements, 0x10 bytes (sizeof)
	/*0x018*/     union _ULARGE_INTEGER Time;    // 4 elements, 0x8 bytes (sizeof)
}KTIMER_TABLE_ENTRY, * PKTIMER_TABLE_ENTRY;

typedef struct _KTIMER_TABLE                      // 2 elements, 0x2200 bytes (sizeof)
{
	/*0x000*/     struct _KTIMER* TimerExpiry[64];
	/*0x200*/     struct _KTIMER_TABLE_ENTRY TimerEntries[256];
}KTIMER_TABLE, * PKTIMER_TABLE;

typedef struct _flags                      // 5 elements, 0x1 bytes (sizeof)
{
	/*0x000*/     UINT8        Removable : 1;            // 0 BitPosition
	/*0x000*/     UINT8        GroupAssigned : 1;        // 1 BitPosition
	/*0x000*/     UINT8        GroupCommitted : 1;       // 2 BitPosition
	/*0x000*/     UINT8        GroupAssignmentFixed : 1; // 3 BitPosition
	/*0x000*/     UINT8        Fill : 4;                 // 4 BitPosition
}flags, * Pflags;

typedef struct _CACHED_KSTACK_LIST // 5 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     union _SLIST_HEADER SListHead; // 5 elements, 0x10 bytes (sizeof)
	/*0x010*/     LONG32       MinimumFree;
	/*0x014*/     ULONG32      Misses;
	/*0x018*/     ULONG32      MissesLast;
	/*0x01C*/     ULONG32      Pad0;
}CACHED_KSTACK_LIST, * PCACHED_KSTACK_LIST;

typedef struct _KNODE                              // 18 elements, 0xC0 bytes (sizeof)
{
	/*0x000*/     union _SLIST_HEADER PagedPoolSListHead;        // 5 elements, 0x10 bytes (sizeof)
	/*0x010*/     union _SLIST_HEADER NonPagedPoolSListHead[3];
	/*0x040*/     struct _GROUP_AFFINITY Affinity;               // 3 elements, 0x10 bytes (sizeof)
	/*0x050*/     ULONG32      ProximityId;
	/*0x054*/     UINT16       NodeNumber;
	/*0x056*/     UINT16       PrimaryNodeNumber;
	/*0x058*/     UINT8        MaximumProcessors;
	/*0x059*/     UINT8        Color;
	/*0x05A*/     struct _flags Flags;                           // 5 elements, 0x1 bytes (sizeof)
	/*0x05B*/     UINT8        NodePad0;
	/*0x05C*/     ULONG32      Seed;
	/*0x060*/     ULONG32      MmShiftedColor;
	/*0x064*/     UINT8        _PADDING0_[0x4];
	/*0x068*/     UINT64       FreeCount[2];
	/*0x078*/     ULONG32      Right;
	/*0x07C*/     ULONG32      Left;
	/*0x080*/     struct _CACHED_KSTACK_LIST CachedKernelStacks; // 5 elements, 0x20 bytes (sizeof)
	/*0x0A0*/     LONG32       ParkLock;
	/*0x0A4*/     ULONG32      NodePad1;
	/*0x0A8*/     UINT8        _PADDING1_[0x18];
}KNODE, * PKNODE;

typedef struct _PPM_IDLE_STATE                                                                                                                                              // 14 elements, 0x60 bytes (sizeof)
{
	/*0x000*/     struct _KAFFINITY_EX DomainMembers;                                                                                                                                     // 4 elements, 0x28 bytes (sizeof)
	/*0x028*/     PVOID IdleCheck;
	/*0x030*/     PVOID IdleHandler;
	/*0x038*/     UINT64       HvConfig;
	/*0x040*/     VOID* Context;
	/*0x048*/     ULONG32      Latency;
	/*0x04C*/     ULONG32      Power;
	/*0x050*/     ULONG32      TimeCheck;
	/*0x054*/     ULONG32      StateFlags;
	/*0x058*/     UINT8        PromotePercent;
	/*0x059*/     UINT8        DemotePercent;
	/*0x05A*/     UINT8        PromotePercentBase;
	/*0x05B*/     UINT8        DemotePercentBase;
	/*0x05C*/     UINT8        StateType;
	/*0x05D*/     UINT8        _PADDING0_[0x3];
}PPM_IDLE_STATE, * PPPM_IDLE_STATE;

typedef struct _PPM_IDLE_STATES            // 8 elements, 0xA0 bytes (sizeof)
{
	/*0x000*/     ULONG32      Count;
	union                                  // 5 elements, 0x4 bytes (sizeof)
	{
		/*0x004*/         ULONG32      AsULONG;
		struct                             // 4 elements, 0x4 bytes (sizeof)
		{
			/*0x004*/             ULONG32      AllowScaling : 1; // 0 BitPosition
			/*0x004*/             ULONG32      Disabled : 1;     // 1 BitPosition
			/*0x004*/             ULONG32      HvMaxCState : 4;  // 2 BitPosition
			/*0x004*/             ULONG32      Reserved : 26;    // 6 BitPosition
		};
	}Flags;
	/*0x008*/     ULONG32      TargetState;
	/*0x00C*/     ULONG32      ActualState;
	/*0x010*/     ULONG32      OldState;
	/*0x014*/     UINT8        NewlyUnparked;
	/*0x015*/     UINT8        _PADDING0_[0x3];
	/*0x018*/     struct _KAFFINITY_EX TargetProcessors; // 4 elements, 0x28 bytes (sizeof)
	/*0x040*/     struct _PPM_IDLE_STATE State[1];
}PPM_IDLE_STATES, * PPPM_IDLE_STATES;

typedef struct _PROC_IDLE_STATE_BUCKET // 4 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     UINT64       TotalTime;
	/*0x008*/     UINT64       MinTime;
	/*0x010*/     UINT64       MaxTime;
	/*0x018*/     ULONG32      Count;
	/*0x01C*/     UINT8        _PADDING0_[0x4];
}PROC_IDLE_STATE_BUCKET, * PPROC_IDLE_STATE_BUCKET;

typedef struct _PROC_IDLE_STATE_ACCOUNTING              // 7 elements, 0x228 bytes (sizeof)
{
	/*0x000*/     UINT64       TotalTime;
	/*0x008*/     ULONG32      IdleTransitions;
	/*0x00C*/     ULONG32      FailedTransitions;
	/*0x010*/     ULONG32      InvalidBucketIndex;
	/*0x014*/     UINT8        _PADDING0_[0x4];
	/*0x018*/     UINT64       MinTime;
	/*0x020*/     UINT64       MaxTime;
	/*0x028*/     struct _PROC_IDLE_STATE_BUCKET IdleTimeBuckets[16];
}PROC_IDLE_STATE_ACCOUNTING, * PPROC_IDLE_STATE_ACCOUNTING;

typedef struct _PROC_IDLE_ACCOUNTING             // 6 elements, 0x2C0 bytes (sizeof)
{
	/*0x000*/     ULONG32      StateCount;
	/*0x004*/     ULONG32      TotalTransitions;
	/*0x008*/     ULONG32      ResetCount;
	/*0x00C*/     UINT8        _PADDING0_[0x4];
	/*0x010*/     UINT64       StartTime;
	/*0x018*/     UINT64       BucketLimits[16];
	/*0x098*/     struct _PROC_IDLE_STATE_ACCOUNTING State[1];
}PROC_IDLE_ACCOUNTING, * PPROC_IDLE_ACCOUNTING;

typedef enum _PROC_HYPERVISOR_STATE  // 3 elements, 0x4 bytes
{
	ProcHypervisorNone = 0 /*0x0*/,
	ProcHypervisorPresent = 1 /*0x1*/,
	ProcHypervisorPower = 2 /*0x2*/
}PROC_HYPERVISOR_STATE, * PPROC_HYPERVISOR_STATE;

typedef struct _PPM_FFH_THROTTLE_STATE_INFO // 5 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     UINT8        EnableLogging;
	/*0x001*/     UINT8        _PADDING0_[0x3];
	/*0x004*/     ULONG32      MismatchCount;
	/*0x008*/     UINT8        Initialized;
	/*0x009*/     UINT8        _PADDING1_[0x7];
	/*0x010*/     UINT64       LastValue;
	/*0x018*/     union _LARGE_INTEGER LastLogTickCount;  // 4 elements, 0x8 bytes (sizeof)
}PPM_FFH_THROTTLE_STATE_INFO, * PPPM_FFH_THROTTLE_STATE_INFO;

typedef struct _PROC_IDLE_SNAP // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     UINT64       Time;
	/*0x008*/     UINT64       Idle;
}PROC_IDLE_SNAP, * PPROC_IDLE_SNAP;

typedef struct _PROC_PERF_CONSTRAINT      // 9 elements, 0x30 bytes (sizeof)
{
	/*0x000*/     struct _KPRCB* Prcb;
	/*0x008*/     UINT64       PerfContext;
	/*0x010*/     ULONG32      PercentageCap;
	/*0x014*/     ULONG32      ThermalCap;
	/*0x018*/     ULONG32      TargetFrequency;
	/*0x01C*/     ULONG32      AcumulatedFullFrequency;
	/*0x020*/     ULONG32      AcumulatedZeroFrequency;
	/*0x024*/     ULONG32      FrequencyHistoryTotal;
	/*0x028*/     ULONG32      AverageFrequency;
	/*0x02C*/     UINT8        _PADDING0_[0x4];
}PROC_PERF_CONSTRAINT, * PPROC_PERF_CONSTRAINT;

typedef struct _PROC_PERF_DOMAIN                                         // 26 elements, 0xB8 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY Link;                                             // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _KPRCB* Master;
	/*0x018*/     struct _KAFFINITY_EX Members;                                        // 4 elements, 0x28 bytes (sizeof)
	/*0x040*/     PVOID FeedbackHandler;
	/*0x048*/     PVOID GetFFHThrottleState;
	/*0x050*/     PVOID BoostPolicyHandler;
	/*0x058*/     PVOID PerfSelectionHandler;
	/*0x060*/     PVOID PerfHandler;
	/*0x068*/     struct _PROC_PERF_CONSTRAINT* Processors;
	/*0x070*/     UINT64       PerfChangeTime;
	/*0x078*/     ULONG32      ProcessorCount;
	/*0x07C*/     ULONG32      PreviousFrequencyMhz;
	/*0x080*/     ULONG32      CurrentFrequencyMhz;
	/*0x084*/     ULONG32      PreviousFrequency;
	/*0x088*/     ULONG32      CurrentFrequency;
	/*0x08C*/     ULONG32      CurrentPerfContext;
	/*0x090*/     ULONG32      DesiredFrequency;
	/*0x094*/     ULONG32      MaxFrequency;
	/*0x098*/     ULONG32      MinPerfPercent;
	/*0x09C*/     ULONG32      MinThrottlePercent;
	/*0x0A0*/     ULONG32      MaxPercent;
	/*0x0A4*/     ULONG32      MinPercent;
	/*0x0A8*/     ULONG32      ConstrainedMaxPercent;
	/*0x0AC*/     ULONG32      ConstrainedMinPercent;
	/*0x0B0*/     UINT8        Coordination;
	/*0x0B1*/     UINT8        _PADDING0_[0x3];
	/*0x0B4*/     LONG32       PerfChangeIntervalCount;
}PROC_PERF_DOMAIN, * PPROC_PERF_DOMAIN;

typedef struct _PROC_PERF_LOAD        // 2 elements, 0x2 bytes (sizeof)
{
	/*0x000*/     UINT8        BusyPercentage;
	/*0x001*/     UINT8        FrequencyPercentage;
}PROC_PERF_LOAD, * PPROC_PERF_LOAD;

typedef struct _PROC_HISTORY_ENTRY // 3 elements, 0x4 bytes (sizeof)
{
	/*0x000*/     UINT16       Utility;
	/*0x002*/     UINT8        Frequency;
	/*0x003*/     UINT8        Reserved;
}PROC_HISTORY_ENTRY, * PPROC_HISTORY_ENTRY;

typedef struct _PROCESSOR_POWER_STATE                         // 27 elements, 0x100 bytes (sizeof)
{
	/*0x000*/     struct _PPM_IDLE_STATES* IdleStates;
	/*0x008*/     UINT64       IdleTimeLast;
	/*0x010*/     UINT64       IdleTimeTotal;
	/*0x018*/     UINT64       IdleTimeEntry;
	/*0x020*/     struct _PROC_IDLE_ACCOUNTING* IdleAccounting;
	/*0x028*/     enum _PROC_HYPERVISOR_STATE Hypervisor;
	/*0x02C*/     ULONG32      PerfHistoryTotal;
	/*0x030*/     UINT8        ThermalConstraint;
	/*0x031*/     UINT8        PerfHistoryCount;
	/*0x032*/     UINT8        PerfHistorySlot;
	/*0x033*/     UINT8        Reserved;
	/*0x034*/     ULONG32      LastSysTime;
	/*0x038*/     UINT64       WmiDispatchPtr;
	/*0x040*/     LONG32       WmiInterfaceEnabled;
	/*0x044*/     UINT8        _PADDING0_[0x4];
	/*0x048*/     struct _PPM_FFH_THROTTLE_STATE_INFO FFHThrottleStateInfo; // 5 elements, 0x20 bytes (sizeof)
	/*0x068*/     struct _KDPC PerfActionDpc;                               // 9 elements, 0x40 bytes (sizeof)
	/*0x0A8*/     LONG32       PerfActionMask;
	/*0x0AC*/     UINT8        _PADDING1_[0x4];
	/*0x0B0*/     struct _PROC_IDLE_SNAP IdleCheck;                         // 2 elements, 0x10 bytes (sizeof)
	/*0x0C0*/     struct _PROC_IDLE_SNAP PerfCheck;                         // 2 elements, 0x10 bytes (sizeof)
	/*0x0D0*/     struct _PROC_PERF_DOMAIN* Domain;
	/*0x0D8*/     struct _PROC_PERF_CONSTRAINT* PerfConstraint;
	/*0x0E0*/     struct _PROC_PERF_LOAD* Load;
	/*0x0E8*/     struct _PROC_HISTORY_ENTRY* PerfHistory;
	/*0x0F0*/     ULONG32      Utility;
	/*0x0F4*/     ULONG32      OverUtilizedHistory;
	/*0x0F8*/     ULONG32      AffinityCount;
	/*0x0FC*/     ULONG32      AffinityHistory;
}PROCESSOR_POWER_STATE, * PPROCESSOR_POWER_STATE;

typedef struct _KREQUEST_PACKET                   // 2 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     VOID* CurrentPacket[3];
	/*0x018*/     PVOID WorkerRoutine;
}KREQUEST_PACKET, * PKREQUEST_PACKET;

typedef struct _REQUEST_MAILBOX            // 3 elements, 0x40 bytes (sizeof)
{
	/*0x000*/     struct _REQUEST_MAILBOX* Next;
	/*0x008*/     INT64        RequestSummary;
	/*0x010*/     struct _KREQUEST_PACKET RequestPacket; // 2 elements, 0x20 bytes (sizeof)
	/*0x030*/     UINT8        _PADDING0_[0x10];
}REQUEST_MAILBOX, * PREQUEST_MAILBOX;

typedef struct _KPRCB                                                   // 242 elements, 0x4D00 bytes (sizeof)
{
	/*0x000*/      ULONG32      MxCsr;
	/*0x004*/      UINT8        LegacyNumber;
	/*0x005*/      UINT8        ReservedMustBeZero;
	/*0x006*/      UINT8        InterruptRequest;
	/*0x007*/      UINT8        IdleHalt;
	/*0x008*/      struct _KTHREAD* CurrentThread;
	/*0x010*/      struct _KTHREAD* NextThread;
	/*0x018*/      struct _KTHREAD* IdleThread;
	/*0x020*/      UINT8        NestingLevel;
	/*0x021*/      UINT8        PrcbPad00[3];
	/*0x024*/      ULONG32      Number;
	/*0x028*/      UINT64       RspBase;
	/*0x030*/      UINT64       PrcbLock;
	/*0x038*/      UINT64       PrcbPad01;
	/*0x040*/      struct _KPROCESSOR_STATE ProcessorState;                            // 2 elements, 0x5B0 bytes (sizeof)
	/*0x5F0*/      CHAR         CpuType;
	/*0x5F1*/      CHAR         CpuID;
	union                                                               // 2 elements, 0x2 bytes (sizeof)
	{
		/*0x5F2*/          UINT16       CpuStep;
		struct                                                          // 2 elements, 0x2 bytes (sizeof)
		{
			/*0x5F2*/              UINT8        CpuStepping;
			/*0x5F3*/              UINT8        CpuModel;
		};
	};
	/*0x5F4*/      ULONG32      MHz;
	/*0x5F8*/      UINT64       HalReserved[8];
	/*0x638*/      UINT16       MinorVersion;
	/*0x63A*/      UINT16       MajorVersion;
	/*0x63C*/      UINT8        BuildType;
	/*0x63D*/      UINT8        CpuVendor;
	/*0x63E*/      UINT8        CoresPerPhysicalProcessor;
	/*0x63F*/      UINT8        LogicalProcessorsPerCore;
	/*0x640*/      ULONG32      ApicMask;
	/*0x644*/      ULONG32      CFlushSize;
	/*0x648*/      VOID* AcpiReserved;
	/*0x650*/      ULONG32      InitialApicId;
	/*0x654*/      ULONG32      Stride;
	/*0x658*/      UINT16       Group;
	/*0x65A*/      UINT8        _PADDING0_[0x6];
	/*0x660*/      UINT64       GroupSetMember;
	/*0x668*/      UINT8        GroupIndex;
	/*0x669*/      UINT8        _PADDING1_[0x7];
	/*0x670*/      struct _KSPIN_LOCK_QUEUE LockQueue[17];
	/*0x780*/      struct _PP_LOOKASIDE_LIST PPLookasideList[16];
	/*0x880*/      struct _GENERAL_LOOKASIDE_POOL PPNPagedLookasideList[32];
	/*0x1480*/     struct _GENERAL_LOOKASIDE_POOL PPPagedLookasideList[32];
	/*0x2080*/     LONG32       PacketBarrier;
	/*0x2084*/     UINT8        _PADDING2_[0x4];
	/*0x2088*/     struct _SINGLE_LIST_ENTRY DeferredReadyListHead;                    // 1 elements, 0x8 bytes (sizeof)
	/*0x2090*/     LONG32       MmPageFaultCount;
	/*0x2094*/     LONG32       MmCopyOnWriteCount;
	/*0x2098*/     LONG32       MmTransitionCount;
	/*0x209C*/     LONG32       MmDemandZeroCount;
	/*0x20A0*/     LONG32       MmPageReadCount;
	/*0x20A4*/     LONG32       MmPageReadIoCount;
	/*0x20A8*/     LONG32       MmDirtyPagesWriteCount;
	/*0x20AC*/     LONG32       MmDirtyWriteIoCount;
	/*0x20B0*/     LONG32       MmMappedPagesWriteCount;
	/*0x20B4*/     LONG32       MmMappedWriteIoCount;
	/*0x20B8*/     ULONG32      KeSystemCalls;
	/*0x20BC*/     ULONG32      KeContextSwitches;
	/*0x20C0*/     ULONG32      CcFastReadNoWait;
	/*0x20C4*/     ULONG32      CcFastReadWait;
	/*0x20C8*/     ULONG32      CcFastReadNotPossible;
	/*0x20CC*/     ULONG32      CcCopyReadNoWait;
	/*0x20D0*/     ULONG32      CcCopyReadWait;
	/*0x20D4*/     ULONG32      CcCopyReadNoWaitMiss;
	/*0x20D8*/     LONG32       LookasideIrpFloat;
	/*0x20DC*/     LONG32       IoReadOperationCount;
	/*0x20E0*/     LONG32       IoWriteOperationCount;
	/*0x20E4*/     LONG32       IoOtherOperationCount;
	/*0x20E8*/     union _LARGE_INTEGER IoReadTransferCount;                           // 4 elements, 0x8 bytes (sizeof)
	/*0x20F0*/     union _LARGE_INTEGER IoWriteTransferCount;                          // 4 elements, 0x8 bytes (sizeof)
	/*0x20F8*/     union _LARGE_INTEGER IoOtherTransferCount;                          // 4 elements, 0x8 bytes (sizeof)
	/*0x2100*/     LONG32       TargetCount;
	/*0x2104*/     ULONG32      IpiFrozen;
	/*0x2108*/     UINT8        _PADDING3_[0x78];
	/*0x2180*/     struct _KDPC_DATA DpcData[2];
	/*0x21C0*/     VOID* DpcStack;
	/*0x21C8*/     LONG32       MaximumDpcQueueDepth;
	/*0x21CC*/     ULONG32      DpcRequestRate;
	/*0x21D0*/     ULONG32      MinimumDpcRate;
	/*0x21D4*/     ULONG32      DpcLastCount;
	/*0x21D8*/     UINT8        ThreadDpcEnable;
	/*0x21D9*/     UINT8        QuantumEnd;
	/*0x21DA*/     UINT8        DpcRoutineActive;
	/*0x21DB*/     UINT8        IdleSchedule;
	union                                                               // 3 elements, 0x4 bytes (sizeof)
	{
		/*0x21DC*/         LONG32       DpcRequestSummary;
		/*0x21DC*/         INT16        DpcRequestSlot[2];
		struct                                                          // 2 elements, 0x4 bytes (sizeof)
		{
			/*0x21DC*/             INT16        NormalDpcState;
			union                                                       // 2 elements, 0x2 bytes (sizeof)
			{
				/*0x21DE*/                 UINT16       DpcThreadActive : 1;                       // 0 BitPosition
				/*0x21DE*/                 INT16        ThreadDpcState;
			};
		};
	};
	/*0x21E0*/     ULONG32      TimerHand;
	/*0x21E4*/     LONG32       MasterOffset;
	/*0x21E8*/     ULONG32      LastTick;
	/*0x21EC*/     ULONG32      UnusedPad;
	/*0x21F0*/     UINT64       PrcbPad50[2];
	/*0x2200*/     struct _KTIMER_TABLE TimerTable;                                    // 2 elements, 0x2200 bytes (sizeof)
	/*0x4400*/     struct _KGATE DpcGate;                                              // 1 elements, 0x18 bytes (sizeof)
	/*0x4418*/     VOID* PrcbPad52;
	/*0x4420*/     struct _KDPC CallDpc;                                               // 9 elements, 0x40 bytes (sizeof)
	/*0x4460*/     LONG32       ClockKeepAlive;
	/*0x4464*/     UINT8        ClockCheckSlot;
	/*0x4465*/     UINT8        ClockPollCycle;
	/*0x4466*/     UINT16       NmiActive;
	/*0x4468*/     LONG32       DpcWatchdogPeriod;
	/*0x446C*/     LONG32       DpcWatchdogCount;
	/*0x4470*/     UINT64       TickOffset;
	/*0x4478*/     LONG32       KeSpinLockOrdering;
	/*0x447C*/     ULONG32      PrcbPad70;
	/*0x4480*/     struct _LIST_ENTRY WaitListHead;                                    // 2 elements, 0x10 bytes (sizeof)
	/*0x4490*/     UINT64       WaitLock;
	/*0x4498*/     ULONG32      ReadySummary;
	/*0x449C*/     ULONG32      QueueIndex;
	/*0x44A0*/     struct _KDPC TimerExpirationDpc;                                    // 9 elements, 0x40 bytes (sizeof)
	/*0x44E0*/     UINT64       PrcbPad72[4];
	/*0x4500*/     struct _LIST_ENTRY DispatcherReadyListHead[32];
	/*0x4700*/     ULONG32      InterruptCount;
	/*0x4704*/     ULONG32      KernelTime;
	/*0x4708*/     ULONG32      UserTime;
	/*0x470C*/     ULONG32      DpcTime;
	/*0x4710*/     ULONG32      InterruptTime;
	/*0x4714*/     ULONG32      AdjustDpcThreshold;
	/*0x4718*/     UINT8        DebuggerSavedIRQL;
	/*0x4719*/     UINT8        PrcbPad80[7];
	/*0x4720*/     ULONG32      DpcTimeCount;
	/*0x4724*/     ULONG32      DpcTimeLimit;
	/*0x4728*/     ULONG32      PeriodicCount;
	/*0x472C*/     ULONG32      PeriodicBias;
	/*0x4730*/     ULONG32      AvailableTime;
	/*0x4734*/     ULONG32      KeExceptionDispatchCount;
	/*0x4738*/     struct _KNODE* ParentNode;
	/*0x4740*/     UINT64       StartCycles;
	/*0x4748*/     UINT64       PrcbPad82[3];
	/*0x4760*/     LONG32       MmSpinLockOrdering;
	/*0x4764*/     ULONG32      PageColor;
	/*0x4768*/     ULONG32      NodeColor;
	/*0x476C*/     ULONG32      NodeShiftedColor;
	/*0x4770*/     ULONG32      SecondaryColorMask;
	/*0x4774*/     ULONG32      PrcbPad83;
	/*0x4778*/     UINT64       CycleTime;
	/*0x4780*/     ULONG32      CcFastMdlReadNoWait;
	/*0x4784*/     ULONG32      CcFastMdlReadWait;
	/*0x4788*/     ULONG32      CcFastMdlReadNotPossible;
	/*0x478C*/     ULONG32      CcMapDataNoWait;
	/*0x4790*/     ULONG32      CcMapDataWait;
	/*0x4794*/     ULONG32      CcPinMappedDataCount;
	/*0x4798*/     ULONG32      CcPinReadNoWait;
	/*0x479C*/     ULONG32      CcPinReadWait;
	/*0x47A0*/     ULONG32      CcMdlReadNoWait;
	/*0x47A4*/     ULONG32      CcMdlReadWait;
	/*0x47A8*/     ULONG32      CcLazyWriteHotSpots;
	/*0x47AC*/     ULONG32      CcLazyWriteIos;
	/*0x47B0*/     ULONG32      CcLazyWritePages;
	/*0x47B4*/     ULONG32      CcDataFlushes;
	/*0x47B8*/     ULONG32      CcDataPages;
	/*0x47BC*/     ULONG32      CcLostDelayedWrites;
	/*0x47C0*/     ULONG32      CcFastReadResourceMiss;
	/*0x47C4*/     ULONG32      CcCopyReadWaitMiss;
	/*0x47C8*/     ULONG32      CcFastMdlReadResourceMiss;
	/*0x47CC*/     ULONG32      CcMapDataNoWaitMiss;
	/*0x47D0*/     ULONG32      CcMapDataWaitMiss;
	/*0x47D4*/     ULONG32      CcPinReadNoWaitMiss;
	/*0x47D8*/     ULONG32      CcPinReadWaitMiss;
	/*0x47DC*/     ULONG32      CcMdlReadNoWaitMiss;
	/*0x47E0*/     ULONG32      CcMdlReadWaitMiss;
	/*0x47E4*/     ULONG32      CcReadAheadIos;
	/*0x47E8*/     LONG32       MmCacheTransitionCount;
	/*0x47EC*/     LONG32       MmCacheReadCount;
	/*0x47F0*/     LONG32       MmCacheIoCount;
	/*0x47F4*/     ULONG32      PrcbPad91[1];
	/*0x47F8*/     UINT64       RuntimeAccumulation;
	/*0x4800*/     struct _PROCESSOR_POWER_STATE PowerState;                           // 27 elements, 0x100 bytes (sizeof)
	/*0x4900*/     UINT8        PrcbPad92[16];
	/*0x4910*/     ULONG32      KeAlignmentFixupCount;
	/*0x4914*/     UINT8        _PADDING4_[0x4];
	/*0x4918*/     struct _KDPC DpcWatchdogDpc;                                        // 9 elements, 0x40 bytes (sizeof)
	/*0x4958*/     struct _KTIMER DpcWatchdogTimer;                                    // 6 elements, 0x40 bytes (sizeof)
	/*0x4998*/     struct _CACHE_DESCRIPTOR Cache[5];
	/*0x49D4*/     ULONG32      CacheCount;
	/*0x49D8*/     ULONG32      CachedCommit;
	/*0x49DC*/     ULONG32      CachedResidentAvailable;
	/*0x49E0*/     VOID* HyperPte;
	/*0x49E8*/     VOID* WheaInfo;
	/*0x49F0*/     VOID* EtwSupport;
	/*0x49F8*/     UINT8        _PADDING5_[0x8];
	/*0x4A00*/     union _SLIST_HEADER InterruptObjectPool;                            // 5 elements, 0x10 bytes (sizeof)
	/*0x4A10*/     union _SLIST_HEADER HypercallPageList;                              // 5 elements, 0x10 bytes (sizeof)
	/*0x4A20*/     VOID* HypercallPageVirtual;
	/*0x4A28*/     VOID* VirtualApicAssist;
	/*0x4A30*/     UINT64* StatisticsPage;
	/*0x4A38*/     VOID* RateControl;
	/*0x4A40*/     UINT64       CacheProcessorMask[5];
	/*0x4A68*/     struct _KAFFINITY_EX PackageProcessorSet;                           // 4 elements, 0x28 bytes (sizeof)
	/*0x4A90*/     UINT64       CoreProcessorSet;
	/*0x4A98*/     VOID* PebsIndexAddress;
	/*0x4AA0*/     UINT64       PrcbPad93[12];
	/*0x4B00*/     ULONG32      SpinLockAcquireCount;
	/*0x4B04*/     ULONG32      SpinLockContentionCount;
	/*0x4B08*/     ULONG32      SpinLockSpinCount;
	/*0x4B0C*/     ULONG32      IpiSendRequestBroadcastCount;
	/*0x4B10*/     ULONG32      IpiSendRequestRoutineCount;
	/*0x4B14*/     ULONG32      IpiSendSoftwareInterruptCount;
	/*0x4B18*/     ULONG32      ExInitializeResourceCount;
	/*0x4B1C*/     ULONG32      ExReInitializeResourceCount;
	/*0x4B20*/     ULONG32      ExDeleteResourceCount;
	/*0x4B24*/     ULONG32      ExecutiveResourceAcquiresCount;
	/*0x4B28*/     ULONG32      ExecutiveResourceContentionsCount;
	/*0x4B2C*/     ULONG32      ExecutiveResourceReleaseExclusiveCount;
	/*0x4B30*/     ULONG32      ExecutiveResourceReleaseSharedCount;
	/*0x4B34*/     ULONG32      ExecutiveResourceConvertsCount;
	/*0x4B38*/     ULONG32      ExAcqResExclusiveAttempts;
	/*0x4B3C*/     ULONG32      ExAcqResExclusiveAcquiresExclusive;
	/*0x4B40*/     ULONG32      ExAcqResExclusiveAcquiresExclusiveRecursive;
	/*0x4B44*/     ULONG32      ExAcqResExclusiveWaits;
	/*0x4B48*/     ULONG32      ExAcqResExclusiveNotAcquires;
	/*0x4B4C*/     ULONG32      ExAcqResSharedAttempts;
	/*0x4B50*/     ULONG32      ExAcqResSharedAcquiresExclusive;
	/*0x4B54*/     ULONG32      ExAcqResSharedAcquiresShared;
	/*0x4B58*/     ULONG32      ExAcqResSharedAcquiresSharedRecursive;
	/*0x4B5C*/     ULONG32      ExAcqResSharedWaits;
	/*0x4B60*/     ULONG32      ExAcqResSharedNotAcquires;
	/*0x4B64*/     ULONG32      ExAcqResSharedStarveExclusiveAttempts;
	/*0x4B68*/     ULONG32      ExAcqResSharedStarveExclusiveAcquiresExclusive;
	/*0x4B6C*/     ULONG32      ExAcqResSharedStarveExclusiveAcquiresShared;
	/*0x4B70*/     ULONG32      ExAcqResSharedStarveExclusiveAcquiresSharedRecursive;
	/*0x4B74*/     ULONG32      ExAcqResSharedStarveExclusiveWaits;
	/*0x4B78*/     ULONG32      ExAcqResSharedStarveExclusiveNotAcquires;
	/*0x4B7C*/     ULONG32      ExAcqResSharedWaitForExclusiveAttempts;
	/*0x4B80*/     ULONG32      ExAcqResSharedWaitForExclusiveAcquiresExclusive;
	/*0x4B84*/     ULONG32      ExAcqResSharedWaitForExclusiveAcquiresShared;
	/*0x4B88*/     ULONG32      ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive;
	/*0x4B8C*/     ULONG32      ExAcqResSharedWaitForExclusiveWaits;
	/*0x4B90*/     ULONG32      ExAcqResSharedWaitForExclusiveNotAcquires;
	/*0x4B94*/     ULONG32      ExSetResOwnerPointerExclusive;
	/*0x4B98*/     ULONG32      ExSetResOwnerPointerSharedNew;
	/*0x4B9C*/     ULONG32      ExSetResOwnerPointerSharedOld;
	/*0x4BA0*/     ULONG32      ExTryToAcqExclusiveAttempts;
	/*0x4BA4*/     ULONG32      ExTryToAcqExclusiveAcquires;
	/*0x4BA8*/     ULONG32      ExBoostExclusiveOwner;
	/*0x4BAC*/     ULONG32      ExBoostSharedOwners;
	/*0x4BB0*/     ULONG32      ExEtwSynchTrackingNotificationsCount;
	/*0x4BB4*/     ULONG32      ExEtwSynchTrackingNotificationsAccountedCount;
	/*0x4BB8*/     UINT8        VendorString[13];
	/*0x4BC5*/     UINT8        PrcbPad10[3];
	/*0x4BC8*/     ULONG32      FeatureBits;
	/*0x4BCC*/     UINT8        _PADDING6_[0x4];
	/*0x4BD0*/     union _LARGE_INTEGER UpdateSignature;                               // 4 elements, 0x8 bytes (sizeof)
	/*0x4BD8*/     struct _CONTEXT* Context;
	/*0x4BE0*/     ULONG32      ContextFlags;
	/*0x4BE4*/     UINT8        _PADDING7_[0x4];
	/*0x4BE8*/     struct _XSAVE_AREA* ExtendedState;
	/*0x4BF0*/     UINT8        _PADDING8_[0x10];
	/*0x4C00*/     struct _REQUEST_MAILBOX* Mailbox;
	/*0x4C08*/     UINT8        _PADDING9_[0x78];
	/*0x4C80*/     struct _REQUEST_MAILBOX RequestMailbox[1];
	/*0x4CC0*/     UINT8        _PADDING10_[0x40];
}KPRCB, * PKPRCB;

typedef struct _COUNTER_READING       // 4 elements, 0x18 bytes (sizeof)
{
	/*0x000*/     enum _HARDWARE_COUNTER_TYPE Type;
	/*0x004*/     ULONG32      Index;
	/*0x008*/     UINT64       Start;
	/*0x010*/     UINT64       Total;
}COUNTER_READING, * PCOUNTER_READING;

typedef struct _THREAD_PERFORMANCE_DATA       // 10 elements, 0x1C0 bytes (sizeof)
{
	/*0x000*/     UINT16       Size;
	/*0x002*/     UINT16       Version;
	/*0x004*/     struct _PROCESSOR_NUMBER ProcessorNumber; // 3 elements, 0x4 bytes (sizeof)
	/*0x008*/     ULONG32      ContextSwitches;
	/*0x00C*/     ULONG32      HwCountersCount;
	/*0x010*/     UINT64       UpdateCount;
	/*0x018*/     UINT64       WaitReasonBitMap;
	/*0x020*/     UINT64       HardwareCounters;
	/*0x028*/     struct _COUNTER_READING CycleTime;        // 4 elements, 0x18 bytes (sizeof)
	/*0x040*/     struct _COUNTER_READING HwCounters[16];
}THREAD_PERFORMANCE_DATA, * PTHREAD_PERFORMANCE_DATA;

typedef struct _KTHREAD_COUNTERS               // 7 elements, 0x1A8 bytes (sizeof)
{
	/*0x000*/     UINT64       WaitReasonBitMap;
	/*0x008*/     struct _THREAD_PERFORMANCE_DATA* UserData;
	/*0x010*/     ULONG32      Flags;
	/*0x014*/     ULONG32      ContextSwitches;
	/*0x018*/     UINT64       CycleTimeBias;
	/*0x020*/     UINT64       HardwareCounters;
	/*0x028*/     struct _COUNTER_READING HwCounter[16];
}KTHREAD_COUNTERS, * PKTHREAD_COUNTERS;
/*
typedef struct __XSAVE_FORMAT{
	WORD	 ControlWord;//     : Uint2B
	WORD	 StatusWord;// : Uint2B
	UCHAR	 TagWord;// : UChar
	UCHAR Reserved1; //: UChar
	WORD ErrorOpcode;// : Uint2B
	DWORD ErrorOffset;// : Uint4B
	WORD ErrorSelector;// : Uint2B
	WORD Reserved2;// : Uint2B
	DWORD DataOffset;// : Uint4B
	WORD DataSelector;// : Uint2B
	WORD	 Reserved3;// : Uint2B
	DWORD	MxCsr;// : Uint4B
	DWORD MxCsr_Mask;// : Uint4B
	M128A FloatRegisters[8];// : [8] _M128A
	M128A	 XmmRegisters[16];// _M128A
	UCHAR Reserved4[96];// UChar



}KXSAVE_FORMAT, *KPXSAVE_FORMAT;*/

typedef struct _TERMINATION_PORT    // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     struct _TERMINATION_PORT* Next;
	/*0x008*/     VOID* Port;
}TERMINATION_PORT, * PTERMINATION_PORT;

#ifndef _LIST_ENTRY64_S_
#define _LIST_ENTRY64_S_
typedef struct _LIST_ENTRY64_S // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     UINT64       Flink;
	/*0x008*/     UINT64       Blink;
}LIST_ENTRY64_S, * PLIST_ENTRY64_S;
#endif // !_LIST_ENTRY64_S_

#ifndef _PEB_LDR_DATA_
#define _PEB_LDR_DATA_
typedef struct _PEB_LDR_DATA                            // 9 elements, 0x58 bytes (sizeof)
{
	/*0x000*/     ULONG32      Length;
	/*0x004*/     UINT8        Initialized;
	/*0x005*/     UINT8        _PADDING0_[0x3];
	/*0x008*/     VOID* SsHandle;
	/*0x010*/     struct _LIST_ENTRY InLoadOrderModuleList;           // 2 elements, 0x10 bytes (sizeof)
	/*0x020*/     struct _LIST_ENTRY InMemoryOrderModuleList;         // 2 elements, 0x10 bytes (sizeof)
	/*0x030*/     struct _LIST_ENTRY InInitializationOrderModuleList; // 2 elements, 0x10 bytes (sizeof)
	/*0x040*/     VOID* EntryInProgress;
	/*0x048*/     UINT8        ShutdownInProgress;
	/*0x049*/     UINT8        _PADDING1_[0x7];
	/*0x050*/     VOID* ShutdownThreadId;
}PEB_LDR_DATA, * PPEB_LDR_DATA;
#endif // !_PEB_LDR_DATA_

typedef struct _RTL_AVL_TREE
{
	/* 0x0000 */ struct _RTL_BALANCED_NODE* Root;
} RTL_AVL_TREE, * PRTL_AVL_TREE; /* size: 0x0008 */

typedef union _PS_INTERLOCKED_TIMER_DELAY_VALUES
{
	union
	{
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned __int64 DelayMs : 30; /* bit position: 0 */
			/* 0x0000 */ unsigned __int64 CoalescingWindowMs : 30; /* bit position: 30 */
			/* 0x0000 */ unsigned __int64 Reserved : 1; /* bit position: 60 */
			/* 0x0000 */ unsigned __int64 NewTimerWheel : 1; /* bit position: 61 */
			/* 0x0000 */ unsigned __int64 Retry : 1; /* bit position: 62 */
			/* 0x0000 */ unsigned __int64 Locked : 1; /* bit position: 63 */
		}; /* bitfield */
		/* 0x0000 */ unsigned __int64 All;
	}; /* size: 0x0008 */
} PS_INTERLOCKED_TIMER_DELAY_VALUES, * PPS_INTERLOCKED_TIMER_DELAY_VALUES; /* size: 0x0008 */

typedef struct _PS_PROTECTION
{
	union
	{
		/* 0x0000 */ unsigned char Level;
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned char Type : 3; /* bit position: 0 */
			/* 0x0000 */ unsigned char Audit : 1; /* bit position: 3 */
			/* 0x0000 */ unsigned char Signer : 4; /* bit position: 4 */
		}; /* bitfield */
	}; /* size: 0x0001 */
} PS_PROTECTION, * PPS_PROTECTION; /* size: 0x0001 */

typedef struct _MMSUPPORT_INSTANCE
{
	/* 0x0000 */ unsigned long NextPageColor;
	/* 0x0004 */ unsigned long PageFaultCount;
	/* 0x0008 */ unsigned __int64 TrimmedPageCount;
	/* 0x0010 */ struct _MMWSL_INSTANCE* VmWorkingSetList;
	/* 0x0018 */ struct _LIST_ENTRY WorkingSetExpansionLinks;
	/* 0x0028 */ unsigned __int64 AgeDistribution[8];
	/* 0x0068 */ struct _KGATE* ExitOutswapGate;
	/* 0x0070 */ unsigned __int64 MinimumWorkingSetSize;
	/* 0x0078 */ unsigned __int64 WorkingSetLeafSize;
	/* 0x0080 */ unsigned __int64 WorkingSetLeafPrivateSize;
	/* 0x0088 */ unsigned __int64 WorkingSetSize;
	/* 0x0090 */ unsigned __int64 WorkingSetPrivateSize;
	/* 0x0098 */ unsigned __int64 MaximumWorkingSetSize;
	/* 0x00a0 */ unsigned __int64 PeakWorkingSetSize;
	/* 0x00a8 */ unsigned long HardFaultCount;
	/* 0x00ac */ unsigned short LastTrimStamp;
	/* 0x00ae */ unsigned short PartitionId;
	/* 0x00b0 */ unsigned __int64 SelfmapLock;
	/* 0x00b8 */ struct _MMSUPPORT_FLAGS Flags;
	/* 0x00bc */ long __PADDING__[1];
} MMSUPPORT_INSTANCE, * PMMSUPPORT_INSTANCE; /* size: 0x00c0 */

typedef struct _MMSUPPORT_SHARED
{
	/* 0x0000 */ volatile long WorkingSetLock;
	/* 0x0004 */ long GoodCitizenWaiting;
	/* 0x0008 */ unsigned __int64 ReleasedCommitDebt;
	/* 0x0010 */ unsigned __int64 ResetPagesRepurposedCount;
	/* 0x0018 */ void* WsSwapSupport;
	/* 0x0020 */ void* CommitReleaseContext;
	/* 0x0028 */ void* AccessLog;
	/* 0x0030 */ volatile unsigned __int64 ChargedWslePages;
	/* 0x0038 */ unsigned __int64 ActualWslePages;
	/* 0x0040 */ unsigned __int64 WorkingSetCoreLock;
	/* 0x0048 */ void* ShadowMapping;
	/* 0x0050 */ long __PADDING__[12];
} MMSUPPORT_SHARED, * PMMSUPPORT_SHARED; /* size: 0x0080 */

typedef struct _MMSUPPORT_FULL
{
	/* 0x0000 */ struct _MMSUPPORT_INSTANCE Instance;
	/* 0x00c0 */ struct _MMSUPPORT_SHARED Shared;
} MMSUPPORT_FULL, * PMMSUPPORT_FULL; /* size: 0x0140 */

typedef struct _JOBOBJECT_WAKE_FILTER
{
	/* 0x0000 */ unsigned long HighEdgeFilter;
	/* 0x0004 */ unsigned long LowEdgeFilter;
} JOBOBJECT_WAKE_FILTER, * PJOBOBJECT_WAKE_FILTER; /* size: 0x0008 */

typedef struct _PS_PROCESS_WAKE_INFORMATION
{
	/* 0x0000 */ unsigned __int64 NotificationChannel;
	/* 0x0008 */ unsigned long WakeCounters[7];
	/* 0x0024 */ struct _JOBOBJECT_WAKE_FILTER WakeFilter;
	/* 0x002c */ unsigned long NoWakeCounter;
} PS_PROCESS_WAKE_INFORMATION, * PPS_PROCESS_WAKE_INFORMATION; /* size: 0x0030 */

typedef struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES
{
	/* 0x0000 */ struct _RTL_AVL_TREE Tree;
	/* 0x0008 */ struct _EX_PUSH_LOCK Lock;
} PS_DYNAMIC_ENFORCED_ADDRESS_RANGES, * PPS_DYNAMIC_ENFORCED_ADDRESS_RANGES; /* size: 0x0010 */

#ifndef _PEB_
#define _PEB_
typedef struct _PEB
{
	/* 0x0000 */ unsigned char InheritedAddressSpace;
	/* 0x0001 */ unsigned char ReadImageFileExecOptions;
	/* 0x0002 */ unsigned char BeingDebugged;
	union
	{
		/* 0x0003 */ unsigned char BitField;
		struct /* bitfield */
		{
			/* 0x0003 */ unsigned char ImageUsesLargePages : 1; /* bit position: 0 */
			/* 0x0003 */ unsigned char IsProtectedProcess : 1; /* bit position: 1 */
			/* 0x0003 */ unsigned char IsImageDynamicallyRelocated : 1; /* bit position: 2 */
			/* 0x0003 */ unsigned char SkipPatchingUser32Forwarders : 1; /* bit position: 3 */
			/* 0x0003 */ unsigned char IsPackagedProcess : 1; /* bit position: 4 */
			/* 0x0003 */ unsigned char IsAppContainer : 1; /* bit position: 5 */
			/* 0x0003 */ unsigned char IsProtectedProcessLight : 1; /* bit position: 6 */
			/* 0x0003 */ unsigned char IsLongPathAwareProcess : 1; /* bit position: 7 */
		}; /* bitfield */
	}; /* size: 0x0001 */
	/* 0x0004 */ unsigned char Padding0[4];
	/* 0x0008 */ void* Mutant;
	/* 0x0010 */ void* ImageBaseAddress;
	/* 0x0018 */ struct _PEB_LDR_DATA* Ldr;
	/* 0x0020 */ struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;
	/* 0x0028 */ void* SubSystemData;
	/* 0x0030 */ void* ProcessHeap;
	/* 0x0038 */ struct _RTL_CRITICAL_SECTION* FastPebLock;
	/* 0x0040 */ union _SLIST_HEADER* volatile AtlThunkSListPtr;
	/* 0x0048 */ void* IFEOKey;
	union
	{
		/* 0x0050 */ unsigned long CrossProcessFlags;
		struct /* bitfield */
		{
			/* 0x0050 */ unsigned long ProcessInJob : 1; /* bit position: 0 */
			/* 0x0050 */ unsigned long ProcessInitializing : 1; /* bit position: 1 */
			/* 0x0050 */ unsigned long ProcessUsingVEH : 1; /* bit position: 2 */
			/* 0x0050 */ unsigned long ProcessUsingVCH : 1; /* bit position: 3 */
			/* 0x0050 */ unsigned long ProcessUsingFTH : 1; /* bit position: 4 */
			/* 0x0050 */ unsigned long ProcessPreviouslyThrottled : 1; /* bit position: 5 */
			/* 0x0050 */ unsigned long ProcessCurrentlyThrottled : 1; /* bit position: 6 */
			/* 0x0050 */ unsigned long ProcessImagesHotPatched : 1; /* bit position: 7 */
			/* 0x0050 */ unsigned long ReservedBits0 : 24; /* bit position: 8 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0054 */ unsigned char Padding1[4];
	union
	{
		/* 0x0058 */ void* KernelCallbackTable;
		/* 0x0058 */ void* UserSharedInfoPtr;
	}; /* size: 0x0008 */
	/* 0x0060 */ unsigned long SystemReserved;
	/* 0x0064 */ unsigned long AtlThunkSListPtr32;
	/* 0x0068 */ void* ApiSetMap;
	/* 0x0070 */ unsigned long TlsExpansionCounter;
	/* 0x0074 */ unsigned char Padding2[4];
	/* 0x0078 */ void* TlsBitmap;
	/* 0x0080 */ unsigned long TlsBitmapBits[2];
	/* 0x0088 */ void* ReadOnlySharedMemoryBase;
	/* 0x0090 */ void* SharedData;
	/* 0x0098 */ void** ReadOnlyStaticServerData;
	/* 0x00a0 */ void* AnsiCodePageData;
	/* 0x00a8 */ void* OemCodePageData;
	/* 0x00b0 */ void* UnicodeCaseTableData;
	/* 0x00b8 */ unsigned long NumberOfProcessors;
	/* 0x00bc */ unsigned long NtGlobalFlag;
	/* 0x00c0 */ union _LARGE_INTEGER CriticalSectionTimeout;
	/* 0x00c8 */ unsigned __int64 HeapSegmentReserve;
	/* 0x00d0 */ unsigned __int64 HeapSegmentCommit;
	/* 0x00d8 */ unsigned __int64 HeapDeCommitTotalFreeThreshold;
	/* 0x00e0 */ unsigned __int64 HeapDeCommitFreeBlockThreshold;
	/* 0x00e8 */ unsigned long NumberOfHeaps;
	/* 0x00ec */ unsigned long MaximumNumberOfHeaps;
	/* 0x00f0 */ void** ProcessHeaps;
	/* 0x00f8 */ void* GdiSharedHandleTable;
	/* 0x0100 */ void* ProcessStarterHelper;
	/* 0x0108 */ unsigned long GdiDCAttributeList;
	/* 0x010c */ unsigned char Padding3[4];
	/* 0x0110 */ struct _RTL_CRITICAL_SECTION* LoaderLock;
	/* 0x0118 */ unsigned long OSMajorVersion;
	/* 0x011c */ unsigned long OSMinorVersion;
	/* 0x0120 */ unsigned short OSBuildNumber;
	/* 0x0122 */ unsigned short OSCSDVersion;
	/* 0x0124 */ unsigned long OSPlatformId;
	/* 0x0128 */ unsigned long ImageSubsystem;
	/* 0x012c */ unsigned long ImageSubsystemMajorVersion;
	/* 0x0130 */ unsigned long ImageSubsystemMinorVersion;
	/* 0x0134 */ unsigned char Padding4[4];
	/* 0x0138 */ unsigned __int64 ActiveProcessAffinityMask;
	/* 0x0140 */ unsigned long GdiHandleBuffer[60];
	/* 0x0230 */ void* PostProcessInitRoutine /* function */;
	/* 0x0238 */ void* TlsExpansionBitmap;
	/* 0x0240 */ unsigned long TlsExpansionBitmapBits[32];
	/* 0x02c0 */ unsigned long SessionId;
	/* 0x02c4 */ unsigned char Padding5[4];
	/* 0x02c8 */ union _ULARGE_INTEGER AppCompatFlags;
	/* 0x02d0 */ union _ULARGE_INTEGER AppCompatFlagsUser;
	/* 0x02d8 */ void* pShimData;
	/* 0x02e0 */ void* AppCompatInfo;
	/* 0x02e8 */ struct _UNICODE_STRING CSDVersion;
	/* 0x02f8 */ const struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;
	/* 0x0300 */ struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;
	/* 0x0308 */ const struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;
	/* 0x0310 */ struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;
	/* 0x0318 */ unsigned __int64 MinimumStackCommit;
	/* 0x0320 */ void* SparePointers[4];
	/* 0x0340 */ unsigned long SpareUlongs[5];
	/* 0x0354 */ long Padding_1;
	/* 0x0358 */ void* WerRegistrationData;
	/* 0x0360 */ void* WerShipAssertPtr;
	/* 0x0368 */ void* pUnused;
	/* 0x0370 */ void* pImageHeaderHash;
	union
	{
		/* 0x0378 */ unsigned long TracingFlags;
		struct /* bitfield */
		{
			/* 0x0378 */ unsigned long HeapTracingEnabled : 1; /* bit position: 0 */
			/* 0x0378 */ unsigned long CritSecTracingEnabled : 1; /* bit position: 1 */
			/* 0x0378 */ unsigned long LibLoaderTracingEnabled : 1; /* bit position: 2 */
			/* 0x0378 */ unsigned long SpareTracingBits : 29; /* bit position: 3 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x037c */ unsigned char Padding6[4];
	/* 0x0380 */ unsigned __int64 CsrServerReadOnlySharedMemoryBase;
	/* 0x0388 */ unsigned __int64 TppWorkerpListLock;
	/* 0x0390 */ struct _LIST_ENTRY TppWorkerpList;
	/* 0x03a0 */ void* WaitOnAddressHashTable[128];
	/* 0x07a0 */ void* TelemetryCoverageHeader;
	/* 0x07a8 */ unsigned long CloudFileFlags;
	/* 0x07ac */ unsigned long CloudFileDiagFlags;
	/* 0x07b0 */ char PlaceholderCompatibilityMode;
	/* 0x07b1 */ char PlaceholderCompatibilityModeReserved[7];
	/* 0x07b8 */ struct _LEAP_SECOND_DATA* LeapSecondData;
	union
	{
		/* 0x07c0 */ unsigned long LeapSecondFlags;
		struct /* bitfield */
		{
			/* 0x07c0 */ unsigned long SixtySecondEnabled : 1; /* bit position: 0 */
			/* 0x07c0 */ unsigned long Reserved : 31; /* bit position: 1 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x07c4 */ unsigned long NtGlobalFlag2;
} PEB, * PPEB; /* size: 0x07c8 */
/*
+0x000 InheritedAddressSpace : UChar
+ 0x001 ReadImageFileExecOptions : UChar
+ 0x002 BeingDebugged : UChar
+ 0x003 BitField : UChar
+ 0x003 ImageUsesLargePages : Pos 0, 1 Bit
+ 0x003 IsProtectedProcess : Pos 1, 1 Bit
+ 0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit
+ 0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit
+ 0x003 IsPackagedProcess : Pos 4, 1 Bit
+ 0x003 IsAppContainer : Pos 5, 1 Bit
+ 0x003 IsProtectedProcessLight : Pos 6, 1 Bit
+ 0x003 IsLongPathAwareProcess : Pos 7, 1 Bit
+ 0x004 Padding0 : [4] UChar
+ 0x008 Mutant : Ptr64 Void
+ 0x010 ImageBaseAddress : Ptr64 Void
+ 0x018 Ldr : Ptr64 _PEB_LDR_DATA
+ 0x020 ProcessParameters : Ptr64 _RTL_USER_PROCESS_PARAMETERS
+ 0x028 SubSystemData : Ptr64 Void
+ 0x030 ProcessHeap : Ptr64 Void
+ 0x038 FastPebLock : Ptr64 _RTL_CRITICAL_SECTION
+ 0x040 AtlThunkSListPtr : Ptr64 _SLIST_HEADER
+ 0x048 IFEOKey : Ptr64 Void
+ 0x050 CrossProcessFlags : Uint4B
+ 0x050 ProcessInJob : Pos 0, 1 Bit
+ 0x050 ProcessInitializing : Pos 1, 1 Bit
+ 0x050 ProcessUsingVEH : Pos 2, 1 Bit
+ 0x050 ProcessUsingVCH : Pos 3, 1 Bit
+ 0x050 ProcessUsingFTH : Pos 4, 1 Bit
+ 0x050 ProcessPreviouslyThrottled : Pos 5, 1 Bit
+ 0x050 ProcessCurrentlyThrottled : Pos 6, 1 Bit
+ 0x050 ProcessImagesHotPatched : Pos 7, 1 Bit
+ 0x050 ReservedBits0 : Pos 8, 24 Bits
+ 0x054 Padding1 : [4] UChar
+ 0x058 KernelCallbackTable : Ptr64 Void
+ 0x058 UserSharedInfoPtr : Ptr64 Void
+ 0x060 SystemReserved : Uint4B
+ 0x064 AtlThunkSListPtr32 : Uint4B
+ 0x068 ApiSetMap : Ptr64 Void
+ 0x070 TlsExpansionCounter : Uint4B
+ 0x074 Padding2 : [4] UChar
+ 0x078 TlsBitmap : Ptr64 Void
+ 0x080 TlsBitmapBits : [2] Uint4B
+ 0x088 ReadOnlySharedMemoryBase : Ptr64 Void
+ 0x090 SharedData : Ptr64 Void
+ 0x098 ReadOnlyStaticServerData : Ptr64 Ptr64 Void
+ 0x0a0 AnsiCodePageData : Ptr64 Void
+ 0x0a8 OemCodePageData : Ptr64 Void
+ 0x0b0 UnicodeCaseTableData : Ptr64 Void
+ 0x0b8 NumberOfProcessors : Uint4B
+ 0x0bc NtGlobalFlag : Uint4B
+ 0x0c0 CriticalSectionTimeout : _LARGE_INTEGER
+ 0x0c8 HeapSegmentReserve : Uint8B
+ 0x0d0 HeapSegmentCommit : Uint8B
+ 0x0d8 HeapDeCommitTotalFreeThreshold : Uint8B
+ 0x0e0 HeapDeCommitFreeBlockThreshold : Uint8B
+ 0x0e8 NumberOfHeaps : Uint4B
+ 0x0ec MaximumNumberOfHeaps : Uint4B
+ 0x0f0 ProcessHeaps : Ptr64 Ptr64 Void
+ 0x0f8 GdiSharedHandleTable : Ptr64 Void
+ 0x100 ProcessStarterHelper : Ptr64 Void
+ 0x108 GdiDCAttributeList : Uint4B
+ 0x10c Padding3 : [4] UChar
+ 0x110 LoaderLock : Ptr64 _RTL_CRITICAL_SECTION
+ 0x118 OSMajorVersion : Uint4B
+ 0x11c OSMinorVersion : Uint4B
+ 0x120 OSBuildNumber : Uint2B
+ 0x122 OSCSDVersion : Uint2B
+ 0x124 OSPlatformId : Uint4B
+ 0x128 ImageSubsystem : Uint4B
+ 0x12c ImageSubsystemMajorVersion : Uint4B
+ 0x130 ImageSubsystemMinorVersion : Uint4B
+ 0x134 Padding4 : [4] UChar
+ 0x138 ActiveProcessAffinityMask : Uint8B
+ 0x140 GdiHandleBuffer : [60] Uint4B
+ 0x230 PostProcessInitRoutine : Ptr64     void
+ 0x238 TlsExpansionBitmap : Ptr64 Void
+ 0x240 TlsExpansionBitmapBits : [32] Uint4B
+ 0x2c0 SessionId : Uint4B
+ 0x2c4 Padding5 : [4] UChar
+ 0x2c8 AppCompatFlags : _ULARGE_INTEGER
+ 0x2d0 AppCompatFlagsUser : _ULARGE_INTEGER
+ 0x2d8 pShimData : Ptr64 Void
+ 0x2e0 AppCompatInfo : Ptr64 Void
+ 0x2e8 CSDVersion : _UNICODE_STRING
+ 0x2f8 ActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA
+ 0x300 ProcessAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP
+ 0x308 SystemDefaultActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA
+ 0x310 SystemAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP
+ 0x318 MinimumStackCommit : Uint8B
+ 0x320 SparePointers : [4] Ptr64 Void
+ 0x340 SpareUlongs : [5] Uint4B
+ 0x358 WerRegistrationData : Ptr64 Void
+ 0x360 WerShipAssertPtr : Ptr64 Void
+ 0x368 pUnused : Ptr64 Void
+ 0x370 pImageHeaderHash : Ptr64 Void
+ 0x378 TracingFlags : Uint4B
+ 0x378 HeapTracingEnabled : Pos 0, 1 Bit
+ 0x378 CritSecTracingEnabled : Pos 1, 1 Bit
+ 0x378 LibLoaderTracingEnabled : Pos 2, 1 Bit
+ 0x378 SpareTracingBits : Pos 3, 29 Bits
+ 0x37c Padding6 : [4] UChar
+ 0x380 CsrServerReadOnlySharedMemoryBase : Uint8B
+ 0x388 TppWorkerpListLock : Uint8B
+ 0x390 TppWorkerpList : _LIST_ENTRY
+ 0x3a0 WaitOnAddressHashTable : [128] Ptr64 Void
+ 0x7a0 TelemetryCoverageHeader : Ptr64 Void
+ 0x7a8 CloudFileFlags : Uint4B
+ 0x7ac CloudFileDiagFlags : Uint4B
+ 0x7b0 PlaceholderCompatibilityMode : Char
+ 0x7b1 PlaceholderCompatibilityModeReserved : [7] Char
+ 0x7b8 LeapSecondData : Ptr64 _LEAP_SECOND_DATA
+ 0x7c0 LeapSecondFlags : Uint4B
+ 0x7c0 SixtySecondEnabled : Pos 0, 1 Bit
+ 0x7c0 Reserved : Pos 1, 31 Bits
+ 0x7c4 NtGlobalFlag2 : Uint4B
*/
#endif

typedef struct _EPROCESS_S
{
	/* 0x0000 */ struct _KPROCESS Pcb;
	/* 0x0438 */ struct _EX_PUSH_LOCK ProcessLock;
	/* 0x0440 */ void* UniqueProcessId;
	/* 0x0448 */ struct _LIST_ENTRY ActiveProcessLinks;
	/* 0x0458 */ struct _EX_RUNDOWN_REF RundownProtect;
	union
	{
		/* 0x0460 */ unsigned long Flags2;
		struct /* bitfield */
		{
			/* 0x0460 */ unsigned long JobNotReallyActive : 1; /* bit position: 0 */
			/* 0x0460 */ unsigned long AccountingFolded : 1; /* bit position: 1 */
			/* 0x0460 */ unsigned long NewProcessReported : 1; /* bit position: 2 */
			/* 0x0460 */ unsigned long ExitProcessReported : 1; /* bit position: 3 */
			/* 0x0460 */ unsigned long ReportCommitChanges : 1; /* bit position: 4 */
			/* 0x0460 */ unsigned long LastReportMemory : 1; /* bit position: 5 */
			/* 0x0460 */ unsigned long ForceWakeCharge : 1; /* bit position: 6 */
			/* 0x0460 */ unsigned long CrossSessionCreate : 1; /* bit position: 7 */
			/* 0x0460 */ unsigned long NeedsHandleRundown : 1; /* bit position: 8 */
			/* 0x0460 */ unsigned long RefTraceEnabled : 1; /* bit position: 9 */
			/* 0x0460 */ unsigned long PicoCreated : 1; /* bit position: 10 */
			/* 0x0460 */ unsigned long EmptyJobEvaluated : 1; /* bit position: 11 */
			/* 0x0460 */ unsigned long DefaultPagePriority : 3; /* bit position: 12 */
			/* 0x0460 */ unsigned long PrimaryTokenFrozen : 1; /* bit position: 15 */
			/* 0x0460 */ unsigned long ProcessVerifierTarget : 1; /* bit position: 16 */
			/* 0x0460 */ unsigned long RestrictSetThreadContext : 1; /* bit position: 17 */
			/* 0x0460 */ unsigned long AffinityPermanent : 1; /* bit position: 18 */
			/* 0x0460 */ unsigned long AffinityUpdateEnable : 1; /* bit position: 19 */
			/* 0x0460 */ unsigned long PropagateNode : 1; /* bit position: 20 */
			/* 0x0460 */ unsigned long ExplicitAffinity : 1; /* bit position: 21 */
			/* 0x0460 */ unsigned long ProcessExecutionState : 2; /* bit position: 22 */
			/* 0x0460 */ unsigned long EnableReadVmLogging : 1; /* bit position: 24 */
			/* 0x0460 */ unsigned long EnableWriteVmLogging : 1; /* bit position: 25 */
			/* 0x0460 */ unsigned long FatalAccessTerminationRequested : 1; /* bit position: 26 */
			/* 0x0460 */ unsigned long DisableSystemAllowedCpuSet : 1; /* bit position: 27 */
			/* 0x0460 */ unsigned long ProcessStateChangeRequest : 2; /* bit position: 28 */
			/* 0x0460 */ unsigned long ProcessStateChangeInProgress : 1; /* bit position: 30 */
			/* 0x0460 */ unsigned long InPrivate : 1; /* bit position: 31 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	union
	{
		/* 0x0464 */ unsigned long Flags;
		struct /* bitfield */
		{
			/* 0x0464 */ unsigned long CreateReported : 1; /* bit position: 0 */
			/* 0x0464 */ unsigned long NoDebugInherit : 1; /* bit position: 1 */
			/* 0x0464 */ unsigned long ProcessExiting : 1; /* bit position: 2 */
			/* 0x0464 */ unsigned long ProcessDelete : 1; /* bit position: 3 */
			/* 0x0464 */ unsigned long ManageExecutableMemoryWrites : 1; /* bit position: 4 */
			/* 0x0464 */ unsigned long VmDeleted : 1; /* bit position: 5 */
			/* 0x0464 */ unsigned long OutswapEnabled : 1; /* bit position: 6 */
			/* 0x0464 */ unsigned long Outswapped : 1; /* bit position: 7 */
			/* 0x0464 */ unsigned long FailFastOnCommitFail : 1; /* bit position: 8 */
			/* 0x0464 */ unsigned long Wow64VaSpace4Gb : 1; /* bit position: 9 */
			/* 0x0464 */ unsigned long AddressSpaceInitialized : 2; /* bit position: 10 */
			/* 0x0464 */ unsigned long SetTimerResolution : 1; /* bit position: 12 */
			/* 0x0464 */ unsigned long BreakOnTermination : 1; /* bit position: 13 */
			/* 0x0464 */ unsigned long DeprioritizeViews : 1; /* bit position: 14 */
			/* 0x0464 */ unsigned long WriteWatch : 1; /* bit position: 15 */
			/* 0x0464 */ unsigned long ProcessInSession : 1; /* bit position: 16 */
			/* 0x0464 */ unsigned long OverrideAddressSpace : 1; /* bit position: 17 */
			/* 0x0464 */ unsigned long HasAddressSpace : 1; /* bit position: 18 */
			/* 0x0464 */ unsigned long LaunchPrefetched : 1; /* bit position: 19 */
			/* 0x0464 */ unsigned long Background : 1; /* bit position: 20 */
			/* 0x0464 */ unsigned long VmTopDown : 1; /* bit position: 21 */
			/* 0x0464 */ unsigned long ImageNotifyDone : 1; /* bit position: 22 */
			/* 0x0464 */ unsigned long PdeUpdateNeeded : 1; /* bit position: 23 */
			/* 0x0464 */ unsigned long VdmAllowed : 1; /* bit position: 24 */
			/* 0x0464 */ unsigned long ProcessRundown : 1; /* bit position: 25 */
			/* 0x0464 */ unsigned long ProcessInserted : 1; /* bit position: 26 */
			/* 0x0464 */ unsigned long DefaultIoPriority : 3; /* bit position: 27 */
			/* 0x0464 */ unsigned long ProcessSelfDelete : 1; /* bit position: 30 */
			/* 0x0464 */ unsigned long SetTimerResolutionLink : 1; /* bit position: 31 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0468 */ union _LARGE_INTEGER CreateTime;
	/* 0x0470 */ unsigned __int64 ProcessQuotaUsage[2];
	/* 0x0480 */ unsigned __int64 ProcessQuotaPeak[2];
	/* 0x0490 */ unsigned __int64 PeakVirtualSize;
	/* 0x0498 */ unsigned __int64 VirtualSize;
	/* 0x04a0 */ struct _LIST_ENTRY SessionProcessLinks;
	union
	{
		/* 0x04b0 */ void* ExceptionPortData;
		/* 0x04b0 */ unsigned __int64 ExceptionPortValue;
		/* 0x04b0 */ unsigned __int64 ExceptionPortState : 3; /* bit position: 0 */
	}; /* size: 0x0008 */
	/* 0x04b8 */ struct _EX_FAST_REF Token;
	/* 0x04c0 */ unsigned __int64 MmReserved;
	/* 0x04c8 */ struct _EX_PUSH_LOCK AddressCreationLock;
	/* 0x04d0 */ struct _EX_PUSH_LOCK PageTableCommitmentLock;
	/* 0x04d8 */ struct _ETHREAD* RotateInProgress;
	/* 0x04e0 */ struct _ETHREAD* ForkInProgress;
	/* 0x04e8 */ struct _EJOB* volatile CommitChargeJob;
	/* 0x04f0 */ struct _RTL_AVL_TREE CloneRoot;
	/* 0x04f8 */ volatile unsigned __int64 NumberOfPrivatePages;
	/* 0x0500 */ volatile unsigned __int64 NumberOfLockedPages;
	/* 0x0508 */ void* Win32Process;
	/* 0x0510 */ struct _EJOB* volatile Job;
	/* 0x0518 */ void* SectionObject;
	/* 0x0520 */ void* SectionBaseAddress;
	/* 0x0528 */ unsigned long Cookie;
	/* 0x052c */ long Padding_1;
	/* 0x0530 */ struct _PAGEFAULT_HISTORY* WorkingSetWatch;
	/* 0x0538 */ void* Win32WindowStation;
	/* 0x0540 */ void* InheritedFromUniqueProcessId;
	/* 0x0548 */ volatile unsigned __int64 OwnerProcessId;
	/* 0x0550 */ struct _PEB* Peb;
	/* 0x0558 */ struct _MM_SESSION_SPACE* Session;
	/* 0x0560 */ void* Spare1;
	/* 0x0568 */ struct _EPROCESS_QUOTA_BLOCK* QuotaBlock;
	/* 0x0570 */ struct _HANDLE_TABLE* ObjectTable;
	/* 0x0578 */ void* DebugPort;
	/* 0x0580 */ struct _EWOW64PROCESS* WoW64Process;
	/* 0x0588 */ void* DeviceMap;
	/* 0x0590 */ void* EtwDataSource;
	/* 0x0598 */ unsigned __int64 PageDirectoryPte;
	/* 0x05a0 */ struct _FILE_OBJECT* ImageFilePointer;
	/* 0x05a8 */ unsigned char ImageFileName[15];
	/* 0x05b7 */ unsigned char PriorityClass;
	/* 0x05b8 */ void* SecurityPort;
	/* 0x05c0 */ struct _SE_AUDIT_PROCESS_CREATION_INFO SeAuditProcessCreationInfo;
	/* 0x05c8 */ struct _LIST_ENTRY JobLinks;
	/* 0x05d8 */ void* HighestUserAddress;
	/* 0x05e0 */ struct _LIST_ENTRY ThreadListHead;
	/* 0x05f0 */ volatile unsigned long ActiveThreads;
	/* 0x05f4 */ unsigned long ImagePathHash;
	/* 0x05f8 */ unsigned long DefaultHardErrorProcessing;
	/* 0x05fc */ long LastThreadExitStatus;
	/* 0x0600 */ struct _EX_FAST_REF PrefetchTrace;
	/* 0x0608 */ void* LockedPagesList;
	/* 0x0610 */ union _LARGE_INTEGER ReadOperationCount;
	/* 0x0618 */ union _LARGE_INTEGER WriteOperationCount;
	/* 0x0620 */ union _LARGE_INTEGER OtherOperationCount;
	/* 0x0628 */ union _LARGE_INTEGER ReadTransferCount;
	/* 0x0630 */ union _LARGE_INTEGER WriteTransferCount;
	/* 0x0638 */ union _LARGE_INTEGER OtherTransferCount;
	/* 0x0640 */ unsigned __int64 CommitChargeLimit;
	/* 0x0648 */ volatile unsigned __int64 CommitCharge;
	/* 0x0650 */ volatile unsigned __int64 CommitChargePeak;
	/* 0x0658 */ long Padding_2[10];
	/* 0x0680 */ struct _MMSUPPORT_FULL Vm;
	/* 0x07c0 */ struct _LIST_ENTRY MmProcessLinks;
	/* 0x07d0 */ unsigned long ModifiedPageCount;
	/* 0x07d4 */ long ExitStatus;
	/* 0x07d8 */ struct _RTL_AVL_TREE VadRoot;
	/* 0x07e0 */ void* VadHint;
	/* 0x07e8 */ unsigned __int64 VadCount;
	/* 0x07f0 */ volatile unsigned __int64 VadPhysicalPages;
	/* 0x07f8 */ unsigned __int64 VadPhysicalPagesLimit;
	/* 0x0800 */ struct _ALPC_PROCESS_CONTEXT AlpcContext;
	/* 0x0820 */ struct _LIST_ENTRY TimerResolutionLink;
	/* 0x0830 */ struct _PO_DIAG_STACK_RECORD* TimerResolutionStackRecord;
	/* 0x0838 */ unsigned long RequestedTimerResolution;
	/* 0x083c */ unsigned long SmallestTimerResolution;
	/* 0x0840 */ union _LARGE_INTEGER ExitTime;
	/* 0x0848 */ struct _INVERTED_FUNCTION_TABLE* InvertedFunctionTable;
	/* 0x0850 */ struct _EX_PUSH_LOCK InvertedFunctionTableLock;
	/* 0x0858 */ unsigned long ActiveThreadsHighWatermark;
	/* 0x085c */ unsigned long LargePrivateVadCount;
	/* 0x0860 */ struct _EX_PUSH_LOCK ThreadListLock;
	/* 0x0868 */ void* WnfContext;
	/* 0x0870 */ struct _EJOB* ServerSilo;
	/* 0x0878 */ unsigned char SignatureLevel;
	/* 0x0879 */ unsigned char SectionSignatureLevel;
	/* 0x087a */ struct _PS_PROTECTION Protection;
	struct /* bitfield */
	{
		/* 0x087b */ unsigned char HangCount : 3; /* bit position: 0 */
		/* 0x087b */ unsigned char GhostCount : 3; /* bit position: 3 */
		/* 0x087b */ unsigned char PrefilterException : 1; /* bit position: 6 */
	}; /* bitfield */
	union
	{
		/* 0x087c */ unsigned long Flags3;
		struct /* bitfield */
		{
			/* 0x087c */ unsigned long Minimal : 1; /* bit position: 0 */
			/* 0x087c */ unsigned long ReplacingPageRoot : 1; /* bit position: 1 */
			/* 0x087c */ unsigned long Crashed : 1; /* bit position: 2 */
			/* 0x087c */ unsigned long JobVadsAreTracked : 1; /* bit position: 3 */
			/* 0x087c */ unsigned long VadTrackingDisabled : 1; /* bit position: 4 */
			/* 0x087c */ unsigned long AuxiliaryProcess : 1; /* bit position: 5 */
			/* 0x087c */ unsigned long SubsystemProcess : 1; /* bit position: 6 */
			/* 0x087c */ unsigned long IndirectCpuSets : 1; /* bit position: 7 */
			/* 0x087c */ unsigned long RelinquishedCommit : 1; /* bit position: 8 */
			/* 0x087c */ unsigned long HighGraphicsPriority : 1; /* bit position: 9 */
			/* 0x087c */ unsigned long CommitFailLogged : 1; /* bit position: 10 */
			/* 0x087c */ unsigned long ReserveFailLogged : 1; /* bit position: 11 */
			/* 0x087c */ unsigned long SystemProcess : 1; /* bit position: 12 */
			/* 0x087c */ unsigned long HideImageBaseAddresses : 1; /* bit position: 13 */
			/* 0x087c */ unsigned long AddressPolicyFrozen : 1; /* bit position: 14 */
			/* 0x087c */ unsigned long ProcessFirstResume : 1; /* bit position: 15 */
			/* 0x087c */ unsigned long ForegroundExternal : 1; /* bit position: 16 */
			/* 0x087c */ unsigned long ForegroundSystem : 1; /* bit position: 17 */
			/* 0x087c */ unsigned long HighMemoryPriority : 1; /* bit position: 18 */
			/* 0x087c */ unsigned long EnableProcessSuspendResumeLogging : 1; /* bit position: 19 */
			/* 0x087c */ unsigned long EnableThreadSuspendResumeLogging : 1; /* bit position: 20 */
			/* 0x087c */ unsigned long SecurityDomainChanged : 1; /* bit position: 21 */
			/* 0x087c */ unsigned long SecurityFreezeComplete : 1; /* bit position: 22 */
			/* 0x087c */ unsigned long VmProcessorHost : 1; /* bit position: 23 */
			/* 0x087c */ unsigned long VmProcessorHostTransition : 1; /* bit position: 24 */
			/* 0x087c */ unsigned long AltSyscall : 1; /* bit position: 25 */
			/* 0x087c */ unsigned long TimerResolutionIgnore : 1; /* bit position: 26 */
			/* 0x087c */ unsigned long DisallowUserTerminate : 1; /* bit position: 27 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0880 */ long DeviceAsid;
	/* 0x0884 */ long Padding_3;
	/* 0x0888 */ void* SvmData;
	/* 0x0890 */ struct _EX_PUSH_LOCK SvmProcessLock;
	/* 0x0898 */ unsigned __int64 SvmLock;
	/* 0x08a0 */ struct _LIST_ENTRY SvmProcessDeviceListHead;
	/* 0x08b0 */ unsigned __int64 LastFreezeInterruptTime;
	/* 0x08b8 */ struct _PROCESS_DISK_COUNTERS* DiskCounters;
	/* 0x08c0 */ void* PicoContext;
	/* 0x08c8 */ void* EnclaveTable;
	/* 0x08d0 */ unsigned __int64 EnclaveNumber;
	/* 0x08d8 */ struct _EX_PUSH_LOCK EnclaveLock;
	/* 0x08e0 */ unsigned long HighPriorityFaultsAllowed;
	/* 0x08e4 */ long Padding_4;
	/* 0x08e8 */ struct _PO_PROCESS_ENERGY_CONTEXT* EnergyContext;
	/* 0x08f0 */ void* VmContext;
	/* 0x08f8 */ unsigned __int64 SequenceNumber;
	/* 0x0900 */ unsigned __int64 CreateInterruptTime;
	/* 0x0908 */ unsigned __int64 CreateUnbiasedInterruptTime;
	/* 0x0910 */ unsigned __int64 TotalUnbiasedFrozenTime;
	/* 0x0918 */ unsigned __int64 LastAppStateUpdateTime;
	struct /* bitfield */
	{
		/* 0x0920 */ unsigned __int64 LastAppStateUptime : 61; /* bit position: 0 */
		/* 0x0920 */ unsigned __int64 LastAppState : 3; /* bit position: 61 */
	}; /* bitfield */
	/* 0x0928 */ volatile unsigned __int64 SharedCommitCharge;
	/* 0x0930 */ struct _EX_PUSH_LOCK SharedCommitLock;
	/* 0x0938 */ struct _LIST_ENTRY SharedCommitLinks;
	union
	{
		struct
		{
			/* 0x0948 */ unsigned __int64 AllowedCpuSets;
			/* 0x0950 */ unsigned __int64 DefaultCpuSets;
		}; /* size: 0x0010 */
		struct
		{
			/* 0x0948 */ unsigned __int64* AllowedCpuSetsIndirect;
			/* 0x0950 */ unsigned __int64* DefaultCpuSetsIndirect;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0958 */ void* DiskIoAttribution;
	/* 0x0960 */ void* DxgProcess;
	/* 0x0968 */ unsigned long Win32KFilterSet;
	/* 0x096c */ long Padding_5;
	/* 0x0970 */ volatile union _PS_INTERLOCKED_TIMER_DELAY_VALUES ProcessTimerDelay;
	/* 0x0978 */ volatile unsigned long KTimerSets;
	/* 0x097c */ volatile unsigned long KTimer2Sets;
	/* 0x0980 */ volatile unsigned long ThreadTimerSets;
	/* 0x0984 */ long Padding_6;
	/* 0x0988 */ unsigned __int64 VirtualTimerListLock;
	/* 0x0990 */ struct _LIST_ENTRY VirtualTimerListHead;
	union
	{
		/* 0x09a0 */ struct _WNF_STATE_NAME WakeChannel;
		/* 0x09a0 */ struct _PS_PROCESS_WAKE_INFORMATION WakeInfo;
	}; /* size: 0x0030 */
	union
	{
		/* 0x09d0 */ unsigned long MitigationFlags;
		struct
		{
			struct /* bitfield */
			{
				/* 0x09d0 */ unsigned long ControlFlowGuardEnabled : 1; /* bit position: 0 */
				/* 0x09d0 */ unsigned long ControlFlowGuardExportSuppressionEnabled : 1; /* bit position: 1 */
				/* 0x09d0 */ unsigned long ControlFlowGuardStrict : 1; /* bit position: 2 */
				/* 0x09d0 */ unsigned long DisallowStrippedImages : 1; /* bit position: 3 */
				/* 0x09d0 */ unsigned long ForceRelocateImages : 1; /* bit position: 4 */
				/* 0x09d0 */ unsigned long HighEntropyASLREnabled : 1; /* bit position: 5 */
				/* 0x09d0 */ unsigned long StackRandomizationDisabled : 1; /* bit position: 6 */
				/* 0x09d0 */ unsigned long ExtensionPointDisable : 1; /* bit position: 7 */
				/* 0x09d0 */ unsigned long DisableDynamicCode : 1; /* bit position: 8 */
				/* 0x09d0 */ unsigned long DisableDynamicCodeAllowOptOut : 1; /* bit position: 9 */
				/* 0x09d0 */ unsigned long DisableDynamicCodeAllowRemoteDowngrade : 1; /* bit position: 10 */
				/* 0x09d0 */ unsigned long AuditDisableDynamicCode : 1; /* bit position: 11 */
				/* 0x09d0 */ unsigned long DisallowWin32kSystemCalls : 1; /* bit position: 12 */
				/* 0x09d0 */ unsigned long AuditDisallowWin32kSystemCalls : 1; /* bit position: 13 */
				/* 0x09d0 */ unsigned long EnableFilteredWin32kAPIs : 1; /* bit position: 14 */
				/* 0x09d0 */ unsigned long AuditFilteredWin32kAPIs : 1; /* bit position: 15 */
				/* 0x09d0 */ unsigned long DisableNonSystemFonts : 1; /* bit position: 16 */
				/* 0x09d0 */ unsigned long AuditNonSystemFontLoading : 1; /* bit position: 17 */
				/* 0x09d0 */ unsigned long PreferSystem32Images : 1; /* bit position: 18 */
				/* 0x09d0 */ unsigned long ProhibitRemoteImageMap : 1; /* bit position: 19 */
				/* 0x09d0 */ unsigned long AuditProhibitRemoteImageMap : 1; /* bit position: 20 */
				/* 0x09d0 */ unsigned long ProhibitLowILImageMap : 1; /* bit position: 21 */
				/* 0x09d0 */ unsigned long AuditProhibitLowILImageMap : 1; /* bit position: 22 */
				/* 0x09d0 */ unsigned long SignatureMitigationOptIn : 1; /* bit position: 23 */
				/* 0x09d0 */ unsigned long AuditBlockNonMicrosoftBinaries : 1; /* bit position: 24 */
				/* 0x09d0 */ unsigned long AuditBlockNonMicrosoftBinariesAllowStore : 1; /* bit position: 25 */
				/* 0x09d0 */ unsigned long LoaderIntegrityContinuityEnabled : 1; /* bit position: 26 */
				/* 0x09d0 */ unsigned long AuditLoaderIntegrityContinuity : 1; /* bit position: 27 */
				/* 0x09d0 */ unsigned long EnableModuleTamperingProtection : 1; /* bit position: 28 */
				/* 0x09d0 */ unsigned long EnableModuleTamperingProtectionNoInherit : 1; /* bit position: 29 */
				/* 0x09d0 */ unsigned long RestrictIndirectBranchPrediction : 1; /* bit position: 30 */
				/* 0x09d0 */ unsigned long IsolateSecurityDomain : 1; /* bit position: 31 */
			}; /* bitfield */
		} /* size: 0x0004 */ MitigationFlagsValues;
	}; /* size: 0x0004 */
	union
	{
		/* 0x09d4 */ unsigned long MitigationFlags2;
		struct
		{
			struct /* bitfield */
			{
				/* 0x09d4 */ unsigned long EnableExportAddressFilter : 1; /* bit position: 0 */
				/* 0x09d4 */ unsigned long AuditExportAddressFilter : 1; /* bit position: 1 */
				/* 0x09d4 */ unsigned long EnableExportAddressFilterPlus : 1; /* bit position: 2 */
				/* 0x09d4 */ unsigned long AuditExportAddressFilterPlus : 1; /* bit position: 3 */
				/* 0x09d4 */ unsigned long EnableRopStackPivot : 1; /* bit position: 4 */
				/* 0x09d4 */ unsigned long AuditRopStackPivot : 1; /* bit position: 5 */
				/* 0x09d4 */ unsigned long EnableRopCallerCheck : 1; /* bit position: 6 */
				/* 0x09d4 */ unsigned long AuditRopCallerCheck : 1; /* bit position: 7 */
				/* 0x09d4 */ unsigned long EnableRopSimExec : 1; /* bit position: 8 */
				/* 0x09d4 */ unsigned long AuditRopSimExec : 1; /* bit position: 9 */
				/* 0x09d4 */ unsigned long EnableImportAddressFilter : 1; /* bit position: 10 */
				/* 0x09d4 */ unsigned long AuditImportAddressFilter : 1; /* bit position: 11 */
				/* 0x09d4 */ unsigned long DisablePageCombine : 1; /* bit position: 12 */
				/* 0x09d4 */ unsigned long SpeculativeStoreBypassDisable : 1; /* bit position: 13 */
				/* 0x09d4 */ unsigned long CetUserShadowStacks : 1; /* bit position: 14 */
				/* 0x09d4 */ unsigned long AuditCetUserShadowStacks : 1; /* bit position: 15 */
				/* 0x09d4 */ unsigned long AuditCetUserShadowStacksLogged : 1; /* bit position: 16 */
				/* 0x09d4 */ unsigned long UserCetSetContextIpValidation : 1; /* bit position: 17 */
				/* 0x09d4 */ unsigned long AuditUserCetSetContextIpValidation : 1; /* bit position: 18 */
				/* 0x09d4 */ unsigned long AuditUserCetSetContextIpValidationLogged : 1; /* bit position: 19 */
				/* 0x09d4 */ unsigned long CetUserShadowStacksStrictMode : 1; /* bit position: 20 */
				/* 0x09d4 */ unsigned long BlockNonCetBinaries : 1; /* bit position: 21 */
				/* 0x09d4 */ unsigned long BlockNonCetBinariesNonEhcont : 1; /* bit position: 22 */
				/* 0x09d4 */ unsigned long AuditBlockNonCetBinaries : 1; /* bit position: 23 */
				/* 0x09d4 */ unsigned long AuditBlockNonCetBinariesLogged : 1; /* bit position: 24 */
				/* 0x09d4 */ unsigned long Reserved1 : 1; /* bit position: 25 */
				/* 0x09d4 */ unsigned long Reserved2 : 1; /* bit position: 26 */
				/* 0x09d4 */ unsigned long Reserved3 : 1; /* bit position: 27 */
				/* 0x09d4 */ unsigned long Reserved4 : 1; /* bit position: 28 */
				/* 0x09d4 */ unsigned long Reserved5 : 1; /* bit position: 29 */
				/* 0x09d4 */ unsigned long CetDynamicApisOutOfProcOnly : 1; /* bit position: 30 */
				/* 0x09d4 */ unsigned long UserCetSetContextIpValidationRelaxedMode : 1; /* bit position: 31 */
			}; /* bitfield */
		} /* size: 0x0004 */ MitigationFlags2Values;
	}; /* size: 0x0004 */
	/* 0x09d8 */ void* PartitionObject;
	/* 0x09e0 */ unsigned __int64 SecurityDomain;
	/* 0x09e8 */ unsigned __int64 ParentSecurityDomain;
	/* 0x09f0 */ void* CoverageSamplerContext;
	/* 0x09f8 */ void* MmHotPatchContext;
	/* 0x0a00 */ struct _RTL_AVL_TREE DynamicEHContinuationTargetsTree;
	/* 0x0a08 */ struct _EX_PUSH_LOCK DynamicEHContinuationTargetsLock;
	/* 0x0a10 */ struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES DynamicEnforcedCetCompatibleRanges;
	/* 0x0a20 */ unsigned long DisabledComponentFlags;
	/* 0x0a24 */ long __PADDING__[7];
} EPROCESS_S, * PEPROCESS_S; /* size: 0x0a40 */

typedef struct _EPROCESS_test
{
	/* 0x0000 */ struct _KPROCESS Pcb;
	/* 0x0438 */ struct _EX_PUSH_LOCK ProcessLock;
	/* 0x0440 */ void* UniqueProcessId;
	/* 0x0448 */ struct _LIST_ENTRY ActiveProcessLinks;
	/* 0x0458 */ struct _EX_RUNDOWN_REF RundownProtect;
}EPROCESS_test, * PEPROCESS_test;


#ifndef _LDR_DATA_TABLE_ENTRY_
#define _LDR_DATA_TABLE_ENTRY_
typedef struct _LDR_DATA_TABLE_ENTRY                         // 24 elements, 0xE0 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY InLoadOrderLinks;                     // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _LIST_ENTRY InMemoryOrderLinks;                   // 2 elements, 0x10 bytes (sizeof)
	/*0x020*/     struct _LIST_ENTRY InInitializationOrderLinks;           // 2 elements, 0x10 bytes (sizeof)
	/*0x030*/     VOID* DllBase;
	/*0x038*/     VOID* EntryPoint;
	/*0x040*/     ULONG32      SizeOfImage;
	/*0x044*/     UINT8        _PADDING0_[0x4];
	/*0x048*/     struct _UNICODE_STRING FullDllName;                      // 3 elements, 0x10 bytes (sizeof)
	/*0x058*/     struct _UNICODE_STRING BaseDllName;                      // 3 elements, 0x10 bytes (sizeof)
	/*0x068*/     ULONG32      Flags;
	/*0x06C*/     UINT16       LoadCount;
	/*0x06E*/     UINT16       TlsIndex;
	union                                                    // 2 elements, 0x10 bytes (sizeof)
	{
		/*0x070*/         struct _LIST_ENTRY HashLinks;                        // 2 elements, 0x10 bytes (sizeof)
		struct                                               // 2 elements, 0x10 bytes (sizeof)
		{
			/*0x070*/             VOID* SectionPointer;
			/*0x078*/             ULONG32      CheckSum;
			/*0x07C*/             UINT8        _PADDING1_[0x4];
		};
	};
	union                                                    // 2 elements, 0x8 bytes (sizeof)
	{
		/*0x080*/         ULONG32      TimeDateStamp;
		/*0x080*/         VOID* LoadedImports;
	};
	/*0x088*/     ULONG64 EntryPointActivationContext;
	/*0x090*/     VOID* PatchInformation;
	/*0x098*/     struct _LIST_ENTRY ForwarderLinks;                       // 2 elements, 0x10 bytes (sizeof)
	/*0x0A8*/     struct _LIST_ENTRY ServiceTagLinks;                      // 2 elements, 0x10 bytes (sizeof)
	/*0x0B8*/     struct _LIST_ENTRY StaticLinks;                          // 2 elements, 0x10 bytes (sizeof)
	/*0x0C8*/     VOID* ContextInformation;
	/*0x0D0*/     UINT64       OriginalBase;
	/*0x0D8*/     union _LARGE_INTEGER LoadTime;                           // 4 elements, 0x8 bytes (sizeof)
}LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;
#endif _LDR_DATA_TABLE_ENTRY_

typedef struct _CLIENT_ID64     // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     UINT64       UniqueProcess;
	/*0x008*/     UINT64       UniqueThread;
}CLIENT_ID64, * PCLIENT_ID64;

typedef struct _GDI_TEB_BATCH64   // 3 elements, 0x4E8 bytes (sizeof)
{
	/*0x000*/     ULONG32      Offset;
	/*0x004*/     UINT8        _PADDING0_[0x4];
	/*0x008*/     UINT64       HDC;
	/*0x010*/     ULONG32      Buffer[310];
}GDI_TEB_BATCH64, * PGDI_TEB_BATCH64;

typedef struct _ACTIVATION_CONTEXT_STACK64
{
	/* 0x0000 */ unsigned __int64 ActiveFrame;
	/* 0x0008 */ struct LIST_ENTRY64 FrameListCache;
	/* 0x0018 */ unsigned long Flags;
	/* 0x001c */ unsigned long NextCookieSequenceNumber;
	/* 0x0020 */ unsigned long StackId;
	/* 0x0024 */ long __PADDING__[1];
} ACTIVATION_CONTEXT_STACK64, * PACTIVATION_CONTEXT_STACK64; /* size: 0x0028 */

typedef struct _TEB64
{
	/* 0x0000 */ struct _NT_TIB64 NtTib;
	/* 0x0038 */ unsigned __int64 EnvironmentPointer;
	/* 0x0040 */ struct _CLIENT_ID64 ClientId;
	/* 0x0050 */ unsigned __int64 ActiveRpcHandle;
	/* 0x0058 */ unsigned __int64 ThreadLocalStoragePointer;
	/* 0x0060 */ unsigned __int64 ProcessEnvironmentBlock;
	/* 0x0068 */ unsigned long LastErrorValue;
	/* 0x006c */ unsigned long CountOfOwnedCriticalSections;
	/* 0x0070 */ unsigned __int64 CsrClientThread;
	/* 0x0078 */ unsigned __int64 Win32ThreadInfo;
	/* 0x0080 */ unsigned long User32Reserved[26];
	/* 0x00e8 */ unsigned long UserReserved[5];
	/* 0x00fc */ long Padding_2;
	/* 0x0100 */ unsigned __int64 WOW32Reserved;
	/* 0x0108 */ unsigned long CurrentLocale;
	/* 0x010c */ unsigned long FpSoftwareStatusRegister;
	/* 0x0110 */ unsigned __int64 ReservedForDebuggerInstrumentation[16];
	/* 0x0190 */ unsigned __int64 SystemReserved1[30];
	/* 0x0280 */ char PlaceholderCompatibilityMode;
	/* 0x0281 */ unsigned char PlaceholderHydrationAlwaysExplicit;
	/* 0x0282 */ char PlaceholderReserved[10];
	/* 0x028c */ unsigned long ProxiedProcessId;
	/* 0x0290 */ struct _ACTIVATION_CONTEXT_STACK64 _ActivationStack;
	/* 0x02b8 */ unsigned char WorkingOnBehalfTicket[8];
	/* 0x02c0 */ long ExceptionCode;
	/* 0x02c4 */ unsigned char Padding0[4];
	/* 0x02c8 */ unsigned __int64 ActivationContextStackPointer;
	/* 0x02d0 */ unsigned __int64 InstrumentationCallbackSp;
	/* 0x02d8 */ unsigned __int64 InstrumentationCallbackPreviousPc;
	/* 0x02e0 */ unsigned __int64 InstrumentationCallbackPreviousSp;
	/* 0x02e8 */ unsigned long TxFsContext;
	/* 0x02ec */ unsigned char InstrumentationCallbackDisabled;
	/* 0x02ed */ unsigned char UnalignedLoadStoreExceptions;
	/* 0x02ee */ unsigned char Padding1[2];
	/* 0x02f0 */ struct _GDI_TEB_BATCH64 GdiTebBatch;
	/* 0x07d8 */ struct _CLIENT_ID64 RealClientId;
	/* 0x07e8 */ unsigned __int64 GdiCachedProcessHandle;
	/* 0x07f0 */ unsigned long GdiClientPID;
	/* 0x07f4 */ unsigned long GdiClientTID;
	/* 0x07f8 */ unsigned __int64 GdiThreadLocalInfo;
	/* 0x0800 */ unsigned __int64 Win32ClientInfo[62];
	/* 0x09f0 */ unsigned __int64 glDispatchTable[233];
	/* 0x1138 */ unsigned __int64 glReserved1[29];
	/* 0x1220 */ unsigned __int64 glReserved2;
	/* 0x1228 */ unsigned __int64 glSectionInfo;
	/* 0x1230 */ unsigned __int64 glSection;
	/* 0x1238 */ unsigned __int64 glTable;
	/* 0x1240 */ unsigned __int64 glCurrentRC;
	/* 0x1248 */ unsigned __int64 glContext;
	/* 0x1250 */ unsigned long LastStatusValue;
	/* 0x1254 */ unsigned char Padding2[4];
	/* 0x1258 */ struct _STRING64 StaticUnicodeString;
	/* 0x1268 */ wchar_t StaticUnicodeBuffer[261];
	/* 0x1472 */ unsigned char Padding3[6];
	/* 0x1478 */ unsigned __int64 DeallocationStack;
	/* 0x1480 */ unsigned __int64 TlsSlots[64];
	/* 0x1680 */ struct LIST_ENTRY64 TlsLinks;
	/* 0x1690 */ unsigned __int64 Vdm;
	/* 0x1698 */ unsigned __int64 ReservedForNtRpc;
	/* 0x16a0 */ unsigned __int64 DbgSsReserved[2];
	/* 0x16b0 */ unsigned long HardErrorMode;
	/* 0x16b4 */ unsigned char Padding4[4];
	/* 0x16b8 */ unsigned __int64 Instrumentation[11];
	/* 0x1710 */ struct _GUID ActivityId;
	/* 0x1720 */ unsigned __int64 SubProcessTag;
	/* 0x1728 */ unsigned __int64 PerflibData;
	/* 0x1730 */ unsigned __int64 EtwTraceData;
	/* 0x1738 */ unsigned __int64 WinSockData;
	/* 0x1740 */ unsigned long GdiBatchCount;
	union
	{
		/* 0x1744 */ struct _PROCESSOR_NUMBER CurrentIdealProcessor;
		/* 0x1744 */ unsigned long IdealProcessorValue;
		struct
		{
			/* 0x1744 */ unsigned char ReservedPad0;
			/* 0x1745 */ unsigned char ReservedPad1;
			/* 0x1746 */ unsigned char ReservedPad2;
			/* 0x1747 */ unsigned char IdealProcessor;
		}; /* size: 0x0004 */
	}; /* size: 0x0004 */
	/* 0x1748 */ unsigned long GuaranteedStackBytes;
	/* 0x174c */ unsigned char Padding5[4];
	/* 0x1750 */ unsigned __int64 ReservedForPerf;
	/* 0x1758 */ unsigned __int64 ReservedForOle;
	/* 0x1760 */ unsigned long WaitingOnLoaderLock;
	/* 0x1764 */ unsigned char Padding6[4];
	/* 0x1768 */ unsigned __int64 SavedPriorityState;
	/* 0x1770 */ unsigned __int64 ReservedForCodeCoverage;
	/* 0x1778 */ unsigned __int64 ThreadPoolData;
	/* 0x1780 */ unsigned __int64 TlsExpansionSlots;
	/* 0x1788 */ unsigned __int64 DeallocationBStore;
	/* 0x1790 */ unsigned __int64 BStoreLimit;
	/* 0x1798 */ unsigned long MuiGeneration;
	/* 0x179c */ unsigned long IsImpersonating;
	/* 0x17a0 */ unsigned __int64 NlsCache;
	/* 0x17a8 */ unsigned __int64 pShimData;
	/* 0x17b0 */ unsigned long HeapData;
	/* 0x17b4 */ unsigned char Padding7[4];
	/* 0x17b8 */ unsigned __int64 CurrentTransactionHandle;
	/* 0x17c0 */ unsigned __int64 ActiveFrame;
	/* 0x17c8 */ unsigned __int64 FlsData;
	/* 0x17d0 */ unsigned __int64 PreferredLanguages;
	/* 0x17d8 */ unsigned __int64 UserPrefLanguages;
	/* 0x17e0 */ unsigned __int64 MergedPrefLanguages;
	/* 0x17e8 */ unsigned long MuiImpersonation;
	union
	{
		/* 0x17ec */ volatile unsigned short CrossTebFlags;
		/* 0x17ec */ unsigned short SpareCrossTebBits : 16; /* bit position: 0 */
	}; /* size: 0x0002 */
	union
	{
		/* 0x17ee */ unsigned short SameTebFlags;
		struct /* bitfield */
		{
			/* 0x17ee */ unsigned short SafeThunkCall : 1; /* bit position: 0 */
			/* 0x17ee */ unsigned short InDebugPrint : 1; /* bit position: 1 */
			/* 0x17ee */ unsigned short HasFiberData : 1; /* bit position: 2 */
			/* 0x17ee */ unsigned short SkipThreadAttach : 1; /* bit position: 3 */
			/* 0x17ee */ unsigned short WerInShipAssertCode : 1; /* bit position: 4 */
			/* 0x17ee */ unsigned short RanProcessInit : 1; /* bit position: 5 */
			/* 0x17ee */ unsigned short ClonedThread : 1; /* bit position: 6 */
			/* 0x17ee */ unsigned short SuppressDebugMsg : 1; /* bit position: 7 */
			/* 0x17ee */ unsigned short DisableUserStackWalk : 1; /* bit position: 8 */
			/* 0x17ee */ unsigned short RtlExceptionAttached : 1; /* bit position: 9 */
			/* 0x17ee */ unsigned short InitialThread : 1; /* bit position: 10 */
			/* 0x17ee */ unsigned short SessionAware : 1; /* bit position: 11 */
			/* 0x17ee */ unsigned short LoadOwner : 1; /* bit position: 12 */
			/* 0x17ee */ unsigned short LoaderWorker : 1; /* bit position: 13 */
			/* 0x17ee */ unsigned short SkipLoaderInit : 1; /* bit position: 14 */
			/* 0x17ee */ unsigned short SpareSameTebBits : 1; /* bit position: 15 */
		}; /* bitfield */
	}; /* size: 0x0002 */
	/* 0x17f0 */ unsigned __int64 TxnScopeEnterCallback;
	/* 0x17f8 */ unsigned __int64 TxnScopeExitCallback;
	/* 0x1800 */ unsigned __int64 TxnScopeContext;
	/* 0x1808 */ unsigned long LockCount;
	/* 0x180c */ long WowTebOffset;
	/* 0x1810 */ unsigned __int64 ResourceRetValue;
	/* 0x1818 */ unsigned __int64 ReservedForWdf;
	/* 0x1820 */ unsigned __int64 ReservedForCrt;
	/* 0x1828 */ struct _GUID EffectiveContainerId;
} TEB64, * PTEB64; /* size: 0x1838 */










#define THREAD_TERMINATE						(0x0001)  
#define THREAD_SUSPEND_RESUME					(0x0002)  
#define THREAD_GET_CONTEXT						(0x0008)  
#define THREAD_SET_CONTEXT						(0x0010)  
#define THREAD_QUERY_INFORMATION				(0x0040)  
#define THREAD_SET_INFORMATION					(0x0020)  
#define THREAD_SET_THREAD_TOKEN					(0x0080)
#define THREAD_IMPERSONATE						(0x0100)
#define THREAD_DIRECT_IMPERSONATION				(0x0200)

#define PROCESS_TERMINATE						(0x0001)  
#define PROCESS_CREATE_THREAD					(0x0002)  
#define PROCESS_SET_SESSIONID					(0x0004)  
#define PROCESS_VM_OPERATION					(0x0008)  
#define PROCESS_VM_READ							(0x0010)  
#define PROCESS_VM_WRITE						(0x0020)  
#define PROCESS_DUP_HANDLE						(0x0040)  
#define PROCESS_CREATE_PROCESS					(0x0080)  
#define PROCESS_SET_QUOTA						(0x0100)  
#define PROCESS_SET_INFORMATION					(0x0200)  
#define PROCESS_QUERY_INFORMATION				(0x0400)  
#define PROCESS_SUSPEND_RESUME					(0x0800)  
#define PROCESS_QUERY_LIMITED_INFORMATION		(0x1000)  

//////////////////////////////////////////////////////////////////////////////////////////////////////////////EPROCESS 
typedef struct _SEP_TOKEN_PRIVILEGES
{
	ULONG64 Present;
	ULONG64 Enabled;
	ULONG64 EnabledByDefault;
}SEP_TOKEN_PRIVILEGES,*PSEP_TOKEN_PRIVILEGES;
typedef struct _SEP_AUDIT_POLICY
{
	UCHAR AdtTokenPolicy[27];
	UCHAR PolicySetStatus;
}SEP_AUDIT_POLICY,*PSEP_AUDIT_POLICY;

typedef struct _TOKEN
{
	TOKEN_SOURCE TokenSource;
	LUID          TokenId;
	LUID          AuthenticationId;
	LUID ParentTokenId;
	LARGE_INTEGER  ExpirationTime;
	ERESOURCE* TokenLock;
	LUID ModifiedId;
	SEP_TOKEN_PRIVILEGES Privileges;
	SEP_AUDIT_POLICY AuditPolicy;
	ULONG32 SessionId;
	ULONG32 UserAndGroupCount;
	ULONG32 RestrictedSidCount;
	ULONG32 VariableLength;
	ULONG32 DynamicCharged;
	ULONG32 DynamicAvailable;
	ULONG32 DefaultOwnerIndex;
	SID_AND_ATTRIBUTES* UserAndGroups;
	SID_AND_ATTRIBUTES* RestrictedSids;
	PVOID PrimaryGroup;
	PULONG32 DynamicPart;
	ACL* DefaultDacl;
	TOKEN_TYPE TokenType;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	ULONG32 TokenFlags;
	UCHAR TokenInUse;
	ULONG32 IntegrityLevelIndex;
	ULONG32 MandatoryPolicy;
	struct  _SEP_LOGON_SESSION_REFERENCES* LogonSession;
	LUID OriginatingLogonSession;
	SID_AND_ATTRIBUTES_HASH SidHash;
	SID_AND_ATTRIBUTES_HASH RestrictedSidHash;
	struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes;
	ULONG64 VariablePart;
}TOKEN,*PTOKEN;

typedef struct _KGDTENTRY                 // 3 elements, 0x8 bytes (sizeof)  
{
	union
	{
		/*0x000*/     UINT16       LimitLow;
		/*0x002*/     UINT16       BaseLow;
		union                                 // 2 elements, 0x4 bytes (sizeof)  
		{
			struct                            // 4 elements, 0x4 bytes (sizeof)  
			{
				/*0x004*/             UINT8        BaseMid;
				/*0x005*/             UINT8        Flags1;
				/*0x006*/             UINT8        Flags2;
				/*0x007*/             UINT8        BaseHi;
			}Bytes;
			struct                            // 10 elements, 0x4 bytes (sizeof) 
			{
				/*0x004*/             ULONG32      BaseMid : 8;     // 0 BitPosition                   
				/*0x004*/             ULONG32      Type : 5;        // 8 BitPosition                   
				/*0x004*/             ULONG32      Dpl : 2;         // 13 BitPosition                  
				/*0x004*/             ULONG32      Pres : 1;        // 15 BitPosition                  
				/*0x004*/             ULONG32      LimitHi : 4;     // 16 BitPosition                  
				/*0x004*/             ULONG32      Sys : 1;         // 20 BitPosition                  
				/*0x004*/             ULONG32      Reserved_0 : 1;  // 21 BitPosition                  
				/*0x004*/             ULONG32      Default_Big : 1; // 22 BitPosition                  
				/*0x004*/             ULONG32      Granularity : 1; // 23 BitPosition                  
				/*0x004*/             ULONG32      BaseHi : 8;      // 24 BitPosition                  
			}Bits;
		}HighWord;

		UINT64 Alignment;
	};

	ULONG32 BaseUpper;
	ULONG32 MustBeZero;
}KGDTENTRY, * PKGDTENTRY;

///////////////////////////////////////////////////////////ETHREAD

typedef struct _KAPC_STATE_S             // 5 elements, 0x18 bytes (sizeof) 
{
	/*0x000*/     struct _LIST_ENTRY ApcListHead[2];
	/*0x010*/     struct _KPROCESS_S* Process;
	/*0x014*/     UINT8        KernelApcInProgress;
	/*0x015*/     UINT8        KernelApcPending;
	/*0x016*/     UINT8        UserApcPending;
	/*0x017*/     UINT8        _PADDING0_[0x1];
}KAPC_STATE_S, * PKAPC_STATE_S;

typedef struct _GDI_TEB_BATCH // 3 elements, 0x4E0 bytes (sizeof) 
{
	/*0x000*/     ULONG32      Offset;
	/*0x004*/     ULONG_PTR      HDC;
	/*0x008*/     ULONG32      Buffer[310];
}GDI_TEB_BATCH, * PGDI_TEB_BATCH;

typedef struct _TEB                                                  // 99 elements, 0xFE4 bytes (sizeof) 
{
	/*0x000*/     struct _NT_TIB NtTib;                                            // 8 elements, 0x1C bytes (sizeof)   
	/*0x01C*/     VOID* EnvironmentPointer;
	/*0x020*/     struct _CLIENT_ID ClientId;                                      // 2 elements, 0x8 bytes (sizeof)    
	/*0x028*/     VOID* ActiveRpcHandle;
	/*0x02C*/     VOID* ThreadLocalStoragePointer;
	/*0x030*/     PEB* ProcessEnvironmentBlock;
	/*0x034*/     ULONG32      LastErrorValue;
	/*0x038*/     ULONG32      CountOfOwnedCriticalSections;
	/*0x03C*/     VOID* CsrClientThread;
	/*0x040*/     VOID* Win32ThreadInfo;
	/*0x044*/     ULONG32      User32Reserved[26];
	/*0x0AC*/     ULONG32      UserReserved[5];
	/*0x0C0*/     VOID* WOW32Reserved;
	/*0x0C4*/     ULONG32      CurrentLocale;
	/*0x0C8*/     ULONG32      FpSoftwareStatusRegister;
	/*0x0CC*/     VOID* SystemReserved1[54];
	/*0x1A4*/     LONG32       ExceptionCode;
	/*0x1A8*/     VOID* ActivationContextStackPointer;
	/*0x1AC*/     UINT8        SpareBytes[24];
	/*0x1D0*/     ULONG32      TxFsContext;
	/*0x1D4*/     struct _GDI_TEB_BATCH GdiTebBatch;                               // 3 elements, 0x4E0 bytes (sizeof)  
	/*0x6B4*/     struct _CLIENT_ID RealClientId;                                  // 2 elements, 0x8 bytes (sizeof)    
	/*0x6BC*/     VOID* GdiCachedProcessHandle;
	/*0x6C0*/     ULONG32      GdiClientPID;
	/*0x6C4*/     ULONG32      GdiClientTID;
	/*0x6C8*/     VOID* GdiThreadLocalInfo;
	/*0x6CC*/     ULONG_PTR      Win32ClientInfo[62];
	/*0x7C4*/     VOID* glDispatchTable[233];
	/*0xB68*/     ULONG_PTR      glReserved1[29];
	/*0xBDC*/     VOID* glReserved2;
	/*0xBE0*/     VOID* glSectionInfo;
	/*0xBE4*/     VOID* glSection;
	/*0xBE8*/     VOID* glTable;
	/*0xBEC*/     VOID* glCurrentRC;
	/*0xBF0*/     VOID* glContext;
	/*0xBF4*/     ULONG32      LastStatusValue;
	/*0xBF8*/     struct _UNICODE_STRING StaticUnicodeString;                      // 3 elements, 0x8 bytes (sizeof)    
	/*0xC00*/     WCHAR        StaticUnicodeBuffer[261];
	/*0xE0C*/     VOID* DeallocationStack;
	/*0xE10*/     VOID* TlsSlots[64];
	/*0xF10*/     struct _LIST_ENTRY TlsLinks;                                     // 2 elements, 0x8 bytes (sizeof)    
	/*0xF18*/     VOID* Vdm;
	/*0xF1C*/     VOID* ReservedForNtRpc;
	/*0xF20*/     VOID* DbgSsReserved[2];
	/*0xF28*/     ULONG32      HardErrorMode;
	/*0xF2C*/     VOID* Instrumentation[11];
	/*0xF50*/     struct _GUID ActivityId;                                         // 4 elements, 0x10 bytes (sizeof)   
	/*0xF60*/     VOID* SubProcessTag;
	/*0xF64*/     VOID* EtwLocalData;
	/*0xF68*/     VOID* EtwTraceData;
	/*0xF6C*/     VOID* WinSockData;
	/*0xF70*/     ULONG32      GdiBatchCount;
	union                                                            // 3 elements, 0x4 bytes (sizeof)    
	{
		/*0xF74*/         struct _PROCESSOR_NUMBER CurrentIdealProcessor;              // 3 elements, 0x4 bytes (sizeof)    
		/*0xF74*/         ULONG32      IdealProcessorValue;
		struct                                                       // 4 elements, 0x4 bytes (sizeof)    
		{
			/*0xF74*/             UINT8        ReservedPad0;
			/*0xF75*/             UINT8        ReservedPad1;
			/*0xF76*/             UINT8        ReservedPad2;
			/*0xF77*/             UINT8        IdealProcessor;
		};
	};
	/*0xF78*/     ULONG32      GuaranteedStackBytes;
	/*0xF7C*/     VOID* ReservedForPerf;
	/*0xF80*/     VOID* ReservedForOle;
	/*0xF84*/     ULONG32      WaitingOnLoaderLock;
	/*0xF88*/     VOID* SavedPriorityState;
	/*0xF8C*/     ULONG_PTR     SoftPatchPtr1;
	/*0xF90*/     VOID* ThreadPoolData;
	/*0xF94*/     VOID** TlsExpansionSlots;
	PVOID DeallocationBStore;
	PVOID BStoreLimit;
	/*0xF98*/     ULONG32      MuiGeneration;
	/*0xF9C*/     ULONG32      IsImpersonating;
	/*0xFA0*/     VOID* NlsCache;
	/*0xFA4*/     VOID* pShimData;
	/*0xFA8*/     ULONG32      HeapVirtualAffinity;
	/*0xFAC*/     VOID* CurrentTransactionHandle;
	/*0xFB0*/     VOID* ActiveFrame;
	/*0xFB4*/     VOID* FlsData;
	/*0xFB8*/     VOID* PreferredLanguages;
	/*0xFBC*/     VOID* UserPrefLanguages;
	/*0xFC0*/     VOID* MergedPrefLanguages;
	/*0xFC4*/     ULONG32      MuiImpersonation;
	union                                                            // 2 elements, 0x2 bytes (sizeof)    
	{
		/*0xFC8*/         UINT16       CrossTebFlags;
		/*0xFC8*/         UINT16       SpareCrossTebBits : 16;                         // 0 BitPosition                     
	};
	union                                                            // 2 elements, 0x2 bytes (sizeof)    
	{
		/*0xFCA*/         UINT16       SameTebFlags;
		struct                                                       // 12 elements, 0x2 bytes (sizeof)   
		{
			/*0xFCA*/             UINT16       SafeThunkCall : 1;                          // 0 BitPosition                     
			/*0xFCA*/             UINT16       InDebugPrint : 1;                           // 1 BitPosition                     
			/*0xFCA*/             UINT16       HasFiberData : 1;                           // 2 BitPosition                     
			/*0xFCA*/             UINT16       SkipThreadAttach : 1;                       // 3 BitPosition                     
			/*0xFCA*/             UINT16       WerInShipAssertCode : 1;                    // 4 BitPosition                     
			/*0xFCA*/             UINT16       RanProcessInit : 1;                         // 5 BitPosition                     
			/*0xFCA*/             UINT16       ClonedThread : 1;                           // 6 BitPosition                     
			/*0xFCA*/             UINT16       SuppressDebugMsg : 1;                       // 7 BitPosition                     
			/*0xFCA*/             UINT16       DisableUserStackWalk : 1;                   // 8 BitPosition                     
			/*0xFCA*/             UINT16       RtlExceptionAttached : 1;                   // 9 BitPosition                     
			/*0xFCA*/             UINT16       InitialThread : 1;                          // 10 BitPosition                    
			/*0xFCA*/             UINT16       SpareSameTebBits : 5;                       // 11 BitPosition                    
		};
	};
	/*0xFCC*/     VOID* TxnScopeEnterCallback;
	/*0xFD0*/     VOID* TxnScopeExitCallback;
	/*0xFD4*/     VOID* TxnScopeContext;
	/*0xFD8*/     ULONG32      LockCount;
	/*0xFDC*/     ULONG32      SpareUlong0;
	/*0xFE0*/     VOID* ResourceRetValue;
}TEB, * PTEB;

//调试对象
typedef struct _DEBUG_OBJECT
{
	KEVENT EventsPresent;
	FAST_MUTEX Mutex;
	LIST_ENTRY EventList;
	union
	{
		ULONG Flags;
		struct
		{
			UCHAR DebuggerInactive : 1;
			UCHAR KillProcessOnExit : 1;
		};
	};
} DEBUG_OBJECT, * PDEBUG_OBJECT;


//异常消息
typedef struct _DBGKM_EXCEPTION {
	EXCEPTION_RECORD ExceptionRecord;
	ULONG FirstChance;
} DBGKM_EXCEPTION, * PDBGKM_EXCEPTION;

//创建线程消息
typedef struct {
	ULONG SubSystemKey;
	PVOID StartAddress;
} DBGKM_CREATE_THREAD, * PDBGKM_CREATE_THREAD;

//创建进程消息
typedef struct _DBGKM_CREATE_PROCESS {
	ULONG SubSystemKey;
	HANDLE FileHandle;
	PVOID BaseOfImage;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, * PDBGKM_CREATE_PROCESS;

//退出线程消息
typedef struct _DBGKM_EXIT_THREAD {
	NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, * PDBGKM_EXIT_THREAD;

//退出进程消息
typedef struct _DBGKM_EXIT_PROCESS {
	NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, * PDBGKM_EXIT_PROCESS;

//加载模块消息
typedef struct _DBGKM_LOAD_DLL {
	HANDLE FileHandle;
	PVOID BaseOfDll;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	PVOID NamePointer;
} DBGKM_LOAD_DLL, * PDBGKM_LOAD_DLL;

//卸载模块消息
typedef struct _DBGKM_UNLOAD_DLL {
	PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, * PDBGKM_UNLOAD_DLL;

//PORT_MESSAGE结构
typedef struct _PORT_MESSAGE
{
	union
	{
		struct
		{
			CSHORT DataLength;
			CSHORT TotalLength;
		} s1;
		ULONG Length;
	} u1;
	union
	{
		struct
		{
			CSHORT Type;
			CSHORT DataInfoOffset;
		} s2;
		ULONG ZeroInit;
	} u2;
	union
	{
		CLIENT_ID ClientId;
		double DoNotUseThisField;
	};
	ULONG32 MessageId;
	union
	{
		ULONGLONG ClientViewSize;
		ULONG32 CallbackId;
	};
} PORT_MESSAGE, * PPORT_MESSAGE;

//
// Debug Message API Number
//


typedef enum  _DBGKM_APINUMBER
{
	DbgKmExceptionApi = 0,
	DbgKmCreateThreadApi = 1,
	DbgKmCreateProcessApi = 2,
	DbgKmExitThreadApi = 3,
	DbgKmExitProcessApi = 4,
	DbgKmLoadDllApi = 5,
	DbgKmUnloadDllApi = 6,
	DbgKmErrorReportApi = 7,
	DbgKmMaxApiNumber = 8,
} DBGKM_APINUMBER;


//
// LPC Debug Message
//
typedef struct _DBGKM_MSG
{
	PORT_MESSAGE h;
	DBGKM_APINUMBER ApiNumber;
	NTSTATUS ReturnedStatus;
	union
	{
		DBGKM_EXCEPTION Exception;
		DBGKM_CREATE_THREAD CreateThread;
		DBGKM_CREATE_PROCESS CreateProcess;
		DBGKM_EXIT_THREAD ExitThread;
		DBGKM_EXIT_PROCESS ExitProcess;
		DBGKM_LOAD_DLL LoadDll;
		DBGKM_UNLOAD_DLL UnloadDll;
	};
	UCHAR unknow[0x40];
}DBGKM_MSG, * PDBGKM_MSG;


//消息结构
typedef struct _DBGKM_APIMSG {
	PORT_MESSAGE h;								//+0x0
	DBGKM_APINUMBER ApiNumber;					//+0x28
	NTSTATUS ReturnedStatus;					//+0x1c
	union {
		DBGKM_EXCEPTION Exception;
		DBGKM_CREATE_THREAD CreateThread;
		DBGKM_CREATE_PROCESS CreateProcessInfo;
		DBGKM_EXIT_THREAD ExitThread;
		DBGKM_EXIT_PROCESS ExitProcess;
		DBGKM_LOAD_DLL LoadDll;
		DBGKM_UNLOAD_DLL UnloadDll;
	} u;										//0x20

	//以上这个部分占了0x74个大小，而windows7此结构的大小是A8，下面应该是输入异常相关的信息，为此，我们要凑够0xA8个大小，不然处理异常的时候会蓝屏掉
	UCHAR	ExceptPart[0x40];
} DBGKM_APIMSG, * PDBGKM_APIMSG;


//调试事件
typedef struct _DEBUG_EVENT
{
	LIST_ENTRY EventList;	//+0x0			
	KEVENT ContinueEvent;	//+0x10		
	CLIENT_ID ClientId;		//0x28		
	PEPROCESS_S Process;		//0x38 
	PETHREAD_S Thread;		//0x40			
	NTSTATUS Status;		//0x48	
	ULONG Flags;			//0x4c			
	PETHREAD BackoutThread;	//0x50		
	DBGKM_APIMSG ApiMsg;	//0x58	
} DEBUG_EVENT, * PDEBUG_EVENT;

#ifndef _DBG_STATE_
#define _DBG_STATE_
//
// Debug States
//
typedef enum _DBG_STATE
{
	DbgIdle,
	DbgReplyPending,
	DbgCreateThreadStateChange,
	DbgCreateProcessStateChange,
	DbgExitThreadStateChange,
	DbgExitProcessStateChange,
	DbgExceptionStateChange,
	DbgBreakpointStateChange,
	DbgSingleStepStateChange,
	DbgLoadDllStateChange,
	DbgUnloadDllStateChange
} DBG_STATE, * PDBG_STATE;

#endif // !_DBG_STATE_


typedef struct _DBGUI_CREATE_THREAD {
	HANDLE HandleToThread;
	DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, * PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS {
	HANDLE HandleToProcess;
	HANDLE HandleToThread;
	DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, * PDBGUI_CREATE_PROCESS;

//typedef struct _DBGUI_WAIT_STATE_CHANGE {
//	DBG_STATE NewState;
//	CLIENT_ID AppClientId;
//	union {
//		DBGKM_EXCEPTION Exception;
//		DBGUI_CREATE_THREAD CreateThread;
//		DBGUI_CREATE_PROCESS CreateProcessInfo;
//		DBGKM_EXIT_THREAD ExitThread;
//		DBGKM_EXIT_PROCESS ExitProcess;
//		DBGKM_LOAD_DLL LoadDll;
//		DBGKM_UNLOAD_DLL UnloadDll;
//	} StateInfo;
//} DBGUI_WAIT_STATE_CHANGE, * PDBGUI_WAIT_STATE_CHANGE;

//
// User-Mode Debug State Change Structure
//
typedef struct _DBGUI_WAIT_STATE_CHANGE
{
	DBG_STATE NewState;
	CLIENT_ID AppClientId;
	union
	{
		struct
		{
			HANDLE HandleToThread;
			DBGKM_CREATE_THREAD NewThread;
		} CreateThread;
		struct
		{
			HANDLE HandleToProcess;
			HANDLE HandleToThread;
			DBGKM_CREATE_PROCESS NewProcess;
		} CreateProcessInfo;
		DBGKM_EXIT_THREAD ExitThread;
		DBGKM_EXIT_PROCESS ExitProcess;
		DBGKM_EXCEPTION Exception;
		DBGKM_LOAD_DLL LoadDll;
		DBGKM_UNLOAD_DLL UnloadDll;
	} StateInfo;
} DBGUI_WAIT_STATE_CHANGE, * PDBGUI_WAIT_STATE_CHANGE;

typedef struct _IMAGE_COMMITMENT
{
	struct _CONTROL_AREA* ControlArea;
	//..........
}IMAGE_COMMITMENT, * PIMAGE_COMMITMENT;

typedef struct _MMSECTION_FLAGS               // 27 elements, 0x4 bytes (sizeof) 
{
	/*0x000*/     UINT32       BeingDeleted : 1;            // 0 BitPosition                   
	/*0x000*/     UINT32       BeingCreated : 1;            // 1 BitPosition                   
	/*0x000*/     UINT32       BeingPurged : 1;             // 2 BitPosition                   
	/*0x000*/     UINT32       NoModifiedWriting : 1;       // 3 BitPosition                   
	/*0x000*/     UINT32       FailAllIo : 1;               // 4 BitPosition                   
	/*0x000*/     UINT32       Image : 1;                   // 5 BitPosition                   
	/*0x000*/     UINT32       Based : 1;                   // 6 BitPosition                   
	/*0x000*/     UINT32       File : 1;                    // 7 BitPosition                   
	/*0x000*/     UINT32       Networked : 1;               // 8 BitPosition                   
	/*0x000*/     UINT32       Rom : 1;                     // 9 BitPosition                   
	/*0x000*/     UINT32       PhysicalMemory : 1;          // 10 BitPosition                  
	/*0x000*/     UINT32       CopyOnWrite : 1;             // 11 BitPosition                  
	/*0x000*/     UINT32       Reserve : 1;                 // 12 BitPosition                  
	/*0x000*/     UINT32       Commit : 1;                  // 13 BitPosition                  
	/*0x000*/     UINT32       Accessed : 1;                // 14 BitPosition                  
	/*0x000*/     UINT32       WasPurged : 1;               // 15 BitPosition                  
	/*0x000*/     UINT32       UserReference : 1;           // 16 BitPosition                  
	/*0x000*/     UINT32       GlobalMemory : 1;            // 17 BitPosition                  
	/*0x000*/     UINT32       DeleteOnClose : 1;           // 18 BitPosition                  
	/*0x000*/     UINT32       FilePointerNull : 1;         // 19 BitPosition                  
	/*0x000*/     UINT32       GlobalOnlyPerSession : 1;    // 20 BitPosition                  
	/*0x000*/     UINT32       SetMappedFileIoComplete : 1; // 21 BitPosition                  
	/*0x000*/     UINT32       CollidedFlush : 1;           // 22 BitPosition                  
	/*0x000*/     UINT32       NoChange : 1;                // 23 BitPosition                  
	/*0x000*/     UINT32       Spare : 1;                   // 24 BitPosition                  
	/*0x000*/     UINT32       UserWritable : 1;            // 25 BitPosition                  
	/*0x000*/     UINT32       PreferredNode : 6;           // 26 BitPosition                  
}MMSECTION_FLAGS, * PMMSECTION_FLAGS;

typedef struct _CONTROL_AREA                                      // 16 elements, 0x50 bytes (sizeof) 
{
	/*0x000*/     void* Segment;
	/*0x004*/     struct _LIST_ENTRY DereferenceList;                           // 2 elements, 0x8 bytes (sizeof)   
	/*0x00C*/     ULONG64      NumberOfSectionReferences;
	/*0x010*/     ULONG64      NumberOfPfnReferences;
	/*0x014*/     ULONG64      NumberOfMappedViews;
	/*0x018*/     ULONG64      NumberOfUserReferences;
	union                                                         // 2 elements, 0x4 bytes (sizeof)   
	{
		/*0x01C*/         ULONG32      LongFlags;
		/*0x01C*/         ULONG32	   Flags;                            // 27 elements, 0x4 bytes (sizeof)  
	}u;
	/*0x020*/     ULONG32      FlushInProgressCount;
	/*0x024*/     struct _EX_FAST_REF FilePointer;                              // 3 elements, 0x4 bytes (sizeof)   
	/*0x028*/     LONG32       ControlAreaLock;
	union                                                         // 2 elements, 0x4 bytes (sizeof)   
	{
		/*0x02C*/         ULONG32      ModifiedWriteCount;
		/*0x02C*/         ULONG32      StartingFrame;
	};
	/*0x030*/     void* WaitingForDeletion;
	union                                                         // 1 elements, 0xC bytes (sizeof)   
	{
		struct                                                    // 9 elements, 0xC bytes (sizeof)   
		{
			union                                                 // 2 elements, 0x4 bytes (sizeof)   
			{
				/*0x034*/                 ULONG32      NumberOfSystemCacheViews;
				/*0x034*/                 ULONG32      ImageRelocationStartBit;
			};
			union                                                 // 2 elements, 0x4 bytes (sizeof)   
			{
				/*0x038*/                 LONG32       WritableUserReferences;
				struct                                            // 4 elements, 0x4 bytes (sizeof)   
				{
					/*0x038*/                     ULONG32      ImageRelocationSizeIn64k : 16;   // 0 BitPosition                    
					/*0x038*/                     ULONG32      Unused : 14;                     // 16 BitPosition                   
					/*0x038*/                     ULONG32      BitMap64 : 1;                    // 30 BitPosition                   
					/*0x038*/                     ULONG32      ImageActive : 1;                 // 31 BitPosition                   
				};
			};
			union                                                 // 2 elements, 0x4 bytes (sizeof)   
			{
				/*0x03C*/                 void* SubsectionRoot;
				/*0x03C*/                 void* SeImageStub;
			};
		}e2;
	}u2;
	/*0x040*/     INT64        LockedPages;
	/*0x048*/     struct _LIST_ENTRY ViewList;                                  // 2 elements, 0x8 bytes (sizeof)   
}CONTROL_AREA, * PCONTROL_AREA;

typedef struct _SUBSECTION
{
	CONTROL_AREA* ControlArea;
	PVOID SubsectionBase;
	PVOID NextSubsection;
	ULONG32 PtesInSubsection;
	ULONG32 UnusedPtes;
	PVOID GlobalPerSessionHead;
	union
	{
		ULONG32 x1;
	}u;
	ULONG32 StartingSector;
	ULONG32 NumberOfFullSectors;
}SUBSECTION, * PSUBSECTION;

typedef struct _SEGMENT_OBJECT                     // 9 elements, 0x28 bytes (sizeof) 
{
	/*0x000*/     VOID* BaseAddress;
	/*0x004*/     ULONG32      TotalNumberOfPtes;
	/*0x008*/     union _LARGE_INTEGER SizeOfSegment;            // 4 elements, 0x8 bytes (sizeof)  
	/*0x010*/     ULONG32      NonExtendedPtes;
	/*0x014*/     ULONG32 ImageCommitment;		//这个成员经过分析我们重新定义一下                                                   
	/*0x018*/     struct _CONTROL_AREA* ControlArea;
	/*0x01C*/     PSUBSECTION Subsection;
	/*0x020*/     struct _MMSECTION_FLAGS*	MmSectionFlags;
	/*0x024*/     void* MmSubSectionFlags;
}SEGMENT_OBJECT, * PSEGMENT_OBJECT;


//模块相关
typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY
{
	ULONG Unknow1;
	ULONG Unknow2;
	ULONG Unknow3;
	ULONG Unknow4;
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	char ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _tagSysModuleList {          //模块链结构
	ULONG ulCount;
	SYSTEM_MODULE_INFORMATION_ENTRY smi[1];
} MODULES, * PMODULES;


//句柄相关
typedef struct _HANDLE_TABLE_ENTRY
{
	union
	{
		PVOID		Object;
		UINT32		ObAttributes;
		PVOID		InfoTable;
		UINT_PTR		Value;
	};
	union
	{
		union
		{
			UINT32 GrantedAccess;
			struct
			{
				UINT16 GrantedAccessIndex;
				UINT16 CreatorBackTraceIndex;
			};
		};
		UINT32 NextFreeTableEntry;
	};
} HANDLE_TABLE_ENTRY, * PHANDLE_TABLE_ENTRY;//Win7 x64/x86

typedef struct _HANDLE_TABLE
{
	UINT_PTR			TableCode;			     // +00	4	+00	 8
	PEPROCESS			QuotaProcess;			 // +04	4	+08	 8
	HANDLE				UniqueProcessId;		 // +08	4	+10	 8
	PVOID				HandleLock;			     // +0c	4	+18	 8
	LIST_ENTRY			HandleTableList;		 // +10	4	+20  16
	PVOID				HandleContentionEvent;	 // +18	8	+30  8
	PVOID				DebugInfo;			     // +1c	4	+38  8
	INT32				ExtraInfoPages;		     // +20	4	+40  4
	UINT32				Flags;				     // +24	4	+44  4
	UINT32				FirstFreeHandle;		 // +28	4	+48  4
#ifdef _WIN64
	UINT32				Padding;				 // +4c  4
#endif // _WIN64
	PHANDLE_TABLE_ENTRY	LastFreeHandleEntry;	 // +2c	4	+50  8
	UINT32				HandleCount;			 // +30	4	+58  4
	UINT32				NextHandleNeedingPool;	 // +34	4	+5c  4
	UINT32				HandleCountHighWatermark;// +38	4	+60  4
} HANDLE_TABLE, * PHANDLE_TABLE;//Win7 x64/x86

//SSDT
typedef struct _SERVICE_DESCIPTOR_TABLE {
	PULONG ServiceTableBase;
	PVOID ServiceCounterTableBase; //仅适用于checked build版本
	ULONG_PTR NumberOfServices;
	PVOID ParamTableBase;
} ServiceDescriptorTableEntry_t, * PServiceDescriptorTableEntry_t;

typedef struct _OBJECT_TYPE_INITIALIZER                                                                                                                                      // 25 elements, 0x70 bytes (sizeof)
{
	/*0x000*/     UINT16       Length;
	union                                                                                                                                                                       // 2 elements, 0x1 bytes (sizeof)
	{
		/*0x002*/         UINT8        ObjectTypeFlags;
		struct                                                                                                                                                                  // 7 elements, 0x1 bytes (sizeof)
		{
			/*0x002*/             UINT8        CaseInsensitive : 1;                                                                                                                                   // 0 BitPosition
			/*0x002*/             UINT8        UnnamedObjectsOnly : 1;                                                                                                                                // 1 BitPosition
			/*0x002*/             UINT8        UseDefaultObject : 1;                                                                                                                                  // 2 BitPosition
			/*0x002*/             UINT8        SecurityRequired : 1;                                                                                                                                  // 3 BitPosition
			/*0x002*/             UINT8        MaintainHandleCount : 1;                                                                                                                               // 4 BitPosition
			/*0x002*/             UINT8        MaintainTypeList : 1;                                                                                                                                  // 5 BitPosition
			/*0x002*/             UINT8        SupportsObjectCallbacks : 1;                                                                                                                           // 6 BitPosition
		};
	};
	/*0x004*/     ULONG32      ObjectTypeCode;
	/*0x008*/     ULONG32      InvalidAttributes;
	/*0x00C*/     struct _GENERIC_MAPPING GenericMapping;                                                                                                                                     // 4 elements, 0x10 bytes (sizeof)
	/*0x01C*/     ULONG32      ValidAccessMask;
	/*0x020*/     ULONG32      RetainAccess;
	/*0x024*/     enum _POOL_TYPE PoolType;
	/*0x028*/     ULONG32      DefaultPagedPoolCharge;
	/*0x02C*/     ULONG32      DefaultNonPagedPoolCharge;
	/*0x030*/     PVOID DumpProcedure;
	/*0x038*/     PVOID OpenProcedure;
	/*0x040*/     PVOID CloseProcedure;
	/*0x048*/     PVOID DeleteProcedure;
	/*0x050*/     PVOID ParseProcedure;
	/*0x058*/     PVOID SecurityProcedure;
	/*0x060*/     PVOID QueryNameProcedure;
	/*0x068*/     PVOID OkayToCloseProcedure;
}OBJECT_TYPE_INITIALIZER, * POBJECT_TYPE_INITIALIZER;

typedef struct _OBJECT_TYPE                   // 12 elements, 0xD0 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY TypeList;              // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _UNICODE_STRING Name;              // 3 elements, 0x10 bytes (sizeof)
	/*0x020*/     VOID* DefaultObject;
	/*0x028*/     UINT8        Index;
	/*0x02C*/     ULONG32      TotalNumberOfObjects;
	/*0x030*/     ULONG32      TotalNumberOfHandles;
	/*0x034*/     ULONG32      HighWaterNumberOfObjects;
	/*0x038*/     ULONG32      HighWaterNumberOfHandles;
	/*0x040*/     struct _OBJECT_TYPE_INITIALIZER TypeInfo; // 25 elements, 0x70 bytes (sizeof)
	/*0x0B0*/     struct _EX_PUSH_LOCK TypeLock;            // 7 elements, 0x8 bytes (sizeof)
	/*0x0B8*/     ULONG32      Key;
	/*0x0C0*/     struct _LIST_ENTRY CallbackList;          // 2 elements, 0x10 bytes (sizeof)
}OBJECT_TYPE, * POBJECT_TYPE;

typedef struct _OBJECT_TYPE_INITIALIZER_WIN7
{
	USHORT Length;
	USHORT ObjectTypeFlags;
	ULONG ObjectTypeCode;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	ULONG RetainAccess;
	POOL_TYPE PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
	PVOID DumpProcedure;
	PVOID OpenProcedure;
	PVOID CloseProcedure;
	PVOID DeleteProcedure;
	PVOID ParseProcedure;
	PVOID SecurityProcedure;
	PVOID QueryNameProcedure;
	PVOID OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER_WIN7, * POBJECT_TYPE_INITIALIZER_WIN7;

typedef struct _OBJECT_TYPE_INITIALIZER_WIN10
{
	UINT16 Length;
	UINT16 ObjectTypeFlags;
	ULONG ObjectTypeCode;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	ULONG RetainAccess;
	POOL_TYPE PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
	PVOID DumpProcedure;
	PVOID OpenProcedure;
	PVOID OpenProcedureEx;
	PVOID CloseProcedure;
	PVOID DeleteProcedure;
	PVOID ParseProcedure;
	PVOID SecurityProcedure;
	PVOID QueryNameProcedure;
	PVOID OkayToCloseProcedure;
	ULONG WaitObjectFlagMask;
	ULONG WaitObjectFlagOffset;
	ULONG WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_WIN10, * POBJECT_TYPE_INITIALIZER_WIN10;


typedef struct _OBJECT_HEADER
{
	INT64 PointerCount;
	union
	{
		INT64 HandleCount;
		PVOID NextToFree;
	};

	EX_PUSH_LOCK Lock;
	UCHAR TypeIndex;
	UCHAR TraceFlags;
	UCHAR InfoMask;
	UCHAR Flags;
	union
	{
		struct _OBJECT_CREATE_INFORMATION* ObjectCreateInfo;
		PVOID QuotaBlockCharged;
	};

	PVOID SecurityDescriptor;
}OBJECT_HEADER, * POBJECT_HEADER;


typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
	SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
	SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
	SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
	SystemPathInformation, // not implemented
	SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
	SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
	SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
	SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
	SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
	SystemCallTimeInformation, // 10, not implemented
	SystemModuleInformation, // q: RTL_PROCESS_MODULES
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation, // not implemented
	SystemNonPagedPoolInformation, // not implemented
	SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
	SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
	SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
	SystemVdmInstemulInformation, // q
	SystemVdmBopInformation, // 20, not implemented
	SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
	SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
	SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION
	SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
	SystemFullMemoryInformation, // not implemented
	SystemLoadGdiDriverInformation, // s (kernel-mode only)
	SystemUnloadGdiDriverInformation, // s (kernel-mode only)
	SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
	SystemSummaryMemoryInformation, // not implemented
	SystemMirrorMemoryInformation, // 30, s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege)
	SystemPerformanceTraceInformation, // s
	SystemObsolete0, // not implemented
	SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
	SystemCrashDumpStateInformation, // s (requires SeDebugPrivilege)
	SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
	SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
	SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
	SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
	SystemPrioritySeperation, // s (requires SeTcbPrivilege)
	SystemVerifierAddDriverInformation, // 40, s (requires SeDebugPrivilege)
	SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
	SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
	SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
	SystemCurrentTimeZoneInformation, // q
	SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
	SystemTimeSlipNotification, // s (requires SeSystemtimePrivilege)
	SystemSessionCreate, // not implemented
	SystemSessionDetach, // not implemented
	SystemSessionInformation, // not implemented
	SystemRangeStartInformation, // 50, q
	SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
	SystemVerifierThunkExtend, // s (kernel-mode only)
	SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
	SystemLoadGdiDriverInSystemSpace, // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
	SystemNumaProcessorMap, // q
	SystemPrefetcherInformation, // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
	SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
	SystemRecommendedSharedDataAlignment, // q
	SystemComPlusPackage, // q; s
	SystemNumaAvailableMemory, // 60
	SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION
	SystemEmulationBasicInformation, // q
	SystemEmulationProcessorInformation,
	SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
	SystemLostDelayedWriteInformation, // q: ULONG
	SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
	SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
	SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
	SystemHotpatchInformation, // q; s
	SystemObjectSecurityMode, // 70, q
	SystemWatchdogTimerHandler, // s (kernel-mode only)
	SystemWatchdogTimerInformation, // q (kernel-mode only); s (kernel-mode only)
	SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
	SystemWow64SharedInformationObsolete, // not implemented
	SystemRegisterFirmwareTableInformationHandler, // s (kernel-mode only)
	SystemFirmwareTableInformation, // not implemented
	SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
	SystemVerifierTriageInformation, // not implemented
	SystemSuperfetchInformation, // q: SUPERFETCH_INFORMATION; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
	SystemMemoryListInformation, // 80, q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege)
	SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
	SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
	SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
	SystemVerifierCancellationInformation, // not implemented // name:wow64:whNT32QuerySystemVerifierCancellationInformation
	SystemProcessorPowerInformationEx, // not implemented
	SystemRefTraceInformation, // q; s // ObQueryRefTraceInformation
	SystemSpecialPoolInformation, // q; s (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
	SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
	SystemErrorPortInformation, // s (requires SeTcbPrivilege)
	SystemBootEnvironmentInformation, // 90, q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION
	SystemHypervisorInformation, // q; s (kernel-mode only)
	SystemVerifierInformationEx, // q; s
	SystemTimeZoneInformation, // s (requires SeTimeZonePrivilege)
	SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
	SystemCoverageInformation, // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
	SystemPrefetchPatchInformation, // not implemented
	SystemVerifierFaultsInformation, // s (requires SeDebugPrivilege)
	SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
	SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
	SystemProcessorPerformanceDistribution, // 100, q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION
	SystemNumaProximityNodeInformation, // q
	SystemDynamicTimeZoneInformation, // q; s (requires SeTimeZonePrivilege)
	SystemCodeIntegrityInformation, // q // SeCodeIntegrityQueryInformation
	SystemProcessorMicrocodeUpdateInformation, // s
	SystemProcessorBrandString, // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
	SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
	SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
	SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
	SystemStoreInformation, // q; s // SmQueryStoreInformation
	SystemRegistryAppendString, // 110, s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS
	SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
	SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
	SystemCpuQuotaInformation, // q; s // PsQueryCpuQuotaInformation
	SystemNativeBasicInformation, // not implemented
	SystemSpare1, // not implemented
	SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
	SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
	SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
	SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
	SystemSystemPtesInformationEx, // 120, q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes)
	SystemNodeDistanceInformation, // q
	SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
	SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
	SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
	SystemSessionBigPoolInformation, // since WIN8
	SystemBootGraphicsInformation,
	SystemScrubPhysicalMemoryInformation,
	SystemBadPageInformation,
	SystemProcessorProfileControlArea,
	SystemCombinePhysicalMemoryInformation, // 130
	SystemEntropyInterruptTimingCallback,
	SystemConsoleInformation,
	SystemPlatformBinaryInformation,
	SystemThrottleNotificationInformation,
	SystemHypervisorProcessorCountInformation,
	SystemDeviceDataInformation,
	SystemDeviceDataEnumerationInformation,
	SystemMemoryTopologyInformation,
	SystemMemoryChannelInformation,
	SystemBootLogoInformation, // 140
	SystemProcessorPerformanceInformationEx, // since WINBLUE
	SystemSpare0,
	SystemSecureBootPolicyInformation,
	SystemPageFileInformationEx,
	SystemSecureBootInformation,
	SystemEntropyInterruptTimingRawInformation,
	SystemPortableWorkspaceEfiLauncherInformation,
	SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
	SystemKernelDebuggerInformationEx,
	SystemBootMetadataInformation, // 150
	SystemSoftRebootInformation,
	SystemElamCertificateInformation,
	SystemOfflineDumpConfigInformation,
	SystemProcessorFeaturesInformation,
	SystemRegistryReconciliationInformation,
	SystemEdidInformation,
	MaxSystemInfoClass,
	SystemKernelDebuggerFlags = 163
} SYSTEM_INFORMATION_CLASS;



```

`HyperHideDrv/KernelExportAPI.h`:

```h
#pragma once
#include <ntddk.h>
#include <ntifs.h>
#include <ntimage.h>
#include "KernelDbgStruct.h"


EXTERN_C PPEB  PsGetProcessPeb(PEPROCESS);

EXTERN_C NTKERNELAPI NTSTATUS ObCreateObjectType(
	__in PUNICODE_STRING TypeName,
	__in PVOID ObjectTypeInitializer,
	__in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
	__out PVOID* ObjectType
);

EXTERN_C NTKERNELAPI PVOID PsGetProcessDebugPort(
	_In_ PEPROCESS Process
);

EXTERN_C NTSTATUS NTAPI PsSuspendProcess(
	PEPROCESS Process);

EXTERN_C NTSTATUS NTAPI PsResumeProcess(PEPROCESS Process);


EXTERN_C  NTSTATUS NTAPI NtTraceControl(
	_In_ ULONG FunctionCode,
	_In_reads_bytes_opt_(InBufferLen) PVOID InBuffer,
	_In_ ULONG InBufferLen,
	_Out_writes_bytes_opt_(OutBufferLen) PVOID OutBuffer,
	_In_ ULONG OutBufferLen,
	_Out_ PULONG ReturnLength
);
EXTERN_C UCHAR* NTAPI PsGetProcessImageFileName(
	__in PEPROCESS Process
);

EXTERN_C NTSTATUS NTAPI PsReferenceProcessFilePointer(//通过EPROCESS获取文件对象
	IN PEPROCESS Process,
	OUT PVOID* pFilePointer
);

EXTERN_C NTSTATUS  NTAPI ZwQuerySystemInformation(
	IN ULONG SystemInformationClass,  //处理进程信息,只需要处理类别为5的即可
	OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength
);
EXTERN_C PVOID NTAPI ObGetObjectType(
	IN PVOID pObject);

EXTERN_C HANDLE NTAPI PsGetProcessInheritedFromUniqueProcessId(//获取父进程ID
	PEPROCESS Process);

EXTERN_C PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(
	PVOID Base
);
EXTERN_C NTKERNELAPI PVOID PsGetProcessDebugPort(
	_In_ PEPROCESS Process
);
EXTERN_C LONG NTAPI ExSystemExceptionFilter(VOID);
EXTERN_C NTSTATUS ObCreateObject(
	__in KPROCESSOR_MODE ProbeMode,
	__in POBJECT_TYPE ObjectType,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in KPROCESSOR_MODE OwnershipMode,
	__inout_opt PVOID ParseContext,
	__in ULONG ObjectBodySize,
	__in ULONG PagedPoolCharge,
	__in ULONG NonPagedPoolCharge,
	__out PVOID* Object
);

EXTERN_C void ExfAcquirePushLockShared(
	EX_PUSH_LOCK Lock
);
EXTERN_C void ExfReleasePushLockShared(
	EX_PUSH_LOCK Lock
);
```

`HyperHideDrv/KernelStruct.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntimage.h>




```

`HyperHideDrv/KernelStruct1.h`:

```h
#include <ntifs.h>
#define DEBUG_OBJECT_DELETE_PENDING			(0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE			(0x2) // Kill all debugged processes on close
#define DEBUG_KILL_ON_CLOSE					(0x01)
#define DEBUG_EVENT_READ					(0x01)  // Event had been seen by win32 app
#define DEBUG_EVENT_NOWAIT					(0x02)  // No waiter one this. Just free the pool
#define DEBUG_EVENT_INACTIVE				(0x04)  // The message is in inactive. It may be activated or deleted later
#define DEBUG_EVENT_RELEASE					(0x08)  // Release rundown protection on this thread
#define DEBUG_EVENT_PROTECT_FAILED			(0x10)  // Rundown protection failed to be acquired on this thread
#define DEBUG_EVENT_SUSPEND					(0x20)  // Resume thread on continue

//
// Define debug object access types. No security is present on this object.
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
	DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

//一些内核其他定义声明

//
// Used to signify that the delete APC has been queued or the
// thread has called PspExitThread itself.
//
#define PS_CROSS_THREAD_FLAGS_TERMINATED           0x00000001UL
//
// Thread create failed
//
#define PS_CROSS_THREAD_FLAGS_DEADTHREAD           0x00000002UL
//
// Debugger isn't shown this thread
//
#define PS_CROSS_THREAD_FLAGS_HIDEFROMDBG          0x00000004UL
//
// Thread is impersonating
//
#define PS_CROSS_THREAD_FLAGS_IMPERSONATING        0x00000008UL
//
// This is a system thread
//
#define PS_CROSS_THREAD_FLAGS_SYSTEM               0x00000010UL
//
// Hard errors are disabled for this thread
//
#define PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED 0x00000020UL
//
// We should break in when this thread is terminated
//
#define PS_CROSS_THREAD_FLAGS_BREAK_ON_TERMINATION 0x00000040UL
//
// This thread should skip sending its create thread message
//
#define PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG    0x00000080UL
//
// This thread should skip sending its final thread termination message
//
#define PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG 0x00000100UL

#define IS_SYSTEM_THREAD(Thread)  (((Thread)->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SYSTEM) != 0)

#define PS_PROCESS_FLAGS_CREATE_REPORTED        0x00000001UL // Create process debug call has occurred
#define PS_PROCESS_FLAGS_NO_DEBUG_INHERIT       0x00000002UL // Don't inherit debug port
#define PS_PROCESS_FLAGS_PROCESS_EXITING        0x00000004UL // PspExitProcess entered
#define PS_PROCESS_FLAGS_PROCESS_DELETE         0x00000008UL // Delete process has been issued
#define PS_PROCESS_FLAGS_WOW64_SPLIT_PAGES      0x00000010UL // Wow64 split pages
#define PS_PROCESS_FLAGS_VM_DELETED             0x00000020UL // VM is deleted
#define PS_PROCESS_FLAGS_OUTSWAP_ENABLED        0x00000040UL // Outswap enabled
#define PS_PROCESS_FLAGS_OUTSWAPPED             0x00000080UL // Outswapped
#define PS_PROCESS_FLAGS_FORK_FAILED            0x00000100UL // Fork status
#define PS_PROCESS_FLAGS_WOW64_4GB_VA_SPACE     0x00000200UL // Wow64 process with 4gb virtual address space
#define PS_PROCESS_FLAGS_ADDRESS_SPACE1         0x00000400UL // Addr space state1
#define PS_PROCESS_FLAGS_ADDRESS_SPACE2         0x00000800UL // Addr space state2
#define PS_PROCESS_FLAGS_SET_TIMER_RESOLUTION   0x00001000UL // SetTimerResolution has been called
#define PS_PROCESS_FLAGS_BREAK_ON_TERMINATION   0x00002000UL // Break on process termination
#define PS_PROCESS_FLAGS_CREATING_SESSION       0x00004000UL // Process is creating a session
#define PS_PROCESS_FLAGS_USING_WRITE_WATCH      0x00008000UL // Process is using the write watch APIs
#define PS_PROCESS_FLAGS_IN_SESSION             0x00010000UL // Process is in a session
#define PS_PROCESS_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00020000UL // Process must use native address space (Win64 only)
#define PS_PROCESS_FLAGS_HAS_ADDRESS_SPACE      0x00040000UL // This process has an address space
#define PS_PROCESS_FLAGS_LAUNCH_PREFETCHED      0x00080000UL // Process launch was prefetched
#define PS_PROCESS_INJECT_INPAGE_ERRORS         0x00100000UL // Process should be given inpage errors - hardcoded in trap.asm too
#define PS_PROCESS_FLAGS_VM_TOP_DOWN            0x00200000UL // Process memory allocations default to top-down
#define PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE      0x00400000UL // We have sent a message for this image
#define PS_PROCESS_FLAGS_PDE_UPDATE_NEEDED      0x00800000UL // The system PDEs need updating for this process (NT32 only)
#define PS_PROCESS_FLAGS_VDM_ALLOWED            0x01000000UL // Process allowed to invoke NTVDM support
#define PS_PROCESS_FLAGS_SMAP_ALLOWED           0x02000000UL // Process allowed to invoke SMAP support
#define PS_PROCESS_FLAGS_CREATE_FAILED          0x04000000UL // Process create failed

#define PS_PROCESS_FLAGS_DEFAULT_IO_PRIORITY    0x38000000UL // The default I/O priority for created threads. (3 bits)

#define PS_PROCESS_FLAGS_PRIORITY_SHIFT         27

#define PS_PROCESS_FLAGS_EXECUTE_SPARE1         0x40000000UL //
#define PS_PROCESS_FLAGS_EXECUTE_SPARE2         0x80000000UL //


#define THREAD_TERMINATE						(0x0001)  
#define THREAD_SUSPEND_RESUME					(0x0002)  
#define THREAD_GET_CONTEXT						(0x0008)  
#define THREAD_SET_CONTEXT						(0x0010)  
#define THREAD_QUERY_INFORMATION				(0x0040)  
#define THREAD_SET_INFORMATION					(0x0020)  
#define THREAD_SET_THREAD_TOKEN					(0x0080)
#define THREAD_IMPERSONATE						(0x0100)
#define THREAD_DIRECT_IMPERSONATION				(0x0200)

#define PROCESS_TERMINATE						(0x0001)  
#define PROCESS_CREATE_THREAD					(0x0002)  
#define PROCESS_SET_SESSIONID					(0x0004)  
#define PROCESS_VM_OPERATION					(0x0008)  
#define PROCESS_VM_READ							(0x0010)  
#define PROCESS_VM_WRITE						(0x0020)  
#define PROCESS_DUP_HANDLE						(0x0040)  
#define PROCESS_CREATE_PROCESS					(0x0080)  
#define PROCESS_SET_QUOTA						(0x0100)  
#define PROCESS_SET_INFORMATION					(0x0200)  
#define PROCESS_QUERY_INFORMATION				(0x0400)  
#define PROCESS_SUSPEND_RESUME					(0x0800)  
#define PROCESS_QUERY_LIMITED_INFORMATION		(0x1000)  
#define PROCESS_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
                                   0xFFF)


#define LPC_REQUEST								1
#define LPC_REPLY								2
#define LPC_DATAGRAM							3
#define LPC_LOST_REPLY							4
#define LPC_PORT_CLOSED							5
#define LPC_CLIENT_DIED							6
#define LPC_EXCEPTION							7
#define LPC_DEBUG_EVENT							8
#define LPC_ERROR_EVENT							9
#define LPC_CONNECTION_REQUEST					10
#define DBGK_KILL_PROCESS_ON_EXIT         (0x1)
#define DBGK_ALL_FLAGS                    (DBGK_KILL_PROCESS_ON_EXIT)


typedef struct _KERNEL_STACK_SEGMENT // 5 elements, 0x28 bytes (sizeof)
{
	/*0x000*/     UINT64       StackBase;
	/*0x008*/     UINT64       StackLimit;
	/*0x010*/     UINT64       KernelStack;
	/*0x018*/     UINT64       InitialStack;
	/*0x020*/     UINT64       ActualLimit;
}KERNEL_STACK_SEGMENT, *PKERNEL_STACK_SEGMENT;

typedef struct _KERNEL_STACK_CONTROL       // 2 elements, 0x50 bytes (sizeof)
{
	/*0x000*/     struct _KERNEL_STACK_SEGMENT Current;  // 5 elements, 0x28 bytes (sizeof)
	/*0x028*/     struct _KERNEL_STACK_SEGMENT Previous; // 5 elements, 0x28 bytes (sizeof)
}KERNEL_STACK_CONTROL, *PKERNEL_STACK_CONTROL;

#ifndef _EX_FAST_REF_
#define _EX_FAST_REF_
typedef struct _EX_FAST_REF      // 3 elements, 0x8 bytes (sizeof)
{
	union                        // 3 elements, 0x8 bytes (sizeof)
	{
		/*0x000*/         VOID* Object;
		/*0x000*/         UINT64       RefCnt : 4; // 0 BitPosition
		/*0x000*/         UINT64       Value;
	};
}EX_FAST_REF, * PEX_FAST_REF;
#endif // !_EX_FAST_REF_

#ifndef _KWAIT_STATUS_REGISTER_
#define _KWAIT_STATUS_REGISTER_
typedef union _KWAIT_STATUS_REGISTER // 8 elements, 0x1 bytes (sizeof) 
{
	/*0x000*/     UINT8        Flags;
	struct                           // 7 elements, 0x1 bytes (sizeof) 
	{
		/*0x000*/         UINT8        State : 2;      // 0 BitPosition                  
		/*0x000*/         UINT8        Affinity : 1;   // 2 BitPosition                  
		/*0x000*/         UINT8        Priority : 1;   // 3 BitPosition                  
		/*0x000*/         UINT8        Apc : 1;        // 4 BitPosition                  
		/*0x000*/         UINT8        UserApc : 1;    // 5 BitPosition                  
		/*0x000*/         UINT8        Alert : 1;      // 6 BitPosition                  
		/*0x000*/         UINT8        Unused : 1;     // 7 BitPosition                  
	};
}KWAIT_STATUS_REGISTER, * PKWAIT_STATUS_REGISTER;
#endif // !_KWAIT_STATUS_REGISTER_

#ifndef _PS_CLIENT_SECURITY_CONTEXT_
#define _PS_CLIENT_SECURITY_CONTEXT_
typedef union _PS_CLIENT_SECURITY_CONTEXT    // 4 elements, 0x4 bytes (sizeof) 
{
	/*0x000*/     ULONG_PTR      ImpersonationData;
	/*0x000*/     VOID* ImpersonationToken;
	struct                                   // 2 elements, 0x4 bytes (sizeof) 
	{
		/*0x000*/         ULONG_PTR      ImpersonationLevel : 2; // 0 BitPosition                  
		/*0x000*/         ULONG_PTR      EffectiveOnly : 1;      // 2 BitPosition                  
	};
}PS_CLIENT_SECURITY_CONTEXT, * PPS_CLIENT_SECURITY_CONTEXT;
#endif // !_PS_CLIENT_SECURITY_CONTEXT_

typedef struct _EX_PUSH_LOCK                 // 7 elements, 0x8 bytes (sizeof)
{
	union                                    // 3 elements, 0x8 bytes (sizeof)
	{
		struct                               // 5 elements, 0x8 bytes (sizeof)
		{
			/*0x000*/             UINT64       Locked : 1;         // 0 BitPosition
			/*0x000*/             UINT64       Waiting : 1;        // 1 BitPosition
			/*0x000*/             UINT64       Waking : 1;         // 2 BitPosition
			/*0x000*/             UINT64       MultipleShared : 1; // 3 BitPosition
			/*0x000*/             UINT64       Shared : 60;        // 4 BitPosition
		};
		/*0x000*/         UINT64       Value;
		/*0x000*/         VOID* Ptr;
	};
}/*EX_PUSH_LOCK, *PEX_PUSH_LOCK*/;

#ifndef _KTHREAD_S_
#define _KTHREAD_S_
typedef struct _RTL_RB_TREE
{
	/* 0x0000 */ struct _RTL_BALANCED_NODE* Root;
	union
	{
		/* 0x0008 */ unsigned char Encoded : 1; /* bit position: 0 */
		/* 0x0008 */ struct _RTL_BALANCED_NODE* Min;
	}; /* size: 0x0008 */
} RTL_RB_TREE, * PRTL_RB_TREE; /* size: 0x0010 */

typedef union _KLOCK_ENTRY_BOOST_BITMAP
{
	union
	{
		/* 0x0000 */ unsigned long AllFields;
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned long AllBoosts : 17; /* bit position: 0 */
			/* 0x0000 */ unsigned long Reserved : 15; /* bit position: 17 */
		}; /* bitfield */
		struct
		{
			struct /* bitfield */
			{
				/* 0x0000 */ unsigned short CpuBoostsBitmap : 15; /* bit position: 0 */
				/* 0x0000 */ unsigned short IoBoost : 1; /* bit position: 15 */
			}; /* bitfield */
			struct /* bitfield */
			{
				/* 0x0002 */ unsigned short IoQoSBoost : 1; /* bit position: 0 */
				/* 0x0002 */ unsigned short IoNormalPriorityWaiterCount : 8; /* bit position: 1 */
				/* 0x0002 */ unsigned short IoQoSWaiterCount : 7; /* bit position: 9 */
			}; /* bitfield */
		}; /* size: 0x0004 */
	}; /* size: 0x0004 */
} KLOCK_ENTRY_BOOST_BITMAP, * PKLOCK_ENTRY_BOOST_BITMAP; /* size: 0x0004 */

typedef struct _KLOCK_ENTRY_LOCK_STATE
{
	union
	{
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned __int64 CrossThreadReleasable : 1; /* bit position: 0 */
			/* 0x0000 */ unsigned __int64 Busy : 1; /* bit position: 1 */
			/* 0x0000 */ unsigned __int64 Reserved : 61; /* bit position: 2 */
			/* 0x0000 */ unsigned __int64 InTree : 1; /* bit position: 63 */
		}; /* bitfield */
		/* 0x0000 */ void* LockState;
	}; /* size: 0x0008 */
	union
	{
		/* 0x0008 */ void* SessionState;
		struct
		{
			/* 0x0008 */ unsigned long SessionId;
			/* 0x000c */ unsigned long SessionPad;
		}; /* size: 0x0008 */
	}; /* size: 0x0008 */
} KLOCK_ENTRY_LOCK_STATE, * PKLOCK_ENTRY_LOCK_STATE; /* size: 0x0010 */

typedef struct _KLOCK_ENTRY
{
	union
	{
		/* 0x0000 */ struct _RTL_BALANCED_NODE TreeNode;
		/* 0x0000 */ struct _SINGLE_LIST_ENTRY FreeListEntry;
	}; /* size: 0x0018 */
	union
	{
		/* 0x0018 */ unsigned long EntryFlags;
		struct
		{
			/* 0x0018 */ unsigned char EntryOffset;
			union
			{
				/* 0x0019 */ unsigned char ThreadLocalFlags;
				struct
				{
					struct /* bitfield */
					{
						/* 0x0019 */ unsigned char WaitingBit : 1; /* bit position: 0 */
						/* 0x0019 */ unsigned char Spare0 : 7; /* bit position: 1 */
					}; /* bitfield */
					union
					{
						/* 0x001a */ unsigned char AcquiredByte;
						struct
						{
							/* 0x001a */ unsigned char AcquiredBit : 1; /* bit position: 0 */
							union
							{
								/* 0x001b */ unsigned char CrossThreadFlags;
								struct /* bitfield */
								{
									/* 0x001b */ unsigned char HeadNodeBit : 1; /* bit position: 0 */
									/* 0x001b */ unsigned char IoPriorityBit : 1; /* bit position: 1 */
									/* 0x001b */ unsigned char IoQoSWaiter : 1; /* bit position: 2 */
									/* 0x001b */ unsigned char Spare1 : 5; /* bit position: 3 */
								}; /* bitfield */
							}; /* size: 0x0001 */
						}; /* size: 0x0002 */
					}; /* size: 0x0002 */
				}; /* size: 0x0003 */
			}; /* size: 0x0003 */
		}; /* size: 0x0004 */
		struct /* bitfield */
		{
			/* 0x0018 */ unsigned long StaticState : 8; /* bit position: 0 */
			/* 0x0018 */ unsigned long AllFlags : 24; /* bit position: 8 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x001c */ unsigned long SpareFlags;
	union
	{
		/* 0x0020 */ struct _KLOCK_ENTRY_LOCK_STATE LockState;
		/* 0x0020 */ void* volatile LockUnsafe;
		struct
		{
			/* 0x0020 */ volatile unsigned char CrossThreadReleasableAndBusyByte;
			/* 0x0021 */ unsigned char Reserved[6];
			/* 0x0027 */ volatile unsigned char InTreeByte;
			union
			{
				/* 0x0028 */ void* SessionState;
				struct
				{
					/* 0x0028 */ unsigned long SessionId;
					/* 0x002c */ unsigned long SessionPad;
				}; /* size: 0x0008 */
			}; /* size: 0x0008 */
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	union
	{
		struct
		{
			/* 0x0030 */ struct _RTL_RB_TREE OwnerTree;
			/* 0x0040 */ struct _RTL_RB_TREE WaiterTree;
		}; /* size: 0x0020 */
		/* 0x0030 */ char CpuPriorityKey;
	}; /* size: 0x0020 */
	/* 0x0050 */ unsigned __int64 EntryLock;
	/* 0x0058 */ union _KLOCK_ENTRY_BOOST_BITMAP BoostBitmap;
	/* 0x005c */ unsigned long SparePad;
} KLOCK_ENTRY, * PKLOCK_ENTRY; /* size: 0x0060 */

typedef struct _PS_PROPERTY_SET
{
	/* 0x0000 */ struct _LIST_ENTRY ListHead;
	/* 0x0010 */ unsigned __int64 Lock;
} PS_PROPERTY_SET, * PPS_PROPERTY_SET; /* size: 0x0018 */

typedef struct _KTHREAD_S
{
	/* 0x0000 */ struct _DISPATCHER_HEADER Header;
	/* 0x0018 */ void* SListFaultAddress;
	/* 0x0020 */ unsigned __int64 QuantumTarget;
	/* 0x0028 */ void* InitialStack;
	/* 0x0030 */ void* volatile StackLimit;
	/* 0x0038 */ void* StackBase;
	/* 0x0040 */ unsigned __int64 ThreadLock;
	/* 0x0048 */ volatile unsigned __int64 CycleTime;
	/* 0x0050 */ unsigned long CurrentRunTime;
	/* 0x0054 */ unsigned long ExpectedRunTime;
	/* 0x0058 */ void* KernelStack;
	/* 0x0060 */ struct _XSAVE_FORMAT* StateSaveArea;
	/* 0x0068 */ struct _KSCHEDULING_GROUP* volatile SchedulingGroup;
	/* 0x0070 */ union _KWAIT_STATUS_REGISTER WaitRegister;
	/* 0x0071 */ volatile unsigned char Running;
	/* 0x0072 */ unsigned char Alerted[2];
	union
	{
		struct /* bitfield */
		{
			/* 0x0074 */ unsigned long AutoBoostActive : 1; /* bit position: 0 */
			/* 0x0074 */ unsigned long ReadyTransition : 1; /* bit position: 1 */
			/* 0x0074 */ unsigned long WaitNext : 1; /* bit position: 2 */
			/* 0x0074 */ unsigned long SystemAffinityActive : 1; /* bit position: 3 */
			/* 0x0074 */ unsigned long Alertable : 1; /* bit position: 4 */
			/* 0x0074 */ unsigned long UserStackWalkActive : 1; /* bit position: 5 */
			/* 0x0074 */ unsigned long ApcInterruptRequest : 1; /* bit position: 6 */
			/* 0x0074 */ unsigned long QuantumEndMigrate : 1; /* bit position: 7 */
			/* 0x0074 */ unsigned long UmsDirectedSwitchEnable : 1; /* bit position: 8 */
			/* 0x0074 */ unsigned long TimerActive : 1; /* bit position: 9 */
			/* 0x0074 */ unsigned long SystemThread : 1; /* bit position: 10 */
			/* 0x0074 */ unsigned long ProcessDetachActive : 1; /* bit position: 11 */
			/* 0x0074 */ unsigned long CalloutActive : 1; /* bit position: 12 */
			/* 0x0074 */ unsigned long ScbReadyQueue : 1; /* bit position: 13 */
			/* 0x0074 */ unsigned long ApcQueueable : 1; /* bit position: 14 */
			/* 0x0074 */ unsigned long ReservedStackInUse : 1; /* bit position: 15 */
			/* 0x0074 */ unsigned long UmsPerformingSyscall : 1; /* bit position: 16 */
			/* 0x0074 */ unsigned long TimerSuspended : 1; /* bit position: 17 */
			/* 0x0074 */ unsigned long SuspendedWaitMode : 1; /* bit position: 18 */
			/* 0x0074 */ unsigned long SuspendSchedulerApcWait : 1; /* bit position: 19 */
			/* 0x0074 */ unsigned long CetUserShadowStack : 1; /* bit position: 20 */
			/* 0x0074 */ unsigned long BypassProcessFreeze : 1; /* bit position: 21 */
			/* 0x0074 */ unsigned long Reserved : 10; /* bit position: 22 */
		}; /* bitfield */
		/* 0x0074 */ long MiscFlags;
	}; /* size: 0x0004 */
	union
	{
		struct /* bitfield */
		{
			/* 0x0078 */ unsigned long ThreadFlagsSpare : 2; /* bit position: 0 */
			/* 0x0078 */ unsigned long AutoAlignment : 1; /* bit position: 2 */
			/* 0x0078 */ unsigned long DisableBoost : 1; /* bit position: 3 */
			/* 0x0078 */ unsigned long AlertedByThreadId : 1; /* bit position: 4 */
			/* 0x0078 */ unsigned long QuantumDonation : 1; /* bit position: 5 */
			/* 0x0078 */ unsigned long EnableStackSwap : 1; /* bit position: 6 */
			/* 0x0078 */ unsigned long GuiThread : 1; /* bit position: 7 */
			/* 0x0078 */ unsigned long DisableQuantum : 1; /* bit position: 8 */
			/* 0x0078 */ unsigned long ChargeOnlySchedulingGroup : 1; /* bit position: 9 */
			/* 0x0078 */ unsigned long DeferPreemption : 1; /* bit position: 10 */
			/* 0x0078 */ unsigned long QueueDeferPreemption : 1; /* bit position: 11 */
			/* 0x0078 */ unsigned long ForceDeferSchedule : 1; /* bit position: 12 */
			/* 0x0078 */ unsigned long SharedReadyQueueAffinity : 1; /* bit position: 13 */
			/* 0x0078 */ unsigned long FreezeCount : 1; /* bit position: 14 */
			/* 0x0078 */ unsigned long TerminationApcRequest : 1; /* bit position: 15 */
			/* 0x0078 */ unsigned long AutoBoostEntriesExhausted : 1; /* bit position: 16 */
			/* 0x0078 */ unsigned long KernelStackResident : 1; /* bit position: 17 */
			/* 0x0078 */ unsigned long TerminateRequestReason : 2; /* bit position: 18 */
			/* 0x0078 */ unsigned long ProcessStackCountDecremented : 1; /* bit position: 20 */
			/* 0x0078 */ unsigned long RestrictedGuiThread : 1; /* bit position: 21 */
			/* 0x0078 */ unsigned long VpBackingThread : 1; /* bit position: 22 */
			/* 0x0078 */ unsigned long ThreadFlagsSpare2 : 1; /* bit position: 23 */
			/* 0x0078 */ unsigned long EtwStackTraceApcInserted : 8; /* bit position: 24 */
		}; /* bitfield */
		/* 0x0078 */ volatile long ThreadFlags;
	}; /* size: 0x0004 */
	/* 0x007c */ volatile unsigned char Tag;
	/* 0x007d */ unsigned char SystemHeteroCpuPolicy;
	struct /* bitfield */
	{
		/* 0x007e */ unsigned char UserHeteroCpuPolicy : 7; /* bit position: 0 */
		/* 0x007e */ unsigned char ExplicitSystemHeteroCpuPolicy : 1; /* bit position: 7 */
	}; /* bitfield */
	union
	{
		struct /* bitfield */
		{
			/* 0x007f */ unsigned char RunningNonRetpolineCode : 1; /* bit position: 0 */
			/* 0x007f */ unsigned char SpecCtrlSpare : 7; /* bit position: 1 */
		}; /* bitfield */
		/* 0x007f */ unsigned char SpecCtrl;
	}; /* size: 0x0001 */
	/* 0x0080 */ unsigned long SystemCallNumber;
	/* 0x0084 */ unsigned long ReadyTime;
	/* 0x0088 */ void* FirstArgument;
	/* 0x0090 */ struct _KTRAP_FRAME* TrapFrame;
	union
	{
		/* 0x0098 */ struct _KAPC_STATE ApcState;
		struct
		{
			/* 0x0098 */ unsigned char ApcStateFill[43];
			/* 0x00c3 */ char Priority;
			/* 0x00c4 */ unsigned long UserIdealProcessor;
		}; /* size: 0x0030 */
	}; /* size: 0x0030 */
	/* 0x00c8 */ volatile __int64 WaitStatus;
	/* 0x00d0 */ struct _KWAIT_BLOCK* WaitBlockList;
	union
	{
		/* 0x00d8 */ struct _LIST_ENTRY WaitListEntry;
		/* 0x00d8 */ struct _SINGLE_LIST_ENTRY SwapListEntry;
	}; /* size: 0x0010 */
	/* 0x00e8 */ struct _DISPATCHER_HEADER* volatile Queue;
	/* 0x00f0 */ void* Teb;
	/* 0x00f8 */ unsigned __int64 RelativeTimerBias;
	/* 0x0100 */ struct _KTIMER Timer;
	union
	{
		/* 0x0140 */ struct _KWAIT_BLOCK WaitBlock[4];
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill4[20];
			/* 0x0154 */ unsigned long ContextSwitches;
		}; /* size: 0x0018 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill5[68];
			/* 0x0184 */ volatile unsigned char State;
			/* 0x0185 */ char Spare13;
			/* 0x0186 */ unsigned char WaitIrql;
			/* 0x0187 */ char WaitMode;
		}; /* size: 0x0048 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill6[116];
			/* 0x01b4 */ unsigned long WaitTime;
		}; /* size: 0x0078 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill7[164];
			union
			{
				struct
				{
					/* 0x01e4 */ short KernelApcDisable;
					/* 0x01e6 */ short SpecialApcDisable;
				}; /* size: 0x0004 */
				/* 0x01e4 */ unsigned long CombinedApcDisable;
			}; /* size: 0x0004 */
		}; /* size: 0x00a8 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill8[40];
			/* 0x0168 */ struct _KTHREAD_COUNTERS* ThreadCounters;
		}; /* size: 0x0030 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill9[88];
			/* 0x0198 */ struct _XSTATE_SAVE* XStateSave;
		}; /* size: 0x0060 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill10[136];
			/* 0x01c8 */ void* volatile Win32Thread;
		}; /* size: 0x0090 */
		struct
		{
			/* 0x0140 */ unsigned char WaitBlockFill11[176];
			/* 0x01f0 */ struct _UMS_CONTROL_BLOCK* Ucb;
			/* 0x01f8 */ struct _KUMS_CONTEXT_HEADER* volatile Uch;
		}; /* size: 0x00c0 */
	}; /* size: 0x00c0 */
	union
	{
		/* 0x0200 */ volatile long ThreadFlags2;
		struct /* bitfield */
		{
			/* 0x0200 */ unsigned long BamQosLevel : 8; /* bit position: 0 */
			/* 0x0200 */ unsigned long ThreadFlags2Reserved : 24; /* bit position: 8 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0204 */ unsigned long Spare21;
	/* 0x0208 */ struct _LIST_ENTRY QueueListEntry;
	union
	{
		/* 0x0218 */ volatile unsigned long NextProcessor;
		struct /* bitfield */
		{
			/* 0x0218 */ unsigned long NextProcessorNumber : 31; /* bit position: 0 */
			/* 0x0218 */ unsigned long SharedReadyQueue : 1; /* bit position: 31 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x021c */ long QueuePriority;
	/* 0x0220 */ struct _KPROCESS* Process;
	union
	{
		/* 0x0228 */ struct _GROUP_AFFINITY UserAffinity;
		struct
		{
			/* 0x0228 */ unsigned char UserAffinityFill[10];
			/* 0x0232 */ char PreviousMode;
			/* 0x0233 */ char BasePriority;
			union
			{
				/* 0x0234 */ char PriorityDecrement;
				struct /* bitfield */
				{
					/* 0x0234 */ unsigned char ForegroundBoost : 4; /* bit position: 0 */
					/* 0x0234 */ unsigned char UnusualBoost : 4; /* bit position: 4 */
				}; /* bitfield */
			}; /* size: 0x0001 */
			/* 0x0235 */ unsigned char Preempted;
			/* 0x0236 */ unsigned char AdjustReason;
			/* 0x0237 */ char AdjustIncrement;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0238 */ unsigned __int64 AffinityVersion;
	union
	{
		/* 0x0240 */ struct _GROUP_AFFINITY Affinity;
		struct
		{
			/* 0x0240 */ unsigned char AffinityFill[10];
			/* 0x024a */ unsigned char ApcStateIndex;
			/* 0x024b */ unsigned char WaitBlockCount;
			/* 0x024c */ unsigned long IdealProcessor;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0250 */ unsigned __int64 NpxState;
	union
	{
		/* 0x0258 */ struct _KAPC_STATE SavedApcState;
		struct
		{
			/* 0x0258 */ unsigned char SavedApcStateFill[43];
			/* 0x0283 */ unsigned char WaitReason;
			/* 0x0284 */ char SuspendCount;
			/* 0x0285 */ char Saturation;
			/* 0x0286 */ unsigned short SListFaultCount;
		}; /* size: 0x0030 */
	}; /* size: 0x0030 */
	union
	{
		/* 0x0288 */ struct _KAPC SchedulerApc;
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill0[1];
			/* 0x0289 */ unsigned char ResourceIndex;
		}; /* size: 0x0002 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill1[3];
			/* 0x028b */ unsigned char QuantumReset;
		}; /* size: 0x0004 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill2[4];
			/* 0x028c */ unsigned long KernelTime;
		}; /* size: 0x0008 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill3[64];
			/* 0x02c8 */ struct _KPRCB* volatile WaitPrcb;
		}; /* size: 0x0048 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill4[72];
			/* 0x02d0 */ void* LegoData;
		}; /* size: 0x0050 */
		struct
		{
			/* 0x0288 */ unsigned char SchedulerApcFill5[83];
			/* 0x02db */ unsigned char CallbackNestingLevel;
			/* 0x02dc */ unsigned long UserTime;
		}; /* size: 0x0058 */
	}; /* size: 0x0058 */
	/* 0x02e0 */ struct _KEVENT SuspendEvent;
	/* 0x02f8 */ struct _LIST_ENTRY ThreadListEntry;
	/* 0x0308 */ struct _LIST_ENTRY MutantListHead;
	/* 0x0318 */ unsigned char AbEntrySummary;
	/* 0x0319 */ unsigned char AbWaitEntryCount;
	/* 0x031a */ unsigned char AbAllocationRegionCount;
	/* 0x031b */ char SystemPriority;
	/* 0x031c */ unsigned long SecureThreadCookie;
	/* 0x0320 */ struct _KLOCK_ENTRY* LockEntries;
	/* 0x0328 */ struct _SINGLE_LIST_ENTRY PropagateBoostsEntry;
	/* 0x0330 */ struct _SINGLE_LIST_ENTRY IoSelfBoostsEntry;
	/* 0x0338 */ unsigned char PriorityFloorCounts[16];
	/* 0x0348 */ unsigned char PriorityFloorCountsReserved[16];
	/* 0x0358 */ unsigned long PriorityFloorSummary;
	/* 0x035c */ volatile long AbCompletedIoBoostCount;
	/* 0x0360 */ volatile long AbCompletedIoQoSBoostCount;
	/* 0x0364 */ volatile short KeReferenceCount;
	/* 0x0366 */ unsigned char AbOrphanedEntrySummary;
	/* 0x0367 */ unsigned char AbOwnedEntryCount;
	/* 0x0368 */ unsigned long ForegroundLossTime;
	/* 0x036c */ long Padding_0;
	union
	{
		/* 0x0370 */ struct _LIST_ENTRY GlobalForegroundListEntry;
		struct
		{
			/* 0x0370 */ struct _SINGLE_LIST_ENTRY ForegroundDpcStackListEntry;
			/* 0x0378 */ unsigned __int64 InGlobalForegroundList;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0380 */ __int64 ReadOperationCount;
	/* 0x0388 */ __int64 WriteOperationCount;
	/* 0x0390 */ __int64 OtherOperationCount;
	/* 0x0398 */ __int64 ReadTransferCount;
	/* 0x03a0 */ __int64 WriteTransferCount;
	/* 0x03a8 */ __int64 OtherTransferCount;
	/* 0x03b0 */ struct _KSCB* QueuedScb;
	/* 0x03b8 */ volatile unsigned long ThreadTimerDelay;
	union
	{
		/* 0x03bc */ volatile long ThreadFlags3;
		struct /* bitfield */
		{
			/* 0x03bc */ unsigned long ThreadFlags3Reserved : 8; /* bit position: 0 */
			/* 0x03bc */ unsigned long PpmPolicy : 2; /* bit position: 8 */
			/* 0x03bc */ unsigned long ThreadFlags3Reserved2 : 22; /* bit position: 10 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x03c0 */ unsigned __int64 TracingPrivate[1];
	/* 0x03c8 */ void* SchedulerAssist;
	/* 0x03d0 */ void* volatile AbWaitObject;
	/* 0x03d8 */ unsigned long ReservedPreviousReadyTimeValue;
	/* 0x03dc */ long Padding_1;
	/* 0x03e0 */ unsigned __int64 KernelWaitTime;
	/* 0x03e8 */ unsigned __int64 UserWaitTime;
	union
	{
		/* 0x03f0 */ struct _LIST_ENTRY GlobalUpdateVpThreadPriorityListEntry;
		struct
		{
			/* 0x03f0 */ struct _SINGLE_LIST_ENTRY UpdateVpThreadPriorityDpcStackListEntry;
			/* 0x03f8 */ unsigned __int64 InGlobalUpdateVpThreadPriorityList;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0400 */ long SchedulerAssistPriorityFloor;
	/* 0x0404 */ unsigned long Spare28;
	/* 0x0408 */ unsigned __int64 EndPadding[5];
} KTHREAD_S, * PKTHREAD_S; /* size: 0x0430 */

typedef struct _ETHREAD_S
{
	/* 0x0000 */ struct _KTHREAD_S Tcb;
	/* 0x0430 */ union _LARGE_INTEGER CreateTime;
	union
	{
		/* 0x0438 */ union _LARGE_INTEGER ExitTime;
		/* 0x0438 */ struct _LIST_ENTRY KeyedWaitChain;
	}; /* size: 0x0010 */
	union
	{
		/* 0x0448 */ struct _LIST_ENTRY PostBlockList;
		struct
		{
			/* 0x0448 */ void* ForwardLinkShadow;
			/* 0x0450 */ void* StartAddress;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	union
	{
		/* 0x0458 */ struct _TERMINATION_PORT* TerminationPort;
		/* 0x0458 */ struct _ETHREAD* ReaperLink;
		/* 0x0458 */ void* KeyedWaitValue;
	}; /* size: 0x0008 */
	/* 0x0460 */ unsigned __int64 ActiveTimerListLock;
	/* 0x0468 */ struct _LIST_ENTRY ActiveTimerListHead;
	/* 0x0478 */ struct _CLIENT_ID Cid;
	union
	{
		/* 0x0488 */ struct _KSEMAPHORE KeyedWaitSemaphore;
		/* 0x0488 */ struct _KSEMAPHORE AlpcWaitSemaphore;
	}; /* size: 0x0020 */
	/* 0x04a8 */ union _PS_CLIENT_SECURITY_CONTEXT ClientSecurity;
	/* 0x04b0 */ struct _LIST_ENTRY IrpList;
	/* 0x04c0 */ unsigned __int64 TopLevelIrp;
	/* 0x04c8 */ struct _DEVICE_OBJECT* DeviceToVerify;
	/* 0x04d0 */ void* Win32StartAddress;
	/* 0x04d8 */ void* ChargeOnlySession;
	/* 0x04e0 */ void* LegacyPowerObject;
	/* 0x04e8 */ struct _LIST_ENTRY ThreadListEntry;
	/* 0x04f8 */ struct _EX_RUNDOWN_REF RundownProtect;
	/* 0x0500 */ struct _EX_PUSH_LOCK ThreadLock;
	/* 0x0508 */ unsigned long ReadClusterSize;
	/* 0x050c */ volatile long MmLockOrdering;
	union
	{
		/* 0x0510 */ unsigned long CrossThreadFlags;
		struct /* bitfield */
		{
			/* 0x0510 */ unsigned long Terminated : 1; /* bit position: 0 */
			/* 0x0510 */ unsigned long ThreadInserted : 1; /* bit position: 1 */
			/* 0x0510 */ unsigned long HideFromDebugger : 1; /* bit position: 2 */
			/* 0x0510 */ unsigned long ActiveImpersonationInfo : 1; /* bit position: 3 */
			/* 0x0510 */ unsigned long HardErrorsAreDisabled : 1; /* bit position: 4 */
			/* 0x0510 */ unsigned long BreakOnTermination : 1; /* bit position: 5 */
			/* 0x0510 */ unsigned long SkipCreationMsg : 1; /* bit position: 6 */
			/* 0x0510 */ unsigned long SkipTerminationMsg : 1; /* bit position: 7 */
			/* 0x0510 */ unsigned long CopyTokenOnOpen : 1; /* bit position: 8 */
			/* 0x0510 */ unsigned long ThreadIoPriority : 3; /* bit position: 9 */
			/* 0x0510 */ unsigned long ThreadPagePriority : 3; /* bit position: 12 */
			/* 0x0510 */ unsigned long RundownFail : 1; /* bit position: 15 */
			/* 0x0510 */ unsigned long UmsForceQueueTermination : 1; /* bit position: 16 */
			/* 0x0510 */ unsigned long IndirectCpuSets : 1; /* bit position: 17 */
			/* 0x0510 */ unsigned long DisableDynamicCodeOptOut : 1; /* bit position: 18 */
			/* 0x0510 */ unsigned long ExplicitCaseSensitivity : 1; /* bit position: 19 */
			/* 0x0510 */ unsigned long PicoNotifyExit : 1; /* bit position: 20 */
			/* 0x0510 */ unsigned long DbgWerUserReportActive : 1; /* bit position: 21 */
			/* 0x0510 */ unsigned long ForcedSelfTrimActive : 1; /* bit position: 22 */
			/* 0x0510 */ unsigned long SamplingCoverage : 1; /* bit position: 23 */
			/* 0x0510 */ unsigned long ReservedCrossThreadFlags : 8; /* bit position: 24 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	union
	{
		/* 0x0514 */ unsigned long SameThreadPassiveFlags;
		struct /* bitfield */
		{
			/* 0x0514 */ unsigned long ActiveExWorker : 1; /* bit position: 0 */
			/* 0x0514 */ unsigned long MemoryMaker : 1; /* bit position: 1 */
			/* 0x0514 */ unsigned long StoreLockThread : 2; /* bit position: 2 */
			/* 0x0514 */ unsigned long ClonedThread : 1; /* bit position: 4 */
			/* 0x0514 */ unsigned long KeyedEventInUse : 1; /* bit position: 5 */
			/* 0x0514 */ unsigned long SelfTerminate : 1; /* bit position: 6 */
			/* 0x0514 */ unsigned long RespectIoPriority : 1; /* bit position: 7 */
			/* 0x0514 */ unsigned long ActivePageLists : 1; /* bit position: 8 */
			/* 0x0514 */ unsigned long SecureContext : 1; /* bit position: 9 */
			/* 0x0514 */ unsigned long ZeroPageThread : 1; /* bit position: 10 */
			/* 0x0514 */ unsigned long WorkloadClass : 1; /* bit position: 11 */
			/* 0x0514 */ unsigned long ReservedSameThreadPassiveFlags : 20; /* bit position: 12 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	union
	{
		/* 0x0518 */ unsigned long SameThreadApcFlags;
		struct
		{
			struct /* bitfield */
			{
				/* 0x0518 */ unsigned char OwnsProcessAddressSpaceExclusive : 1; /* bit position: 0 */
				/* 0x0518 */ unsigned char OwnsProcessAddressSpaceShared : 1; /* bit position: 1 */
				/* 0x0518 */ unsigned char HardFaultBehavior : 1; /* bit position: 2 */
				/* 0x0518 */ volatile unsigned char StartAddressInvalid : 1; /* bit position: 3 */
				/* 0x0518 */ unsigned char EtwCalloutActive : 1; /* bit position: 4 */
				/* 0x0518 */ unsigned char SuppressSymbolLoad : 1; /* bit position: 5 */
				/* 0x0518 */ unsigned char Prefetching : 1; /* bit position: 6 */
				/* 0x0518 */ unsigned char OwnsVadExclusive : 1; /* bit position: 7 */
			}; /* bitfield */
			struct /* bitfield */
			{
				/* 0x0519 */ unsigned char SystemPagePriorityActive : 1; /* bit position: 0 */
				/* 0x0519 */ unsigned char SystemPagePriority : 3; /* bit position: 1 */
				/* 0x0519 */ unsigned char AllowUserWritesToExecutableMemory : 1; /* bit position: 4 */
				/* 0x0519 */ unsigned char AllowKernelWritesToExecutableMemory : 1; /* bit position: 5 */
				/* 0x0519 */ unsigned char OwnsVadShared : 1; /* bit position: 6 */
			}; /* bitfield */
		}; /* size: 0x0002 */
	}; /* size: 0x0004 */
	/* 0x051c */ unsigned char CacheManagerActive;
	/* 0x051d */ unsigned char DisablePageFaultClustering;
	/* 0x051e */ unsigned char ActiveFaultCount;
	/* 0x051f */ unsigned char LockOrderState;
	/* 0x0520 */ unsigned long PerformanceCountLowReserved;
	/* 0x0524 */ long PerformanceCountHighReserved;
	/* 0x0528 */ unsigned __int64 AlpcMessageId;
	union
	{
		/* 0x0530 */ void* AlpcMessage;
		/* 0x0530 */ unsigned long AlpcReceiveAttributeSet;
	}; /* size: 0x0008 */
	/* 0x0538 */ struct _LIST_ENTRY AlpcWaitListEntry;
	/* 0x0548 */ long ExitStatus;
	/* 0x054c */ unsigned long CacheManagerCount;
	/* 0x0550 */ unsigned long IoBoostCount;
	/* 0x0554 */ unsigned long IoQoSBoostCount;
	/* 0x0558 */ unsigned long IoQoSThrottleCount;
	/* 0x055c */ unsigned long KernelStackReference;
	/* 0x0560 */ struct _LIST_ENTRY BoostList;
	/* 0x0570 */ struct _LIST_ENTRY DeboostList;
	/* 0x0580 */ unsigned __int64 BoostListLock;
	/* 0x0588 */ unsigned __int64 IrpListLock;
	/* 0x0590 */ void* ReservedForSynchTracking;
	/* 0x0598 */ struct _SINGLE_LIST_ENTRY CmCallbackListHead;
	/* 0x05a0 */ const struct _GUID* ActivityId;
	/* 0x05a8 */ struct _SINGLE_LIST_ENTRY SeLearningModeListHead;
	/* 0x05b0 */ void* VerifierContext;
	/* 0x05b8 */ void* AdjustedClientToken;
	/* 0x05c0 */ void* WorkOnBehalfThread;
	/* 0x05c8 */ struct _PS_PROPERTY_SET PropertySet;
	/* 0x05e0 */ void* PicoContext;
	/* 0x05e8 */ unsigned __int64 UserFsBase;
	/* 0x05f0 */ unsigned __int64 UserGsBase;
	/* 0x05f8 */ struct _THREAD_ENERGY_VALUES* EnergyValues;
	union
	{
		/* 0x0600 */ unsigned __int64 SelectedCpuSets;
		/* 0x0600 */ unsigned __int64* SelectedCpuSetsIndirect;
	}; /* size: 0x0008 */
	/* 0x0608 */ struct _EJOB* Silo;
	/* 0x0610 */ struct _UNICODE_STRING* ThreadName;
	/* 0x0618 */ struct _CONTEXT* SetContextState;
	/* 0x0620 */ unsigned long LastExpectedRunTime;
	/* 0x0624 */ unsigned long HeapData;
	/* 0x0628 */ struct _LIST_ENTRY OwnerEntryListHead;
	/* 0x0638 */ unsigned __int64 DisownedOwnerEntryListLock;
	/* 0x0640 */ struct _LIST_ENTRY DisownedOwnerEntryListHead;
	/* 0x0650 */ struct _KLOCK_ENTRY LockEntries[6];
	/* 0x0890 */ void* CmDbgInfo;
} ETHREAD_S, * PETHREAD_S; /* size: 0x0898 */
#endif // !_KTHREAD_S_




typedef struct _OBJECT_TYPE_INITIALIZER_S                                                                                                                                      // 25 elements, 0x70 bytes (sizeof)
{
	/*0x000*/     UINT16       Length;
	union                                                                                                                                                                       // 2 elements, 0x1 bytes (sizeof)
	{
		/*0x002*/         UINT16        ObjectTypeFlags;
		struct                                                                                                                                                                  // 7 elements, 0x1 bytes (sizeof)
		{
			/*0x002*/             UINT8        CaseInsensitive : 1;                                                                                                                                   // 0 BitPosition
			/*0x002*/             UINT8        UnnamedObjectsOnly : 1;                                                                                                                                // 1 BitPosition
			/*0x002*/             UINT8        UseDefaultObject : 1;                                                                                                                                  // 2 BitPosition
			/*0x002*/             UINT8        SecurityRequired : 1;                                                                                                                                  // 3 BitPosition
			/*0x002*/             UINT8        MaintainHandleCount : 1;                                                                                                                               // 4 BitPosition
			/*0x002*/             UINT8        MaintainTypeList : 1;                                                                                                                                  // 5 BitPosition
			/*0x002*/             UINT8        SupportsObjectCallbacks : 1;                                                                                                                           // 6 BitPosition
		};
	};
	/*0x004*/     ULONG32      ObjectTypeCode;
	/*0x008*/     ULONG32      InvalidAttributes;
	/*0x00C*/     struct _GENERIC_MAPPING GenericMapping;                                                                                                                                     // 4 elements, 0x10 bytes (sizeof)
	/*0x01C*/     ULONG32      ValidAccessMask;
	/*0x020*/     ULONG32      RetainAccess;
	/*0x024*/     enum _POOL_TYPE PoolType;
	/*0x028*/     ULONG32      DefaultPagedPoolCharge;
	/*0x02C*/     ULONG32      DefaultNonPagedPoolCharge;
	/*0x030*/     PVOID DumpProcedure;
	/*0x038*/     PVOID OpenProcedure;
	/*0x040*/     PVOID CloseProcedure;
	/*0x048*/     PVOID DeleteProcedure;
	/*0x050*/     PVOID ParseProcedure;
	/*0x058*/     PVOID SecurityProcedure;
	/*0x060*/     PVOID QueryNameProcedure;
	/*0x068*/     PVOID OkayToCloseProcedure;
}OBJECT_TYPE_INITIALIZER_S, *POBJECT_TYPE_INITIALIZER_S;

/*
+0x000 Length           : Uint2B
+ 0x002 ObjectTypeFlags : Uint2B
+ 0x002 CaseInsensitive : Pos 0, 1 Bit
+ 0x002 UnnamedObjectsOnly : Pos 1, 1 Bit
+ 0x002 UseDefaultObject : Pos 2, 1 Bit
+ 0x002 SecurityRequired : Pos 3, 1 Bit
+ 0x002 MaintainHandleCount : Pos 4, 1 Bit
+ 0x002 MaintainTypeList : Pos 5, 1 Bit
+ 0x002 SupportsObjectCallbacks : Pos 6, 1 Bit
+ 0x002 CacheAligned : Pos 7, 1 Bit
+ 0x003 UseExtendedParameters : Pos 0, 1 Bit
+ 0x003 Reserved : Pos 1, 7 Bits
+ 0x004 ObjectTypeCode : Uint4B
+ 0x008 InvalidAttributes : Uint4B
+ 0x00c GenericMapping : _GENERIC_MAPPING
+ 0x01c ValidAccessMask : Uint4B
+ 0x020 RetainAccess : Uint4B
+ 0x024 PoolType : _POOL_TYPE
+ 0x028 DefaultPagedPoolCharge : Uint4B
+ 0x02c DefaultNonPagedPoolCharge : Uint4B
+ 0x030 DumpProcedure : Ptr64     void
+ 0x038 OpenProcedure : Ptr64     long
+ 0x040 CloseProcedure : Ptr64     void
+ 0x048 DeleteProcedure : Ptr64     void
+ 0x050 ParseProcedure : Ptr64     long
+ 0x050 ParseProcedureEx : Ptr64     long
+ 0x058 SecurityProcedure : Ptr64     long
+ 0x060 QueryNameProcedure : Ptr64     long
+ 0x068 OkayToCloseProcedure : Ptr64     unsigned char
+ 0x070 WaitObjectFlagMask : Uint4B
+ 0x074 WaitObjectFlagOffset : Uint2B
+ 0x076 WaitObjectPointerOffset : Uint2B
*/

typedef struct _OBJECT_TYPE_S                   // 12 elements, 0xD0 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY TypeList;              // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _UNICODE_STRING Name;              // 3 elements, 0x10 bytes (sizeof)
	/*0x020*/     VOID* DefaultObject;
	/*0x028*/     UINT8        Index;
	/*0x029*/     UINT8        _PADDING0_[0x3];
	/*0x02C*/     ULONG32      TotalNumberOfObjects;
	/*0x030*/     ULONG32      TotalNumberOfHandles;
	/*0x034*/     ULONG32      HighWaterNumberOfObjects;
	/*0x038*/     ULONG32      HighWaterNumberOfHandles;
	/*0x03C*/     UINT8        _PADDING1_[0x4];
	/*0x040*/     struct _OBJECT_TYPE_INITIALIZER_S TypeInfo; // 25 elements, 0x70 bytes (sizeof)
	/*0x0B0*/     struct _EX_PUSH_LOCK TypeLock;            // 7 elements, 0x8 bytes (sizeof)
	/*0x0B8*/     ULONG32      Key;
	/*0x0BC*/     UINT8        _PADDING2_[0x4];
	/*0x0C0*/     struct _LIST_ENTRY CallbackList;          // 2 elements, 0x10 bytes (sizeof)
}OBJECT_TYPE_S, * POBJECT_TYPE_S;

/*
+0x000 TypeList         : _LIST_ENTRY
+ 0x010 Name : _UNICODE_STRING
+ 0x020 DefaultObject : Ptr64 Void
+ 0x028 Index : UChar
+ 0x02c TotalNumberOfObjects : Uint4B
+ 0x030 TotalNumberOfHandles : Uint4B
+ 0x034 HighWaterNumberOfObjects : Uint4B
+ 0x038 HighWaterNumberOfHandles : Uint4B
+ 0x040 TypeInfo : _OBJECT_TYPE_INITIALIZER
+ 0x0b8 TypeLock : _EX_PUSH_LOCK
+ 0x0c0 Key : Uint4B
+ 0x0c8 CallbackList : _LIST_ENTRY
*/

#ifndef _MODULE_INFO_
#define _MODULE_INFO_
typedef struct _MODULE_INFO
{
	ULONG64			UnKown1;
	UNICODE_STRING	FileName;		//+0x4
	PVOID			BaseOfDll;		//+0xC
	wchar_t* Buffer;			//+0x10
	//...
}MODULE_INFO, * PMODULE_INFO;
#endif // !_MODULE_INFO_

#ifndef _SYSTEM_DLL_
#define _SYSTEM_DLL_
typedef struct _SYSTEM_DLL
{
	EX_FAST_REF		FastRef;
	EX_PUSH_LOCK	Lock;
	MODULE_INFO		ModuleInfo;
}SYSTEM_DLL, * PSYSTEM_DLL;
#endif // !_SYSTEM_DLL_

typedef NTSTATUS
(*OBCREATEOBJECTTYPE)(
PUNICODE_STRING usTypeName,
POBJECT_TYPE_INITIALIZER_S ObjectTypeInit,
PVOID	Reserved,
POBJECT_TYPE *ObjectType);

#ifndef _KAFFINITY_EX_
#define _KAFFINITY_EX_
typedef struct _KAFFINITY_EX // 4 elements, 0x28 bytes (sizeof)
{
	/*0x000*/     UINT16       Count;
	/*0x002*/     UINT16       Size;
	/*0x004*/     ULONG32      Reserved;
	/*0x008*/     UINT64       Bitmap[4];
}KAFFINITY_EX, * PKAFFINITY_EX;
#endif // !_KAFFINITY_EX_

typedef struct _KGUARDED_MUTEX64              // 7 elements, 0x38 bytes (sizeof)
{
	/*0x000*/     LONG32       Count;
	/*0x004*/     UINT8        _PADDING0_[0x4];
	/*0x008*/     ULONG64 Owner;
	/*0x010*/     ULONG32      Contention;
	/*0x014*/     UINT8        _PADDING1_[0x4];
	/*0x018*/     struct _KGATE Gate;                     // 1 elements, 0x18 bytes (sizeof)
	union                                   // 2 elements, 0x8 bytes (sizeof)
	{
		struct                              // 2 elements, 0x8 bytes (sizeof)
		{
			/*0x030*/             INT16        KernelApcDisable;
			/*0x032*/             INT16        SpecialApcDisable;
			/*0x034*/             UINT8        _PADDING2_[0x4];
		};
		/*0x030*/         ULONG32      CombinedApcDisable;
	};
}KGUARDED_MUTEX64, *PKGUARDED_MUTEX64;

typedef union _KGDTENTRY64 {
	struct {
		USHORT  LimitLow;
		USHORT  BaseLow;
		union {
			struct {
				UCHAR   BaseMiddle;
				UCHAR   Flags1;
				UCHAR   Flags2;
				UCHAR   BaseHigh;
			} Bytes;

			struct {
				ULONG   BaseMiddle : 8;
				ULONG   Type : 5;//把S位包含进去了，也就是是否为系统段描述符的位。
				ULONG   Dpl : 2;
				ULONG   Present : 1;
				ULONG   LimitHigh : 4;
				ULONG   System : 1;//即AVL，系统软件自定义的。
				ULONG   LongMode : 1;
				ULONG   DefaultBig : 1;//即INTEL的D/B (default operation size/default stack pointer size and/or upper bound) flag。
				ULONG   Granularity : 1;
				ULONG   BaseHigh : 8;
			} Bits;
		};

		ULONG BaseUpper;
		ULONG MustBeZero;
	};

	ULONG64 Alignment;
} KGDTENTRY64, *PKGDTENTRY64;

typedef struct _PS_PER_CPU_QUOTA_CACHE_AWARE // 5 elements, 0x40 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY SortedListEntry;      // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _LIST_ENTRY IdleOnlyListHead;     // 2 elements, 0x10 bytes (sizeof)
	/*0x020*/     UINT64       CycleBaseAllowance;
	/*0x028*/     INT64        CyclesRemaining;
	/*0x030*/     ULONG32      CurrentGeneration;
	/*0x034*/     UINT8        _PADDING0_[0xC];
}PS_PER_CPU_QUOTA_CACHE_AWARE, *PPS_PER_CPU_QUOTA_CACHE_AWARE;

#ifndef _MMADDRESS_NODE_
#define _MMADDRESS_NODE_
typedef struct _MMADDRESS_NODE          // 5 elements, 0x28 bytes (sizeof)
{
	union                               // 2 elements, 0x8 bytes (sizeof)
	{
		/*0x000*/         INT64        Balance : 2;       // 0 BitPosition
		/*0x000*/         struct _MMADDRESS_NODE* Parent;
	}u1;
	/*0x008*/     struct _MMADDRESS_NODE* LeftChild;
	/*0x010*/     struct _MMADDRESS_NODE* RightChild;
	/*0x018*/     UINT64       StartingVpn;
	/*0x020*/     UINT64       EndingVpn;
}MMADDRESS_NODE, * PMMADDRESS_NODE;
#endif // !_MMADDRESS_NODE_

typedef struct _MM_AVL_TABLE                          // 6 elements, 0x40 bytes (sizeof)
{
	/*0x000*/     struct _MMADDRESS_NODE BalancedRoot;              // 5 elements, 0x28 bytes (sizeof)
	struct                                            // 3 elements, 0x8 bytes (sizeof)
	{
		/*0x028*/         UINT64       DepthOfTree : 5;                 // 0 BitPosition
		/*0x028*/         UINT64       Unused : 3;                      // 5 BitPosition
		/*0x028*/         UINT64       NumberGenericTableElements : 56; // 8 BitPosition
	};
	/*0x030*/     VOID*        NodeHint;
	/*0x038*/     VOID*        NodeFreeHint;
}MM_AVL_TABLE, *PMM_AVL_TABLE;

typedef struct _PS_CPU_QUOTA_BLOCK                                        // 14 elements, 0x4080 bytes (sizeof)
{
	union                                                                 // 2 elements, 0x40 bytes (sizeof)
	{
		struct                                                            // 5 elements, 0x40 bytes (sizeof)
		{
			/*0x000*/             struct _LIST_ENTRY ListEntry;                                 // 2 elements, 0x10 bytes (sizeof)
			/*0x010*/             ULONG32      SessionId;
			/*0x014*/             ULONG32      CpuShareWeight;
			/*0x018*/             CHAR CapturedWeightData[0x8]; // 3 elements, 0x8 bytes (sizeof)
			union                                                         // 2 elements, 0x4 bytes (sizeof)
			{
				struct                                                    // 2 elements, 0x4 bytes (sizeof)
				{
					/*0x020*/                     ULONG32      DuplicateInputMarker : 1;                // 0 BitPosition
					/*0x020*/                     ULONG32      Reserved : 31;                           // 1 BitPosition
				};
				/*0x020*/                 LONG32       MiscFlags;
			};
		};
		struct                                                            // 2 elements, 0x40 bytes (sizeof)
		{
			/*0x000*/             UINT64       BlockCurrentGenerationLock;
			/*0x008*/             UINT64       CyclesAccumulated;
			/*0x010*/             UINT8        _PADDING0_[0x30];
		};
	};
	/*0x040*/     UINT64       CycleCredit;
	/*0x048*/     ULONG32      BlockCurrentGeneration;
	/*0x04C*/     ULONG32      CpuCyclePercent;
	/*0x050*/     UINT8        CyclesFinishedForCurrentGeneration;
	/*0x051*/     UINT8        _PADDING1_[0x2F];
	/*0x080*/     struct _PS_PER_CPU_QUOTA_CACHE_AWARE Cpu[256];
}PS_CPU_QUOTA_BLOCK, *PPS_CPU_QUOTA_BLOCK;

typedef struct _EJOB                                // 42 elements, 0x1C8 bytes (sizeof)
{
	/*0x000*/     struct _KEVENT Event;                           // 1 elements, 0x18 bytes (sizeof)
	/*0x018*/     struct _LIST_ENTRY JobLinks;                    // 2 elements, 0x10 bytes (sizeof)
	/*0x028*/     struct _LIST_ENTRY ProcessListHead;             // 2 elements, 0x10 bytes (sizeof)
	/*0x038*/     struct _ERESOURCE JobLock;                      // 15 elements, 0x68 bytes (sizeof)
	/*0x0A0*/     union _LARGE_INTEGER TotalUserTime;             // 4 elements, 0x8 bytes (sizeof)
	/*0x0A8*/     union _LARGE_INTEGER TotalKernelTime;           // 4 elements, 0x8 bytes (sizeof)
	/*0x0B0*/     union _LARGE_INTEGER ThisPeriodTotalUserTime;   // 4 elements, 0x8 bytes (sizeof)
	/*0x0B8*/     union _LARGE_INTEGER ThisPeriodTotalKernelTime; // 4 elements, 0x8 bytes (sizeof)
	/*0x0C0*/     ULONG32      TotalPageFaultCount;
	/*0x0C4*/     ULONG32      TotalProcesses;
	/*0x0C8*/     ULONG32      ActiveProcesses;
	/*0x0CC*/     ULONG32      TotalTerminatedProcesses;
	/*0x0D0*/     union _LARGE_INTEGER PerProcessUserTimeLimit;   // 4 elements, 0x8 bytes (sizeof)
	/*0x0D8*/     union _LARGE_INTEGER PerJobUserTimeLimit;       // 4 elements, 0x8 bytes (sizeof)
	/*0x0E0*/     UINT64       MinimumWorkingSetSize;
	/*0x0E8*/     UINT64       MaximumWorkingSetSize;
	/*0x0F0*/     ULONG32      LimitFlags;
	/*0x0F4*/     ULONG32      ActiveProcessLimit;
	/*0x0F8*/     struct _KAFFINITY_EX Affinity;                  // 4 elements, 0x28 bytes (sizeof)
	/*0x120*/     UINT8        PriorityClass;
	/*0x121*/     UINT8        _PADDING0_[0x7];
	/*0x128*/     ULONG64 AccessState;
	/*0x130*/     ULONG32      UIRestrictionsClass;
	/*0x134*/     ULONG32      EndOfJobTimeAction;
	/*0x138*/     VOID*        CompletionPort;
	/*0x140*/     VOID*        CompletionKey;
	/*0x148*/     ULONG32      SessionId;
	/*0x14C*/     ULONG32      SchedulingClass;
	/*0x150*/     UINT64       ReadOperationCount;
	/*0x158*/     UINT64       WriteOperationCount;
	/*0x160*/     UINT64       OtherOperationCount;
	/*0x168*/     UINT64       ReadTransferCount;
	/*0x170*/     UINT64       WriteTransferCount;
	/*0x178*/     UINT64       OtherTransferCount;
	/*0x180*/     UINT64       ProcessMemoryLimit;
	/*0x188*/     UINT64       JobMemoryLimit;
	/*0x190*/     UINT64       PeakProcessMemoryUsed;
	/*0x198*/     UINT64       PeakJobMemoryUsed;
	/*0x1A0*/     UINT64       CurrentJobMemoryUsed;
	/*0x1A8*/     struct _EX_PUSH_LOCK MemoryLimitsLock;          // 7 elements, 0x8 bytes (sizeof)
	/*0x1B0*/     struct _LIST_ENTRY JobSetLinks;                 // 2 elements, 0x10 bytes (sizeof)
	/*0x1C0*/     ULONG32      MemberLevel;
	/*0x1C4*/     ULONG32      JobFlags;
}EJOB, *PEJOB;

typedef struct _HARDWARE_PTE
{
	ULONG64 Valid : 1;
	ULONG64 Write : 1;
	ULONG64 Owner : 1;
	ULONG64 WriteThrough : 1;
	ULONG64 CacheDisable : 1;
	ULONG64 Accessed : 1;
	ULONG64 Dirty : 1;
	ULONG64 LargePage : 1;
	ULONG64 Global : 1;
	ULONG64 CopyOnWrite : 1;
	ULONG64 Prototype : 1;
	ULONG64 reserved0 : 1;
	ULONG64 PageFrameNumber : 28;
	ULONG64 reserved1 : 12;
	ULONG64 SoftwareWsIndex : 11;
	ULONG64 NoExecute : 1;
} HARDWARE_PTE, *PHARDWARE_PTE;

typedef struct _MMWSLE_NONDIRECT_HASH // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     VOID*        Key;
	/*0x008*/     ULONG32      Index;
	/*0x00C*/     UINT8        _PADDING0_[0x4];
}MMWSLE_NONDIRECT_HASH, *PMMWSLE_NONDIRECT_HASH;

typedef struct _MMWSLENTRY               // 7 elements, 0x8 bytes (sizeof)
{
	/*0x000*/     UINT64       Valid : 1;              // 0 BitPosition
	/*0x000*/     UINT64       Spare : 1;              // 1 BitPosition
	/*0x000*/     UINT64       Hashed : 1;             // 2 BitPosition
	/*0x000*/     UINT64       Direct : 1;             // 3 BitPosition
	/*0x000*/     UINT64       Protection : 5;         // 4 BitPosition
	/*0x000*/     UINT64       Age : 3;                // 9 BitPosition
	/*0x000*/     UINT64       VirtualPageNumber : 52; // 12 BitPosition
}MMWSLENTRY, *PMMWSLENTRY;

typedef struct _MMWSLE_FREE_ENTRY   // 3 elements, 0x8 bytes (sizeof)
{
	/*0x000*/     UINT64       MustBeZero : 1;    // 0 BitPosition
	/*0x000*/     UINT64       PreviousFree : 31; // 1 BitPosition
	/*0x000*/     UINT64       NextFree : 32;     // 32 BitPosition
}MMWSLE_FREE_ENTRY, *PMMWSLE_FREE_ENTRY;

typedef struct _MMWSLE                // 1 elements, 0x8 bytes (sizeof)
{
	union                             // 4 elements, 0x8 bytes (sizeof)
	{
		/*0x000*/         VOID*        VirtualAddress;
		/*0x000*/         UINT64       Long;
		/*0x000*/         struct _MMWSLENTRY e1;        // 7 elements, 0x8 bytes (sizeof)
		/*0x000*/         struct _MMWSLE_FREE_ENTRY e2; // 3 elements, 0x8 bytes (sizeof)
	}u1;
}MMWSLE, *PMMWSLE;

typedef struct _MMWSLE_HASH // 1 elements, 0x4 bytes (sizeof)
{
	/*0x000*/     ULONG32      Index;
}MMWSLE_HASH, *PMMWSLE_HASH;

typedef struct _MMWSL                                   // 25 elements, 0x488 bytes (sizeof)
{
	/*0x000*/     ULONG32      FirstFree;
	/*0x004*/     ULONG32      FirstDynamic;
	/*0x008*/     ULONG32      LastEntry;
	/*0x00C*/     ULONG32      NextSlot;
	/*0x010*/     struct _MMWSLE* Wsle;
	/*0x018*/     VOID*        LowestPagableAddress;
	/*0x020*/     ULONG32      LastInitializedWsle;
	/*0x024*/     ULONG32      NextAgingSlot;
	/*0x028*/     ULONG32      NumberOfCommittedPageTables;
	/*0x02C*/     ULONG32      VadBitMapHint;
	/*0x030*/     ULONG32      NonDirectCount;
	/*0x034*/     ULONG32      LastVadBit;
	/*0x038*/     ULONG32      MaximumLastVadBit;
	/*0x03C*/     ULONG32      LastAllocationSizeHint;
	/*0x040*/     ULONG32      LastAllocationSize;
	/*0x044*/     UINT8        _PADDING0_[0x4];
	/*0x048*/     struct _MMWSLE_NONDIRECT_HASH* NonDirectHash;
	/*0x050*/     struct _MMWSLE_HASH* HashTableStart;
	/*0x058*/     struct _MMWSLE_HASH* HighestPermittedHashAddress;
	/*0x060*/     ULONG32      MaximumUserPageTablePages;
	/*0x064*/     ULONG32      MaximumUserPageDirectoryPages;
	/*0x068*/     ULONG32*     CommittedPageTables;
	/*0x070*/     ULONG32      NumberOfCommittedPageDirectories;
	/*0x074*/     UINT8        _PADDING1_[0x4];
	/*0x078*/     UINT64       CommittedPageDirectories[128];
	/*0x478*/     ULONG32      NumberOfCommittedPageDirectoryParents;
	/*0x47C*/     UINT8        _PADDING2_[0x4];
	/*0x480*/     UINT64       CommittedPageDirectoryParents[1];
}MMWSL, *PMMWSL;

typedef struct _MMSUPPORT_FLAGS                 // 15 elements, 0x4 bytes (sizeof)
{
	struct                                      // 6 elements, 0x1 bytes (sizeof)
	{
		/*0x000*/         UINT8        WorkingSetType : 3;        // 0 BitPosition
		/*0x000*/         UINT8        ModwriterAttached : 1;     // 3 BitPosition
		/*0x000*/         UINT8        TrimHard : 1;              // 4 BitPosition
		/*0x000*/         UINT8        MaximumWorkingSetHard : 1; // 5 BitPosition
		/*0x000*/         UINT8        ForceTrim : 1;             // 6 BitPosition
		/*0x000*/         UINT8        MinimumWorkingSetHard : 1; // 7 BitPosition
	};
	struct                                      // 4 elements, 0x1 bytes (sizeof)
	{
		/*0x001*/         UINT8        SessionMaster : 1;         // 0 BitPosition
		/*0x001*/         UINT8        TrimmerState : 2;          // 1 BitPosition
		/*0x001*/         UINT8        Reserved : 1;              // 3 BitPosition
		/*0x001*/         UINT8        PageStealers : 4;          // 4 BitPosition
	};
	/*0x002*/     UINT8        MemoryPriority : 8;            // 0 BitPosition
	struct                                      // 4 elements, 0x1 bytes (sizeof)
	{
		/*0x003*/         UINT8        WsleDeleted : 1;           // 0 BitPosition
		/*0x003*/         UINT8        VmExiting : 1;             // 1 BitPosition
		/*0x003*/         UINT8        ExpansionFailed : 1;       // 2 BitPosition
		/*0x003*/         UINT8        Available : 5;             // 3 BitPosition
	};
}MMSUPPORT_FLAGS, *PMMSUPPORT_FLAGS;

typedef struct _MMSUPPORT                        // 21 elements, 0x88 bytes (sizeof)
{
	/*0x000*/     struct _EX_PUSH_LOCK WorkingSetMutex;        // 7 elements, 0x8 bytes (sizeof)
	/*0x008*/     struct _KGATE* ExitGate;
	/*0x010*/     VOID*        AccessLog;
	/*0x018*/     struct _LIST_ENTRY WorkingSetExpansionLinks; // 2 elements, 0x10 bytes (sizeof)
	/*0x028*/     ULONG32      AgeDistribution[7];
	/*0x044*/     ULONG32      MinimumWorkingSetSize;
	/*0x048*/     ULONG32      WorkingSetSize;
	/*0x04C*/     ULONG32      WorkingSetPrivateSize;
	/*0x050*/     ULONG32      MaximumWorkingSetSize;
	/*0x054*/     ULONG32      ChargedWslePages;
	/*0x058*/     ULONG32      ActualWslePages;
	/*0x05C*/     ULONG32      WorkingSetSizeOverhead;
	/*0x060*/     ULONG32      PeakWorkingSetSize;
	/*0x064*/     ULONG32      HardFaultCount;
	/*0x068*/     struct _MMWSL* VmWorkingSetList;
	/*0x070*/     UINT16       NextPageColor;
	/*0x072*/     UINT16       LastTrimStamp;
	/*0x074*/     ULONG32      PageFaultCount;
	/*0x078*/     ULONG32      RepurposeCount;
	/*0x07C*/     ULONG32      Spare[2];
	/*0x084*/     struct _MMSUPPORT_FLAGS Flags;               // 15 elements, 0x4 bytes (sizeof)
}MMSUPPORT, *PMMSUPPORT;

typedef struct _SE_AUDIT_PROCESS_CREATION_INFO      // 1 elements, 0x8 bytes (sizeof)
{
	/*0x000*/     struct _OBJECT_NAME_INFORMATION* ImageFileName;
}SE_AUDIT_PROCESS_CREATION_INFO, *PSE_AUDIT_PROCESS_CREATION_INFO;

typedef struct _ALPC_PROCESS_CONTEXT  // 3 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     struct _EX_PUSH_LOCK Lock;        // 7 elements, 0x8 bytes (sizeof)
	/*0x008*/     struct _LIST_ENTRY ViewListHead;  // 2 elements, 0x10 bytes (sizeof)
	/*0x018*/     UINT64       PagedPoolQuotaCache;
}ALPC_PROCESS_CONTEXT, *PALPC_PROCESS_CONTEXT;

typedef struct _PO_DIAG_STACK_RECORD // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     ULONG32      StackDepth;
	/*0x004*/     UINT8        _PADDING0_[0x4];
	/*0x008*/     VOID*        Stack[1];
}PO_DIAG_STACK_RECORD, *PPO_DIAG_STACK_RECORD;

typedef union _KEXECUTE_OPTIONS                           // 9 elements, 0x1 bytes (sizeof) 
{
	struct                                                // 8 elements, 0x1 bytes (sizeof) 
	{
		/*0x000*/         UINT8        ExecuteDisable : 1;                  // 0 BitPosition                  
		/*0x000*/         UINT8        ExecuteEnable : 1;                   // 1 BitPosition                  
		/*0x000*/         UINT8        DisableThunkEmulation : 1;           // 2 BitPosition                  
		/*0x000*/         UINT8        Permanent : 1;                       // 3 BitPosition                  
		/*0x000*/         UINT8        ExecuteDispatchEnable : 1;           // 4 BitPosition                  
		/*0x000*/         UINT8        ImageDispatchEnable : 1;             // 5 BitPosition                  
		/*0x000*/         UINT8        DisableExceptionChainValidation : 1; // 6 BitPosition                  
		/*0x000*/         UINT8        Spare : 1;                           // 7 BitPosition                  
	};
	/*0x000*/     UINT8        ExecuteOptions;
}KEXECUTE_OPTIONS, *PKEXECUTE_OPTIONS;

typedef union _KSTACK_COUNT           // 3 elements, 0x4 bytes (sizeof) 
{
	/*0x000*/     LONG32       Value;
	struct                            // 2 elements, 0x4 bytes (sizeof) 
	{
		/*0x000*/         ULONG32      State : 3;       // 0 BitPosition                  
		/*0x000*/         ULONG32      StackCount : 29; // 3 BitPosition                  
	};
}KSTACK_COUNT, *PKSTACK_COUNT;

#pragma pack(push) //保存对齐状态
#pragma pack(1)//设定为4字节对齐
typedef struct _KPROCESS
{
	/* 0x0000 */ struct _DISPATCHER_HEADER Header;
	/* 0x0018 */ struct _LIST_ENTRY ProfileListHead;
	/* 0x0028 */ unsigned __int64 DirectoryTableBase;
	/* 0x0030 */ struct _LIST_ENTRY ThreadListHead;
	/* 0x0040 */ unsigned long ProcessLock;
	/* 0x0044 */ unsigned long ProcessTimerDelay;
	/* 0x0048 */ unsigned __int64 DeepFreezeStartTime;
	/* 0x0050 */ struct _KAFFINITY_EX Affinity;
	/* 0x00f8 */ unsigned __int64 AffinityPadding[12];
	/* 0x0158 */ struct _LIST_ENTRY ReadyListHead;
	/* 0x0168 */ struct _SINGLE_LIST_ENTRY SwapListEntry;
	/* 0x0170 */ volatile struct _KAFFINITY_EX ActiveProcessors;
	/* 0x0218 */ unsigned __int64 ActiveProcessorsPadding[12];
	union
	{
		struct /* bitfield */
		{
			/* 0x0278 */ unsigned long AutoAlignment : 1; /* bit position: 0 */
			/* 0x0278 */ unsigned long DisableBoost : 1; /* bit position: 1 */
			/* 0x0278 */ unsigned long DisableQuantum : 1; /* bit position: 2 */
			/* 0x0278 */ unsigned long DeepFreeze : 1; /* bit position: 3 */
			/* 0x0278 */ unsigned long TimerVirtualization : 1; /* bit position: 4 */
			/* 0x0278 */ unsigned long CheckStackExtents : 1; /* bit position: 5 */
			/* 0x0278 */ unsigned long CacheIsolationEnabled : 1; /* bit position: 6 */
			/* 0x0278 */ unsigned long PpmPolicy : 3; /* bit position: 7 */
			/* 0x0278 */ unsigned long VaSpaceDeleted : 1; /* bit position: 10 */
			/* 0x0278 */ unsigned long ReservedFlags : 21; /* bit position: 11 */
		}; /* bitfield */
		/* 0x0278 */ volatile long ProcessFlags;
	}; /* size: 0x0004 */
	/* 0x027c */ unsigned long ActiveGroupsMask;
	/* 0x0280 */ char BasePriority;
	/* 0x0281 */ char QuantumReset;
	/* 0x0282 */ char Visited;
	/* 0x0283 */ union _KEXECUTE_OPTIONS Flags;
	/* 0x0284 */ unsigned short ThreadSeed[20];
	/* 0x02ac */ unsigned short ThreadSeedPadding[12];
	/* 0x02c4 */ unsigned short IdealProcessor[20];
	/* 0x02ec */ unsigned short IdealProcessorPadding[12];
	/* 0x0304 */ unsigned short IdealNode[20];
	/* 0x032c */ unsigned short IdealNodePadding[12];
	/* 0x0344 */ unsigned short IdealGlobalNode;
	/* 0x0346 */ unsigned short Spare1;
	/* 0x0348 */ volatile union _KSTACK_COUNT StackCount;
	/* 0x034c */ long Padding_0;
	/* 0x0350 */ struct _LIST_ENTRY ProcessListEntry;
	/* 0x0360 */ unsigned __int64 CycleTime;
	/* 0x0368 */ unsigned __int64 ContextSwitches;
	/* 0x0370 */ struct _KSCHEDULING_GROUP* SchedulingGroup;
	/* 0x0378 */ unsigned long FreezeCount;
	/* 0x037c */ unsigned long KernelTime;
	/* 0x0380 */ unsigned long UserTime;
	/* 0x0384 */ unsigned long ReadyTime;
	/* 0x0388 */ unsigned __int64 UserDirectoryTableBase;
	/* 0x0390 */ unsigned char AddressPolicy;
	/* 0x0391 */ unsigned char Spare2[71];
	/* 0x03d8 */ void* InstrumentationCallback;
	union
	{
		union
		{
			/* 0x03e0 */ unsigned __int64 SecureHandle;
			struct
			{
				struct /* bitfield */
				{
					/* 0x03e0 */ unsigned __int64 SecureProcess : 1; /* bit position: 0 */
					/* 0x03e0 */ unsigned __int64 Unused : 1; /* bit position: 1 */
				}; /* bitfield */
			} /* size: 0x0008 */ Flags;
		}; /* size: 0x0008 */
	} /* size: 0x0008 */ SecureState;
	/* 0x03e8 */ unsigned __int64 KernelWaitTime;
	/* 0x03f0 */ unsigned __int64 UserWaitTime;
	/* 0x03f8 */ unsigned __int64 EndPadding[8];
} KPROCESS, * PKPROCESS; /* size: 0x0438 */
#pragma pack(pop)//恢复对齐状态

typedef struct _RTL_UMS_CONTEXT                       // 28 elements, 0x540 bytes (sizeof)
{
	/*0x000*/     struct _SINGLE_LIST_ENTRY Link;                   // 1 elements, 0x8 bytes (sizeof)
	/*0x008*/     UINT8        _PADDING0_[0x8];
	/*0x010*/     struct _CONTEXT Context;                          // 64 elements, 0x4D0 bytes (sizeof)
	/*0x4E0*/     VOID*        Teb;
	/*0x4E8*/     VOID*        UserContext;
	union                                             // 2 elements, 0x8 bytes (sizeof)
	{
		struct                                        // 11 elements, 0x4 bytes (sizeof)
		{
			/*0x4F0*/             ULONG32      ScheduledThread : 1;         // 0 BitPosition
			/*0x4F0*/             ULONG32      HasQuantumReq : 1;           // 1 BitPosition
			/*0x4F0*/             ULONG32      HasAffinityReq : 1;          // 2 BitPosition
			/*0x4F0*/             ULONG32      HasPriorityReq : 1;          // 3 BitPosition
			/*0x4F0*/             ULONG32      Suspended : 1;               // 4 BitPosition
			/*0x4F0*/             ULONG32      VolatileContext : 1;         // 5 BitPosition
			/*0x4F0*/             ULONG32      Terminated : 1;              // 6 BitPosition
			/*0x4F0*/             ULONG32      DebugActive : 1;             // 7 BitPosition
			/*0x4F0*/             ULONG32      RunningOnSelfThread : 1;     // 8 BitPosition
			/*0x4F0*/             ULONG32      DenyRunningOnSelfThread : 1; // 9 BitPosition
			/*0x4F0*/             ULONG32      ReservedFlags : 22;          // 10 BitPosition
		};
		/*0x4F0*/         LONG32       Flags;
	};
	union                                             // 2 elements, 0x8 bytes (sizeof)
	{
		struct                                        // 3 elements, 0x8 bytes (sizeof)
		{
			/*0x4F8*/             UINT64       KernelUpdateLock : 1;        // 0 BitPosition
			/*0x4F8*/             UINT64       Reserved : 1;                // 1 BitPosition
			/*0x4F8*/             UINT64       PrimaryClientID : 62;        // 2 BitPosition
		};
		/*0x4F8*/         UINT64       ContextLock;
	};
	/*0x500*/     UINT64       QuantumValue;
	/*0x508*/     struct _GROUP_AFFINITY AffinityMask;              // 3 elements, 0x10 bytes (sizeof)
	/*0x518*/     LONG32       Priority;
	/*0x51C*/     UINT8        _PADDING1_[0x4];
	/*0x520*/     struct _RTL_UMS_CONTEXT* PrimaryUmsContext;
	/*0x528*/     ULONG32      SwitchCount;
	/*0x52C*/     ULONG32      KernelYieldCount;
	/*0x530*/     ULONG32      MixedYieldCount;
	/*0x534*/     ULONG32      YieldCount;
	/*0x538*/     UINT8        _PADDING2_[0x8];
}RTL_UMS_CONTEXT, *PRTL_UMS_CONTEXT;

typedef struct _UMS_CONTROL_BLOCK                                // 22 elements, 0x98 bytes (sizeof)
{
	/*0x000*/     struct _RTL_UMS_CONTEXT* UmsContext;
	/*0x008*/     struct _SINGLE_LIST_ENTRY* CompletionListEntry;
	/*0x010*/     struct _KEVENT* CompletionListEvent;
	/*0x018*/     ULONG32      ServiceSequenceNumber;
	/*0x01C*/     UINT8        _PADDING0_[0x4];
	union                                                        // 2 elements, 0x6C bytes (sizeof)
	{
		struct                                                   // 6 elements, 0x6C bytes (sizeof)
		{
			/*0x020*/             struct _KQUEUE UmsQueue;                             // 5 elements, 0x40 bytes (sizeof)
			/*0x060*/             struct _LIST_ENTRY QueueEntry;                       // 2 elements, 0x10 bytes (sizeof)
			/*0x070*/             struct _RTL_UMS_CONTEXT* YieldingUmsContext;
			/*0x078*/             VOID*        YieldingParam;
			/*0x080*/             VOID*        UmsTeb;
			union                                                // 2 elements, 0x4 bytes (sizeof)
			{
				/*0x088*/                 ULONG32      PrimaryFlags;
				/*0x088*/                 ULONG32      UmsContextHeaderReady : 1;          // 0 BitPosition
			};
		};
		struct                                                   // 6 elements, 0x6C bytes (sizeof)
		{
			/*0x020*/             struct _KQUEUE* UmsAssociatedQueue;
			/*0x028*/             struct _LIST_ENTRY* UmsQueueListEntry;
			/*0x030*/             struct _KUMS_CONTEXT_HEADER* UmsContextHeader;
			/*0x038*/             struct _KGATE UmsWaitGate;                           // 1 elements, 0x18 bytes (sizeof)
			/*0x050*/             VOID*        StagingArea;
			union                                                // 2 elements, 0x4 bytes (sizeof)
			{
				/*0x058*/                 LONG32       Flags;
				struct                                           // 4 elements, 0x4 bytes (sizeof)
				{
					/*0x058*/                     ULONG32      UmsForceQueueTermination : 1;   // 0 BitPosition
					/*0x058*/                     ULONG32      UmsAssociatedQueueUsed : 1;     // 1 BitPosition
					/*0x058*/                     ULONG32      UmsThreadParked : 1;            // 2 BitPosition
					/*0x058*/                     ULONG32      UmsPrimaryDeliveredContext : 1; // 3 BitPosition
				};
			};
		};
	};
	/*0x090*/     UINT16       TebSelector;
	/*0x092*/     UINT8        _PADDING1_[0x6];
}UMS_CONTROL_BLOCK, *PUMS_CONTROL_BLOCK;

typedef struct _KDESCRIPTOR // 3 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     UINT16       Pad[3];
	/*0x006*/     UINT16       Limit;
	/*0x008*/     VOID*        Base;
}KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS     // 27 elements, 0xD8 bytes (sizeof)
{
	/*0x000*/     UINT64       Cr0;
	/*0x008*/     UINT64       Cr2;
	/*0x010*/     UINT64       Cr3;
	/*0x018*/     UINT64       Cr4;
	/*0x020*/     UINT64       KernelDr0;
	/*0x028*/     UINT64       KernelDr1;
	/*0x030*/     UINT64       KernelDr2;
	/*0x038*/     UINT64       KernelDr3;
	/*0x040*/     UINT64       KernelDr6;
	/*0x048*/     UINT64       KernelDr7;
	/*0x050*/     struct _KDESCRIPTOR Gdtr;          // 3 elements, 0x10 bytes (sizeof)
	/*0x060*/     struct _KDESCRIPTOR Idtr;          // 3 elements, 0x10 bytes (sizeof)
	/*0x070*/     UINT16       Tr;
	/*0x072*/     UINT16       Ldtr;
	/*0x074*/     ULONG32      MxCsr;
	/*0x078*/     UINT64       DebugControl;
	/*0x080*/     UINT64       LastBranchToRip;
	/*0x088*/     UINT64       LastBranchFromRip;
	/*0x090*/     UINT64       LastExceptionToRip;
	/*0x098*/     UINT64       LastExceptionFromRip;
	/*0x0A0*/     UINT64       Cr8;
	/*0x0A8*/     UINT64       MsrGsBase;
	/*0x0B0*/     UINT64       MsrGsSwap;
	/*0x0B8*/     UINT64       MsrStar;
	/*0x0C0*/     UINT64       MsrLStar;
	/*0x0C8*/     UINT64       MsrCStar;
	/*0x0D0*/     UINT64       MsrSyscallMask;
}KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

typedef struct _KPROCESSOR_STATE                 // 2 elements, 0x5B0 bytes (sizeof)
{
	/*0x000*/     struct _KSPECIAL_REGISTERS SpecialRegisters; // 27 elements, 0xD8 bytes (sizeof)
	/*0x0D8*/     UINT8        _PADDING0_[0x8];
	/*0x0E0*/     struct _CONTEXT ContextFrame;                // 64 elements, 0x4D0 bytes (sizeof)
}KPROCESSOR_STATE, *PKPROCESSOR_STATE;

typedef struct _PP_LOOKASIDE_LIST // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     struct _GENERAL_LOOKASIDE* P;
	/*0x008*/     struct _GENERAL_LOOKASIDE* L;
}PP_LOOKASIDE_LIST, *PPP_LOOKASIDE_LIST;

typedef struct _KDPC_DATA           // 4 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY DpcListHead; // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     UINT64       DpcLock;
	/*0x018*/     LONG32       DpcQueueDepth;
	/*0x01C*/     ULONG32      DpcCount;
}KDPC_DATA, *PKDPC_DATA;

typedef struct _KTIMER_TABLE_ENTRY // 3 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     UINT64       Lock;
	/*0x008*/     struct _LIST_ENTRY Entry;      // 2 elements, 0x10 bytes (sizeof)
	/*0x018*/     union _ULARGE_INTEGER Time;    // 4 elements, 0x8 bytes (sizeof)
}KTIMER_TABLE_ENTRY, *PKTIMER_TABLE_ENTRY;

typedef struct _KTIMER_TABLE                      // 2 elements, 0x2200 bytes (sizeof)
{
	/*0x000*/     struct _KTIMER* TimerExpiry[64];
	/*0x200*/     struct _KTIMER_TABLE_ENTRY TimerEntries[256];
}KTIMER_TABLE, *PKTIMER_TABLE;

typedef struct _flags                      // 5 elements, 0x1 bytes (sizeof)
{
	/*0x000*/     UINT8        Removable : 1;            // 0 BitPosition
	/*0x000*/     UINT8        GroupAssigned : 1;        // 1 BitPosition
	/*0x000*/     UINT8        GroupCommitted : 1;       // 2 BitPosition
	/*0x000*/     UINT8        GroupAssignmentFixed : 1; // 3 BitPosition
	/*0x000*/     UINT8        Fill : 4;                 // 4 BitPosition
}flags, *Pflags;

typedef struct _CACHED_KSTACK_LIST // 5 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     union _SLIST_HEADER SListHead; // 5 elements, 0x10 bytes (sizeof)
	/*0x010*/     LONG32       MinimumFree;
	/*0x014*/     ULONG32      Misses;
	/*0x018*/     ULONG32      MissesLast;
	/*0x01C*/     ULONG32      Pad0;
}CACHED_KSTACK_LIST, *PCACHED_KSTACK_LIST;

typedef struct _KNODE                              // 18 elements, 0xC0 bytes (sizeof)
{
	/*0x000*/     union _SLIST_HEADER PagedPoolSListHead;        // 5 elements, 0x10 bytes (sizeof)
	/*0x010*/     union _SLIST_HEADER NonPagedPoolSListHead[3];
	/*0x040*/     struct _GROUP_AFFINITY Affinity;               // 3 elements, 0x10 bytes (sizeof)
	/*0x050*/     ULONG32      ProximityId;
	/*0x054*/     UINT16       NodeNumber;
	/*0x056*/     UINT16       PrimaryNodeNumber;
	/*0x058*/     UINT8        MaximumProcessors;
	/*0x059*/     UINT8        Color;
	/*0x05A*/     struct _flags Flags;                           // 5 elements, 0x1 bytes (sizeof)
	/*0x05B*/     UINT8        NodePad0;
	/*0x05C*/     ULONG32      Seed;
	/*0x060*/     ULONG32      MmShiftedColor;
	/*0x064*/     UINT8        _PADDING0_[0x4];
	/*0x068*/     UINT64       FreeCount[2];
	/*0x078*/     ULONG32      Right;
	/*0x07C*/     ULONG32      Left;
	/*0x080*/     struct _CACHED_KSTACK_LIST CachedKernelStacks; // 5 elements, 0x20 bytes (sizeof)
	/*0x0A0*/     LONG32       ParkLock;
	/*0x0A4*/     ULONG32      NodePad1;
	/*0x0A8*/     UINT8        _PADDING1_[0x18];
}KNODE, *PKNODE;

typedef struct _PPM_IDLE_STATE                                                                                                                                              // 14 elements, 0x60 bytes (sizeof)
{
	/*0x000*/     struct _KAFFINITY_EX DomainMembers;                                                                                                                                     // 4 elements, 0x28 bytes (sizeof)
	/*0x028*/     PVOID IdleCheck;
	/*0x030*/     PVOID IdleHandler;
	/*0x038*/     UINT64       HvConfig;
	/*0x040*/     VOID*        Context;
	/*0x048*/     ULONG32      Latency;
	/*0x04C*/     ULONG32      Power;
	/*0x050*/     ULONG32      TimeCheck;
	/*0x054*/     ULONG32      StateFlags;
	/*0x058*/     UINT8        PromotePercent;
	/*0x059*/     UINT8        DemotePercent;
	/*0x05A*/     UINT8        PromotePercentBase;
	/*0x05B*/     UINT8        DemotePercentBase;
	/*0x05C*/     UINT8        StateType;
	/*0x05D*/     UINT8        _PADDING0_[0x3];
}PPM_IDLE_STATE, *PPPM_IDLE_STATE;

typedef struct _PPM_IDLE_STATES            // 8 elements, 0xA0 bytes (sizeof)
{
	/*0x000*/     ULONG32      Count;
	union                                  // 5 elements, 0x4 bytes (sizeof)
	{
		/*0x004*/         ULONG32      AsULONG;
		struct                             // 4 elements, 0x4 bytes (sizeof)
		{
			/*0x004*/             ULONG32      AllowScaling : 1; // 0 BitPosition
			/*0x004*/             ULONG32      Disabled : 1;     // 1 BitPosition
			/*0x004*/             ULONG32      HvMaxCState : 4;  // 2 BitPosition
			/*0x004*/             ULONG32      Reserved : 26;    // 6 BitPosition
		};
	}Flags;
	/*0x008*/     ULONG32      TargetState;
	/*0x00C*/     ULONG32      ActualState;
	/*0x010*/     ULONG32      OldState;
	/*0x014*/     UINT8        NewlyUnparked;
	/*0x015*/     UINT8        _PADDING0_[0x3];
	/*0x018*/     struct _KAFFINITY_EX TargetProcessors; // 4 elements, 0x28 bytes (sizeof)
	/*0x040*/     struct _PPM_IDLE_STATE State[1];
}PPM_IDLE_STATES, *PPPM_IDLE_STATES;

typedef struct _PROC_IDLE_STATE_BUCKET // 4 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     UINT64       TotalTime;
	/*0x008*/     UINT64       MinTime;
	/*0x010*/     UINT64       MaxTime;
	/*0x018*/     ULONG32      Count;
	/*0x01C*/     UINT8        _PADDING0_[0x4];
}PROC_IDLE_STATE_BUCKET, *PPROC_IDLE_STATE_BUCKET;

typedef struct _PROC_IDLE_STATE_ACCOUNTING              // 7 elements, 0x228 bytes (sizeof)
{
	/*0x000*/     UINT64       TotalTime;
	/*0x008*/     ULONG32      IdleTransitions;
	/*0x00C*/     ULONG32      FailedTransitions;
	/*0x010*/     ULONG32      InvalidBucketIndex;
	/*0x014*/     UINT8        _PADDING0_[0x4];
	/*0x018*/     UINT64       MinTime;
	/*0x020*/     UINT64       MaxTime;
	/*0x028*/     struct _PROC_IDLE_STATE_BUCKET IdleTimeBuckets[16];
}PROC_IDLE_STATE_ACCOUNTING, *PPROC_IDLE_STATE_ACCOUNTING;

typedef struct _PROC_IDLE_ACCOUNTING             // 6 elements, 0x2C0 bytes (sizeof)
{
	/*0x000*/     ULONG32      StateCount;
	/*0x004*/     ULONG32      TotalTransitions;
	/*0x008*/     ULONG32      ResetCount;
	/*0x00C*/     UINT8        _PADDING0_[0x4];
	/*0x010*/     UINT64       StartTime;
	/*0x018*/     UINT64       BucketLimits[16];
	/*0x098*/     struct _PROC_IDLE_STATE_ACCOUNTING State[1];
}PROC_IDLE_ACCOUNTING, *PPROC_IDLE_ACCOUNTING;

typedef enum _PROC_HYPERVISOR_STATE  // 3 elements, 0x4 bytes
{
	ProcHypervisorNone = 0 /*0x0*/,
	ProcHypervisorPresent = 1 /*0x1*/,
	ProcHypervisorPower = 2 /*0x2*/
}PROC_HYPERVISOR_STATE, *PPROC_HYPERVISOR_STATE;

typedef struct _PPM_FFH_THROTTLE_STATE_INFO // 5 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     UINT8        EnableLogging;
	/*0x001*/     UINT8        _PADDING0_[0x3];
	/*0x004*/     ULONG32      MismatchCount;
	/*0x008*/     UINT8        Initialized;
	/*0x009*/     UINT8        _PADDING1_[0x7];
	/*0x010*/     UINT64       LastValue;
	/*0x018*/     union _LARGE_INTEGER LastLogTickCount;  // 4 elements, 0x8 bytes (sizeof)
}PPM_FFH_THROTTLE_STATE_INFO, *PPPM_FFH_THROTTLE_STATE_INFO;

typedef struct _PROC_IDLE_SNAP // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     UINT64       Time;
	/*0x008*/     UINT64       Idle;
}PROC_IDLE_SNAP, *PPROC_IDLE_SNAP;

typedef struct _PROC_PERF_CONSTRAINT      // 9 elements, 0x30 bytes (sizeof)
{
	/*0x000*/     struct _KPRCB* Prcb;
	/*0x008*/     UINT64       PerfContext;
	/*0x010*/     ULONG32      PercentageCap;
	/*0x014*/     ULONG32      ThermalCap;
	/*0x018*/     ULONG32      TargetFrequency;
	/*0x01C*/     ULONG32      AcumulatedFullFrequency;
	/*0x020*/     ULONG32      AcumulatedZeroFrequency;
	/*0x024*/     ULONG32      FrequencyHistoryTotal;
	/*0x028*/     ULONG32      AverageFrequency;
	/*0x02C*/     UINT8        _PADDING0_[0x4];
}PROC_PERF_CONSTRAINT, *PPROC_PERF_CONSTRAINT;

typedef struct _PROC_PERF_DOMAIN                                         // 26 elements, 0xB8 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY Link;                                             // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _KPRCB* Master;
	/*0x018*/     struct _KAFFINITY_EX Members;                                        // 4 elements, 0x28 bytes (sizeof)
	/*0x040*/     PVOID FeedbackHandler;
	/*0x048*/     PVOID GetFFHThrottleState;
	/*0x050*/     PVOID BoostPolicyHandler;
	/*0x058*/     PVOID PerfSelectionHandler;
	/*0x060*/     PVOID PerfHandler;
	/*0x068*/     struct _PROC_PERF_CONSTRAINT* Processors;
	/*0x070*/     UINT64       PerfChangeTime;
	/*0x078*/     ULONG32      ProcessorCount;
	/*0x07C*/     ULONG32      PreviousFrequencyMhz;
	/*0x080*/     ULONG32      CurrentFrequencyMhz;
	/*0x084*/     ULONG32      PreviousFrequency;
	/*0x088*/     ULONG32      CurrentFrequency;
	/*0x08C*/     ULONG32      CurrentPerfContext;
	/*0x090*/     ULONG32      DesiredFrequency;
	/*0x094*/     ULONG32      MaxFrequency;
	/*0x098*/     ULONG32      MinPerfPercent;
	/*0x09C*/     ULONG32      MinThrottlePercent;
	/*0x0A0*/     ULONG32      MaxPercent;
	/*0x0A4*/     ULONG32      MinPercent;
	/*0x0A8*/     ULONG32      ConstrainedMaxPercent;
	/*0x0AC*/     ULONG32      ConstrainedMinPercent;
	/*0x0B0*/     UINT8        Coordination;
	/*0x0B1*/     UINT8        _PADDING0_[0x3];
	/*0x0B4*/     LONG32       PerfChangeIntervalCount;
}PROC_PERF_DOMAIN, *PPROC_PERF_DOMAIN;

typedef struct _PROC_PERF_LOAD        // 2 elements, 0x2 bytes (sizeof)
{
	/*0x000*/     UINT8        BusyPercentage;
	/*0x001*/     UINT8        FrequencyPercentage;
}PROC_PERF_LOAD, *PPROC_PERF_LOAD;

typedef struct _PROC_HISTORY_ENTRY // 3 elements, 0x4 bytes (sizeof)
{
	/*0x000*/     UINT16       Utility;
	/*0x002*/     UINT8        Frequency;
	/*0x003*/     UINT8        Reserved;
}PROC_HISTORY_ENTRY, *PPROC_HISTORY_ENTRY;

typedef struct _PROCESSOR_POWER_STATE                         // 27 elements, 0x100 bytes (sizeof)
{
	/*0x000*/     struct _PPM_IDLE_STATES* IdleStates;
	/*0x008*/     UINT64       IdleTimeLast;
	/*0x010*/     UINT64       IdleTimeTotal;
	/*0x018*/     UINT64       IdleTimeEntry;
	/*0x020*/     struct _PROC_IDLE_ACCOUNTING* IdleAccounting;
	/*0x028*/     enum _PROC_HYPERVISOR_STATE Hypervisor;
	/*0x02C*/     ULONG32      PerfHistoryTotal;
	/*0x030*/     UINT8        ThermalConstraint;
	/*0x031*/     UINT8        PerfHistoryCount;
	/*0x032*/     UINT8        PerfHistorySlot;
	/*0x033*/     UINT8        Reserved;
	/*0x034*/     ULONG32      LastSysTime;
	/*0x038*/     UINT64       WmiDispatchPtr;
	/*0x040*/     LONG32       WmiInterfaceEnabled;
	/*0x044*/     UINT8        _PADDING0_[0x4];
	/*0x048*/     struct _PPM_FFH_THROTTLE_STATE_INFO FFHThrottleStateInfo; // 5 elements, 0x20 bytes (sizeof)
	/*0x068*/     struct _KDPC PerfActionDpc;                               // 9 elements, 0x40 bytes (sizeof)
	/*0x0A8*/     LONG32       PerfActionMask;
	/*0x0AC*/     UINT8        _PADDING1_[0x4];
	/*0x0B0*/     struct _PROC_IDLE_SNAP IdleCheck;                         // 2 elements, 0x10 bytes (sizeof)
	/*0x0C0*/     struct _PROC_IDLE_SNAP PerfCheck;                         // 2 elements, 0x10 bytes (sizeof)
	/*0x0D0*/     struct _PROC_PERF_DOMAIN* Domain;
	/*0x0D8*/     struct _PROC_PERF_CONSTRAINT* PerfConstraint;
	/*0x0E0*/     struct _PROC_PERF_LOAD* Load;
	/*0x0E8*/     struct _PROC_HISTORY_ENTRY* PerfHistory;
	/*0x0F0*/     ULONG32      Utility;
	/*0x0F4*/     ULONG32      OverUtilizedHistory;
	/*0x0F8*/     ULONG32      AffinityCount;
	/*0x0FC*/     ULONG32      AffinityHistory;
}PROCESSOR_POWER_STATE, *PPROCESSOR_POWER_STATE;

typedef struct _KREQUEST_PACKET                   // 2 elements, 0x20 bytes (sizeof)
{
	/*0x000*/     VOID*        CurrentPacket[3];
	/*0x018*/     PVOID WorkerRoutine;
}KREQUEST_PACKET, *PKREQUEST_PACKET;

typedef struct _REQUEST_MAILBOX            // 3 elements, 0x40 bytes (sizeof)
{
	/*0x000*/     struct _REQUEST_MAILBOX* Next;
	/*0x008*/     INT64        RequestSummary;
	/*0x010*/     struct _KREQUEST_PACKET RequestPacket; // 2 elements, 0x20 bytes (sizeof)
	/*0x030*/     UINT8        _PADDING0_[0x10];
}REQUEST_MAILBOX, *PREQUEST_MAILBOX;

typedef struct _KPRCB                                                   // 242 elements, 0x4D00 bytes (sizeof)
{
	/*0x000*/      ULONG32      MxCsr;
	/*0x004*/      UINT8        LegacyNumber;
	/*0x005*/      UINT8        ReservedMustBeZero;
	/*0x006*/      UINT8        InterruptRequest;
	/*0x007*/      UINT8        IdleHalt;
	/*0x008*/      struct _KTHREAD* CurrentThread;
	/*0x010*/      struct _KTHREAD* NextThread;
	/*0x018*/      struct _KTHREAD* IdleThread;
	/*0x020*/      UINT8        NestingLevel;
	/*0x021*/      UINT8        PrcbPad00[3];
	/*0x024*/      ULONG32      Number;
	/*0x028*/      UINT64       RspBase;
	/*0x030*/      UINT64       PrcbLock;
	/*0x038*/      UINT64       PrcbPad01;
	/*0x040*/      struct _KPROCESSOR_STATE ProcessorState;                            // 2 elements, 0x5B0 bytes (sizeof)
	/*0x5F0*/      CHAR         CpuType;
	/*0x5F1*/      CHAR         CpuID;
	union                                                               // 2 elements, 0x2 bytes (sizeof)
	{
		/*0x5F2*/          UINT16       CpuStep;
		struct                                                          // 2 elements, 0x2 bytes (sizeof)
		{
			/*0x5F2*/              UINT8        CpuStepping;
			/*0x5F3*/              UINT8        CpuModel;
		};
	};
	/*0x5F4*/      ULONG32      MHz;
	/*0x5F8*/      UINT64       HalReserved[8];
	/*0x638*/      UINT16       MinorVersion;
	/*0x63A*/      UINT16       MajorVersion;
	/*0x63C*/      UINT8        BuildType;
	/*0x63D*/      UINT8        CpuVendor;
	/*0x63E*/      UINT8        CoresPerPhysicalProcessor;
	/*0x63F*/      UINT8        LogicalProcessorsPerCore;
	/*0x640*/      ULONG32      ApicMask;
	/*0x644*/      ULONG32      CFlushSize;
	/*0x648*/      VOID*        AcpiReserved;
	/*0x650*/      ULONG32      InitialApicId;
	/*0x654*/      ULONG32      Stride;
	/*0x658*/      UINT16       Group;
	/*0x65A*/      UINT8        _PADDING0_[0x6];
	/*0x660*/      UINT64       GroupSetMember;
	/*0x668*/      UINT8        GroupIndex;
	/*0x669*/      UINT8        _PADDING1_[0x7];
	/*0x670*/      struct _KSPIN_LOCK_QUEUE LockQueue[17];
	/*0x780*/      struct _PP_LOOKASIDE_LIST PPLookasideList[16];
	/*0x880*/      struct _GENERAL_LOOKASIDE_POOL PPNPagedLookasideList[32];
	/*0x1480*/     struct _GENERAL_LOOKASIDE_POOL PPPagedLookasideList[32];
	/*0x2080*/     LONG32       PacketBarrier;
	/*0x2084*/     UINT8        _PADDING2_[0x4];
	/*0x2088*/     struct _SINGLE_LIST_ENTRY DeferredReadyListHead;                    // 1 elements, 0x8 bytes (sizeof)
	/*0x2090*/     LONG32       MmPageFaultCount;
	/*0x2094*/     LONG32       MmCopyOnWriteCount;
	/*0x2098*/     LONG32       MmTransitionCount;
	/*0x209C*/     LONG32       MmDemandZeroCount;
	/*0x20A0*/     LONG32       MmPageReadCount;
	/*0x20A4*/     LONG32       MmPageReadIoCount;
	/*0x20A8*/     LONG32       MmDirtyPagesWriteCount;
	/*0x20AC*/     LONG32       MmDirtyWriteIoCount;
	/*0x20B0*/     LONG32       MmMappedPagesWriteCount;
	/*0x20B4*/     LONG32       MmMappedWriteIoCount;
	/*0x20B8*/     ULONG32      KeSystemCalls;
	/*0x20BC*/     ULONG32      KeContextSwitches;
	/*0x20C0*/     ULONG32      CcFastReadNoWait;
	/*0x20C4*/     ULONG32      CcFastReadWait;
	/*0x20C8*/     ULONG32      CcFastReadNotPossible;
	/*0x20CC*/     ULONG32      CcCopyReadNoWait;
	/*0x20D0*/     ULONG32      CcCopyReadWait;
	/*0x20D4*/     ULONG32      CcCopyReadNoWaitMiss;
	/*0x20D8*/     LONG32       LookasideIrpFloat;
	/*0x20DC*/     LONG32       IoReadOperationCount;
	/*0x20E0*/     LONG32       IoWriteOperationCount;
	/*0x20E4*/     LONG32       IoOtherOperationCount;
	/*0x20E8*/     union _LARGE_INTEGER IoReadTransferCount;                           // 4 elements, 0x8 bytes (sizeof)
	/*0x20F0*/     union _LARGE_INTEGER IoWriteTransferCount;                          // 4 elements, 0x8 bytes (sizeof)
	/*0x20F8*/     union _LARGE_INTEGER IoOtherTransferCount;                          // 4 elements, 0x8 bytes (sizeof)
	/*0x2100*/     LONG32       TargetCount;
	/*0x2104*/     ULONG32      IpiFrozen;
	/*0x2108*/     UINT8        _PADDING3_[0x78];
	/*0x2180*/     struct _KDPC_DATA DpcData[2];
	/*0x21C0*/     VOID*        DpcStack;
	/*0x21C8*/     LONG32       MaximumDpcQueueDepth;
	/*0x21CC*/     ULONG32      DpcRequestRate;
	/*0x21D0*/     ULONG32      MinimumDpcRate;
	/*0x21D4*/     ULONG32      DpcLastCount;
	/*0x21D8*/     UINT8        ThreadDpcEnable;
	/*0x21D9*/     UINT8        QuantumEnd;
	/*0x21DA*/     UINT8        DpcRoutineActive;
	/*0x21DB*/     UINT8        IdleSchedule;
	union                                                               // 3 elements, 0x4 bytes (sizeof)
	{
		/*0x21DC*/         LONG32       DpcRequestSummary;
		/*0x21DC*/         INT16        DpcRequestSlot[2];
		struct                                                          // 2 elements, 0x4 bytes (sizeof)
		{
			/*0x21DC*/             INT16        NormalDpcState;
			union                                                       // 2 elements, 0x2 bytes (sizeof)
			{
				/*0x21DE*/                 UINT16       DpcThreadActive : 1;                       // 0 BitPosition
				/*0x21DE*/                 INT16        ThreadDpcState;
			};
		};
	};
	/*0x21E0*/     ULONG32      TimerHand;
	/*0x21E4*/     LONG32       MasterOffset;
	/*0x21E8*/     ULONG32      LastTick;
	/*0x21EC*/     ULONG32      UnusedPad;
	/*0x21F0*/     UINT64       PrcbPad50[2];
	/*0x2200*/     struct _KTIMER_TABLE TimerTable;                                    // 2 elements, 0x2200 bytes (sizeof)
	/*0x4400*/     struct _KGATE DpcGate;                                              // 1 elements, 0x18 bytes (sizeof)
	/*0x4418*/     VOID*        PrcbPad52;
	/*0x4420*/     struct _KDPC CallDpc;                                               // 9 elements, 0x40 bytes (sizeof)
	/*0x4460*/     LONG32       ClockKeepAlive;
	/*0x4464*/     UINT8        ClockCheckSlot;
	/*0x4465*/     UINT8        ClockPollCycle;
	/*0x4466*/     UINT16       NmiActive;
	/*0x4468*/     LONG32       DpcWatchdogPeriod;
	/*0x446C*/     LONG32       DpcWatchdogCount;
	/*0x4470*/     UINT64       TickOffset;
	/*0x4478*/     LONG32       KeSpinLockOrdering;
	/*0x447C*/     ULONG32      PrcbPad70;
	/*0x4480*/     struct _LIST_ENTRY WaitListHead;                                    // 2 elements, 0x10 bytes (sizeof)
	/*0x4490*/     UINT64       WaitLock;
	/*0x4498*/     ULONG32      ReadySummary;
	/*0x449C*/     ULONG32      QueueIndex;
	/*0x44A0*/     struct _KDPC TimerExpirationDpc;                                    // 9 elements, 0x40 bytes (sizeof)
	/*0x44E0*/     UINT64       PrcbPad72[4];
	/*0x4500*/     struct _LIST_ENTRY DispatcherReadyListHead[32];
	/*0x4700*/     ULONG32      InterruptCount;
	/*0x4704*/     ULONG32      KernelTime;
	/*0x4708*/     ULONG32      UserTime;
	/*0x470C*/     ULONG32      DpcTime;
	/*0x4710*/     ULONG32      InterruptTime;
	/*0x4714*/     ULONG32      AdjustDpcThreshold;
	/*0x4718*/     UINT8        DebuggerSavedIRQL;
	/*0x4719*/     UINT8        PrcbPad80[7];
	/*0x4720*/     ULONG32      DpcTimeCount;
	/*0x4724*/     ULONG32      DpcTimeLimit;
	/*0x4728*/     ULONG32      PeriodicCount;
	/*0x472C*/     ULONG32      PeriodicBias;
	/*0x4730*/     ULONG32      AvailableTime;
	/*0x4734*/     ULONG32      KeExceptionDispatchCount;
	/*0x4738*/     struct _KNODE* ParentNode;
	/*0x4740*/     UINT64       StartCycles;
	/*0x4748*/     UINT64       PrcbPad82[3];
	/*0x4760*/     LONG32       MmSpinLockOrdering;
	/*0x4764*/     ULONG32      PageColor;
	/*0x4768*/     ULONG32      NodeColor;
	/*0x476C*/     ULONG32      NodeShiftedColor;
	/*0x4770*/     ULONG32      SecondaryColorMask;
	/*0x4774*/     ULONG32      PrcbPad83;
	/*0x4778*/     UINT64       CycleTime;
	/*0x4780*/     ULONG32      CcFastMdlReadNoWait;
	/*0x4784*/     ULONG32      CcFastMdlReadWait;
	/*0x4788*/     ULONG32      CcFastMdlReadNotPossible;
	/*0x478C*/     ULONG32      CcMapDataNoWait;
	/*0x4790*/     ULONG32      CcMapDataWait;
	/*0x4794*/     ULONG32      CcPinMappedDataCount;
	/*0x4798*/     ULONG32      CcPinReadNoWait;
	/*0x479C*/     ULONG32      CcPinReadWait;
	/*0x47A0*/     ULONG32      CcMdlReadNoWait;
	/*0x47A4*/     ULONG32      CcMdlReadWait;
	/*0x47A8*/     ULONG32      CcLazyWriteHotSpots;
	/*0x47AC*/     ULONG32      CcLazyWriteIos;
	/*0x47B0*/     ULONG32      CcLazyWritePages;
	/*0x47B4*/     ULONG32      CcDataFlushes;
	/*0x47B8*/     ULONG32      CcDataPages;
	/*0x47BC*/     ULONG32      CcLostDelayedWrites;
	/*0x47C0*/     ULONG32      CcFastReadResourceMiss;
	/*0x47C4*/     ULONG32      CcCopyReadWaitMiss;
	/*0x47C8*/     ULONG32      CcFastMdlReadResourceMiss;
	/*0x47CC*/     ULONG32      CcMapDataNoWaitMiss;
	/*0x47D0*/     ULONG32      CcMapDataWaitMiss;
	/*0x47D4*/     ULONG32      CcPinReadNoWaitMiss;
	/*0x47D8*/     ULONG32      CcPinReadWaitMiss;
	/*0x47DC*/     ULONG32      CcMdlReadNoWaitMiss;
	/*0x47E0*/     ULONG32      CcMdlReadWaitMiss;
	/*0x47E4*/     ULONG32      CcReadAheadIos;
	/*0x47E8*/     LONG32       MmCacheTransitionCount;
	/*0x47EC*/     LONG32       MmCacheReadCount;
	/*0x47F0*/     LONG32       MmCacheIoCount;
	/*0x47F4*/     ULONG32      PrcbPad91[1];
	/*0x47F8*/     UINT64       RuntimeAccumulation;
	/*0x4800*/     struct _PROCESSOR_POWER_STATE PowerState;                           // 27 elements, 0x100 bytes (sizeof)
	/*0x4900*/     UINT8        PrcbPad92[16];
	/*0x4910*/     ULONG32      KeAlignmentFixupCount;
	/*0x4914*/     UINT8        _PADDING4_[0x4];
	/*0x4918*/     struct _KDPC DpcWatchdogDpc;                                        // 9 elements, 0x40 bytes (sizeof)
	/*0x4958*/     struct _KTIMER DpcWatchdogTimer;                                    // 6 elements, 0x40 bytes (sizeof)
	/*0x4998*/     struct _CACHE_DESCRIPTOR Cache[5];
	/*0x49D4*/     ULONG32      CacheCount;
	/*0x49D8*/     ULONG32      CachedCommit;
	/*0x49DC*/     ULONG32      CachedResidentAvailable;
	/*0x49E0*/     VOID*        HyperPte;
	/*0x49E8*/     VOID*        WheaInfo;
	/*0x49F0*/     VOID*        EtwSupport;
	/*0x49F8*/     UINT8        _PADDING5_[0x8];
	/*0x4A00*/     union _SLIST_HEADER InterruptObjectPool;                            // 5 elements, 0x10 bytes (sizeof)
	/*0x4A10*/     union _SLIST_HEADER HypercallPageList;                              // 5 elements, 0x10 bytes (sizeof)
	/*0x4A20*/     VOID*        HypercallPageVirtual;
	/*0x4A28*/     VOID*        VirtualApicAssist;
	/*0x4A30*/     UINT64*      StatisticsPage;
	/*0x4A38*/     VOID*        RateControl;
	/*0x4A40*/     UINT64       CacheProcessorMask[5];
	/*0x4A68*/     struct _KAFFINITY_EX PackageProcessorSet;                           // 4 elements, 0x28 bytes (sizeof)
	/*0x4A90*/     UINT64       CoreProcessorSet;
	/*0x4A98*/     VOID*        PebsIndexAddress;
	/*0x4AA0*/     UINT64       PrcbPad93[12];
	/*0x4B00*/     ULONG32      SpinLockAcquireCount;
	/*0x4B04*/     ULONG32      SpinLockContentionCount;
	/*0x4B08*/     ULONG32      SpinLockSpinCount;
	/*0x4B0C*/     ULONG32      IpiSendRequestBroadcastCount;
	/*0x4B10*/     ULONG32      IpiSendRequestRoutineCount;
	/*0x4B14*/     ULONG32      IpiSendSoftwareInterruptCount;
	/*0x4B18*/     ULONG32      ExInitializeResourceCount;
	/*0x4B1C*/     ULONG32      ExReInitializeResourceCount;
	/*0x4B20*/     ULONG32      ExDeleteResourceCount;
	/*0x4B24*/     ULONG32      ExecutiveResourceAcquiresCount;
	/*0x4B28*/     ULONG32      ExecutiveResourceContentionsCount;
	/*0x4B2C*/     ULONG32      ExecutiveResourceReleaseExclusiveCount;
	/*0x4B30*/     ULONG32      ExecutiveResourceReleaseSharedCount;
	/*0x4B34*/     ULONG32      ExecutiveResourceConvertsCount;
	/*0x4B38*/     ULONG32      ExAcqResExclusiveAttempts;
	/*0x4B3C*/     ULONG32      ExAcqResExclusiveAcquiresExclusive;
	/*0x4B40*/     ULONG32      ExAcqResExclusiveAcquiresExclusiveRecursive;
	/*0x4B44*/     ULONG32      ExAcqResExclusiveWaits;
	/*0x4B48*/     ULONG32      ExAcqResExclusiveNotAcquires;
	/*0x4B4C*/     ULONG32      ExAcqResSharedAttempts;
	/*0x4B50*/     ULONG32      ExAcqResSharedAcquiresExclusive;
	/*0x4B54*/     ULONG32      ExAcqResSharedAcquiresShared;
	/*0x4B58*/     ULONG32      ExAcqResSharedAcquiresSharedRecursive;
	/*0x4B5C*/     ULONG32      ExAcqResSharedWaits;
	/*0x4B60*/     ULONG32      ExAcqResSharedNotAcquires;
	/*0x4B64*/     ULONG32      ExAcqResSharedStarveExclusiveAttempts;
	/*0x4B68*/     ULONG32      ExAcqResSharedStarveExclusiveAcquiresExclusive;
	/*0x4B6C*/     ULONG32      ExAcqResSharedStarveExclusiveAcquiresShared;
	/*0x4B70*/     ULONG32      ExAcqResSharedStarveExclusiveAcquiresSharedRecursive;
	/*0x4B74*/     ULONG32      ExAcqResSharedStarveExclusiveWaits;
	/*0x4B78*/     ULONG32      ExAcqResSharedStarveExclusiveNotAcquires;
	/*0x4B7C*/     ULONG32      ExAcqResSharedWaitForExclusiveAttempts;
	/*0x4B80*/     ULONG32      ExAcqResSharedWaitForExclusiveAcquiresExclusive;
	/*0x4B84*/     ULONG32      ExAcqResSharedWaitForExclusiveAcquiresShared;
	/*0x4B88*/     ULONG32      ExAcqResSharedWaitForExclusiveAcquiresSharedRecursive;
	/*0x4B8C*/     ULONG32      ExAcqResSharedWaitForExclusiveWaits;
	/*0x4B90*/     ULONG32      ExAcqResSharedWaitForExclusiveNotAcquires;
	/*0x4B94*/     ULONG32      ExSetResOwnerPointerExclusive;
	/*0x4B98*/     ULONG32      ExSetResOwnerPointerSharedNew;
	/*0x4B9C*/     ULONG32      ExSetResOwnerPointerSharedOld;
	/*0x4BA0*/     ULONG32      ExTryToAcqExclusiveAttempts;
	/*0x4BA4*/     ULONG32      ExTryToAcqExclusiveAcquires;
	/*0x4BA8*/     ULONG32      ExBoostExclusiveOwner;
	/*0x4BAC*/     ULONG32      ExBoostSharedOwners;
	/*0x4BB0*/     ULONG32      ExEtwSynchTrackingNotificationsCount;
	/*0x4BB4*/     ULONG32      ExEtwSynchTrackingNotificationsAccountedCount;
	/*0x4BB8*/     UINT8        VendorString[13];
	/*0x4BC5*/     UINT8        PrcbPad10[3];
	/*0x4BC8*/     ULONG32      FeatureBits;
	/*0x4BCC*/     UINT8        _PADDING6_[0x4];
	/*0x4BD0*/     union _LARGE_INTEGER UpdateSignature;                               // 4 elements, 0x8 bytes (sizeof)
	/*0x4BD8*/     struct _CONTEXT* Context;
	/*0x4BE0*/     ULONG32      ContextFlags;
	/*0x4BE4*/     UINT8        _PADDING7_[0x4];
	/*0x4BE8*/     struct _XSAVE_AREA* ExtendedState;
	/*0x4BF0*/     UINT8        _PADDING8_[0x10];
	/*0x4C00*/     struct _REQUEST_MAILBOX* Mailbox;
	/*0x4C08*/     UINT8        _PADDING9_[0x78];
	/*0x4C80*/     struct _REQUEST_MAILBOX RequestMailbox[1];
	/*0x4CC0*/     UINT8        _PADDING10_[0x40];
}KPRCB, *PKPRCB;

typedef struct _COUNTER_READING       // 4 elements, 0x18 bytes (sizeof)
{
	/*0x000*/     enum _HARDWARE_COUNTER_TYPE Type;
	/*0x004*/     ULONG32      Index;
	/*0x008*/     UINT64       Start;
	/*0x010*/     UINT64       Total;
}COUNTER_READING, *PCOUNTER_READING;

typedef struct _THREAD_PERFORMANCE_DATA       // 10 elements, 0x1C0 bytes (sizeof)
{
	/*0x000*/     UINT16       Size;
	/*0x002*/     UINT16       Version;
	/*0x004*/     struct _PROCESSOR_NUMBER ProcessorNumber; // 3 elements, 0x4 bytes (sizeof)
	/*0x008*/     ULONG32      ContextSwitches;
	/*0x00C*/     ULONG32      HwCountersCount;
	/*0x010*/     UINT64       UpdateCount;
	/*0x018*/     UINT64       WaitReasonBitMap;
	/*0x020*/     UINT64       HardwareCounters;
	/*0x028*/     struct _COUNTER_READING CycleTime;        // 4 elements, 0x18 bytes (sizeof)
	/*0x040*/     struct _COUNTER_READING HwCounters[16];
}THREAD_PERFORMANCE_DATA, *PTHREAD_PERFORMANCE_DATA;

typedef struct _KTHREAD_COUNTERS               // 7 elements, 0x1A8 bytes (sizeof)
{
	/*0x000*/     UINT64       WaitReasonBitMap;
	/*0x008*/     struct _THREAD_PERFORMANCE_DATA* UserData;
	/*0x010*/     ULONG32      Flags;
	/*0x014*/     ULONG32      ContextSwitches;
	/*0x018*/     UINT64       CycleTimeBias;
	/*0x020*/     UINT64       HardwareCounters;
	/*0x028*/     struct _COUNTER_READING HwCounter[16];
}KTHREAD_COUNTERS, *PKTHREAD_COUNTERS;
/*
typedef struct __XSAVE_FORMAT{
	WORD	 ControlWord;//     : Uint2B
	WORD	 StatusWord;// : Uint2B
	UCHAR	 TagWord;// : UChar
	UCHAR Reserved1; //: UChar
	WORD ErrorOpcode;// : Uint2B
	DWORD ErrorOffset;// : Uint4B
	WORD ErrorSelector;// : Uint2B
	WORD Reserved2;// : Uint2B
	DWORD DataOffset;// : Uint4B
	WORD DataSelector;// : Uint2B
	WORD	 Reserved3;// : Uint2B
	DWORD	MxCsr;// : Uint4B
	DWORD MxCsr_Mask;// : Uint4B
	M128A FloatRegisters[8];// : [8] _M128A
	M128A	 XmmRegisters[16];// _M128A
	UCHAR Reserved4[96];// UChar



}KXSAVE_FORMAT, *KPXSAVE_FORMAT;*/

typedef struct _TERMINATION_PORT    // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     struct _TERMINATION_PORT* Next;
	/*0x008*/     VOID*        Port;
}TERMINATION_PORT, *PTERMINATION_PORT;

typedef struct _LIST_ENTRY64_S // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     UINT64       Flink;
	/*0x008*/     UINT64       Blink;
}LIST_ENTRY64_S, *PLIST_ENTRY64_S;

#ifndef _PEB_
#define _PEB_
typedef struct _PEB
{
	/* 0x0000 */ unsigned char InheritedAddressSpace;
	/* 0x0001 */ unsigned char ReadImageFileExecOptions;
	/* 0x0002 */ unsigned char BeingDebugged;
	union
	{
		/* 0x0003 */ unsigned char BitField;
		struct /* bitfield */
		{
			/* 0x0003 */ unsigned char ImageUsesLargePages : 1; /* bit position: 0 */
			/* 0x0003 */ unsigned char IsProtectedProcess : 1; /* bit position: 1 */
			/* 0x0003 */ unsigned char IsImageDynamicallyRelocated : 1; /* bit position: 2 */
			/* 0x0003 */ unsigned char SkipPatchingUser32Forwarders : 1; /* bit position: 3 */
			/* 0x0003 */ unsigned char IsPackagedProcess : 1; /* bit position: 4 */
			/* 0x0003 */ unsigned char IsAppContainer : 1; /* bit position: 5 */
			/* 0x0003 */ unsigned char IsProtectedProcessLight : 1; /* bit position: 6 */
			/* 0x0003 */ unsigned char IsLongPathAwareProcess : 1; /* bit position: 7 */
		}; /* bitfield */
	}; /* size: 0x0001 */
	/* 0x0004 */ unsigned char Padding0[4];
	/* 0x0008 */ void* Mutant;
	/* 0x0010 */ void* ImageBaseAddress;
	/* 0x0018 */ struct _PEB_LDR_DATA* Ldr;
	/* 0x0020 */ struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;
	/* 0x0028 */ void* SubSystemData;
	/* 0x0030 */ void* ProcessHeap;
	/* 0x0038 */ struct _RTL_CRITICAL_SECTION* FastPebLock;
	/* 0x0040 */ union _SLIST_HEADER* volatile AtlThunkSListPtr;
	/* 0x0048 */ void* IFEOKey;
	union
	{
		/* 0x0050 */ unsigned long CrossProcessFlags;
		struct /* bitfield */
		{
			/* 0x0050 */ unsigned long ProcessInJob : 1; /* bit position: 0 */
			/* 0x0050 */ unsigned long ProcessInitializing : 1; /* bit position: 1 */
			/* 0x0050 */ unsigned long ProcessUsingVEH : 1; /* bit position: 2 */
			/* 0x0050 */ unsigned long ProcessUsingVCH : 1; /* bit position: 3 */
			/* 0x0050 */ unsigned long ProcessUsingFTH : 1; /* bit position: 4 */
			/* 0x0050 */ unsigned long ProcessPreviouslyThrottled : 1; /* bit position: 5 */
			/* 0x0050 */ unsigned long ProcessCurrentlyThrottled : 1; /* bit position: 6 */
			/* 0x0050 */ unsigned long ProcessImagesHotPatched : 1; /* bit position: 7 */
			/* 0x0050 */ unsigned long ReservedBits0 : 24; /* bit position: 8 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0054 */ unsigned char Padding1[4];
	union
	{
		/* 0x0058 */ void* KernelCallbackTable;
		/* 0x0058 */ void* UserSharedInfoPtr;
	}; /* size: 0x0008 */
	/* 0x0060 */ unsigned long SystemReserved;
	/* 0x0064 */ unsigned long AtlThunkSListPtr32;
	/* 0x0068 */ void* ApiSetMap;
	/* 0x0070 */ unsigned long TlsExpansionCounter;
	/* 0x0074 */ unsigned char Padding2[4];
	/* 0x0078 */ void* TlsBitmap;
	/* 0x0080 */ unsigned long TlsBitmapBits[2];
	/* 0x0088 */ void* ReadOnlySharedMemoryBase;
	/* 0x0090 */ void* SharedData;
	/* 0x0098 */ void** ReadOnlyStaticServerData;
	/* 0x00a0 */ void* AnsiCodePageData;
	/* 0x00a8 */ void* OemCodePageData;
	/* 0x00b0 */ void* UnicodeCaseTableData;
	/* 0x00b8 */ unsigned long NumberOfProcessors;
	/* 0x00bc */ unsigned long NtGlobalFlag;
	/* 0x00c0 */ union _LARGE_INTEGER CriticalSectionTimeout;
	/* 0x00c8 */ unsigned __int64 HeapSegmentReserve;
	/* 0x00d0 */ unsigned __int64 HeapSegmentCommit;
	/* 0x00d8 */ unsigned __int64 HeapDeCommitTotalFreeThreshold;
	/* 0x00e0 */ unsigned __int64 HeapDeCommitFreeBlockThreshold;
	/* 0x00e8 */ unsigned long NumberOfHeaps;
	/* 0x00ec */ unsigned long MaximumNumberOfHeaps;
	/* 0x00f0 */ void** ProcessHeaps;
	/* 0x00f8 */ void* GdiSharedHandleTable;
	/* 0x0100 */ void* ProcessStarterHelper;
	/* 0x0108 */ unsigned long GdiDCAttributeList;
	/* 0x010c */ unsigned char Padding3[4];
	/* 0x0110 */ struct _RTL_CRITICAL_SECTION* LoaderLock;
	/* 0x0118 */ unsigned long OSMajorVersion;
	/* 0x011c */ unsigned long OSMinorVersion;
	/* 0x0120 */ unsigned short OSBuildNumber;
	/* 0x0122 */ unsigned short OSCSDVersion;
	/* 0x0124 */ unsigned long OSPlatformId;
	/* 0x0128 */ unsigned long ImageSubsystem;
	/* 0x012c */ unsigned long ImageSubsystemMajorVersion;
	/* 0x0130 */ unsigned long ImageSubsystemMinorVersion;
	/* 0x0134 */ unsigned char Padding4[4];
	/* 0x0138 */ unsigned __int64 ActiveProcessAffinityMask;
	/* 0x0140 */ unsigned long GdiHandleBuffer[60];
	/* 0x0230 */ void* PostProcessInitRoutine /* function */;
	/* 0x0238 */ void* TlsExpansionBitmap;
	/* 0x0240 */ unsigned long TlsExpansionBitmapBits[32];
	/* 0x02c0 */ unsigned long SessionId;
	/* 0x02c4 */ unsigned char Padding5[4];
	/* 0x02c8 */ union _ULARGE_INTEGER AppCompatFlags;
	/* 0x02d0 */ union _ULARGE_INTEGER AppCompatFlagsUser;
	/* 0x02d8 */ void* pShimData;
	/* 0x02e0 */ void* AppCompatInfo;
	/* 0x02e8 */ struct _UNICODE_STRING CSDVersion;
	/* 0x02f8 */ const struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;
	/* 0x0300 */ struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;
	/* 0x0308 */ const struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;
	/* 0x0310 */ struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;
	/* 0x0318 */ unsigned __int64 MinimumStackCommit;
	/* 0x0320 */ void* SparePointers[4];
	/* 0x0340 */ unsigned long SpareUlongs[5];
	/* 0x0354 */ long Padding_1;
	/* 0x0358 */ void* WerRegistrationData;
	/* 0x0360 */ void* WerShipAssertPtr;
	/* 0x0368 */ void* pUnused;
	/* 0x0370 */ void* pImageHeaderHash;
	union
	{
		/* 0x0378 */ unsigned long TracingFlags;
		struct /* bitfield */
		{
			/* 0x0378 */ unsigned long HeapTracingEnabled : 1; /* bit position: 0 */
			/* 0x0378 */ unsigned long CritSecTracingEnabled : 1; /* bit position: 1 */
			/* 0x0378 */ unsigned long LibLoaderTracingEnabled : 1; /* bit position: 2 */
			/* 0x0378 */ unsigned long SpareTracingBits : 29; /* bit position: 3 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x037c */ unsigned char Padding6[4];
	/* 0x0380 */ unsigned __int64 CsrServerReadOnlySharedMemoryBase;
	/* 0x0388 */ unsigned __int64 TppWorkerpListLock;
	/* 0x0390 */ struct _LIST_ENTRY TppWorkerpList;
	/* 0x03a0 */ void* WaitOnAddressHashTable[128];
	/* 0x07a0 */ void* TelemetryCoverageHeader;
	/* 0x07a8 */ unsigned long CloudFileFlags;
	/* 0x07ac */ unsigned long CloudFileDiagFlags;
	/* 0x07b0 */ char PlaceholderCompatibilityMode;
	/* 0x07b1 */ char PlaceholderCompatibilityModeReserved[7];
	/* 0x07b8 */ struct _LEAP_SECOND_DATA* LeapSecondData;
	union
	{
		/* 0x07c0 */ unsigned long LeapSecondFlags;
		struct /* bitfield */
		{
			/* 0x07c0 */ unsigned long SixtySecondEnabled : 1; /* bit position: 0 */
			/* 0x07c0 */ unsigned long Reserved : 31; /* bit position: 1 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x07c4 */ unsigned long NtGlobalFlag2;
} PEB, * PPEB; /* size: 0x07c8 */
#endif

typedef struct _RTL_AVL_TREE
{
	/* 0x0000 */ struct _RTL_BALANCED_NODE* Root;
} RTL_AVL_TREE, * PRTL_AVL_TREE; /* size: 0x0008 */

typedef union _PS_INTERLOCKED_TIMER_DELAY_VALUES
{
	union
	{
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned __int64 DelayMs : 30; /* bit position: 0 */
			/* 0x0000 */ unsigned __int64 CoalescingWindowMs : 30; /* bit position: 30 */
			/* 0x0000 */ unsigned __int64 Reserved : 1; /* bit position: 60 */
			/* 0x0000 */ unsigned __int64 NewTimerWheel : 1; /* bit position: 61 */
			/* 0x0000 */ unsigned __int64 Retry : 1; /* bit position: 62 */
			/* 0x0000 */ unsigned __int64 Locked : 1; /* bit position: 63 */
		}; /* bitfield */
		/* 0x0000 */ unsigned __int64 All;
	}; /* size: 0x0008 */
} PS_INTERLOCKED_TIMER_DELAY_VALUES, * PPS_INTERLOCKED_TIMER_DELAY_VALUES; /* size: 0x0008 */

typedef struct _PS_PROTECTION
{
	union
	{
		/* 0x0000 */ unsigned char Level;
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned char Type : 3; /* bit position: 0 */
			/* 0x0000 */ unsigned char Audit : 1; /* bit position: 3 */
			/* 0x0000 */ unsigned char Signer : 4; /* bit position: 4 */
		}; /* bitfield */
	}; /* size: 0x0001 */
} PS_PROTECTION, * PPS_PROTECTION; /* size: 0x0001 */

typedef struct _MMSUPPORT_INSTANCE
{
	/* 0x0000 */ unsigned long NextPageColor;
	/* 0x0004 */ unsigned long PageFaultCount;
	/* 0x0008 */ unsigned __int64 TrimmedPageCount;
	/* 0x0010 */ struct _MMWSL_INSTANCE* VmWorkingSetList;
	/* 0x0018 */ struct _LIST_ENTRY WorkingSetExpansionLinks;
	/* 0x0028 */ unsigned __int64 AgeDistribution[8];
	/* 0x0068 */ struct _KGATE* ExitOutswapGate;
	/* 0x0070 */ unsigned __int64 MinimumWorkingSetSize;
	/* 0x0078 */ unsigned __int64 WorkingSetLeafSize;
	/* 0x0080 */ unsigned __int64 WorkingSetLeafPrivateSize;
	/* 0x0088 */ unsigned __int64 WorkingSetSize;
	/* 0x0090 */ unsigned __int64 WorkingSetPrivateSize;
	/* 0x0098 */ unsigned __int64 MaximumWorkingSetSize;
	/* 0x00a0 */ unsigned __int64 PeakWorkingSetSize;
	/* 0x00a8 */ unsigned long HardFaultCount;
	/* 0x00ac */ unsigned short LastTrimStamp;
	/* 0x00ae */ unsigned short PartitionId;
	/* 0x00b0 */ unsigned __int64 SelfmapLock;
	/* 0x00b8 */ struct _MMSUPPORT_FLAGS Flags;
	/* 0x00bc */ long __PADDING__[1];
} MMSUPPORT_INSTANCE, * PMMSUPPORT_INSTANCE; /* size: 0x00c0 */

typedef struct _MMSUPPORT_SHARED
{
	/* 0x0000 */ volatile long WorkingSetLock;
	/* 0x0004 */ long GoodCitizenWaiting;
	/* 0x0008 */ unsigned __int64 ReleasedCommitDebt;
	/* 0x0010 */ unsigned __int64 ResetPagesRepurposedCount;
	/* 0x0018 */ void* WsSwapSupport;
	/* 0x0020 */ void* CommitReleaseContext;
	/* 0x0028 */ void* AccessLog;
	/* 0x0030 */ volatile unsigned __int64 ChargedWslePages;
	/* 0x0038 */ unsigned __int64 ActualWslePages;
	/* 0x0040 */ unsigned __int64 WorkingSetCoreLock;
	/* 0x0048 */ void* ShadowMapping;
	/* 0x0050 */ long __PADDING__[12];
} MMSUPPORT_SHARED, * PMMSUPPORT_SHARED; /* size: 0x0080 */

typedef struct _MMSUPPORT_FULL
{
	/* 0x0000 */ struct _MMSUPPORT_INSTANCE Instance;
	/* 0x00c0 */ struct _MMSUPPORT_SHARED Shared;
} MMSUPPORT_FULL, * PMMSUPPORT_FULL; /* size: 0x0140 */

typedef struct _JOBOBJECT_WAKE_FILTER
{
	/* 0x0000 */ unsigned long HighEdgeFilter;
	/* 0x0004 */ unsigned long LowEdgeFilter;
} JOBOBJECT_WAKE_FILTER, * PJOBOBJECT_WAKE_FILTER; /* size: 0x0008 */

typedef struct _PS_PROCESS_WAKE_INFORMATION
{
	/* 0x0000 */ unsigned __int64 NotificationChannel;
	/* 0x0008 */ unsigned long WakeCounters[7];
	/* 0x0024 */ struct _JOBOBJECT_WAKE_FILTER WakeFilter;
	/* 0x002c */ unsigned long NoWakeCounter;
} PS_PROCESS_WAKE_INFORMATION, * PPS_PROCESS_WAKE_INFORMATION; /* size: 0x0030 */

typedef struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES
{
	/* 0x0000 */ struct _RTL_AVL_TREE Tree;
	/* 0x0008 */ struct _EX_PUSH_LOCK Lock;
} PS_DYNAMIC_ENFORCED_ADDRESS_RANGES, * PPS_DYNAMIC_ENFORCED_ADDRESS_RANGES; /* size: 0x0010 */

typedef struct _EPROCESS_S
{
	/* 0x0000 */ struct _KPROCESS Pcb;
	/* 0x0438 */ struct _EX_PUSH_LOCK ProcessLock;
	/* 0x0440 */ void* UniqueProcessId;
	/* 0x0448 */ struct _LIST_ENTRY ActiveProcessLinks;
	/* 0x0458 */ struct _EX_RUNDOWN_REF RundownProtect;
	union
	{
		/* 0x0460 */ unsigned long Flags2;
		struct /* bitfield */
		{
			/* 0x0460 */ unsigned long JobNotReallyActive : 1; /* bit position: 0 */
			/* 0x0460 */ unsigned long AccountingFolded : 1; /* bit position: 1 */
			/* 0x0460 */ unsigned long NewProcessReported : 1; /* bit position: 2 */
			/* 0x0460 */ unsigned long ExitProcessReported : 1; /* bit position: 3 */
			/* 0x0460 */ unsigned long ReportCommitChanges : 1; /* bit position: 4 */
			/* 0x0460 */ unsigned long LastReportMemory : 1; /* bit position: 5 */
			/* 0x0460 */ unsigned long ForceWakeCharge : 1; /* bit position: 6 */
			/* 0x0460 */ unsigned long CrossSessionCreate : 1; /* bit position: 7 */
			/* 0x0460 */ unsigned long NeedsHandleRundown : 1; /* bit position: 8 */
			/* 0x0460 */ unsigned long RefTraceEnabled : 1; /* bit position: 9 */
			/* 0x0460 */ unsigned long PicoCreated : 1; /* bit position: 10 */
			/* 0x0460 */ unsigned long EmptyJobEvaluated : 1; /* bit position: 11 */
			/* 0x0460 */ unsigned long DefaultPagePriority : 3; /* bit position: 12 */
			/* 0x0460 */ unsigned long PrimaryTokenFrozen : 1; /* bit position: 15 */
			/* 0x0460 */ unsigned long ProcessVerifierTarget : 1; /* bit position: 16 */
			/* 0x0460 */ unsigned long RestrictSetThreadContext : 1; /* bit position: 17 */
			/* 0x0460 */ unsigned long AffinityPermanent : 1; /* bit position: 18 */
			/* 0x0460 */ unsigned long AffinityUpdateEnable : 1; /* bit position: 19 */
			/* 0x0460 */ unsigned long PropagateNode : 1; /* bit position: 20 */
			/* 0x0460 */ unsigned long ExplicitAffinity : 1; /* bit position: 21 */
			/* 0x0460 */ unsigned long ProcessExecutionState : 2; /* bit position: 22 */
			/* 0x0460 */ unsigned long EnableReadVmLogging : 1; /* bit position: 24 */
			/* 0x0460 */ unsigned long EnableWriteVmLogging : 1; /* bit position: 25 */
			/* 0x0460 */ unsigned long FatalAccessTerminationRequested : 1; /* bit position: 26 */
			/* 0x0460 */ unsigned long DisableSystemAllowedCpuSet : 1; /* bit position: 27 */
			/* 0x0460 */ unsigned long ProcessStateChangeRequest : 2; /* bit position: 28 */
			/* 0x0460 */ unsigned long ProcessStateChangeInProgress : 1; /* bit position: 30 */
			/* 0x0460 */ unsigned long InPrivate : 1; /* bit position: 31 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	union
	{
		/* 0x0464 */ unsigned long Flags;
		struct /* bitfield */
		{
			/* 0x0464 */ unsigned long CreateReported : 1; /* bit position: 0 */
			/* 0x0464 */ unsigned long NoDebugInherit : 1; /* bit position: 1 */
			/* 0x0464 */ unsigned long ProcessExiting : 1; /* bit position: 2 */
			/* 0x0464 */ unsigned long ProcessDelete : 1; /* bit position: 3 */
			/* 0x0464 */ unsigned long ManageExecutableMemoryWrites : 1; /* bit position: 4 */
			/* 0x0464 */ unsigned long VmDeleted : 1; /* bit position: 5 */
			/* 0x0464 */ unsigned long OutswapEnabled : 1; /* bit position: 6 */
			/* 0x0464 */ unsigned long Outswapped : 1; /* bit position: 7 */
			/* 0x0464 */ unsigned long FailFastOnCommitFail : 1; /* bit position: 8 */
			/* 0x0464 */ unsigned long Wow64VaSpace4Gb : 1; /* bit position: 9 */
			/* 0x0464 */ unsigned long AddressSpaceInitialized : 2; /* bit position: 10 */
			/* 0x0464 */ unsigned long SetTimerResolution : 1; /* bit position: 12 */
			/* 0x0464 */ unsigned long BreakOnTermination : 1; /* bit position: 13 */
			/* 0x0464 */ unsigned long DeprioritizeViews : 1; /* bit position: 14 */
			/* 0x0464 */ unsigned long WriteWatch : 1; /* bit position: 15 */
			/* 0x0464 */ unsigned long ProcessInSession : 1; /* bit position: 16 */
			/* 0x0464 */ unsigned long OverrideAddressSpace : 1; /* bit position: 17 */
			/* 0x0464 */ unsigned long HasAddressSpace : 1; /* bit position: 18 */
			/* 0x0464 */ unsigned long LaunchPrefetched : 1; /* bit position: 19 */
			/* 0x0464 */ unsigned long Background : 1; /* bit position: 20 */
			/* 0x0464 */ unsigned long VmTopDown : 1; /* bit position: 21 */
			/* 0x0464 */ unsigned long ImageNotifyDone : 1; /* bit position: 22 */
			/* 0x0464 */ unsigned long PdeUpdateNeeded : 1; /* bit position: 23 */
			/* 0x0464 */ unsigned long VdmAllowed : 1; /* bit position: 24 */
			/* 0x0464 */ unsigned long ProcessRundown : 1; /* bit position: 25 */
			/* 0x0464 */ unsigned long ProcessInserted : 1; /* bit position: 26 */
			/* 0x0464 */ unsigned long DefaultIoPriority : 3; /* bit position: 27 */
			/* 0x0464 */ unsigned long ProcessSelfDelete : 1; /* bit position: 30 */
			/* 0x0464 */ unsigned long SetTimerResolutionLink : 1; /* bit position: 31 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0468 */ union _LARGE_INTEGER CreateTime;
	/* 0x0470 */ unsigned __int64 ProcessQuotaUsage[2];
	/* 0x0480 */ unsigned __int64 ProcessQuotaPeak[2];
	/* 0x0490 */ unsigned __int64 PeakVirtualSize;
	/* 0x0498 */ unsigned __int64 VirtualSize;
	/* 0x04a0 */ struct _LIST_ENTRY SessionProcessLinks;
	union
	{
		/* 0x04b0 */ void* ExceptionPortData;
		/* 0x04b0 */ unsigned __int64 ExceptionPortValue;
		/* 0x04b0 */ unsigned __int64 ExceptionPortState : 3; /* bit position: 0 */
	}; /* size: 0x0008 */
	/* 0x04b8 */ struct _EX_FAST_REF Token;
	/* 0x04c0 */ unsigned __int64 MmReserved;
	/* 0x04c8 */ struct _EX_PUSH_LOCK AddressCreationLock;
	/* 0x04d0 */ struct _EX_PUSH_LOCK PageTableCommitmentLock;
	/* 0x04d8 */ struct _ETHREAD* RotateInProgress;
	/* 0x04e0 */ struct _ETHREAD* ForkInProgress;
	/* 0x04e8 */ struct _EJOB* volatile CommitChargeJob;
	/* 0x04f0 */ struct _RTL_AVL_TREE CloneRoot;
	/* 0x04f8 */ volatile unsigned __int64 NumberOfPrivatePages;
	/* 0x0500 */ volatile unsigned __int64 NumberOfLockedPages;
	/* 0x0508 */ void* Win32Process;
	/* 0x0510 */ struct _EJOB* volatile Job;
	/* 0x0518 */ void* SectionObject;
	/* 0x0520 */ void* SectionBaseAddress;
	/* 0x0528 */ unsigned long Cookie;
	/* 0x052c */ long Padding_1;
	/* 0x0530 */ struct _PAGEFAULT_HISTORY* WorkingSetWatch;
	/* 0x0538 */ void* Win32WindowStation;
	/* 0x0540 */ void* InheritedFromUniqueProcessId;
	/* 0x0548 */ volatile unsigned __int64 OwnerProcessId;
	/* 0x0550 */ struct _PEB* Peb;
	/* 0x0558 */ struct _MM_SESSION_SPACE* Session;
	/* 0x0560 */ void* Spare1;
	/* 0x0568 */ struct _EPROCESS_QUOTA_BLOCK* QuotaBlock;
	/* 0x0570 */ struct _HANDLE_TABLE* ObjectTable;
	/* 0x0578 */ void* DebugPort;
	/* 0x0580 */ struct _EWOW64PROCESS* WoW64Process;
	/* 0x0588 */ void* DeviceMap;
	/* 0x0590 */ void* EtwDataSource;
	/* 0x0598 */ unsigned __int64 PageDirectoryPte;
	/* 0x05a0 */ struct _FILE_OBJECT* ImageFilePointer;
	/* 0x05a8 */ unsigned char ImageFileName[15];
	/* 0x05b7 */ unsigned char PriorityClass;
	/* 0x05b8 */ void* SecurityPort;
	/* 0x05c0 */ struct _SE_AUDIT_PROCESS_CREATION_INFO SeAuditProcessCreationInfo;
	/* 0x05c8 */ struct _LIST_ENTRY JobLinks;
	/* 0x05d8 */ void* HighestUserAddress;
	/* 0x05e0 */ struct _LIST_ENTRY ThreadListHead;
	/* 0x05f0 */ volatile unsigned long ActiveThreads;
	/* 0x05f4 */ unsigned long ImagePathHash;
	/* 0x05f8 */ unsigned long DefaultHardErrorProcessing;
	/* 0x05fc */ long LastThreadExitStatus;
	/* 0x0600 */ struct _EX_FAST_REF PrefetchTrace;
	/* 0x0608 */ void* LockedPagesList;
	/* 0x0610 */ union _LARGE_INTEGER ReadOperationCount;
	/* 0x0618 */ union _LARGE_INTEGER WriteOperationCount;
	/* 0x0620 */ union _LARGE_INTEGER OtherOperationCount;
	/* 0x0628 */ union _LARGE_INTEGER ReadTransferCount;
	/* 0x0630 */ union _LARGE_INTEGER WriteTransferCount;
	/* 0x0638 */ union _LARGE_INTEGER OtherTransferCount;
	/* 0x0640 */ unsigned __int64 CommitChargeLimit;
	/* 0x0648 */ volatile unsigned __int64 CommitCharge;
	/* 0x0650 */ volatile unsigned __int64 CommitChargePeak;
	/* 0x0658 */ long Padding_2[10];
	/* 0x0680 */ struct _MMSUPPORT_FULL Vm;
	/* 0x07c0 */ struct _LIST_ENTRY MmProcessLinks;
	/* 0x07d0 */ unsigned long ModifiedPageCount;
	/* 0x07d4 */ long ExitStatus;
	/* 0x07d8 */ struct _RTL_AVL_TREE VadRoot;
	/* 0x07e0 */ void* VadHint;
	/* 0x07e8 */ unsigned __int64 VadCount;
	/* 0x07f0 */ volatile unsigned __int64 VadPhysicalPages;
	/* 0x07f8 */ unsigned __int64 VadPhysicalPagesLimit;
	/* 0x0800 */ struct _ALPC_PROCESS_CONTEXT AlpcContext;
	/* 0x0820 */ struct _LIST_ENTRY TimerResolutionLink;
	/* 0x0830 */ struct _PO_DIAG_STACK_RECORD* TimerResolutionStackRecord;
	/* 0x0838 */ unsigned long RequestedTimerResolution;
	/* 0x083c */ unsigned long SmallestTimerResolution;
	/* 0x0840 */ union _LARGE_INTEGER ExitTime;
	/* 0x0848 */ struct _INVERTED_FUNCTION_TABLE* InvertedFunctionTable;
	/* 0x0850 */ struct _EX_PUSH_LOCK InvertedFunctionTableLock;
	/* 0x0858 */ unsigned long ActiveThreadsHighWatermark;
	/* 0x085c */ unsigned long LargePrivateVadCount;
	/* 0x0860 */ struct _EX_PUSH_LOCK ThreadListLock;
	/* 0x0868 */ void* WnfContext;
	/* 0x0870 */ struct _EJOB* ServerSilo;
	/* 0x0878 */ unsigned char SignatureLevel;
	/* 0x0879 */ unsigned char SectionSignatureLevel;
	/* 0x087a */ struct _PS_PROTECTION Protection;
	struct /* bitfield */
	{
		/* 0x087b */ unsigned char HangCount : 3; /* bit position: 0 */
		/* 0x087b */ unsigned char GhostCount : 3; /* bit position: 3 */
		/* 0x087b */ unsigned char PrefilterException : 1; /* bit position: 6 */
	}; /* bitfield */
	union
	{
		/* 0x087c */ unsigned long Flags3;
		struct /* bitfield */
		{
			/* 0x087c */ unsigned long Minimal : 1; /* bit position: 0 */
			/* 0x087c */ unsigned long ReplacingPageRoot : 1; /* bit position: 1 */
			/* 0x087c */ unsigned long Crashed : 1; /* bit position: 2 */
			/* 0x087c */ unsigned long JobVadsAreTracked : 1; /* bit position: 3 */
			/* 0x087c */ unsigned long VadTrackingDisabled : 1; /* bit position: 4 */
			/* 0x087c */ unsigned long AuxiliaryProcess : 1; /* bit position: 5 */
			/* 0x087c */ unsigned long SubsystemProcess : 1; /* bit position: 6 */
			/* 0x087c */ unsigned long IndirectCpuSets : 1; /* bit position: 7 */
			/* 0x087c */ unsigned long RelinquishedCommit : 1; /* bit position: 8 */
			/* 0x087c */ unsigned long HighGraphicsPriority : 1; /* bit position: 9 */
			/* 0x087c */ unsigned long CommitFailLogged : 1; /* bit position: 10 */
			/* 0x087c */ unsigned long ReserveFailLogged : 1; /* bit position: 11 */
			/* 0x087c */ unsigned long SystemProcess : 1; /* bit position: 12 */
			/* 0x087c */ unsigned long HideImageBaseAddresses : 1; /* bit position: 13 */
			/* 0x087c */ unsigned long AddressPolicyFrozen : 1; /* bit position: 14 */
			/* 0x087c */ unsigned long ProcessFirstResume : 1; /* bit position: 15 */
			/* 0x087c */ unsigned long ForegroundExternal : 1; /* bit position: 16 */
			/* 0x087c */ unsigned long ForegroundSystem : 1; /* bit position: 17 */
			/* 0x087c */ unsigned long HighMemoryPriority : 1; /* bit position: 18 */
			/* 0x087c */ unsigned long EnableProcessSuspendResumeLogging : 1; /* bit position: 19 */
			/* 0x087c */ unsigned long EnableThreadSuspendResumeLogging : 1; /* bit position: 20 */
			/* 0x087c */ unsigned long SecurityDomainChanged : 1; /* bit position: 21 */
			/* 0x087c */ unsigned long SecurityFreezeComplete : 1; /* bit position: 22 */
			/* 0x087c */ unsigned long VmProcessorHost : 1; /* bit position: 23 */
			/* 0x087c */ unsigned long VmProcessorHostTransition : 1; /* bit position: 24 */
			/* 0x087c */ unsigned long AltSyscall : 1; /* bit position: 25 */
			/* 0x087c */ unsigned long TimerResolutionIgnore : 1; /* bit position: 26 */
			/* 0x087c */ unsigned long DisallowUserTerminate : 1; /* bit position: 27 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0880 */ long DeviceAsid;
	/* 0x0884 */ long Padding_3;
	/* 0x0888 */ void* SvmData;
	/* 0x0890 */ struct _EX_PUSH_LOCK SvmProcessLock;
	/* 0x0898 */ unsigned __int64 SvmLock;
	/* 0x08a0 */ struct _LIST_ENTRY SvmProcessDeviceListHead;
	/* 0x08b0 */ unsigned __int64 LastFreezeInterruptTime;
	/* 0x08b8 */ struct _PROCESS_DISK_COUNTERS* DiskCounters;
	/* 0x08c0 */ void* PicoContext;
	/* 0x08c8 */ void* EnclaveTable;
	/* 0x08d0 */ unsigned __int64 EnclaveNumber;
	/* 0x08d8 */ struct _EX_PUSH_LOCK EnclaveLock;
	/* 0x08e0 */ unsigned long HighPriorityFaultsAllowed;
	/* 0x08e4 */ long Padding_4;
	/* 0x08e8 */ struct _PO_PROCESS_ENERGY_CONTEXT* EnergyContext;
	/* 0x08f0 */ void* VmContext;
	/* 0x08f8 */ unsigned __int64 SequenceNumber;
	/* 0x0900 */ unsigned __int64 CreateInterruptTime;
	/* 0x0908 */ unsigned __int64 CreateUnbiasedInterruptTime;
	/* 0x0910 */ unsigned __int64 TotalUnbiasedFrozenTime;
	/* 0x0918 */ unsigned __int64 LastAppStateUpdateTime;
	struct /* bitfield */
	{
		/* 0x0920 */ unsigned __int64 LastAppStateUptime : 61; /* bit position: 0 */
		/* 0x0920 */ unsigned __int64 LastAppState : 3; /* bit position: 61 */
	}; /* bitfield */
	/* 0x0928 */ volatile unsigned __int64 SharedCommitCharge;
	/* 0x0930 */ struct _EX_PUSH_LOCK SharedCommitLock;
	/* 0x0938 */ struct _LIST_ENTRY SharedCommitLinks;
	union
	{
		struct
		{
			/* 0x0948 */ unsigned __int64 AllowedCpuSets;
			/* 0x0950 */ unsigned __int64 DefaultCpuSets;
		}; /* size: 0x0010 */
		struct
		{
			/* 0x0948 */ unsigned __int64* AllowedCpuSetsIndirect;
			/* 0x0950 */ unsigned __int64* DefaultCpuSetsIndirect;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0958 */ void* DiskIoAttribution;
	/* 0x0960 */ void* DxgProcess;
	/* 0x0968 */ unsigned long Win32KFilterSet;
	/* 0x096c */ long Padding_5;
	/* 0x0970 */ volatile union _PS_INTERLOCKED_TIMER_DELAY_VALUES ProcessTimerDelay;
	/* 0x0978 */ volatile unsigned long KTimerSets;
	/* 0x097c */ volatile unsigned long KTimer2Sets;
	/* 0x0980 */ volatile unsigned long ThreadTimerSets;
	/* 0x0984 */ long Padding_6;
	/* 0x0988 */ unsigned __int64 VirtualTimerListLock;
	/* 0x0990 */ struct _LIST_ENTRY VirtualTimerListHead;
	union
	{
		/* 0x09a0 */ struct _WNF_STATE_NAME WakeChannel;
		/* 0x09a0 */ struct _PS_PROCESS_WAKE_INFORMATION WakeInfo;
	}; /* size: 0x0030 */
	union
	{
		/* 0x09d0 */ unsigned long MitigationFlags;
		struct
		{
			struct /* bitfield */
			{
				/* 0x09d0 */ unsigned long ControlFlowGuardEnabled : 1; /* bit position: 0 */
				/* 0x09d0 */ unsigned long ControlFlowGuardExportSuppressionEnabled : 1; /* bit position: 1 */
				/* 0x09d0 */ unsigned long ControlFlowGuardStrict : 1; /* bit position: 2 */
				/* 0x09d0 */ unsigned long DisallowStrippedImages : 1; /* bit position: 3 */
				/* 0x09d0 */ unsigned long ForceRelocateImages : 1; /* bit position: 4 */
				/* 0x09d0 */ unsigned long HighEntropyASLREnabled : 1; /* bit position: 5 */
				/* 0x09d0 */ unsigned long StackRandomizationDisabled : 1; /* bit position: 6 */
				/* 0x09d0 */ unsigned long ExtensionPointDisable : 1; /* bit position: 7 */
				/* 0x09d0 */ unsigned long DisableDynamicCode : 1; /* bit position: 8 */
				/* 0x09d0 */ unsigned long DisableDynamicCodeAllowOptOut : 1; /* bit position: 9 */
				/* 0x09d0 */ unsigned long DisableDynamicCodeAllowRemoteDowngrade : 1; /* bit position: 10 */
				/* 0x09d0 */ unsigned long AuditDisableDynamicCode : 1; /* bit position: 11 */
				/* 0x09d0 */ unsigned long DisallowWin32kSystemCalls : 1; /* bit position: 12 */
				/* 0x09d0 */ unsigned long AuditDisallowWin32kSystemCalls : 1; /* bit position: 13 */
				/* 0x09d0 */ unsigned long EnableFilteredWin32kAPIs : 1; /* bit position: 14 */
				/* 0x09d0 */ unsigned long AuditFilteredWin32kAPIs : 1; /* bit position: 15 */
				/* 0x09d0 */ unsigned long DisableNonSystemFonts : 1; /* bit position: 16 */
				/* 0x09d0 */ unsigned long AuditNonSystemFontLoading : 1; /* bit position: 17 */
				/* 0x09d0 */ unsigned long PreferSystem32Images : 1; /* bit position: 18 */
				/* 0x09d0 */ unsigned long ProhibitRemoteImageMap : 1; /* bit position: 19 */
				/* 0x09d0 */ unsigned long AuditProhibitRemoteImageMap : 1; /* bit position: 20 */
				/* 0x09d0 */ unsigned long ProhibitLowILImageMap : 1; /* bit position: 21 */
				/* 0x09d0 */ unsigned long AuditProhibitLowILImageMap : 1; /* bit position: 22 */
				/* 0x09d0 */ unsigned long SignatureMitigationOptIn : 1; /* bit position: 23 */
				/* 0x09d0 */ unsigned long AuditBlockNonMicrosoftBinaries : 1; /* bit position: 24 */
				/* 0x09d0 */ unsigned long AuditBlockNonMicrosoftBinariesAllowStore : 1; /* bit position: 25 */
				/* 0x09d0 */ unsigned long LoaderIntegrityContinuityEnabled : 1; /* bit position: 26 */
				/* 0x09d0 */ unsigned long AuditLoaderIntegrityContinuity : 1; /* bit position: 27 */
				/* 0x09d0 */ unsigned long EnableModuleTamperingProtection : 1; /* bit position: 28 */
				/* 0x09d0 */ unsigned long EnableModuleTamperingProtectionNoInherit : 1; /* bit position: 29 */
				/* 0x09d0 */ unsigned long RestrictIndirectBranchPrediction : 1; /* bit position: 30 */
				/* 0x09d0 */ unsigned long IsolateSecurityDomain : 1; /* bit position: 31 */
			}; /* bitfield */
		} /* size: 0x0004 */ MitigationFlagsValues;
	}; /* size: 0x0004 */
	union
	{
		/* 0x09d4 */ unsigned long MitigationFlags2;
		struct
		{
			struct /* bitfield */
			{
				/* 0x09d4 */ unsigned long EnableExportAddressFilter : 1; /* bit position: 0 */
				/* 0x09d4 */ unsigned long AuditExportAddressFilter : 1; /* bit position: 1 */
				/* 0x09d4 */ unsigned long EnableExportAddressFilterPlus : 1; /* bit position: 2 */
				/* 0x09d4 */ unsigned long AuditExportAddressFilterPlus : 1; /* bit position: 3 */
				/* 0x09d4 */ unsigned long EnableRopStackPivot : 1; /* bit position: 4 */
				/* 0x09d4 */ unsigned long AuditRopStackPivot : 1; /* bit position: 5 */
				/* 0x09d4 */ unsigned long EnableRopCallerCheck : 1; /* bit position: 6 */
				/* 0x09d4 */ unsigned long AuditRopCallerCheck : 1; /* bit position: 7 */
				/* 0x09d4 */ unsigned long EnableRopSimExec : 1; /* bit position: 8 */
				/* 0x09d4 */ unsigned long AuditRopSimExec : 1; /* bit position: 9 */
				/* 0x09d4 */ unsigned long EnableImportAddressFilter : 1; /* bit position: 10 */
				/* 0x09d4 */ unsigned long AuditImportAddressFilter : 1; /* bit position: 11 */
				/* 0x09d4 */ unsigned long DisablePageCombine : 1; /* bit position: 12 */
				/* 0x09d4 */ unsigned long SpeculativeStoreBypassDisable : 1; /* bit position: 13 */
				/* 0x09d4 */ unsigned long CetUserShadowStacks : 1; /* bit position: 14 */
				/* 0x09d4 */ unsigned long AuditCetUserShadowStacks : 1; /* bit position: 15 */
				/* 0x09d4 */ unsigned long AuditCetUserShadowStacksLogged : 1; /* bit position: 16 */
				/* 0x09d4 */ unsigned long UserCetSetContextIpValidation : 1; /* bit position: 17 */
				/* 0x09d4 */ unsigned long AuditUserCetSetContextIpValidation : 1; /* bit position: 18 */
				/* 0x09d4 */ unsigned long AuditUserCetSetContextIpValidationLogged : 1; /* bit position: 19 */
				/* 0x09d4 */ unsigned long CetUserShadowStacksStrictMode : 1; /* bit position: 20 */
				/* 0x09d4 */ unsigned long BlockNonCetBinaries : 1; /* bit position: 21 */
				/* 0x09d4 */ unsigned long BlockNonCetBinariesNonEhcont : 1; /* bit position: 22 */
				/* 0x09d4 */ unsigned long AuditBlockNonCetBinaries : 1; /* bit position: 23 */
				/* 0x09d4 */ unsigned long AuditBlockNonCetBinariesLogged : 1; /* bit position: 24 */
				/* 0x09d4 */ unsigned long Reserved1 : 1; /* bit position: 25 */
				/* 0x09d4 */ unsigned long Reserved2 : 1; /* bit position: 26 */
				/* 0x09d4 */ unsigned long Reserved3 : 1; /* bit position: 27 */
				/* 0x09d4 */ unsigned long Reserved4 : 1; /* bit position: 28 */
				/* 0x09d4 */ unsigned long Reserved5 : 1; /* bit position: 29 */
				/* 0x09d4 */ unsigned long CetDynamicApisOutOfProcOnly : 1; /* bit position: 30 */
				/* 0x09d4 */ unsigned long UserCetSetContextIpValidationRelaxedMode : 1; /* bit position: 31 */
			}; /* bitfield */
		} /* size: 0x0004 */ MitigationFlags2Values;
	}; /* size: 0x0004 */
	/* 0x09d8 */ void* PartitionObject;
	/* 0x09e0 */ unsigned __int64 SecurityDomain;
	/* 0x09e8 */ unsigned __int64 ParentSecurityDomain;
	/* 0x09f0 */ void* CoverageSamplerContext;
	/* 0x09f8 */ void* MmHotPatchContext;
	/* 0x0a00 */ struct _RTL_AVL_TREE DynamicEHContinuationTargetsTree;
	/* 0x0a08 */ struct _EX_PUSH_LOCK DynamicEHContinuationTargetsLock;
	/* 0x0a10 */ struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES DynamicEnforcedCetCompatibleRanges;
	/* 0x0a20 */ unsigned long DisabledComponentFlags;
	/* 0x0a24 */ long __PADDING__[7];
} EPROCESS_S, * PEPROCESS_S; /* size: 0x0a40 */

typedef struct _EPROCESS_test
{
	/* 0x0000 */ struct _KPROCESS Pcb;
	/* 0x0438 */ struct _EX_PUSH_LOCK ProcessLock;
	/* 0x0440 */ void* UniqueProcessId;
	/* 0x0448 */ struct _LIST_ENTRY ActiveProcessLinks;
	/* 0x0458 */ struct _EX_RUNDOWN_REF RundownProtect;
}EPROCESS_test, * PEPROCESS_test;

typedef struct _PEB_LDR_DATA                            // 9 elements, 0x58 bytes (sizeof)
{
	/*0x000*/     ULONG32      Length;
	/*0x004*/     UINT8        Initialized;
	/*0x005*/     UINT8        _PADDING0_[0x3];
	/*0x008*/     VOID*        SsHandle;
	/*0x010*/     struct _LIST_ENTRY InLoadOrderModuleList;           // 2 elements, 0x10 bytes (sizeof)
	/*0x020*/     struct _LIST_ENTRY InMemoryOrderModuleList;         // 2 elements, 0x10 bytes (sizeof)
	/*0x030*/     struct _LIST_ENTRY InInitializationOrderModuleList; // 2 elements, 0x10 bytes (sizeof)
	/*0x040*/     VOID*        EntryInProgress;
	/*0x048*/     UINT8        ShutdownInProgress;
	/*0x049*/     UINT8        _PADDING1_[0x7];
	/*0x050*/     VOID*        ShutdownThreadId;
}PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY                         // 24 elements, 0xE0 bytes (sizeof)
{
	/*0x000*/     struct _LIST_ENTRY InLoadOrderLinks;                     // 2 elements, 0x10 bytes (sizeof)
	/*0x010*/     struct _LIST_ENTRY InMemoryOrderLinks;                   // 2 elements, 0x10 bytes (sizeof)
	/*0x020*/     struct _LIST_ENTRY InInitializationOrderLinks;           // 2 elements, 0x10 bytes (sizeof)
	/*0x030*/     VOID*        DllBase;
	/*0x038*/     VOID*        EntryPoint;
	/*0x040*/     ULONG32      SizeOfImage;
	/*0x044*/     UINT8        _PADDING0_[0x4];
	/*0x048*/     struct _UNICODE_STRING FullDllName;                      // 3 elements, 0x10 bytes (sizeof)
	/*0x058*/     struct _UNICODE_STRING BaseDllName;                      // 3 elements, 0x10 bytes (sizeof)
	/*0x068*/     ULONG32      Flags;
	/*0x06C*/     UINT16       LoadCount;
	/*0x06E*/     UINT16       TlsIndex;
	union                                                    // 2 elements, 0x10 bytes (sizeof)
	{
		/*0x070*/         struct _LIST_ENTRY HashLinks;                        // 2 elements, 0x10 bytes (sizeof)
		struct                                               // 2 elements, 0x10 bytes (sizeof)
		{
			/*0x070*/             VOID*        SectionPointer;
			/*0x078*/             ULONG32      CheckSum;
			/*0x07C*/             UINT8        _PADDING1_[0x4];
		};
	};
	union                                                    // 2 elements, 0x8 bytes (sizeof)
	{
		/*0x080*/         ULONG32      TimeDateStamp;
		/*0x080*/         VOID*        LoadedImports;
	};
	/*0x088*/     ULONG64 EntryPointActivationContext;
	/*0x090*/     VOID*        PatchInformation;
	/*0x098*/     struct _LIST_ENTRY ForwarderLinks;                       // 2 elements, 0x10 bytes (sizeof)
	/*0x0A8*/     struct _LIST_ENTRY ServiceTagLinks;                      // 2 elements, 0x10 bytes (sizeof)
	/*0x0B8*/     struct _LIST_ENTRY StaticLinks;                          // 2 elements, 0x10 bytes (sizeof)
	/*0x0C8*/     VOID*        ContextInformation;
	/*0x0D0*/     UINT64       OriginalBase;
	/*0x0D8*/     union _LARGE_INTEGER LoadTime;                           // 4 elements, 0x8 bytes (sizeof)
}LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _CLIENT_ID64     // 2 elements, 0x10 bytes (sizeof)
{
	/*0x000*/     UINT64       UniqueProcess;
	/*0x008*/     UINT64       UniqueThread;
}CLIENT_ID64, *PCLIENT_ID64;

typedef struct _GDI_TEB_BATCH64   // 3 elements, 0x4E8 bytes (sizeof)
{
	/*0x000*/     ULONG32      Offset;
	/*0x004*/     UINT8        _PADDING0_[0x4];
	/*0x008*/     UINT64       HDC;
	/*0x010*/     ULONG32      Buffer[310];
}GDI_TEB_BATCH64, *PGDI_TEB_BATCH64;

typedef struct _ACTIVATION_CONTEXT_STACK64
{
	/* 0x0000 */ unsigned __int64 ActiveFrame;
	/* 0x0008 */ struct LIST_ENTRY64 FrameListCache;
	/* 0x0018 */ unsigned long Flags;
	/* 0x001c */ unsigned long NextCookieSequenceNumber;
	/* 0x0020 */ unsigned long StackId;
	/* 0x0024 */ long __PADDING__[1];
} ACTIVATION_CONTEXT_STACK64, * PACTIVATION_CONTEXT_STACK64; /* size: 0x0028 */

typedef struct _TEB64
{
	/* 0x0000 */ struct _NT_TIB64 NtTib;
	/* 0x0038 */ unsigned __int64 EnvironmentPointer;
	/* 0x0040 */ struct _CLIENT_ID64 ClientId;
	/* 0x0050 */ unsigned __int64 ActiveRpcHandle;
	/* 0x0058 */ unsigned __int64 ThreadLocalStoragePointer;
	/* 0x0060 */ unsigned __int64 ProcessEnvironmentBlock;
	/* 0x0068 */ unsigned long LastErrorValue;
	/* 0x006c */ unsigned long CountOfOwnedCriticalSections;
	/* 0x0070 */ unsigned __int64 CsrClientThread;
	/* 0x0078 */ unsigned __int64 Win32ThreadInfo;
	/* 0x0080 */ unsigned long User32Reserved[26];
	/* 0x00e8 */ unsigned long UserReserved[5];
	/* 0x00fc */ long Padding_2;
	/* 0x0100 */ unsigned __int64 WOW32Reserved;
	/* 0x0108 */ unsigned long CurrentLocale;
	/* 0x010c */ unsigned long FpSoftwareStatusRegister;
	/* 0x0110 */ unsigned __int64 ReservedForDebuggerInstrumentation[16];
	/* 0x0190 */ unsigned __int64 SystemReserved1[30];
	/* 0x0280 */ char PlaceholderCompatibilityMode;
	/* 0x0281 */ unsigned char PlaceholderHydrationAlwaysExplicit;
	/* 0x0282 */ char PlaceholderReserved[10];
	/* 0x028c */ unsigned long ProxiedProcessId;
	/* 0x0290 */ struct _ACTIVATION_CONTEXT_STACK64 _ActivationStack;
	/* 0x02b8 */ unsigned char WorkingOnBehalfTicket[8];
	/* 0x02c0 */ long ExceptionCode;
	/* 0x02c4 */ unsigned char Padding0[4];
	/* 0x02c8 */ unsigned __int64 ActivationContextStackPointer;
	/* 0x02d0 */ unsigned __int64 InstrumentationCallbackSp;
	/* 0x02d8 */ unsigned __int64 InstrumentationCallbackPreviousPc;
	/* 0x02e0 */ unsigned __int64 InstrumentationCallbackPreviousSp;
	/* 0x02e8 */ unsigned long TxFsContext;
	/* 0x02ec */ unsigned char InstrumentationCallbackDisabled;
	/* 0x02ed */ unsigned char UnalignedLoadStoreExceptions;
	/* 0x02ee */ unsigned char Padding1[2];
	/* 0x02f0 */ struct _GDI_TEB_BATCH64 GdiTebBatch;
	/* 0x07d8 */ struct _CLIENT_ID64 RealClientId;
	/* 0x07e8 */ unsigned __int64 GdiCachedProcessHandle;
	/* 0x07f0 */ unsigned long GdiClientPID;
	/* 0x07f4 */ unsigned long GdiClientTID;
	/* 0x07f8 */ unsigned __int64 GdiThreadLocalInfo;
	/* 0x0800 */ unsigned __int64 Win32ClientInfo[62];
	/* 0x09f0 */ unsigned __int64 glDispatchTable[233];
	/* 0x1138 */ unsigned __int64 glReserved1[29];
	/* 0x1220 */ unsigned __int64 glReserved2;
	/* 0x1228 */ unsigned __int64 glSectionInfo;
	/* 0x1230 */ unsigned __int64 glSection;
	/* 0x1238 */ unsigned __int64 glTable;
	/* 0x1240 */ unsigned __int64 glCurrentRC;
	/* 0x1248 */ unsigned __int64 glContext;
	/* 0x1250 */ unsigned long LastStatusValue;
	/* 0x1254 */ unsigned char Padding2[4];
	/* 0x1258 */ struct _STRING64 StaticUnicodeString;
	/* 0x1268 */ wchar_t StaticUnicodeBuffer[261];
	/* 0x1472 */ unsigned char Padding3[6];
	/* 0x1478 */ unsigned __int64 DeallocationStack;
	/* 0x1480 */ unsigned __int64 TlsSlots[64];
	/* 0x1680 */ struct LIST_ENTRY64 TlsLinks;
	/* 0x1690 */ unsigned __int64 Vdm;
	/* 0x1698 */ unsigned __int64 ReservedForNtRpc;
	/* 0x16a0 */ unsigned __int64 DbgSsReserved[2];
	/* 0x16b0 */ unsigned long HardErrorMode;
	/* 0x16b4 */ unsigned char Padding4[4];
	/* 0x16b8 */ unsigned __int64 Instrumentation[11];
	/* 0x1710 */ struct _GUID ActivityId;
	/* 0x1720 */ unsigned __int64 SubProcessTag;
	/* 0x1728 */ unsigned __int64 PerflibData;
	/* 0x1730 */ unsigned __int64 EtwTraceData;
	/* 0x1738 */ unsigned __int64 WinSockData;
	/* 0x1740 */ unsigned long GdiBatchCount;
	union
	{
		/* 0x1744 */ struct _PROCESSOR_NUMBER CurrentIdealProcessor;
		/* 0x1744 */ unsigned long IdealProcessorValue;
		struct
		{
			/* 0x1744 */ unsigned char ReservedPad0;
			/* 0x1745 */ unsigned char ReservedPad1;
			/* 0x1746 */ unsigned char ReservedPad2;
			/* 0x1747 */ unsigned char IdealProcessor;
		}; /* size: 0x0004 */
	}; /* size: 0x0004 */
	/* 0x1748 */ unsigned long GuaranteedStackBytes;
	/* 0x174c */ unsigned char Padding5[4];
	/* 0x1750 */ unsigned __int64 ReservedForPerf;
	/* 0x1758 */ unsigned __int64 ReservedForOle;
	/* 0x1760 */ unsigned long WaitingOnLoaderLock;
	/* 0x1764 */ unsigned char Padding6[4];
	/* 0x1768 */ unsigned __int64 SavedPriorityState;
	/* 0x1770 */ unsigned __int64 ReservedForCodeCoverage;
	/* 0x1778 */ unsigned __int64 ThreadPoolData;
	/* 0x1780 */ unsigned __int64 TlsExpansionSlots;
	/* 0x1788 */ unsigned __int64 DeallocationBStore;
	/* 0x1790 */ unsigned __int64 BStoreLimit;
	/* 0x1798 */ unsigned long MuiGeneration;
	/* 0x179c */ unsigned long IsImpersonating;
	/* 0x17a0 */ unsigned __int64 NlsCache;
	/* 0x17a8 */ unsigned __int64 pShimData;
	/* 0x17b0 */ unsigned long HeapData;
	/* 0x17b4 */ unsigned char Padding7[4];
	/* 0x17b8 */ unsigned __int64 CurrentTransactionHandle;
	/* 0x17c0 */ unsigned __int64 ActiveFrame;
	/* 0x17c8 */ unsigned __int64 FlsData;
	/* 0x17d0 */ unsigned __int64 PreferredLanguages;
	/* 0x17d8 */ unsigned __int64 UserPrefLanguages;
	/* 0x17e0 */ unsigned __int64 MergedPrefLanguages;
	/* 0x17e8 */ unsigned long MuiImpersonation;
	union
	{
		/* 0x17ec */ volatile unsigned short CrossTebFlags;
		/* 0x17ec */ unsigned short SpareCrossTebBits : 16; /* bit position: 0 */
	}; /* size: 0x0002 */
	union
	{
		/* 0x17ee */ unsigned short SameTebFlags;
		struct /* bitfield */
		{
			/* 0x17ee */ unsigned short SafeThunkCall : 1; /* bit position: 0 */
			/* 0x17ee */ unsigned short InDebugPrint : 1; /* bit position: 1 */
			/* 0x17ee */ unsigned short HasFiberData : 1; /* bit position: 2 */
			/* 0x17ee */ unsigned short SkipThreadAttach : 1; /* bit position: 3 */
			/* 0x17ee */ unsigned short WerInShipAssertCode : 1; /* bit position: 4 */
			/* 0x17ee */ unsigned short RanProcessInit : 1; /* bit position: 5 */
			/* 0x17ee */ unsigned short ClonedThread : 1; /* bit position: 6 */
			/* 0x17ee */ unsigned short SuppressDebugMsg : 1; /* bit position: 7 */
			/* 0x17ee */ unsigned short DisableUserStackWalk : 1; /* bit position: 8 */
			/* 0x17ee */ unsigned short RtlExceptionAttached : 1; /* bit position: 9 */
			/* 0x17ee */ unsigned short InitialThread : 1; /* bit position: 10 */
			/* 0x17ee */ unsigned short SessionAware : 1; /* bit position: 11 */
			/* 0x17ee */ unsigned short LoadOwner : 1; /* bit position: 12 */
			/* 0x17ee */ unsigned short LoaderWorker : 1; /* bit position: 13 */
			/* 0x17ee */ unsigned short SkipLoaderInit : 1; /* bit position: 14 */
			/* 0x17ee */ unsigned short SpareSameTebBits : 1; /* bit position: 15 */
		}; /* bitfield */
	}; /* size: 0x0002 */
	/* 0x17f0 */ unsigned __int64 TxnScopeEnterCallback;
	/* 0x17f8 */ unsigned __int64 TxnScopeExitCallback;
	/* 0x1800 */ unsigned __int64 TxnScopeContext;
	/* 0x1808 */ unsigned long LockCount;
	/* 0x180c */ long WowTebOffset;
	/* 0x1810 */ unsigned __int64 ResourceRetValue;
	/* 0x1818 */ unsigned __int64 ReservedForWdf;
	/* 0x1820 */ unsigned __int64 ReservedForCrt;
	/* 0x1828 */ struct _GUID EffectiveContainerId;
} TEB64, * PTEB64; /* size: 0x1838 */









```

`HyperHideDrv/KuserSharedData.cpp`:

```cpp
#pragma warning( disable : 4201)
//#include <ntddk.h>
#include <ntifs.h>
#include "Utils.h"
#include "Hider.h"
#include "GlobalData.h"
#include "Log.h"
#include "KuserSharedData.h"

PKUSER_SHARED_DATA KernelKuserSharedData = (PKUSER_SHARED_DATA)(KUSER_SHARED_DATA_KERNELMODE);

PMMPFN MmPfnDatabase = 0;

BOOLEAN GetPfnDatabase() 
{
	ULONG64 TextSize;
	PVOID TextBase;	

	if (GetSectionData("ntoskrnl.exe", ".text", TextSize, TextBase) == FALSE)
		return FALSE;

	CONST CHAR* Pattern = "\x48\x8B\x05\x00\x00\x00\x00\x48\x89\x43\x18\x48\x8D\x05";
	CONST CHAR* Mask = "xxx????xxxxxxx";

	ULONG64 MmPfnDatabaseOffsetAddress = (ULONG64)FindSignature(TextBase, TextSize, Pattern, Mask);
	if (MmPfnDatabaseOffsetAddress >= (ULONG64)TextBase && MmPfnDatabaseOffsetAddress <= (ULONG64)TextBase + TextSize)
	{
		MmPfnDatabase = (PMMPFN)*(ULONG64*)((MmPfnDatabaseOffsetAddress + 7) + *(LONG*)(MmPfnDatabaseOffsetAddress + 3));
		LogInfo("MmPfnDataBase address 0x%llx", MmPfnDatabase);
		return TRUE;
	}

	LogError("Couldn't get PfnDatabase address");
	return FALSE;
}
VOID HookKuserSharedData(Hider::PHIDDEN_PROCESS HiddenProcess)
{
	KAPC_STATE State;
	PHYSICAL_ADDRESS PhysicalMax;
	PhysicalMax.QuadPart = ~0ULL;

	PVOID NewKuserSharedData = MmAllocateContiguousMemory(PAGE_SIZE, PhysicalMax);

	ULONG64 PfnNewKuserSharedData = MmGetPhysicalAddress(NewKuserSharedData).QuadPart >> PAGE_SHIFT;

	KeStackAttachProcess((PRKPROCESS)HiddenProcess->DebuggedProcess, &State);

	PMMPFN FakeKUSDMmpfn = (PMMPFN)(MmPfnDatabase + PfnNewKuserSharedData);

	FakeKUSDMmpfn->u4.EntireField |= 0x200000000000000;

	RtlCopyMemory(NewKuserSharedData, (PVOID)KUSER_SHARED_DATA_USERMODE, PAGE_SIZE);

	HiddenProcess->Kusd.PteKuserSharedData = (PTE*)GetPteAddress(KUSER_SHARED_DATA_USERMODE);

	HiddenProcess->Kusd.OriginalKuserSharedDataPfn = HiddenProcess->Kusd.PteKuserSharedData->Fields.PhysicalAddress;
	HiddenProcess->Kusd.PteKuserSharedData->Fields.PhysicalAddress = PfnNewKuserSharedData;
	HiddenProcess->Kusd.KuserSharedData = (PKUSER_SHARED_DATA)NewKuserSharedData;

	KeUnstackDetachProcess(&State);
}

VOID UnHookKuserSharedData(Hider::PHIDDEN_PROCESS HiddenProcess)
{
	KAPC_STATE State;
	HiddenProcess->HideTypes[HIDE_KUSER_SHARED_DATA] = FALSE;

	KeStackAttachProcess((PRKPROCESS)HiddenProcess->DebuggedProcess, &State);

	PMMPFN FakeKUSDMmpfn = (PMMPFN)(MmPfnDatabase + HiddenProcess->Kusd.PteKuserSharedData->Fields.PhysicalAddress);
	FakeKUSDMmpfn->u4.EntireField &= ~0x200000000000000;

	MmFreeContiguousMemory(HiddenProcess->Kusd.KuserSharedData);

	HiddenProcess->Kusd.KuserSharedData = NULL;
	HiddenProcess->Kusd.PteKuserSharedData->Fields.PhysicalAddress = HiddenProcess->Kusd.OriginalKuserSharedDataPfn;
	KeUnstackDetachProcess(&State);
}

VOID CounterUpdater(PVOID Context)
{
	UNREFERENCED_PARAMETER(Context);

	LARGE_INTEGER TimeToWait = { 0 };
	TimeToWait.QuadPart = -10000LL; // relative 1ms

	while (Hider::StopCounterThread == FALSE)
	{
		KeDelayExecutionThread(KernelMode, FALSE, &TimeToWait);

		KeAcquireGuardedMutex(&Hider::HiderMutex);
		PLIST_ENTRY current = Hider::HiddenProcessesHead.Flink;
		while (current != &Hider::HiddenProcessesHead)
		{
			Hider::PHIDDEN_PROCESS HiddenProcess = (Hider::PHIDDEN_PROCESS)CONTAINING_RECORD(current, Hider::HIDDEN_PROCESS, HiddenProcessesList);
			current = current->Flink;

			if (HiddenProcess->DebuggedProcess != NULL &&
				HiddenProcess->ProcessPaused == FALSE &&
				HiddenProcess->Kusd.KuserSharedData != NULL &&
				HiddenProcess->HideTypes[HIDE_KUSER_SHARED_DATA] == TRUE)
			{

				*(ULONG64*)&HiddenProcess->Kusd.KuserSharedData->InterruptTime = *(ULONG64*)&KernelKuserSharedData->InterruptTime.LowPart - HiddenProcess->Kusd.DeltaInterruptTime;
				HiddenProcess->Kusd.KuserSharedData->InterruptTime.High2Time = HiddenProcess->Kusd.KuserSharedData->InterruptTime.High1Time;

				*(ULONG64*)&HiddenProcess->Kusd.KuserSharedData->SystemTime = *(ULONG64*)&KernelKuserSharedData->SystemTime.LowPart - HiddenProcess->Kusd.DeltaSystemTime;
				HiddenProcess->Kusd.KuserSharedData->SystemTime.High2Time = HiddenProcess->Kusd.KuserSharedData->SystemTime.High1Time;

				HiddenProcess->Kusd.KuserSharedData->LastSystemRITEventTickCount = KernelKuserSharedData->LastSystemRITEventTickCount - HiddenProcess->Kusd.DeltaLastSystemRITEventTickCount;

				*(ULONG64*)&HiddenProcess->Kusd.KuserSharedData->TickCount = *(ULONG64*)&KernelKuserSharedData->TickCount.LowPart - HiddenProcess->Kusd.DeltaTickCount;
				HiddenProcess->Kusd.KuserSharedData->TickCount.High2Time = HiddenProcess->Kusd.KuserSharedData->TickCount.High1Time;

				HiddenProcess->Kusd.KuserSharedData->TimeUpdateLock = KernelKuserSharedData->TimeUpdateLock - HiddenProcess->Kusd.DeltaTimeUpdateLock;

				HiddenProcess->Kusd.KuserSharedData->BaselineSystemTimeQpc = KernelKuserSharedData->BaselineSystemTimeQpc - HiddenProcess->Kusd.DeltaBaselineSystemQpc;
				HiddenProcess->Kusd.KuserSharedData->BaselineInterruptTimeQpc = HiddenProcess->Kusd.KuserSharedData->BaselineSystemTimeQpc;
			}
		}
		KeReleaseGuardedMutex(&Hider::HiderMutex);
	}

	PsTerminateSystemThread(STATUS_SUCCESS);
}

VOID GetBegin(PEPROCESS DebuggedProcess)
{
	KeAcquireGuardedMutex(&Hider::HiderMutex);

	PLIST_ENTRY current = Hider::HiddenProcessesHead.Flink;
	while (current != &Hider::HiddenProcessesHead)
	{
		Hider::PHIDDEN_PROCESS HiddenProcess = (Hider::PHIDDEN_PROCESS)CONTAINING_RECORD(current, Hider::HIDDEN_PROCESS, HiddenProcessesList);
		current = current->Flink;

		if (DebuggedProcess == HiddenProcess->DebuggedProcess &&
			HiddenProcess->Kusd.BeginInterruptTime == NULL)
		{
			HiddenProcess->Kusd.BeginInterruptTime = *(ULONG64*)&KernelKuserSharedData->InterruptTime;
			HiddenProcess->Kusd.BeginSystemTime = *(ULONG64*)&KernelKuserSharedData->SystemTime;
			HiddenProcess->Kusd.BeginLastSystemRITEventTickCount = KernelKuserSharedData->LastSystemRITEventTickCount;
			HiddenProcess->Kusd.BeginTickCount = *(ULONG64*)&KernelKuserSharedData->TickCount;
			HiddenProcess->Kusd.BeginTimeUpdateLock = KernelKuserSharedData->TimeUpdateLock;
			HiddenProcess->Kusd.BeginBaselineSystemQpc = KernelKuserSharedData->BaselineSystemTimeQpc;
			break;
		}
	}

	KeReleaseGuardedMutex(&Hider::HiderMutex);
}

VOID UpdateDelta(PEPROCESS DebuggedProcess)
{
	KeAcquireGuardedMutex(&Hider::HiderMutex);
	PLIST_ENTRY current = Hider::HiddenProcessesHead.Flink;
	while (current != &Hider::HiddenProcessesHead)
	{
		Hider::PHIDDEN_PROCESS HiddenProcess = (Hider::PHIDDEN_PROCESS)CONTAINING_RECORD(current, Hider::HIDDEN_PROCESS, HiddenProcessesList);
		current = current->Flink;

		if (DebuggedProcess == HiddenProcess->DebuggedProcess &&
			HiddenProcess->Kusd.BeginInterruptTime != NULL)
		{
			HiddenProcess->Kusd.DeltaInterruptTime += *(ULONG64*)&KernelKuserSharedData->InterruptTime - HiddenProcess->Kusd.BeginInterruptTime;
			HiddenProcess->Kusd.DeltaSystemTime += *(ULONG64*)&KernelKuserSharedData->SystemTime - HiddenProcess->Kusd.BeginSystemTime;
			HiddenProcess->Kusd.DeltaLastSystemRITEventTickCount += KernelKuserSharedData->LastSystemRITEventTickCount - HiddenProcess->Kusd.BeginLastSystemRITEventTickCount;
			HiddenProcess->Kusd.DeltaTickCount += *(ULONG64*)&KernelKuserSharedData->TickCount - HiddenProcess->Kusd.BeginTickCount;
			HiddenProcess->Kusd.DeltaTimeUpdateLock += KernelKuserSharedData->TimeUpdateLock - HiddenProcess->Kusd.BeginTimeUpdateLock;
			HiddenProcess->Kusd.DeltaBaselineSystemQpc += KernelKuserSharedData->BaselineSystemTimeQpc - HiddenProcess->Kusd.BeginBaselineSystemQpc;

			RtlZeroMemory(&HiddenProcess->Kusd.BeginInterruptTime, sizeof(ULONG64) * 5 + 4);

			break;
		}
	}
	KeReleaseGuardedMutex(&Hider::HiderMutex);
}

```

`HyperHideDrv/KuserSharedData.h`:

```h
#pragma once

typedef struct _MMPFN
{
	union
	{
		LIST_ENTRY ListEntry;                                       //0x0
		RTL_BALANCED_NODE TreeNode;                                 //0x0
		struct
		{
			union
			{
				SINGLE_LIST_ENTRY NextSlistPfn;                     //0x0
				VOID* Next;                                                 //0x0
				ULONGLONG Flink : 36;                                         //0x0
				ULONGLONG NodeFlinkHigh : 28;                                 //0x0
				ULONGLONG Active;                               //0x0
			} u1;                                                           //0x0
			union
			{
				ULONGLONG* PteAddress;                                  //0x8
				ULONGLONG PteLong;                                          //0x8
			};
			ULONGLONG OriginalPte;                                      //0x10
		};
	};
	ULONGLONG u2;                                                  //0x18
	union
	{
		struct
		{
			USHORT ReferenceCount;                                          //0x20
			UCHAR e1;                                         //0x22
		};
		struct
		{
			UCHAR e3;                                         //0x23
			struct
			{
				USHORT ReferenceCount;                                          //0x20
			} e2;                                                               //0x20
		};
		struct
		{
			ULONG EntireField;                                              //0x20
		} e4;                                                               //0x20
	} u3;                                                                   //0x20
	USHORT NodeBlinkLow;                                                    //0x24
	UCHAR Unused : 4;                                                         //0x26
	UCHAR Unused2 : 4;                                                        //0x26
	union
	{
		UCHAR ViewCount;                                                    //0x27
		UCHAR NodeFlinkLow;                                                 //0x27
	};
	union
	{
		ULONGLONG PteFrame : 36;                                              //0x28
		ULONGLONG Channel : 2;                                                //0x28
		ULONGLONG Unused1 : 1;                                                //0x28
		ULONGLONG Unused2 : 1;                                                //0x28
		ULONGLONG Partition : 10;                                             //0x28
		ULONGLONG Spare : 2;                                                  //0x28
		ULONGLONG FileOnly : 1;                                               //0x28
		ULONGLONG PfnExists : 1;                                              //0x28
		ULONGLONG PageIdentity : 3;                                           //0x28
		ULONGLONG PrototypePte : 1;                                           //0x28
		ULONGLONG PageColor : 6;                                              //0x28
		ULONGLONG EntireField;                                              //0x28
	} u4;                                                                   //0x28
}MMPFN,*PMMPFN;

VOID HookKuserSharedData(Hider::PHIDDEN_PROCESS HiddenProcess);

VOID UnHookKuserSharedData(Hider::PHIDDEN_PROCESS HiddenProcess);

VOID GetBegin(PEPROCESS DebuggedProcess);

VOID UpdateDelta(PEPROCESS DebuggedProcess);

VOID CounterUpdater(PVOID Context);

BOOLEAN GetPfnDatabase();
```

`HyperHideDrv/Log.cpp`:

```cpp
#define _NO_CRT_STDIO_INLINE
#include <ntifs.h>
#include <stdarg.h>
#include <ntstrsafe.h>
#include "Log.h"

void LogPrint(log_type Type, const char* fmt, ...)
{
	char* LogType;
	LARGE_INTEGER SystemTime;
	LARGE_INTEGER LocalTime;
	TIME_FIELDS TimeFields;
	char TimeBuffer[20] = {};
	char MessageBuffer[412] = {};
	char OutputBuffer[512] = {};
	va_list Args = {};

	switch (Type)
	{
		case LOG_TYPE_DEBUG:
		{
			LogType = "[DEBUG]";
			break;
		}
		case LOG_TYPE_DUMP:
		{
			LogType = "[DUMP]";
			break;
		}
		case LOG_TYPE_ERROR:
		{
			LogType = "[ERROR]";
			break;
		}
		case LOG_TYPE_INFO:
		{
			LogType = "[INFORMATION]";
			break;
		}
		default:
		{
			LogType = "[UNKNOWN]";
			break;
		}

	}

	KeQuerySystemTime(&SystemTime);
	ExSystemTimeToLocalTime(&SystemTime, &LocalTime);
	RtlTimeToTimeFields(&LocalTime, &TimeFields);

	RtlStringCchPrintfA(
		TimeBuffer,
		sizeof(TimeBuffer),
		"[%02hd:%02hd:%02hd.%03hd]",
		TimeFields.Hour,
		TimeFields.Minute,
		TimeFields.Second,
		TimeFields.Milliseconds);

	va_start(Args, fmt);
	RtlStringCchVPrintfA(MessageBuffer, sizeof(MessageBuffer), fmt, Args);
	va_end(Args);

	char* OutputFormat = "%s  %s  %s\r\n";

	RtlStringCchPrintfA(
		OutputBuffer,
		sizeof(OutputBuffer),
		OutputFormat,
		TimeBuffer,
		LogType,
		MessageBuffer);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "%s", OutputBuffer);
}
```

`HyperHideDrv/Log.h`:

```h
#pragma once
#define LogError(format, ...)  \
    LogPrint(LOG_TYPE_ERROR," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogDebug(format, ...)  \
    LogPrint(LOG_TYPE_DEBUG," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogDump(format, ...)  \
    LogPrint(LOG_TYPE_DUMP," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogInfo(format, ...)  \
    LogPrint(LOG_TYPE_INFO," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)

typedef enum __log_type
{
	LOG_TYPE_DEBUG,
	LOG_TYPE_ERROR,
	LOG_TYPE_DUMP,
	LOG_TYPE_INFO
}log_type;

void LogPrint(log_type type, const char* fmt, ...);
```

`HyperHideDrv/Memroy.cpp`:

```cpp
#include "Memroy.h"

BOOLEAN WriteKernelMemory
(
	PVOID pDestination,
	PVOID pSourceAddress,
	SIZE_T SizeOfCopy)
{
	PMDL pMdl = NULL;
	PVOID pSafeAddress = NULL;
	pMdl = IoAllocateMdl(pDestination, (ULONG)SizeOfCopy, FALSE, FALSE, NULL);
	if (!pMdl) return FALSE;
	__try
	{
		MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		IoFreeMdl(pMdl);
		return FALSE;
	}
	pSafeAddress = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
	if (!pSafeAddress) return FALSE;
	RtlCopyMemory(pSafeAddress, pSourceAddress, SizeOfCopy);
	MmUnlockPages(pMdl);
	IoFreeMdl(pMdl);
	return TRUE;
}


BOOLEAN ReadKernelMemory
(
	PVOID pDestination,
	PVOID pSourceAddress,
	SIZE_T SizeOfCopy)
{
	PMDL pMdl = NULL;
	PVOID pSafeAddress = NULL;
	pMdl = IoAllocateMdl(pSourceAddress, (ULONG)SizeOfCopy, FALSE, FALSE, NULL);
	if (!pMdl) return FALSE;
	__try
	{
		MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		IoFreeMdl(pMdl);
		return FALSE;
	}
	pSafeAddress = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
	if (!pSafeAddress) return FALSE;
	RtlCopyMemory(pDestination, pSafeAddress, SizeOfCopy);
	MmUnlockPages(pMdl);
	IoFreeMdl(pMdl);
	return TRUE;
}


KIRQL WPOFFx64()
{
	KIRQL irql = KeRaiseIrqlToDpcLevel();
	UINT64 cr0 = __readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);
	_disable();
	return irql;
}
void WPONx64(KIRQL irql)
{
	UINT64 cr0 = __readcr0();
	cr0 |= 0x10000;
	_enable();
	__writecr0(cr0);
	KeLowerIrql(irql);
}



PVOID FindMemory
(
	PVOID   SearAddress,
	ULONG   SearLenth,
	TzmMode Mode,
    TZM    Tzm[5])
{
	//int Tzm[5][5]= { {0, 0}, { 0,0 }, { 0,0 }, { 0,0 }, { 0,0 } };
	
	if (!MmIsAddressValid(SearAddress))
	{
		return 0;
	}
	PUCHAR EndAddress = (PUCHAR)SearAddress + SearLenth;
	PUCHAR StartAddress = (PUCHAR)SearAddress;
	__try
	{
		for (; StartAddress < EndAddress; StartAddress++)
		{
			if (*(StartAddress + Tzm[0].Offset) == Tzm[0].Tzm &&
				*(StartAddress + Tzm[1].Offset) == Tzm[1].Tzm &&
				*(StartAddress + Tzm[2].Offset) == Tzm[2].Tzm &&
				*(StartAddress + Tzm[3].Offset) == Tzm[3].Tzm &&
				*(StartAddress + Tzm[4].Offset) == Tzm[4].Tzm)
			{

				switch (Mode)
				{
				case Normal:
					return StartAddress;
				case Call:
					return *(INT*)(StartAddress + 1) + StartAddress + 5;
				case Mov:
					return *(INT*)(StartAddress + 2) + StartAddress + 6;	
				case Lea:
					return *(INT*)(StartAddress + 3) + StartAddress + 7;

				default:
					break;
				}



			}
		}
	}
	_except(1)
	{
		
	}
	return 0;
}
PVOID FindMemoryFromReadAndWriteSection(PVOID ModuleBass, TzmMode Mode, TZM Tzm[5])
{
	if (!MmIsAddressValid(ModuleBass))
	{
		return 0;
	}
	PIMAGE_NT_HEADERS NtHeader=RtlImageNtHeader(ModuleBass);
	if (!NtHeader)
	{
		return 0;
	}

	PIMAGE_SECTION_HEADER SectionHeader = IMAGE_FIRST_SECTION(NtHeader);
	PUCHAR StartAddr;

	for (USHORT i = 0; i < NtHeader->FileHeader.NumberOfSections; ++i, ++SectionHeader)
	{
		if (SectionHeader->Characteristics&(IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_READ))//可读可执行的区段
		{
			StartAddr =(PUCHAR) ((ULONG_PTR)ModuleBass+(ULONG_PTR) SectionHeader->VirtualAddress);
			
			
			PVOID RetAddr= FindMemory(StartAddr, SectionHeader->Misc.VirtualSize, Mode, Tzm);
			if (RetAddr)
			{
				return RetAddr;
			}
			else
			{
				continue;
			}
		}
	}
	return 0;
}



```

`HyperHideDrv/Memroy.h`:

```h
#pragma once
#include "Header.h"

	enum  TzmMode
	{
		Normal,
		Call,
		Mov,
		Lea
	};

	 BOOLEAN WriteKernelMemory
	(
		PVOID pDestination,
		PVOID pSourceAddress,
		SIZE_T SizeOfCopy);
	 BOOLEAN ReadKernelMemory
	(
		PVOID pDestination,
		PVOID pSourceAddress,
		SIZE_T SizeOfCopy);


	 KIRQL WPOFFx64();
	 void  WPONx64(KIRQL irql);
	/************************************************************************
	*   Name : FindMemory
	* Param  : SearAddress 起始地址
	* Param  : SearLenth   搜索长度
	* Param  : Mode        搜索模式 CMemroyNormal//CMemroyCall//CMemroyMov
	* Param  : Tzm[5]      特征码   TZM a[5] = { {0, 0}, { 0,0}, { 0,0 },  {0,0} , { 0,0} };/(特征码,偏移) e8偏移=0
	*     Ret: PVOID
	*  内存搜索
	************************************************************************/
	 PVOID FindMemory(
		PVOID   SearAddress,
		ULONG   SearLenth,
		TzmMode Mode,
		TZM    Tzm[5]);

	 PVOID FindMemoryFromReadAndWriteSection(
		 PVOID ModuleBass,
		 TzmMode Mode, 
		 TZM Tzm[5]);


	



```

`HyperHideDrv/Notifiers.cpp`:

```cpp
#pragma warning( disable : 4201)
//#include <ntddk.h>
#include "Hider.h"
#include "Utils.h"
#include "Ntapi.h"
#include "Log.h"
#include <intrin.h>

VOID ThreadNotifyRoutine(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create)
{
	if (Create == FALSE)
	{
		PETHREAD CurrentThread;
		if (NT_SUCCESS(PsLookupThreadByThreadId(ThreadId, &CurrentThread)) == TRUE)
			Hider::TruncateThreadList(PidToProcess(ProcessId), CurrentThread);
	}
}

VOID ProcessNotifyRoutine(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create)
{
	UNREFERENCED_PARAMETER(ParentId);

	if (Create == FALSE)
		Hider::RemoveEntry(PidToProcess(ProcessId));
}
```

`HyperHideDrv/Notifiers.h`:

```h
#pragma once
#include <ntddk.h>

VOID ThreadNotifyRoutine(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create);

VOID ProcessNotifyRoutine(HANDLE ParentId, HANDLE ProcessId, BOOLEAN Create);
```

`HyperHideDrv/Ntapi.h`:

```h
#pragma once
//#include <ntddk.h>
#ifndef _NTIFS_H
#define _NTIFS_H
#include <ntifs.h>
#endif // !_NTIFS_H
#include "KernelDbgStruct.h"
#include "Ntenums.h"

extern "C"
{
    VOID NTAPI KeGenericCallDpc
    (
        _In_ PKDEFERRED_ROUTINE Routine,
        _In_ PVOID Context
    );

    VOID NTAPI KeSignalCallDpcDone
    (
        _In_ PVOID SystemArgument1
    );

    BOOLEAN NTAPI KeSignalCallDpcSynchronize
    (
        _In_ PVOID SystemArgument2
    );

    //NTKERNELAPI VOID KeStackAttachProcess
    //(
    //    _Inout_ PRKPROCESS PROCESS, 
    //    _Out_ PRKAPC_STATE ApcState
    //);

    //NTKERNELAPI VOID KeUnstackDetachProcess
    //(
    //    _In_ PRKAPC_STATE ApcState
    //);

    NTKERNELAPI NTSTATUS NTAPI ZwQuerySystemInformation
    (
        IN SYSTEM_INFORMATION_CLASS SystemInformationClass, 
        OUT PVOID SystemInformation,
        IN ULONG SystemInformationLength, 
        OUT PULONG ReturnLength OPTIONAL
    );

    NTSTATUS NTAPI MmCopyVirtualMemory
    (
        PEPROCESS SourceProcess,
        PVOID SourceAddress,
        PEPROCESS TargetProcess,
        PVOID TargetAddress,
        SIZE_T BufferSize,
        KPROCESSOR_MODE PreviousMode,
        PSIZE_T ReturnSize
    );

    NTKERNELAPI PVOID NTAPI PsGetProcessWow64Process
    (
        IN PEPROCESS Process
    );

    NTKERNELAPI PPEB NTAPI PsGetProcessPeb
    (
        IN PEPROCESS Process
    );

    NTSYSAPI NTSTATUS NTAPI ObReferenceObjectByName
    (
        PUNICODE_STRING ObjectName,
        ULONG Attributes,
        PACCESS_STATE AccessState,
        ACCESS_MASK DesiredAccess,
        POBJECT_TYPE ObjectType,
        KPROCESSOR_MODE AccessMode,
        PVOID ParseContext OPTIONAL,
        PVOID* Object
    );

    NTSYSAPI UCHAR* NTAPI PsGetProcessImageFileName(PEPROCESS Process);

    NTSYSAPI NTSTATUS NTAPI ZwQueryInformationJobObject(
        HANDLE JobHandle,
        JOBOBJECTINFOCLASS JobInformationClass,
        PVOID JobInformation,
        ULONG JobInformationLength,
        PULONG ReturnLength
    );

    NTSTATUS NTAPI ZwQueryInformationProcess(
        HANDLE           ProcessHandle,
        PROCESSINFOCLASS ProcessInformationClass,
        PVOID            ProcessInformation,
        ULONG            ProcessInformationLength,
        PULONG           ReturnLength
    );

    BOOLEAN NTAPI ObFindHandleForObject(
            __in PEPROCESS Process,
            __in_opt PVOID Object OPTIONAL,
            __in_opt POBJECT_TYPE ObjectType OPTIONAL,
            __in_opt POBJECT_HANDLE_INFORMATION HandleInformation,
            __out PHANDLE Handle
        );

    NTSTATUS NTAPI ZwSetInformationProcess(
        HANDLE ProcessHandle,
        PROCESSINFOCLASS ProcessInformationClass,
        PVOID ProcessInformation,
        ULONG ProcessInformationLength
    );

    BOOLEAN NTAPI PsIsProcessBeingDebugged(PEPROCESS Process);

    HANDLE NTAPI
        PsGetProcessInheritedFromUniqueProcessId(
            __in PEPROCESS Process
        );

    PVOID NTAPI PsGetCurrentProcessWow64Process();

    NTSTATUS
        PsGetContextThread(
            __in PETHREAD Thread,
            __inout PCONTEXT ThreadContext,
            __in KPROCESSOR_MODE Mode
        );
}
```

`HyperHideDrv/Ntenums.h`:

```h
#pragma once
typedef enum _PSCREATETHREADNOTIFYTYPE {
    PsCreateThreadNotifyNonSystem = 0,
    PsCreateThreadNotifySubsystems = 1
} PSCREATETHREADNOTIFYTYPE;

enum SYSDBG_COMMAND
{
    SysDbgGetTriageDump = 29
};

enum JOBOBJECTINFOCLASS
{
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation = 2,
    JobObjectBasicProcessIdList = 3,
    JobObjectBasicUIRestrictions = 4,
    JobObjectSecurityLimitInformation = 5,
    JobObjectEndOfJobTimeInformation = 6,
    JobObjectAssociateCompletionPortInformation = 7,
    JobObjectBasicAndIoAccountingInformation = 8,
    JobObjectExtendedLimitInformation = 9,
    JobObjectJobSetInformation = 10,
    JobObjectGroupInformation = 11,
    JobObjectNotificationLimitInformation = 12,
    JobObjectLimitViolationInformation = 13,
    JobObjectGroupInformationEx = 14,
    JobObjectCpuRateControlInformation = 15,
    JobObjectCompletionFilter = 16,
    JobObjectCompletionCounter = 17,
    JobObjectFreezeInformation = 18,
    JobObjectExtendedAccountingInformation = 19,
    JobObjectWakeInformation = 20,
    JobObjectBackgroundInformation = 21,
    JobObjectSchedulingRankBiasInformation = 22,
    JobObjectTimerVirtualizationInformation = 23,
    JobObjectCycleTimeNotification = 24,
    JobObjectClearEvent = 25,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information = 19,
    JobObjectReserved3Information = 20,
    JobObjectReserved4Information = 21,
    JobObjectReserved5Information = 22,
    JobObjectReserved6Information = 23,
    JobObjectReserved7Information = 24,
    JobObjectReserved8Information = 25,
    MaxJobObjectInfoClass = 26
};

typedef enum _WINDOWINFOCLASS {
    WindowProcess,
    WindowThread,
    WindowActiveWindow,
    WindowFocusWindow,
    WindowIsHung,
    WindowClientBase,
    WindowIsForegroundThread,
} WINDOWINFOCLASS;

typedef enum _THREAD_STATE_ROUTINE
{
    THREADSTATE_GETTHREADINFO,
    THREADSTATE_ACTIVEWINDOW
} THREAD_STATE_ROUTINE;
```

`HyperHideDrv/Ntstructs.h`:

```h
#pragma once
#ifndef _NTSTRUCT_H
#define _NTSTRUCT_H

#ifndef _NTIFS_H
#define _NTIFS_H
#include <ntifs.h>
#endif // !_NTIFS_H

typedef struct _CURDIR
{
    UNICODE_STRING DosPath;                                         //0x0
    VOID* Handle;                                                           //0x10
}CURDIR, * PCURDIR;

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
    USHORT Flags;                                                           //0x0
    USHORT Length;                                                          //0x2
    ULONG TimeStamp;                                                        //0x4
    STRING DosPath;                                                 //0x8
}RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    ULONG MaximumLength;                                                    //0x0
    ULONG Length;                                                           //0x4
    ULONG Flags;                                                            //0x8
    ULONG DebugFlags;                                                       //0xc
    VOID* ConsoleHandle;                                                    //0x10
    ULONG ConsoleFlags;                                                     //0x18
    VOID* StandardInput;                                                    //0x20
    VOID* StandardOutput;                                                   //0x28
    VOID* StandardError;                                                    //0x30
    CURDIR CurrentDirectory;                                        //0x38
    UNICODE_STRING DllPath;                                         //0x50
    UNICODE_STRING ImagePathName;                                   //0x60
    UNICODE_STRING CommandLine;                                     //0x70
    VOID* Environment;                                                      //0x80
    ULONG StartingX;                                                        //0x88
    ULONG StartingY;                                                        //0x8c
    ULONG CountX;                                                           //0x90
    ULONG CountY;                                                           //0x94
    ULONG CountCharsX;                                                      //0x98
    ULONG CountCharsY;                                                      //0x9c
    ULONG FillAttribute;                                                    //0xa0
    ULONG WindowFlags;                                                      //0xa4
    ULONG ShowWindowFlags;                                                  //0xa8
    UNICODE_STRING WindowTitle;                                     //0xb0
    UNICODE_STRING DesktopInfo;                                     //0xc0
    UNICODE_STRING ShellInfo;                                       //0xd0
    UNICODE_STRING RuntimeData;                                     //0xe0
    RTL_DRIVE_LETTER_CURDIR CurrentDirectores[32];                  //0xf0
    ULONGLONG EnvironmentSize;                                              //0x3f0
    ULONGLONG EnvironmentVersion;                                           //0x3f8
    VOID* PackageDependencyData;                                            //0x400
    ULONG ProcessGroupId;                                                   //0x408
    ULONG LoaderThreads;                                                    //0x40c
    UNICODE_STRING RedirectionDllName;                              //0x410
    UNICODE_STRING HeapPartitionName;                               //0x420
    ULONGLONG* DefaultThreadpoolCpuSetMasks;                                //0x430
    ULONG DefaultThreadpoolCpuSetMaskCount;                                 //0x438
}RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _OBJECT_HANDLE_ATTRIBUTE_INFORMATION
{
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
}OBJECT_HANDLE_ATTRIBUTE_INFORMATION, * POBJECT_HANDLE_ATTRIBUTE_INFORMATION;

typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    ULONG NumberOfAssignedProcesses;
    ULONG NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, * PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG Reserved[40];
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
}SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
}SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
}SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
}SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
{
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
}SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION
{
    ULONG Length;
    ULONG CodeIntegrityOptions;
}SYSTEM_CODEINTEGRITY_INFORMATION, * PSYSTEM_CODEINTEGRITY_INFORMATION;

typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION
{
    ULONG SessionId;
    ULONG SizeOfBuf;
    PVOID Buffer;
}SYSTEM_SESSION_PROCESS_INFORMATION, * PSYSTEM_SESSION_PROCESS_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _WOW64_FLOATING_SAVE_AREA
{
    ULONG ControlWord;
    ULONG StatusWord;
    ULONG TagWord;
    ULONG ErrorOffset;
    ULONG ErrorSelector;
    ULONG DataOffset;
    ULONG DataSelector;
    UCHAR RegisterArea[80];
    ULONG Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA, * PWOW64_FLOATING_SAVE_AREA;

typedef struct _WOW64_CONTEXT
{
    ULONG ContextFlags;

    ULONG Dr0;
    ULONG Dr1;
    ULONG Dr2;
    ULONG Dr3;
    ULONG Dr6;
    ULONG Dr7;

    WOW64_FLOATING_SAVE_AREA FloatSave;

    ULONG SegGs;
    ULONG SegFs;
    ULONG SegEs;
    ULONG SegDs;

    ULONG Edi;
    ULONG Esi;
    ULONG Ebx;
    ULONG Edx;
    ULONG Ecx;
    ULONG Eax;

    ULONG Ebp;
    ULONG Eip;
    ULONG SegCs;
    ULONG EFlags;
    ULONG Esp;
    ULONG SegSs;

    UCHAR ExtendedRegisters[512];

} WOW64_CONTEXT, * PWOW64_CONTEXT;

typedef struct _OBJECT_ALL_INFORMATION
{
    ULONG                   NumberOfObjectsTypes;
    OBJECT_TYPE_INFORMATION ObjectTypeInformation[1];
} OBJECT_ALL_INFORMATION, * POBJECT_ALL_INFORMATION;

typedef struct _SYSTEM_THREAD_INFO
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    ULONG BasePriority;
    HANDLE ProcessId;
    HANDLE InheritedFromProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    ULONG_PTR PeakVirtualSize;
    ULONG_PTR VirtualSize;
    ULONG PageFaultCount;
    ULONG_PTR PeakWorkingSetSize;
    ULONG_PTR WorkingSetSize;
    ULONG_PTR QuotaPeakPagedPoolUsage;
    ULONG_PTR QuotaPagedPoolUsage;
    ULONG_PTR QuotaPeakNonPagedPoolUsage;
    ULONG_PTR QuotaNonPagedPoolUsage;
    ULONG_PTR PagefileUsage;
    ULONG_PTR PeakPagefileUsage;
    ULONG_PTR PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1];
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;



typedef struct _SYSTEM_MODULE_ENTRY {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY32 HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

#ifndef _LDR_DATA_TABLE_ENTRY_
#define _LDR_DATA_TABLE_ENTRY_
typedef struct _LDR_DATA_TABLE_ENTRY                         // 24 elements, 0xE0 bytes (sizeof)
{
    /*0x000*/     struct _LIST_ENTRY InLoadOrderLinks;                     // 2 elements, 0x10 bytes (sizeof)
    /*0x010*/     struct _LIST_ENTRY InMemoryOrderLinks;                   // 2 elements, 0x10 bytes (sizeof)
    /*0x020*/     struct _LIST_ENTRY InInitializationOrderLinks;           // 2 elements, 0x10 bytes (sizeof)
    /*0x030*/     VOID* DllBase;
    /*0x038*/     VOID* EntryPoint;
    /*0x040*/     ULONG32      SizeOfImage;
    /*0x044*/     UINT8        _PADDING0_[0x4];
    /*0x048*/     struct _UNICODE_STRING FullDllName;                      // 3 elements, 0x10 bytes (sizeof)
    /*0x058*/     struct _UNICODE_STRING BaseDllName;                      // 3 elements, 0x10 bytes (sizeof)
    /*0x068*/     ULONG32      Flags;
    /*0x06C*/     UINT16       LoadCount;
    /*0x06E*/     UINT16       TlsIndex;
    union                                                    // 2 elements, 0x10 bytes (sizeof)
    {
        /*0x070*/         struct _LIST_ENTRY HashLinks;                        // 2 elements, 0x10 bytes (sizeof)
        struct                                               // 2 elements, 0x10 bytes (sizeof)
        {
            /*0x070*/             VOID* SectionPointer;
            /*0x078*/             ULONG32      CheckSum;
            /*0x07C*/             UINT8        _PADDING1_[0x4];
        };
    };
    union                                                    // 2 elements, 0x8 bytes (sizeof)
    {
        /*0x080*/         ULONG32      TimeDateStamp;
        /*0x080*/         VOID* LoadedImports;
    };
    /*0x088*/     ULONG64 EntryPointActivationContext;
    /*0x090*/     VOID* PatchInformation;
    /*0x098*/     struct _LIST_ENTRY ForwarderLinks;                       // 2 elements, 0x10 bytes (sizeof)
    /*0x0A8*/     struct _LIST_ENTRY ServiceTagLinks;                      // 2 elements, 0x10 bytes (sizeof)
    /*0x0B8*/     struct _LIST_ENTRY StaticLinks;                          // 2 elements, 0x10 bytes (sizeof)
    /*0x0C8*/     VOID* ContextInformation;
    /*0x0D0*/     UINT64       OriginalBase;
    /*0x0D8*/     union _LARGE_INTEGER LoadTime;                           // 4 elements, 0x8 bytes (sizeof)
}LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;
#endif _LDR_DATA_TABLE_ENTRY_



typedef struct _SYSTEM_MODULE {
    PVOID 	Reserved1;
    PVOID 	Reserved2;
    PVOID 	ImageBaseAddress;
    ULONG 	ImageSize;
    ULONG 	Flags;
    unsigned short 	Id;
    unsigned short 	Rank;
    unsigned short 	Unknown;
    unsigned short 	NameOffset;
    unsigned char 	Name[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG                       ModulesCount;
    SYSTEM_MODULE_ENTRY         Modules[1];
    ULONG                       Count;
    SYSTEM_MODULE 	            Sys_Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

/*
struct _EX_FAST_REF
{
    union
    {
        VOID* Object;                                                       //0x0
        ULONGLONG RefCnt : 4;                                                 //0x0
        ULONGLONG Value;                                                    //0x0
    };
};
*/
#endif // !_NTSTRUCT_H



```

`HyperHideDrv/Peb.cpp`:

```cpp
#pragma warning( disable : 4201)
//#include <ntddk.h>
#include <ntifs.h>
#include "Ntapi.h"
#include "Log.h"
#include "Peb.h"

BOOLEAN SetPebDeuggerFlag(PEPROCESS TargetProcess, BOOLEAN Value)
{
	PPEB Peb = PsGetProcessPeb(TargetProcess);
	PPEB32 Peb32 = (PPEB32)PsGetProcessWow64Process(TargetProcess);
	if (Peb32 != NULL)
	{
		KAPC_STATE State;
		KeStackAttachProcess((PRKPROCESS)TargetProcess, &State);
		__try
		{
			Peb32->BeingDebugged = Value;

			Peb->BeingDebugged = Value;
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			LogError("Access Violation");
			KeUnstackDetachProcess(&State);
			return FALSE;
		}

		KeUnstackDetachProcess(&State);
	}
	else if (Peb != NULL)
	{
		KAPC_STATE State;
		KeStackAttachProcess((PRKPROCESS)TargetProcess, &State);
		__try
		{
			Peb->BeingDebugged = Value;
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			LogError("Access Violation");
			KeUnstackDetachProcess(&State);
			return FALSE;
		}
		KeUnstackDetachProcess(&State);
	}
	else
	{
		LogError("Both pebs doesn't exist");
		return FALSE;
	}

	return TRUE;
}

BOOLEAN ClearPebNtGlobalFlag(PEPROCESS TargetProcess)
{
	PPEB Peb = PsGetProcessPeb(TargetProcess);
	PPEB32 Peb32 = (PPEB32)PsGetProcessWow64Process(TargetProcess);
	if (Peb32 != NULL)
	{
		KAPC_STATE State;
		KeStackAttachProcess((PRKPROCESS)TargetProcess, &State);
		__try
		{
			Peb32->NtGlobalFlag &= ~0x70;

			Peb->NtGlobalFlag &= ~0x70;
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			LogError("Access Violation");
			KeUnstackDetachProcess(&State);
			return FALSE;
		}

		KeUnstackDetachProcess(&State);
	}
	else if (Peb != NULL)
	{
		KAPC_STATE State;
		KeStackAttachProcess((PRKPROCESS)TargetProcess, &State);
		__try
		{
			Peb->NtGlobalFlag &= ~0x70;
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			LogError("Access Violation");
			KeUnstackDetachProcess(&State);
			return FALSE;
		}
		KeUnstackDetachProcess(&State);
	}
	else
	{
		LogError("Both pebs doesn't exist");
		return FALSE;
	}

	return TRUE;
}
```

`HyperHideDrv/Peb.h`:

```h
#pragma once

#include "Ntstructs.h"

typedef enum _SYSTEM_DLL_TYPE
{
    PsNativeSystemDll = 0,
    PsWowX86SystemDll = 1,
    PsWowArm32SystemDll = 2,
    PsWowAmd64SystemDll = 3,
    PsWowChpeX86SystemDll = 4,
    PsVsmEnclaveRuntimeDll = 5,
    PsSystemDllTotalTypes = 6
}SYSTEM_DLL_TYPE;

typedef struct _PEB_LDR_DATA32
{
    ULONG 	Length;
    BOOLEAN 	Initialized;
    ULONG SsHandle;
    LIST_ENTRY32 	InLoadOrderModuleList;
    LIST_ENTRY32 	InMemoryOrderModuleList;
    LIST_ENTRY32 	InInitializationOrderModuleList;
    BOOLEAN 	ShutdownInProgress;
}PEB_LDR_DATA32, * PPEB_LDR_DATA32;

#ifndef _PEB_LDR_DATA_
#define _PEB_LDR_DATA_
typedef struct _PEB_LDR_DATA                            // 9 elements, 0x58 bytes (sizeof)
{
    /*0x000*/     ULONG32      Length;
    /*0x004*/     UINT8        Initialized;
    /*0x005*/     UINT8        _PADDING0_[0x3];
    /*0x008*/     VOID* SsHandle;
    /*0x010*/     struct _LIST_ENTRY InLoadOrderModuleList;           // 2 elements, 0x10 bytes (sizeof)
    /*0x020*/     struct _LIST_ENTRY InMemoryOrderModuleList;         // 2 elements, 0x10 bytes (sizeof)
    /*0x030*/     struct _LIST_ENTRY InInitializationOrderModuleList; // 2 elements, 0x10 bytes (sizeof)
    /*0x040*/     VOID* EntryInProgress;
    /*0x048*/     UINT8        ShutdownInProgress;
    /*0x049*/     UINT8        _PADDING1_[0x7];
    /*0x050*/     VOID* ShutdownThreadId;
}PEB_LDR_DATA, * PPEB_LDR_DATA;
#endif // !_PEB_LDR_DATA_

typedef struct _EWOW64PROCESS
{
    VOID* Peb;                                                              //0x0
    USHORT Machine;                                                         //0x8
    SYSTEM_DLL_TYPE NtdllType;                                        //0xc
}EWOW64PROCESS, * PEWOW64PROCESS;

typedef struct _RTL_CRITICAL_SECTION_DEBUG
{
    USHORT Type;                                                            //0x0
    USHORT CreatorBackTraceIndex;                                           //0x2
    VOID* CriticalSection;                                  //0x8
    LIST_ENTRY ProcessLocksList;                                            //0x10
    ULONG EntryCount;                                                       //0x20
    ULONG ContentionCount;                                                  //0x24
    ULONG Flags;                                                            //0x28
    USHORT CreatorBackTraceIndexHigh;                                       //0x2c
    USHORT SpareUSHORT;                                                     //0x2e
}RTL_CRITICAL_SECTION_DEBUG, * PRTL_CRITICAL_SECTION_DEBUG;


typedef struct _RTL_CRITICAL_SECTION
{
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;                          //0x0
    LONG LockCount;                                                         //0x8
    LONG RecursionCount;                                                    //0xc
    VOID* OwningThread;                                                     //0x10
    VOID* LockSemaphore;                                                    //0x18
    ULONGLONG SpinCount;                                                    //0x20
}RTL_CRITICAL_SECTION, * PRTL_CRITICAL_SECTION;

typedef struct _LEAP_SECOND_DATA
{
    UCHAR Enabled;                                                          //0x0
    ULONG Count;                                                            //0x4
    LARGE_INTEGER Data[1];                                           //0x8
}LEAP_SECOND_DATA, * PLEAP_SECOND_DATA;


#ifndef _LIST_ENTRY64_S_
#define _LIST_ENTRY64_S_
typedef struct _LIST_ENTRY64_S // 2 elements, 0x10 bytes (sizeof)
{
    /*0x000*/     UINT64       Flink;
    /*0x008*/     UINT64       Blink;
}LIST_ENTRY64_S, * PLIST_ENTRY64_S;
#endif // !_LIST_ENTRY64_S_

#ifndef _PEB_
#define _PEB_
typedef struct _PEB
{
    /* 0x0000 */ unsigned char InheritedAddressSpace;
    /* 0x0001 */ unsigned char ReadImageFileExecOptions;
    /* 0x0002 */ unsigned char BeingDebugged;
    union
    {
        /* 0x0003 */ unsigned char BitField;
        struct /* bitfield */
        {
            /* 0x0003 */ unsigned char ImageUsesLargePages : 1; /* bit position: 0 */
            /* 0x0003 */ unsigned char IsProtectedProcess : 1; /* bit position: 1 */
            /* 0x0003 */ unsigned char IsImageDynamicallyRelocated : 1; /* bit position: 2 */
            /* 0x0003 */ unsigned char SkipPatchingUser32Forwarders : 1; /* bit position: 3 */
            /* 0x0003 */ unsigned char IsPackagedProcess : 1; /* bit position: 4 */
            /* 0x0003 */ unsigned char IsAppContainer : 1; /* bit position: 5 */
            /* 0x0003 */ unsigned char IsProtectedProcessLight : 1; /* bit position: 6 */
            /* 0x0003 */ unsigned char IsLongPathAwareProcess : 1; /* bit position: 7 */
        }; /* bitfield */
    }; /* size: 0x0001 */
    /* 0x0004 */ unsigned char Padding0[4];
    /* 0x0008 */ void* Mutant;
    /* 0x0010 */ void* ImageBaseAddress;
    /* 0x0018 */ struct _PEB_LDR_DATA* Ldr;
    /* 0x0020 */ struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;
    /* 0x0028 */ void* SubSystemData;
    /* 0x0030 */ void* ProcessHeap;
    /* 0x0038 */ struct _RTL_CRITICAL_SECTION* FastPebLock;
    /* 0x0040 */ union _SLIST_HEADER* volatile AtlThunkSListPtr;
    /* 0x0048 */ void* IFEOKey;
    union
    {
        /* 0x0050 */ unsigned long CrossProcessFlags;
        struct /* bitfield */
        {
            /* 0x0050 */ unsigned long ProcessInJob : 1; /* bit position: 0 */
            /* 0x0050 */ unsigned long ProcessInitializing : 1; /* bit position: 1 */
            /* 0x0050 */ unsigned long ProcessUsingVEH : 1; /* bit position: 2 */
            /* 0x0050 */ unsigned long ProcessUsingVCH : 1; /* bit position: 3 */
            /* 0x0050 */ unsigned long ProcessUsingFTH : 1; /* bit position: 4 */
            /* 0x0050 */ unsigned long ProcessPreviouslyThrottled : 1; /* bit position: 5 */
            /* 0x0050 */ unsigned long ProcessCurrentlyThrottled : 1; /* bit position: 6 */
            /* 0x0050 */ unsigned long ProcessImagesHotPatched : 1; /* bit position: 7 */
            /* 0x0050 */ unsigned long ReservedBits0 : 24; /* bit position: 8 */
        }; /* bitfield */
    }; /* size: 0x0004 */
    /* 0x0054 */ unsigned char Padding1[4];
    union
    {
        /* 0x0058 */ void* KernelCallbackTable;
        /* 0x0058 */ void* UserSharedInfoPtr;
    }; /* size: 0x0008 */
    /* 0x0060 */ unsigned long SystemReserved;
    /* 0x0064 */ unsigned long AtlThunkSListPtr32;
    /* 0x0068 */ void* ApiSetMap;
    /* 0x0070 */ unsigned long TlsExpansionCounter;
    /* 0x0074 */ unsigned char Padding2[4];
    /* 0x0078 */ void* TlsBitmap;
    /* 0x0080 */ unsigned long TlsBitmapBits[2];
    /* 0x0088 */ void* ReadOnlySharedMemoryBase;
    /* 0x0090 */ void* SharedData;
    /* 0x0098 */ void** ReadOnlyStaticServerData;
    /* 0x00a0 */ void* AnsiCodePageData;
    /* 0x00a8 */ void* OemCodePageData;
    /* 0x00b0 */ void* UnicodeCaseTableData;
    /* 0x00b8 */ unsigned long NumberOfProcessors;
    /* 0x00bc */ unsigned long NtGlobalFlag;
    /* 0x00c0 */ union _LARGE_INTEGER CriticalSectionTimeout;
    /* 0x00c8 */ unsigned __int64 HeapSegmentReserve;
    /* 0x00d0 */ unsigned __int64 HeapSegmentCommit;
    /* 0x00d8 */ unsigned __int64 HeapDeCommitTotalFreeThreshold;
    /* 0x00e0 */ unsigned __int64 HeapDeCommitFreeBlockThreshold;
    /* 0x00e8 */ unsigned long NumberOfHeaps;
    /* 0x00ec */ unsigned long MaximumNumberOfHeaps;
    /* 0x00f0 */ void** ProcessHeaps;
    /* 0x00f8 */ void* GdiSharedHandleTable;
    /* 0x0100 */ void* ProcessStarterHelper;
    /* 0x0108 */ unsigned long GdiDCAttributeList;
    /* 0x010c */ unsigned char Padding3[4];
    /* 0x0110 */ struct _RTL_CRITICAL_SECTION* LoaderLock;
    /* 0x0118 */ unsigned long OSMajorVersion;
    /* 0x011c */ unsigned long OSMinorVersion;
    /* 0x0120 */ unsigned short OSBuildNumber;
    /* 0x0122 */ unsigned short OSCSDVersion;
    /* 0x0124 */ unsigned long OSPlatformId;
    /* 0x0128 */ unsigned long ImageSubsystem;
    /* 0x012c */ unsigned long ImageSubsystemMajorVersion;
    /* 0x0130 */ unsigned long ImageSubsystemMinorVersion;
    /* 0x0134 */ unsigned char Padding4[4];
    /* 0x0138 */ unsigned __int64 ActiveProcessAffinityMask;
    /* 0x0140 */ unsigned long GdiHandleBuffer[60];
    /* 0x0230 */ void* PostProcessInitRoutine /* function */;
    /* 0x0238 */ void* TlsExpansionBitmap;
    /* 0x0240 */ unsigned long TlsExpansionBitmapBits[32];
    /* 0x02c0 */ unsigned long SessionId;
    /* 0x02c4 */ unsigned char Padding5[4];
    /* 0x02c8 */ union _ULARGE_INTEGER AppCompatFlags;
    /* 0x02d0 */ union _ULARGE_INTEGER AppCompatFlagsUser;
    /* 0x02d8 */ void* pShimData;
    /* 0x02e0 */ void* AppCompatInfo;
    /* 0x02e8 */ struct _UNICODE_STRING CSDVersion;
    /* 0x02f8 */ const struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;
    /* 0x0300 */ struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;
    /* 0x0308 */ const struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;
    /* 0x0310 */ struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;
    /* 0x0318 */ unsigned __int64 MinimumStackCommit;
    /* 0x0320 */ void* SparePointers[4];
    /* 0x0340 */ unsigned long SpareUlongs[5];
    /* 0x0354 */ long Padding_1;
    /* 0x0358 */ void* WerRegistrationData;
    /* 0x0360 */ void* WerShipAssertPtr;
    /* 0x0368 */ void* pUnused;
    /* 0x0370 */ void* pImageHeaderHash;
    union
    {
        /* 0x0378 */ unsigned long TracingFlags;
        struct /* bitfield */
        {
            /* 0x0378 */ unsigned long HeapTracingEnabled : 1; /* bit position: 0 */
            /* 0x0378 */ unsigned long CritSecTracingEnabled : 1; /* bit position: 1 */
            /* 0x0378 */ unsigned long LibLoaderTracingEnabled : 1; /* bit position: 2 */
            /* 0x0378 */ unsigned long SpareTracingBits : 29; /* bit position: 3 */
        }; /* bitfield */
    }; /* size: 0x0004 */
    /* 0x037c */ unsigned char Padding6[4];
    /* 0x0380 */ unsigned __int64 CsrServerReadOnlySharedMemoryBase;
    /* 0x0388 */ unsigned __int64 TppWorkerpListLock;
    /* 0x0390 */ struct _LIST_ENTRY TppWorkerpList;
    /* 0x03a0 */ void* WaitOnAddressHashTable[128];
    /* 0x07a0 */ void* TelemetryCoverageHeader;
    /* 0x07a8 */ unsigned long CloudFileFlags;
    /* 0x07ac */ unsigned long CloudFileDiagFlags;
    /* 0x07b0 */ char PlaceholderCompatibilityMode;
    /* 0x07b1 */ char PlaceholderCompatibilityModeReserved[7];
    /* 0x07b8 */ struct _LEAP_SECOND_DATA* LeapSecondData;
    union
    {
        /* 0x07c0 */ unsigned long LeapSecondFlags;
        struct /* bitfield */
        {
            /* 0x07c0 */ unsigned long SixtySecondEnabled : 1; /* bit position: 0 */
            /* 0x07c0 */ unsigned long Reserved : 31; /* bit position: 1 */
        }; /* bitfield */
    }; /* size: 0x0004 */
    /* 0x07c4 */ unsigned long NtGlobalFlag2;
} PEB, * PPEB; /* size: 0x07c8 */
#endif // !_PEB_


typedef struct _PEB32
{
    UCHAR InheritedAddressSpace;                                            //0x0
    UCHAR ReadImageFileExecOptions;                                         //0x1
    UCHAR BeingDebugged;                                                    //0x2
    union
    {
        UCHAR BitField;                                                     //0x3
        struct
        {
            UCHAR ImageUsesLargePages : 1;                                    //0x3
            UCHAR IsProtectedProcess : 1;                                     //0x3
            UCHAR IsImageDynamicallyRelocated : 1;                            //0x3
            UCHAR SkipPatchingUser32Forwarders : 1;                           //0x3
            UCHAR IsPackagedProcess : 1;                                      //0x3
            UCHAR IsAppContainer : 1;                                         //0x3
            UCHAR IsProtectedProcessLight : 1;                                //0x3
            UCHAR IsLongPathAwareProcess : 1;                                 //0x3
        };
    };
    ULONG Mutant;                                                           //0x4
    ULONG ImageBaseAddress;                                                 //0x8
    ULONG Ldr;                                                              //0xc
    ULONG ProcessParameters;                                                //0x10
    ULONG SubSystemData;                                                    //0x14
    ULONG ProcessHeap;                                                      //0x18
    ULONG FastPebLock;                                                      //0x1c
    ULONG AtlThunkSListPtr;                                                 //0x20
    ULONG IFEOKey;                                                          //0x24
    union
    {
        ULONG CrossProcessFlags;                                            //0x28
        struct
        {
            ULONG ProcessInJob : 1;                                           //0x28
            ULONG ProcessInitializing : 1;                                    //0x28
            ULONG ProcessUsingVEH : 1;                                        //0x28
            ULONG ProcessUsingVCH : 1;                                        //0x28
            ULONG ProcessUsingFTH : 1;                                        //0x28
            ULONG ProcessPreviouslyThrottled : 1;                             //0x28
            ULONG ProcessCurrentlyThrottled : 1;                              //0x28
            ULONG ProcessImagesHotPatched : 1;                                //0x28
            ULONG ReservedBits0 : 24;                                         //0x28
        };
    };
    union
    {
        ULONG KernelCallbackTable;                                          //0x2c
        ULONG UserSharedInfoPtr;                                            //0x2c
    };
    ULONG SystemReserved;                                                   //0x30
    ULONG AtlThunkSListPtr32;                                               //0x34
    ULONG ApiSetMap;                                                        //0x38
    ULONG TlsExpansionCounter;                                              //0x3c
    ULONG TlsBitmap;                                                        //0x40
    ULONG TlsBitmapBits[2];                                                 //0x44
    ULONG ReadOnlySharedMemoryBase;                                         //0x4c
    ULONG SharedData;                                                       //0x50
    ULONG ReadOnlyStaticServerData;                                         //0x54
    ULONG AnsiCodePageData;                                                 //0x58
    ULONG OemCodePageData;                                                  //0x5c
    ULONG UnicodeCaseTableData;                                             //0x60
    ULONG NumberOfProcessors;                                               //0x64
    ULONG NtGlobalFlag;                                                     //0x68
    LARGE_INTEGER CriticalSectionTimeout;                            //0x70
    ULONG HeapSegmentReserve;                                               //0x78
    ULONG HeapSegmentCommit;                                                //0x7c
    ULONG HeapDeCommitTotalFreeThreshold;                                   //0x80
    ULONG HeapDeCommitFreeBlockThreshold;                                   //0x84
    ULONG NumberOfHeaps;                                                    //0x88
    ULONG MaximumNumberOfHeaps;                                             //0x8c
    ULONG ProcessHeaps;                                                     //0x90
    ULONG GdiSharedHandleTable;                                             //0x94
    ULONG ProcessStarterHelper;                                             //0x98
    ULONG GdiDCAttributeList;                                               //0x9c
    ULONG LoaderLock;                                                       //0xa0
    ULONG OSMajorVersion;                                                   //0xa4
    ULONG OSMinorVersion;                                                   //0xa8
    USHORT OSBuildNumber;                                                   //0xac
    USHORT OSCSDVersion;                                                    //0xae
    ULONG OSPlatformId;                                                     //0xb0
    ULONG ImageSubsystem;                                                   //0xb4
    ULONG ImageSubsystemMajorVersion;                                       //0xb8
    ULONG ImageSubsystemMinorVersion;                                       //0xbc
    ULONG ActiveProcessAffinityMask;                                        //0xc0
    ULONG GdiHandleBuffer[34];                                              //0xc4
    ULONG PostProcessInitRoutine;                                           //0x14c
    ULONG TlsExpansionBitmap;                                               //0x150
    ULONG TlsExpansionBitmapBits[32];                                       //0x154
    ULONG SessionId;                                                        //0x1d4
    ULARGE_INTEGER AppCompatFlags;                                   //0x1d8
    ULARGE_INTEGER AppCompatFlagsUser;                               //0x1e0
    ULONG pShimData;                                                        //0x1e8
    ULONG AppCompatInfo;                                                    //0x1ec
    STRING32 CSDVersion;                                            //0x1f0
    ULONG ActivationContextData;                                            //0x1f8
    ULONG ProcessAssemblyStorageMap;                                        //0x1fc
    ULONG SystemDefaultActivationContextData;                               //0x200
    ULONG SystemAssemblyStorageMap;                                         //0x204
    ULONG MinimumStackCommit;                                               //0x208
    ULONG SparePointers[4];                                                 //0x20c
    ULONG SpareUlongs[5];                                                   //0x21c
    ULONG WerRegistrationData;                                              //0x230
    ULONG WerShipAssertPtr;                                                 //0x234
    ULONG pUnused;                                                          //0x238
    ULONG pImageHeaderHash;                                                 //0x23c
    union
    {
        ULONG TracingFlags;                                                 //0x240
        struct
        {
            ULONG HeapTracingEnabled : 1;                                     //0x240
            ULONG CritSecTracingEnabled : 1;                                  //0x240
            ULONG LibLoaderTracingEnabled : 1;                                //0x240
            ULONG SpareTracingBits : 29;                                      //0x240
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;                            //0x248
    ULONG TppWorkerpListLock;                                               //0x250
    LIST_ENTRY32 TppWorkerpList;                                     //0x254
    ULONG WaitOnAddressHashTable[128];                                      //0x25c
    ULONG TelemetryCoverageHeader;                                          //0x45c
    ULONG CloudFileFlags;                                                   //0x460
    ULONG CloudFileDiagFlags;                                               //0x464
    CHAR PlaceholderCompatibilityMode;                                      //0x468
    CHAR PlaceholderCompatibilityModeReserved[7];                           //0x469
    ULONG LeapSecondData;                                                   //0x470
    union
    {
        ULONG LeapSecondFlags;                                              //0x474
        struct
        {
            ULONG SixtySecondEnabled : 1;                                     //0x474
            ULONG Reserved : 31;                                              //0x474
        };
    };
    ULONG NtGlobalFlag2;                                                    //0x478
}PEB32, * PPEB32;

BOOLEAN SetPebDeuggerFlag(PEPROCESS TargetProcess, BOOLEAN Value);

BOOLEAN ClearPebNtGlobalFlag(PEPROCESS TargetProcess);
```

`HyperHideDrv/Pte.h`:

```h
#pragma once
union PTE {
    unsigned __int64 All;
    struct {
        unsigned __int64 Read : 1; // bit 0											 
        unsigned __int64 Write : 1; // bit 1										 
        unsigned __int64 Execute : 1; // bit 2
        unsigned __int64 EPTMemoryType : 3; // bit 5:3 (EPT Memory type)
        unsigned __int64 IgnorePAT : 1; // bit 6
        unsigned __int64 Ignored1 : 1; // bit 7
        unsigned __int64 AccessedFlag : 1; // bit 8	
        unsigned __int64 DirtyFlag : 1; // bit 9
        unsigned __int64 ExecuteForUserMode : 1; // bit 10
        unsigned __int64 Ignored2 : 1; // bit 11
        unsigned __int64 PhysicalAddress : 36; // bit (N-1):12 or Page-Frame-Number
        unsigned __int64 Reserved : 4; // bit 51:N
        unsigned __int64 Ignored3 : 11; // bit 62:52
        unsigned __int64 SuppressVE : 1; // bit 63
    }Fields;
};
```

`HyperHideDrv/RWNoAttach.cpp`:

```cpp
#include <ntifs.h>
#include <stdint.h>
#include <intrin.h>

uint64_t OldAttach;

uint64_t GetDirectoryTableBase(PEPROCESS Process)
{
	return *(uint64_t*)(uint64_t(Process) + 0x28);
}

void AttachProcess(PEPROCESS Process, PETHREAD Thread)
{
	uint64_t DirectoryTableBase;
	uint64_t result;
	uint64_t Value;

	//Attach to Process
	OldAttach = *(uint64_t*)(uint64_t(Thread) + 0xB8);
	*(uint64_t*)(uint64_t(Thread) + 0xB8) = uint64_t(Process);

	// KernelApcPending
	*(uint64_t*)(uint64_t(Thread) + 0x98 + 0x29) = 0;

	//Get DirectoryTableBase;
	DirectoryTableBase = GetDirectoryTableBase(Process);
	if ((DirectoryTableBase & 2) != 0)
		DirectoryTableBase = DirectoryTableBase | 0x8000000000000000u;

	// Write offset to DirectoryTableBase
	__writegsqword(0x9000u, DirectoryTableBase);
	__writecr3(DirectoryTableBase);

	// Temp Control Register
	Value = __readcr4();
	if ((Value & 0x20080) != 0)
	{
		result = Value ^ 0x80;
		__writecr4(Value ^ 0x80);
		__writecr4(Value);
	}
	else
	{
		result = __readcr3();
		__writecr3(result);
	}
}

#include <ndis.h>
void DetachProcess(PEPROCESS Process, PETHREAD Thread)
{
	// KernelApcPending
	*(uint64_t*)(uint64_t(Thread) + 0x98 + 0x29) = 1;

	// restore to the old
	*(uint64_t*)(uint64_t(Thread) + 0xB8) = OldAttach;

	// Due to DCP the communication with usermode will crash, so we put a Sleep() 1 Millisecond for me it should be enough, so you need to test 
	//NdisMSleep(1);
}

NTSTATUS ReadVirtualMemory(
	PEPROCESS Process,
	PVOID Destination,
	PVOID Source,
	SIZE_T Size)
{
	NTSTATUS ntStatus = STATUS_SUCCESS;
	KAPC_STATE ApcState;
	PHYSICAL_ADDRESS SourcePhysicalAddress;
	PVOID MappedIoSpace;
	PVOID MappedKva;
	PMDL Mdl;
	BOOLEAN ShouldUseSourceAsUserVa;

	if (NT_SUCCESS(ntStatus) && Process)
	{
		ShouldUseSourceAsUserVa = Source <= MmHighestUserAddress ? TRUE : FALSE;

		// 2. Get the physical address corresponding to the user virtual memory
		SourcePhysicalAddress = MmGetPhysicalAddress(
			ShouldUseSourceAsUserVa == TRUE ? Source : Destination);

		if (!SourcePhysicalAddress.QuadPart)
		{
			return STATUS_INVALID_ADDRESS;
		}

		// 4. Map an IO space for MDL
		MappedIoSpace = MmMapIoSpace(SourcePhysicalAddress, Size, MmNonCached);
		if (!MappedIoSpace)
		{
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		// 5. Allocate MDL
		Mdl = IoAllocateMdl(MappedIoSpace, (ULONG)Size, FALSE, FALSE, NULL);
		if (!Mdl)
		{
			MmUnmapIoSpace(MappedIoSpace, Size);
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		// 6. Build MDL for non-paged pool
		MmBuildMdlForNonPagedPool(Mdl);

		// 7. Map to the KVA
		MappedKva = MmMapLockedPagesSpecifyCache(
			Mdl,
			KernelMode,
			MmNonCached,
			NULL,
			FALSE,
			NormalPagePriority);

		if (!MappedKva)
		{
			MmUnmapIoSpace(MappedIoSpace, Size);
			IoFreeMdl(Mdl);
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		// 8. copy memory
		memcpy(
			ShouldUseSourceAsUserVa == TRUE ? Destination : MappedKva,
			ShouldUseSourceAsUserVa == TRUE ? MappedKva : Destination,
			Size);

		MmUnmapIoSpace(MappedIoSpace, Size);
		MmUnmapLockedPages(MappedKva, Mdl);
		IoFreeMdl(Mdl);
	}

	return ntStatus;
}

NTSTATUS ReadProcessMemory(HANDLE ProcessPid, PVOID Address, PVOID Buffer, SIZE_T Size)
{
	PEPROCESS Process = { 0 };
	auto ntStatus = PsLookupProcessByProcessId(ProcessPid, &Process);
	if (NT_SUCCESS(ntStatus) && Process)
	{
		auto CurrentThread = KeGetCurrentThread();

		AttachProcess(Process, CurrentThread);
		ntStatus = ReadVirtualMemory(Process, Buffer, Address, Size);
		DetachProcess(Process, CurrentThread);
	}

	ObDereferenceObject(Process);
	return ntStatus;
}

```

`HyperHideDrv/Ssdt.cpp`:

```cpp
#pragma warning( disable : 4201)
//#include <ntddk.h>
#include "Utils.h"
#include "Log.h"
#include "HypervisorGateway.h"
#include "GlobalData.h"
#include "Ntapi.h"
#include <intrin.h>

typedef struct _SSDT
{
	LONG* ServiceTable;
	PVOID CounterTable;
	ULONG64 SyscallsNumber;
	PVOID ArgumentTable;
}_SSDT, *_PSSDT;

_PSSDT NtTable;
_PSSDT Win32kTable;

ULONG64 Win32kCodeCaves[200] = { 0 };
ULONG64 KernelCodeCaves[200] = { 0 };

extern HYPER_HIDE_GLOBAL_DATA g_HyperHide;

namespace SSDT 
{
	BOOLEAN GetSsdt()
	{
		PVOID KernelTextSectionBase = 0;
		ULONG64 KernelTextSectionSize = 0;

		if (GetSectionData("ntoskrnl.exe", ".text", KernelTextSectionSize, KernelTextSectionBase) == FALSE)
			return FALSE;

		CONST CHAR* Pattern = "\x4C\x8D\x15\x00\x00\x00\x00\x4C\x8D\x1D\x00\x00\x00\x00\xF7";
		CONST CHAR* Mask = "xxx????xxx????x";

		ULONG64 KeServiceDescriptorTableShadowAddress = (ULONG64)FindSignature(KernelTextSectionBase, KernelTextSectionSize, Pattern, Mask);
		if (KeServiceDescriptorTableShadowAddress == NULL)
			return FALSE;

		NtTable = (_PSSDT)((*(ULONG*)(KeServiceDescriptorTableShadowAddress + 10)) + KeServiceDescriptorTableShadowAddress + 14);
		Win32kTable = NtTable + 1;

		return TRUE;
	}

	PVOID GetWin32KFunctionAddress(PCH SyscallName, SHORT SyscallIndex)
	{
		KAPC_STATE State;
		PVOID AddressOfTargetFunction = 0;

		PEPROCESS CsrssProcess = GetCsrssProcess();
		KeStackAttachProcess((PRKPROCESS)CsrssProcess, &State);

		if (g_HyperHide.CurrentWindowsBuildNumber > WINDOWS_8_1)
		{
			ULONG64 ImageSize;
			PVOID ImageBaseAddress;

			if (GetProcessInfo("win32kfull.sys", ImageSize, ImageBaseAddress) == TRUE)
				AddressOfTargetFunction = GetExportedFunctionAddress(NULL, ImageBaseAddress, SyscallName);
		}
		else
		{
			AddressOfTargetFunction = (PVOID)((ULONG64)Win32kTable->ServiceTable + (Win32kTable->ServiceTable[SyscallIndex] >> 4));
		}

		KeUnstackDetachProcess(&State);

		return AddressOfTargetFunction;
	}

	// You can get SyscallIndex on https://j00ru.vexillium.org/syscalls/nt/64/ for 64 bit system nt syscalls
	// And https://j00ru.vexillium.org/syscalls/win32k/64/ for 64 bit system win32k syscalls
	BOOLEAN HookNtSyscall(ULONG SyscallIndex, PVOID NewFunctionAddress, PVOID* OriginFunction)
	{
		if (SyscallIndex > NtTable->SyscallsNumber)
		{
			LogError("There is no such syscall");
			return FALSE;
		}

		static UCHAR KernelAlignIndex = 0;

		PVOID AddressOfTargetFunction = (PVOID)((ULONG64)NtTable->ServiceTable + (NtTable->ServiceTable[SyscallIndex] >> 4));
		return hv::hook_function(AddressOfTargetFunction, NewFunctionAddress, (PVOID)KernelCodeCaves[KernelAlignIndex++], OriginFunction);
	}

	BOOLEAN HookWin32kSyscall(CHAR* SyscallName, SHORT SyscallIndex, PVOID NewFunctionAddress, PVOID* OriginFunction)
	{
		KAPC_STATE State;

		PVOID AddressOfTargetFunction = GetWin32KFunctionAddress(SyscallName, SyscallIndex);
		if (AddressOfTargetFunction == NULL)
			return FALSE;

		static UCHAR Win32kAlignIndex = 0;

		PEPROCESS CsrssProcess = GetCsrssProcess();
		KeStackAttachProcess((PRKPROCESS)CsrssProcess, &State);

		BOOLEAN Status = hv::hook_function(AddressOfTargetFunction, NewFunctionAddress, (PVOID)Win32kCodeCaves[Win32kAlignIndex++], OriginFunction);

		KeUnstackDetachProcess(&State);

		return Status;
	}

	BOOLEAN FindCodeCaves()
	{
		KAPC_STATE State;
		ULONG64 KernelTextSectionSize;
		PVOID KernelTextSectionBase;
		PVOID Win32kBaseTextSectionBase;
		ULONG64 Win32kTextSectionSize;

		if (GetSectionData("ntoskrnl.exe", ".text", KernelTextSectionSize, KernelTextSectionBase) == FALSE)
		{
			LogError("Couldn't get ntoskrnl .text section data");
			return FALSE;
		}

		PEPROCESS CsrssProcess = GetCsrssProcess();
		KeStackAttachProcess((PRKPROCESS)CsrssProcess, &State);

		if (g_HyperHide.CurrentWindowsBuildNumber > WINDOWS_8_1)
		{
			if (GetSectionData("win32kfull.sys", ".text", Win32kTextSectionSize, Win32kBaseTextSectionBase) == FALSE)
			{
				LogError("Couldn't get win32k .text section data");
				return FALSE;
			}
		}

		else
		{
			if (GetSectionData("win32k.sys", ".text", Win32kTextSectionSize, Win32kBaseTextSectionBase) == FALSE)
			{
				LogError("Couldn't get win32k .text section data");
				return FALSE;
			}
		}

		ULONG64 Win32kCodeCaveIndex = 0;
		ULONG64 Win32kCodeCaveSize = 0;

		for (ULONG64 MemoryLocation = (ULONG64)Win32kBaseTextSectionBase; MemoryLocation < Win32kTextSectionSize + (ULONG64)Win32kBaseTextSectionBase, Win32kCodeCaveIndex < 200; MemoryLocation++)
		{
			*(UCHAR*)MemoryLocation == 0xCC || *(UCHAR*)MemoryLocation == 0x90 ? Win32kCodeCaveSize++ : Win32kCodeCaveSize = 0;

			if (Win32kCodeCaveSize == 15)
			{
				// Ignore if at page boundary
				if (PAGE_ALIGN(MemoryLocation) != PAGE_ALIGN(MemoryLocation - 13))
					continue;

				Win32kCodeCaves[Win32kCodeCaveIndex] = MemoryLocation - 13;
				Win32kCodeCaveIndex++;
			}
		}

		KeUnstackDetachProcess(&State);

		ULONG64 KernelCodeCaveIndex = 0;
		ULONG64 KernelCodeCaveSize = 0;

		for (ULONG64 MemoryLocation = (ULONG64)KernelTextSectionBase; MemoryLocation < KernelTextSectionSize + (ULONG64)KernelTextSectionBase, KernelCodeCaveIndex < 200; MemoryLocation++)
		{
			*(UCHAR*)MemoryLocation == 0xCC || *(UCHAR*)MemoryLocation == 0x90 ? KernelCodeCaveSize++ : KernelCodeCaveSize = 0;

			if (KernelCodeCaveSize == 15)
			{
				// Ignore if at page boundary
				if (PAGE_ALIGN(MemoryLocation) != PAGE_ALIGN(MemoryLocation - 13))
					continue;

				KernelCodeCaves[KernelCodeCaveIndex] = MemoryLocation - 13;
				KernelCodeCaveIndex++;
			}
		}

		return TRUE;
	}
}
```

`HyperHideDrv/Ssdt.h`:

```h
#pragma once
#include <ntddk.h>
namespace SSDT 
{
	BOOLEAN FindCodeCaves();

	BOOLEAN HookWin32kSyscall(CHAR* SyscallName, SHORT SyscallIndex, PVOID NewFunctionAddress, PVOID* OriginFunction);

	BOOLEAN HookNtSyscall(ULONG SyscallIndex, PVOID NewFunctionAddress, PVOID* OriginFunction);

	BOOLEAN GetSsdt();

	PVOID GetWin32KFunctionAddress(PCH SyscallName, SHORT SyscallIndex);
}
```

`HyperHideDrv/Txoo.h`:

```h
#include "ntddk.h"
typedef struct _DbgProcess
{
	LIST_ENTRY64 DbgProcessList;
	PEPROCESS DebugProcess;
	PEPROCESS Process;
	POBJECT_TYPE DebugObject;
	HANDLE DbgHanle;
}DbgProcess, *PDbgProcess;

typedef NTSTATUS(__fastcall *pfNtCreateDebugObject)(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags
	);

typedef NTSTATUS(
	__fastcall*
	pfNtDebugActiveProcess)(IN HANDLE ProcessHandle,
	IN HANDLE DebugHandle);

typedef
NTSTATUS(
__fastcall* pfNtWaitForDebugEvent)(IN HANDLE DebugHandle,
IN BOOLEAN Alertable,
IN PLARGE_INTEGER Timeout OPTIONAL,
OUT ULONG64 StateChange);



typedef
NTSTATUS(
__fastcall*
pfNtDebugContinue)(IN HANDLE DebugHandle,
IN PCLIENT_ID AppClientId,
IN NTSTATUS ContinueStatus);
typedef
NTSTATUS
(__fastcall*
pfNtRemoveProcessDebug)(IN HANDLE ProcessHandle,
IN HANDLE DebugHandle);
typedef NTSTATUS (__fastcall *pfDbgkpQueueMessage)(IN PEPROCESS Process, IN PETHREAD Thread, IN OUT ULONG64 ApiMsg, IN ULONG Flags, IN ULONG64 TargetDebugObject);
typedef VOID(__fastcall *pfDbgkMapViewOfSection)(IN PVOID Processs,
	IN PVOID Section,
	IN ULONG BaseAddress
	);
typedef VOID(__fastcall *pfDbgkUnMapViewOfSection)(IN PEPROCESS PROCESS, IN PVOID BaseAddress);
typedef NTSTATUS (__fastcall *pfDbgkOpenProcessDebugPort)(IN PEPROCESS Process, IN KPROCESSOR_MODE PreviousMode, OUT HANDLE *DebugHandle);
typedef VOID(__fastcall *pfDbgkCopyProcessDebugPort)(IN PEPROCESS Process, IN PEPROCESS Parent,  IN ULONG64 unknow, IN ULONG64 unknow1);
typedef BOOLEAN( __fastcall *pfDbgkForwardException)(IN PEXCEPTION_RECORD ExceptionRecord, IN BOOLEAN DebugPort, IN BOOLEAN SecondChance);
extern pfNtCreateDebugObject  ori_pslp40;//pfNtCreateDebugObject
extern pfNtDebugActiveProcess ori_pslp43;//pfNtDebugActiveProcess
extern pfNtWaitForDebugEvent ori_pslp41;//pfNtWaitForDebugEvent
extern pfNtDebugContinue ori_pslp42;//pfNtDebugContinue
extern pfNtRemoveProcessDebug ori_pslp44;//pfNtRemoveProcessDebug
extern pfDbgkForwardException ori_pslp3;//pfDbgkForwardException
extern pfDbgkCopyProcessDebugPort ori_pslp2;//pfDbgkCopyProcessDebugPort
extern pfDbgkOpenProcessDebugPort ori_pslp4;//pfDbgkOpenProcessDebugPort
extern  pfDbgkUnMapViewOfSection ori_pslp5;//pfDbgkUnMapViewOfSection
extern pfDbgkMapViewOfSection ori_pslp6; //pfDbgkMapViewOfSection
extern pfDbgkpQueueMessage ori_pslp11;//pfDbgkpQueueMessage
VOID NTAPI Debug_ExFreeItem(PDbgProcess Item);
PDbgProcess Debug_FindMyNeedData(PDbgProcess DbgStruct);
PDbgProcess Debug_AddStructToList(PDbgProcess DbgStruct);
EXTERN_C VOID InitialzeDbgprocessList();
```

`HyperHideDrv/Utils.cpp`:

```cpp
#pragma warning( disable : 4201)

#include <ntifs.h>
#include <ntimage.h>
#include "Ntapi.h"
#include "Utils.h"
#include "Log.h"
#include "GlobalData.h"
#include "Peb.h"
#include "KernelDbgStruct.h"
#include"Ntapi.h"

extern HYPER_HIDE_GLOBAL_DATA g_HyperHide;

NTAPI_OFFSETS NtapiOffsets;

INT64(__fastcall* MiGetPteAddress)(UINT64);

BOOLEAN RtlUnicodeStringContains(PUNICODE_STRING Str, PUNICODE_STRING SubStr, BOOLEAN CaseInsensitive)
{
	if (Str == NULL || SubStr == NULL || Str->Length < SubStr->Length)
		return FALSE;

	CONST USHORT NumCharsDiff = (Str->Length - SubStr->Length) / sizeof(WCHAR);
	UNICODE_STRING Slice = *Str;
	Slice.Length = SubStr->Length;

	for (USHORT i = 0; i <= NumCharsDiff; ++i, ++Slice.Buffer, Slice.MaximumLength -= sizeof(WCHAR))
	{
		if (RtlEqualUnicodeString(&Slice, SubStr, CaseInsensitive))
			return TRUE;
	}
	return FALSE;
}

BOOLEAN RtlStringContains(PSTRING Str, PSTRING SubStr, BOOLEAN CaseInsensitive)
{
	if (Str == NULL || SubStr == NULL || Str->Length < SubStr->Length)
		return FALSE;

	CONST USHORT NumCharsDiff = (Str->Length - SubStr->Length);
	STRING Slice = *Str;
	Slice.Length = SubStr->Length;

	for (USHORT i = 0; i <= NumCharsDiff; ++i, ++Slice.Buffer, Slice.MaximumLength -= 1)
	{
		if (RtlEqualString(&Slice, SubStr, CaseInsensitive))
			return TRUE;
	}
	return FALSE;
}

UNICODE_STRING PsQueryFullProcessImageName(PEPROCESS TargetProcess)
{
	UNICODE_STRING TruncatedFullImageName = { 0 };

	__try
	{
		PUNICODE_STRING FullImageName = (PUNICODE_STRING) * (ULONG64*)((ULONG64)TargetProcess + NtapiOffsets.SeAuditProcessCreationInfoOffset);
		if (FullImageName->Buffer != NULL || FullImageName->Length != 0)
		{
			for (size_t i = FullImageName->Length / 2; i > 0; i--)
			{
				if (FullImageName->Buffer[i] == L'\\')
				{
					RtlInitUnicodeString(&TruncatedFullImageName, &FullImageName->Buffer[i + 1]);
					break;
				}
			}
		}
	}

	__except (EXCEPTION_EXECUTE_HANDLER)
	{

	}

	return TruncatedFullImageName;
}

PEPROCESS GetCsrssProcess()
{
	PEPROCESS Process = 0;

	// Sometimes it doesn't return csrss process at the first try which is strange because it must exist
	do
	{
		Process = GetProcessByName(L"csrss.exe");
	} while (Process == 0);

	return Process;
}

PVOID FindSignature(PVOID Memory, ULONG64 Size, PCSZ Pattern, PCSZ Mask)
{
	ULONG64 SigLength = strlen(Mask);
	if (SigLength > Size) return NULL;

	for (ULONG64 i = 0; i < Size - SigLength; i++)
	{
		BOOLEAN Found = TRUE;
		for (ULONG64 j = 0; j < SigLength; j++)
			Found &= Mask[j] == '?' || Pattern[j] == *((PCHAR)Memory + i + j);

		if (Found)
			return (PCHAR)Memory + i;
	}
	return NULL;
}

ULONG64 GetPteAddress(ULONG64 Address)
{
	if (g_HyperHide.CurrentWindowsBuildNumber <= WINDOWS_10_VERSION_THRESHOLD2)
	{
		return (ULONG64)(((Address >> 9) & 0x7FFFFFFFF8) - 0x98000000000);
	}
	else
	{
		if (MiGetPteAddress == NULL)
		{
			CHAR* MiGetPteAddressPattern = "\x48\xC1\xE9\x00\x48\xb8\x00\x00\x00\x00\x00\x00\x00\x00\x48\x23\xC8\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\x48\x03\xC1\xC3";
			CHAR* MiGetPteAddressMask = "xxx?xx????????xxxxx????????xxxx";

			ULONG64 KernelTextSectionSize = 0;
			PVOID KernelTextSectionBase = 0;

			if (GetSectionData("ntoskrnl.exe", ".text", KernelTextSectionSize, KernelTextSectionBase) == FALSE)
			{
				LogError("Couldn't get ntoskrnl.exe .text section data");
				return FALSE;
			}

			MiGetPteAddress = (INT64(__fastcall*)(UINT64))FindSignature(KernelTextSectionBase, KernelTextSectionSize, MiGetPteAddressPattern, MiGetPteAddressMask);
			if ((ULONG64)MiGetPteAddress <= (ULONG64)KernelTextSectionBase || (ULONG64)MiGetPteAddress >= (ULONG64)KernelTextSectionBase + KernelTextSectionSize)
			{
				LogError("Couldn't get MiGetPte function address");
				return FALSE;
			}

			LogInfo("MiGetPte address: 0x%llx", MiGetPteAddress);
		}

		return MiGetPteAddress(Address);
	}
}

BOOLEAN GetSectionData(CONST CHAR* ImageName, CONST CHAR* SectionName, ULONG64& SectionSize, PVOID& SectionBaseAddress)
{
	ULONG64 ImageSize = 0;
	PVOID ImageBase = 0;

	if (GetProcessInfo(ImageName, ImageSize, ImageBase) == FALSE)
		return FALSE;

	PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)ImageBase;
	PIMAGE_NT_HEADERS32 NtHeader = (PIMAGE_NT_HEADERS32)(DosHeader->e_lfanew + (ULONG64)ImageBase);
	ULONG NumSections = NtHeader->FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER Section = IMAGE_FIRST_SECTION(NtHeader);

	STRING TargetSectionName;
	RtlInitString(&TargetSectionName, SectionName);

	for (ULONG i = 0; i < NumSections; i++)
	{
		STRING CurrentSectionName;
		RtlInitString(&CurrentSectionName, (PCSZ)Section->Name);
		if (CurrentSectionName.Length > 8)
			CurrentSectionName.Length = 8;

		if (RtlCompareString(&CurrentSectionName, &TargetSectionName, FALSE) == 0)
		{
			SectionSize = Section->Misc.VirtualSize;
			SectionBaseAddress = (PVOID)((ULONG64)ImageBase + (ULONG64)Section->VirtualAddress);

			return TRUE;
		}
		Section++;
	}

	return FALSE;
}

BOOLEAN GetProcessInfo(CONST CHAR* Name, ULONG64& ImageSize, PVOID& ImageBase)
{
	ULONG Bytes;
	NTSTATUS Status = ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &Bytes);
	PSYSTEM_MODULE_INFORMATION Mods = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, Bytes, DRIVER_TAG);
	if (Mods == NULL)
		return FALSE;

	RtlSecureZeroMemory(Mods, Bytes);

	Status = ZwQuerySystemInformation(SystemModuleInformation, Mods, Bytes, &Bytes);
	if (NT_SUCCESS(Status) == FALSE)
	{
		ExFreePoolWithTag(Mods, DRIVER_TAG);
		return FALSE;
	}

	STRING TargetProcessName;
	RtlInitString(&TargetProcessName, Name);

	for (ULONG i = 0; i < Mods->ModulesCount; i++)
	{
		STRING CurrentModuleName;
		RtlInitString(&CurrentModuleName, (PCSZ)Mods->Modules[i].FullPathName);

		if (RtlStringContains(&CurrentModuleName, &TargetProcessName, TRUE) != NULL)
		{
			if (Mods->Modules[i].ImageSize != NULL)
			{
				ImageSize = Mods->Modules[i].ImageSize;
				ImageBase = Mods->Modules[i].ImageBase;
				ExFreePoolWithTag(Mods, DRIVER_TAG);
				return TRUE;
			}
		}
	}

	ExFreePoolWithTag(Mods, DRIVER_TAG);
	return FALSE;
}

PEPROCESS GetProcessByName(WCHAR* ProcessName)
{
	NTSTATUS Status;
	ULONG Bytes;

	ZwQuerySystemInformation(SystemProcessInformation, NULL, NULL, &Bytes);
	PSYSTEM_PROCESS_INFO ProcInfo = (PSYSTEM_PROCESS_INFO)ExAllocatePoolWithTag(NonPagedPool, Bytes, DRIVER_TAG);
	if (ProcInfo == NULL)
		return NULL;

	RtlSecureZeroMemory(ProcInfo, Bytes);

	Status = ZwQuerySystemInformation(SystemProcessInformation, ProcInfo, Bytes, &Bytes);
	if (NT_SUCCESS(Status) == FALSE)
	{
		ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
		return NULL;
	}

	UNICODE_STRING ProcessImageName;
	RtlCreateUnicodeString(&ProcessImageName, ProcessName);

	for (PSYSTEM_PROCESS_INFO Entry = ProcInfo; Entry->NextEntryOffset != NULL; Entry = (PSYSTEM_PROCESS_INFO)((UCHAR*)Entry + Entry->NextEntryOffset))
	{
		if (Entry->ImageName.Buffer != NULL)
		{
			if (RtlCompareUnicodeString(&Entry->ImageName, &ProcessImageName, TRUE) == 0)
			{
				PEPROCESS CurrentPeprocess = PidToProcess(Entry->ProcessId);
				ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
				return CurrentPeprocess;
			}
		}
	}

	ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
	return NULL;
}

PVOID GetExportedFunctionAddress(PEPROCESS TargetProcess, PVOID ModuleBase, CONST CHAR* ExportedFunctionName)
{
	KAPC_STATE State;
	PVOID FunctionAddress = 0;
	if (TargetProcess != NULL)
		KeStackAttachProcess((PRKPROCESS)TargetProcess, &State);

	do
	{
		PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)ModuleBase;
		PIMAGE_NT_HEADERS64 NtHeader = (PIMAGE_NT_HEADERS64)(DosHeader->e_lfanew + (ULONG64)ModuleBase);
		IMAGE_DATA_DIRECTORY ImageDataDirectory = NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

		if (ImageDataDirectory.Size == 0 || ImageDataDirectory.VirtualAddress == 0)
			break;

		PIMAGE_EXPORT_DIRECTORY ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((ULONG64)ModuleBase + ImageDataDirectory.VirtualAddress);
		ULONG* Address = (ULONG*)((ULONG64)ModuleBase + ExportDirectory->AddressOfFunctions);
		ULONG* Name = (ULONG*)((ULONG64)ModuleBase + ExportDirectory->AddressOfNames);
		USHORT* Ordinal = (USHORT*)((ULONG64)ModuleBase + ExportDirectory->AddressOfNameOrdinals);

		STRING TargetExportedFunctionName;
		RtlInitString(&TargetExportedFunctionName, ExportedFunctionName);

		for (size_t i = 0; ExportDirectory->NumberOfFunctions; i++)
		{
			STRING CurrentExportedFunctionName;
			RtlInitString(&CurrentExportedFunctionName, (PCHAR)ModuleBase + Name[i]);

			if (RtlCompareString(&TargetExportedFunctionName, &CurrentExportedFunctionName, TRUE) == 0)
			{
				FunctionAddress = (PVOID)((ULONG64)ModuleBase + Address[Ordinal[i]]);
				break;
			}
		}

	} while (0);

	if (TargetProcess != NULL)
		KeUnstackDetachProcess(&State);

	return FunctionAddress;
}

PVOID GetUserModeModule(PEPROCESS TargetProcess, CONST WCHAR* ModuleName, BOOLEAN IsWow64)
{
	if (TargetProcess == NULL)
		return NULL;

	KAPC_STATE State;
	PVOID Address = NULL;
	KeStackAttachProcess((PRKPROCESS)TargetProcess, &State);

	UNICODE_STRING TargetModuleName;
	RtlCreateUnicodeString(&TargetModuleName, ModuleName);

	__try
	{
		do
		{
			if (IsWow64 == TRUE)
			{
				PPEB32 Peb32 = (PPEB32)PsGetProcessWow64Process(TargetProcess);

				for (PLIST_ENTRY32 ListEntry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)Peb32->Ldr)->InLoadOrderModuleList.Flink;
					ListEntry != &((PPEB_LDR_DATA32)Peb32->Ldr)->InLoadOrderModuleList;
					ListEntry = (PLIST_ENTRY32)ListEntry->Flink)
				{
					PLDR_DATA_TABLE_ENTRY32 Entry = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);

					UNICODE_STRING CurrentModuleName;
					RtlCreateUnicodeString(&CurrentModuleName, (PWCH)Entry->BaseDllName.Buffer);

					if (RtlCompareUnicodeString(&CurrentModuleName, &TargetModuleName, TRUE) == 0)
					{
						Address = (PVOID)Entry->DllBase;
						break;
					}
				}
			}

			else
			{
				PPEB Peb = PsGetProcessPeb(TargetProcess);
				for (PLIST_ENTRY ListEntry = Peb->Ldr->InLoadOrderModuleList.Flink;
					ListEntry != &Peb->Ldr->InLoadOrderModuleList;
					ListEntry = ListEntry->Flink)
				{
					PLDR_DATA_TABLE_ENTRY Entry = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

					UNICODE_STRING CurrentModuleName;
					RtlCreateUnicodeString(&CurrentModuleName, Entry->BaseDllName.Buffer);

					if (RtlCompareUnicodeString(&CurrentModuleName, &TargetModuleName, TRUE) == 0)
					{
						Address = Entry->DllBase;
						break;
					}
				}
			}

		} while (0);

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{

	}

	KeUnstackDetachProcess(&State);
	return Address;
}

BOOLEAN ClearBypassProcessFreezeFlag(PEPROCESS TargetProcess)
{
	NTSTATUS Status;
	ULONG Bytes;

	if (g_HyperHide.CurrentWindowsBuildNumber < WINDOWS_10_VERSION_19H1)
	{
		LogError("This flag doesn't exit on this version of windows");
		return FALSE;
	}

	ZwQuerySystemInformation(SystemProcessInformation, NULL, NULL, &Bytes);
	PSYSTEM_PROCESS_INFO ProcInfo = (PSYSTEM_PROCESS_INFO)ExAllocatePoolWithTag(NonPagedPool, Bytes, DRIVER_TAG);

	if (ProcInfo == NULL)
		return FALSE;

	RtlSecureZeroMemory(ProcInfo, Bytes);

	Status = ZwQuerySystemInformation(SystemProcessInformation, ProcInfo, Bytes, &Bytes);
	if (NT_SUCCESS(Status) == FALSE)
	{
		ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
		return FALSE;
	}

	for (PSYSTEM_PROCESS_INFO Entry = ProcInfo; Entry->NextEntryOffset != NULL; Entry = (PSYSTEM_PROCESS_INFO)((UCHAR*)Entry + Entry->NextEntryOffset))
	{
		if (PidToProcess(Entry->ProcessId) == TargetProcess)
		{
			for (size_t i = 0; i < Entry->NumberOfThreads; i++)
			{
				PETHREAD Thread;
				Status = PsLookupThreadByThreadId(Entry->Threads[i].ClientId.UniqueThread, (PETHREAD*)&Thread);

				if (NT_SUCCESS(Status) == TRUE)
					*(ULONG*)((ULONG64)Thread + NtapiOffsets.BypassProcessFreezeFlagOffset) &= ~(1 << 21);
			}

			ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
			return TRUE;
		}
	}

	ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
	return FALSE;
}

BOOLEAN ClearThreadHideFromDebuggerFlag(PEPROCESS TargetProcess)
{
	NTSTATUS Status;
	ULONG Bytes;

	ZwQuerySystemInformation(SystemProcessInformation, NULL, NULL, &Bytes);
	PSYSTEM_PROCESS_INFO ProcInfo = (PSYSTEM_PROCESS_INFO)ExAllocatePoolWithTag(NonPagedPool, Bytes, DRIVER_TAG);

	if (ProcInfo == NULL)
		return FALSE;

	RtlSecureZeroMemory(ProcInfo, Bytes);

	Status = ZwQuerySystemInformation(SystemProcessInformation, ProcInfo, Bytes, &Bytes);
	if (NT_SUCCESS(Status) == FALSE)
	{
		ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
		return FALSE;
	}

	for (PSYSTEM_PROCESS_INFO Entry = ProcInfo; Entry->NextEntryOffset != NULL; Entry = (PSYSTEM_PROCESS_INFO)((UCHAR*)Entry + Entry->NextEntryOffset))
	{
		if (PidToProcess(Entry->ProcessId) == TargetProcess)
		{
			for (size_t i = 0; i < Entry->NumberOfThreads; i++)
			{
				PETHREAD Thread;
				Status = PsLookupThreadByThreadId(Entry->Threads[i].ClientId.UniqueThread, (PETHREAD*)&Thread);

				if (NT_SUCCESS(Status) == TRUE)
				{
					if (*(ULONG*)((ULONG64)Thread + NtapiOffsets.ThreadHideFromDebuggerFlagOffset) & 0x4)
					{
						Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(TargetProcess, Thread);
						if (HiddenThread != NULL)
							HiddenThread->IsThreadHidden = TRUE;

						*(ULONG*)((ULONG64)Thread + NtapiOffsets.ThreadHideFromDebuggerFlagOffset) &= ~0x4LU;
					}
				}
			}

			ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
			return TRUE;
		}
	}

	ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
	return FALSE;
}

BOOLEAN ClearProcessBreakOnTerminationFlag(Hider::PHIDDEN_PROCESS HiddenProcess)
{
	HANDLE ProcessHandle;
	if (ObOpenObjectByPointer(HiddenProcess->DebuggedProcess, OBJ_KERNEL_HANDLE, NULL, NULL, *PsProcessType, KernelMode, &ProcessHandle) >= 0)
	{
		ULONG BreakOnTermination;
		if (ZwQueryInformationProcess(ProcessHandle, ProcessBreakOnTermination, &BreakOnTermination, sizeof(ULONG), NULL) >= 0)
		{
			HiddenProcess->ValueProcessBreakOnTermination = BreakOnTermination & 1;

			BreakOnTermination = 0;
			if (ZwSetInformationProcess(ProcessHandle, ProcessBreakOnTermination, &BreakOnTermination, sizeof(ULONG)) >= 0)
				return TRUE;
		}

		ObCloseHandle(ProcessHandle, KernelMode);
	}

	return FALSE;
}

VOID SaveProcessDebugFlags(Hider::PHIDDEN_PROCESS HiddenProcess)
{
	HANDLE ProcessHandle;
	if (ObOpenObjectByPointer(HiddenProcess->DebuggedProcess, OBJ_KERNEL_HANDLE, NULL, NULL, *PsProcessType, KernelMode, &ProcessHandle) >= 0)
	{
		ULONG DebugFlags;
		if (ZwQueryInformationProcess(ProcessHandle, ProcessDebugFlags, &DebugFlags, sizeof(ULONG), NULL) >= 0 && PsIsProcessBeingDebugged(HiddenProcess->DebuggedProcess) == FALSE)
		{
			HiddenProcess->ValueProcessDebugFlags = !DebugFlags;
		}

		ObCloseHandle(ProcessHandle, KernelMode);
	}
}

VOID SaveProcessHandleTracing(Hider::PHIDDEN_PROCESS HiddenProcess)
{
	HANDLE ProcessHandle;
	if (ObOpenObjectByPointer(HiddenProcess->DebuggedProcess, OBJ_KERNEL_HANDLE, NULL, NULL, *PsProcessType, KernelMode, &ProcessHandle) >= 0)
	{
		ULONG64 ProcessInformationBuffer[2] = { 0 };

		NTSTATUS Status = ZwQueryInformationProcess(ProcessHandle, ProcessHandleTracing, &ProcessInformationBuffer[0], 16, NULL);
		if (Status == STATUS_SUCCESS)
			HiddenProcess->ProcessHandleTracingEnabled = 1;
		else if (Status == STATUS_INVALID_PARAMETER)
			HiddenProcess->ProcessHandleTracingEnabled = 0;

		ObCloseHandle(ProcessHandle, KernelMode);
	}
}

BOOLEAN ClearThreadBreakOnTerminationFlags(PEPROCESS TargetProcess)
{
	NTSTATUS Status;
	ULONG Bytes;

	ZwQuerySystemInformation(SystemProcessInformation, NULL, NULL, &Bytes);
	PSYSTEM_PROCESS_INFO ProcInfo = (PSYSTEM_PROCESS_INFO)ExAllocatePoolWithTag(NonPagedPool, Bytes, DRIVER_TAG);
	if (ProcInfo == NULL)
		return FALSE;

	RtlSecureZeroMemory(ProcInfo, Bytes);

	Status = ZwQuerySystemInformation(SystemProcessInformation, ProcInfo, Bytes, &Bytes);
	if (NT_SUCCESS(Status) == FALSE)
	{
		ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
		return FALSE;
	}

	for (PSYSTEM_PROCESS_INFO Entry = ProcInfo; Entry->NextEntryOffset != NULL; Entry = (PSYSTEM_PROCESS_INFO)((UCHAR*)Entry + Entry->NextEntryOffset))
	{
		if (PidToProcess(Entry->ProcessId) == TargetProcess)
		{
			for (size_t i = 0; i < Entry->NumberOfThreads; i++)
			{
				PETHREAD Thread;
				if (PsLookupThreadByThreadId(Entry->Threads[i].ClientId.UniqueThread, (PETHREAD*)&Thread) >= 0)
				{
					if (*(ULONG*)((ULONG64)Thread + NtapiOffsets.ThreadBreakOnTerminationFlagOffset) & 0x20)
					{
						Hider::PHIDDEN_THREAD HiddenThread = Hider::AppendThreadList(TargetProcess, Thread);
						if (HiddenThread != NULL)
						{
							HiddenThread->BreakOnTermination = TRUE;

							*(ULONG*)((ULONG64)Thread + NtapiOffsets.ThreadBreakOnTerminationFlagOffset) &= ~0x20;

							ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
							return TRUE;
						}
					}
				}
			}
		}
	}

	ExFreePoolWithTag(ProcInfo, DRIVER_TAG);
	return FALSE;
}

BOOLEAN RsumeProcessGrantedAccess(PEPROCESS_S TargetProcess)
{
	return 0;
}

BOOLEAN IsPicoContextNull(PETHREAD TargetThread)
{
	if (g_HyperHide.CurrentWindowsBuildNumber < WINDOWS_8_1)
		return TRUE;
	else
		return !(*(ULONG64*)((ULONG64)TargetThread + NtapiOffsets.PicoContextOffset));
}

BOOLEAN IsSetThreadContextRestricted(PEPROCESS TargetProcess)
{
	if (g_HyperHide.CurrentWindowsBuildNumber < WINDOWS_10_VERSION_REDSTONE2)
		return FALSE;
	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE2)
		return *(ULONG*)((ULONG64)TargetProcess + NtapiOffsets.RestrictSetThreadContextOffset) & 0x2 ? TRUE : FALSE;
	else
		return *(ULONG*)((ULONG64)TargetProcess + NtapiOffsets.RestrictSetThreadContextOffset) & 0x20000 ? TRUE : FALSE;
}

BOOLEAN GetOffsets()
{
	if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_11)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0x74;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x560;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x560;
		NtapiOffsets.PicoContextOffset = 0x630;
		NtapiOffsets.RestrictSetThreadContextOffset = 0x460;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x5c0;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_21H1 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_21H2 ||
		g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_20H2 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_20H1)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0x74;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x510;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x510;
		NtapiOffsets.PicoContextOffset = 0x5e0;
		NtapiOffsets.RestrictSetThreadContextOffset = 0x460;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x5c0;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_19H2 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_19H1)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0x74;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6e0;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6e0;
		NtapiOffsets.PicoContextOffset = 0x7a8;
		NtapiOffsets.RestrictSetThreadContextOffset = 0x308;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x468;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE5)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6d0;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6d0;
		NtapiOffsets.PicoContextOffset = 0x798;
		NtapiOffsets.RestrictSetThreadContextOffset = 0x300;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x468;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE4)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6d0;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6d0;
		NtapiOffsets.PicoContextOffset = 0x7a0;
		NtapiOffsets.RestrictSetThreadContextOffset = 0x300;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x468;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE3)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6d0;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6d0;
		NtapiOffsets.PicoContextOffset = 0x7a0;
		NtapiOffsets.RestrictSetThreadContextOffset = 0x300;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x468;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE2)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6c8;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6c8;
		NtapiOffsets.PicoContextOffset = 0x798;
		NtapiOffsets.RestrictSetThreadContextOffset = 0x810;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x468;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_REDSTONE1)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6c0;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6c0;
		NtapiOffsets.PicoContextOffset = 0x790;
		NtapiOffsets.RestrictSetThreadContextOffset = 0;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x468;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_THRESHOLD2)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6bc;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6bc;
		NtapiOffsets.PicoContextOffset = 0x788;
		NtapiOffsets.RestrictSetThreadContextOffset = 0;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x468;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_10_VERSION_THRESHOLD1)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6bc;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6bc;
		NtapiOffsets.PicoContextOffset = 0x788;
		NtapiOffsets.RestrictSetThreadContextOffset = 0;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x460;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_8_1)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x6b4;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x6b4;
		NtapiOffsets.PicoContextOffset = 0x770;
		NtapiOffsets.RestrictSetThreadContextOffset = 0;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x450;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_8)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x42c;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x42c;
		NtapiOffsets.PicoContextOffset = 0x770;
		NtapiOffsets.RestrictSetThreadContextOffset = 0;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x450;
	}

	else if (g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_7_SP1 || g_HyperHide.CurrentWindowsBuildNumber == WINDOWS_7)
	{
		NtapiOffsets.BypassProcessFreezeFlagOffset = 0;
		NtapiOffsets.ThreadHideFromDebuggerFlagOffset = 0x448;
		NtapiOffsets.ThreadBreakOnTerminationFlagOffset = 0x448;
		NtapiOffsets.PicoContextOffset = 0;
		NtapiOffsets.RestrictSetThreadContextOffset = 0;
		NtapiOffsets.SeAuditProcessCreationInfoOffset = 0x390;
	}

	else
	{
		return FALSE;
	}

	return TRUE;
}

ULONG GetProcessIDFromThreadHandle(HANDLE ThreadHandle)
{
	ULONG Pid = 0;
	PETHREAD Thread;
	if (NT_SUCCESS(ObReferenceObjectByHandle(ThreadHandle, 0, *PsThreadType, ExGetPreviousMode(), (PVOID*)&Thread, nullptr)))
	{
		Pid = (ULONG)(ULONG_PTR)PsGetProcessId(PsGetThreadProcess(Thread));
		ObDereferenceObject(Thread);
	}
	return Pid;
}

ULONG GetProcessIDFromProcessHandle(HANDLE ProcessHandle)
{
	ULONG Pid = 0;
	PEPROCESS Process;
	if (NT_SUCCESS(ObReferenceObjectByHandle(ProcessHandle, 0, *PsProcessType, ExGetPreviousMode(), (PVOID*)&Process, nullptr)))
	{
		Pid = (ULONG)(ULONG_PTR)PsGetProcessId(Process);
		ObDereferenceObject(Process);
	}
	return Pid;
}

UCHAR* GetProcessNameFromProcessHandle(HANDLE ProcessHandle)
{
	UCHAR* psname = NULL;
	PEPROCESS Process;
	if (NT_SUCCESS(ObReferenceObjectByHandle(ProcessHandle, 0, *PsProcessType, ExGetPreviousMode(), (PVOID*)&Process, nullptr)))
	{
		psname = PsGetProcessImageFileName(Process);
		ObDereferenceObject(Process);
	}
	return psname;
}

#include <intrin.h>
KIRQL WPOFF()        //ԭWPOFFx64
{
	KIRQL irql = KeRaiseIrqlToDpcLevel();
	UINT64 cr0 = __readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);
	_disable();
	return irql;
}

void WPON(KIRQL irql)        //ԭWPONx64
{
	UINT64 cr0 = __readcr0();
	cr0 |= 0x10000;
	_enable();
	__writecr0(cr0);
	KeLowerIrql(irql);
}

BOOLEAN MdlCopyMemory(IN VOID* address, IN VOID* buffer, IN size_t size) {
	BOOLEAN bRet = FALSE;
	PMDL Mdl = IoAllocateMdl(address, (ULONG)size, FALSE, FALSE, NULL);

	if (!Mdl) return FALSE;
	__try {
		MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);
		PVOID Mapping = MmMapLockedPagesSpecifyCache(Mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
		if (Mapping) {
			RtlCopyMemory(buffer, Mapping, size);
			MmUnmapLockedPages(Mapping, Mdl);
			bRet = TRUE;
		}
		MmUnlockPages(Mdl);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

	}

	IoFreeMdl(Mdl);
	return bRet;
}

BOOLEAN ReadMemory2(IN PVOID BaseAddress, PVOID buffer, IN SIZE_T BufferSize, PULONG NumberOfBytesReaded, PEPROCESS pEProcess)
{
	BOOLEAN bRet = FALSE;

	if (pEProcess == NULL)
	{
		DbgPrint("获取进程对象失败");
		return FALSE;
	}

	PVOID GetData;
	__try
	{
		GetData = ExAllocatePool(NonPagedPool, BufferSize);
	}
	__except (1)
	{
		DbgPrint("内存分配异常");
		return FALSE;
	}
	if (!GetData)
	{
		DbgPrint("内存分配失败");
		return FALSE;
	}

	KAPC_STATE stack = { 0 };
	KeStackAttachProcess(pEProcess, &stack);
	ProbeForRead(BaseAddress, BufferSize, sizeof(CHAR));
	RtlCopyMemory(GetData, BaseAddress, BufferSize);
	KeUnstackDetachProcess(&stack);

	KeStackAttachProcess(PsGetCurrentProcess(), &stack);
	ProbeForRead(buffer, BufferSize, sizeof(CHAR));
	RtlCopyMemory(buffer, GetData, BufferSize);//yao
	//DbgPrint("ret:%d [%lX][%lX][%lX][%lX] \n",bRet,*(UCHAR*)(buffer), *(UCHAR*)((UINT64)buffer + 1), *(UCHAR*)((UINT64)buffer + 2), *(UCHAR*)((UINT64)buffer + 3));
	KeUnstackDetachProcess(&stack);


	ExFreePool(GetData);
	return bRet;
}


BOOLEAN ReadMemory1(IN PVOID BaseAddress, PVOID buffer, IN SIZE_T BufferSize, PULONG NumberOfBytesReaded, PEPROCESS pEProcess)
{
	BOOLEAN bRet = FALSE;


	if (pEProcess == NULL)
	{
		DbgPrint("获取进程对象失败");
		return FALSE;
	}

	PVOID GetData;
	__try
	{
		GetData = ExAllocatePool(PagedPool, BufferSize);
	}
	__except (1)
	{
		DbgPrint("内存分配异常");
		return FALSE;
	}
	if (!GetData)
	{
		DbgPrint("内存分配失败");
		return FALSE;
	}
	//memset(GetData, 0, BufferSize);
	KAPC_STATE stack = { 0 };
	KeStackAttachProcess(pEProcess, &stack);
	//DbgBreakPoint();//能双机不,没配置，之前蓝屏了重置
	bRet = MdlCopyMemory(BaseAddress, GetData, BufferSize);
	//__try
	//{
	//	ProbeForRead(BaseAddress, BufferSize, 1);
	//	RtlCopyMemory(GetData, BaseAddress, BufferSize);
	//}
	//__except (1)
	//{
	//	DbgPrint("读取内存出错");
	//	bRet = FALSE;
	//}

	//ObDereferenceObject(pEProcess);
	KeUnstackDetachProcess(&stack);

	KeStackAttachProcess(PsGetCurrentProcess(), &stack);
	RtlCopyMemory(buffer, GetData, BufferSize);//yao
	//看看
	//DbgPrint("ret:%d [%lX][%lX][%lX][%lX] \n",bRet,*(UCHAR*)(buffer), *(UCHAR*)((UINT64)buffer + 1), *(UCHAR*)((UINT64)buffer + 2), *(UCHAR*)((UINT64)buffer + 3));
	KeUnstackDetachProcess(&stack);

	/*DbgPrint("进程ID:%d",data->pid);
	for (int i = 0; i < data->size; i++)
	{
		//data->data[i] = GetData[i];
		DbgPrint("地址:%x 数据:%x data:%x", data->address+i,GetData[i],data->data[i]);
	}
	DbgPrint("输出完毕");*/

	ExFreePool(GetData);
	return bRet;
}

BOOLEAN SafeCopyMemory(PVOID pDestination, PVOID pSourceAddress, SIZE_T SizeOfCopy)
{
	PMDL pMdl = NULL;
	PVOID pSafeAddress = NULL;
	if (!MmIsAddressValid(pDestination) || !MmIsAddressValid(pSourceAddress))
		return FALSE;
	pMdl = IoAllocateMdl(pDestination, (ULONG)SizeOfCopy, FALSE, FALSE, NULL);
	if (!pMdl)
		return FALSE;
	__try
	{
		MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		IoFreeMdl(pMdl);
		return FALSE;
	}
	pSafeAddress = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
	if (!pSafeAddress)
		return FALSE;
	__try
	{
		RtlMoveMemory(pSafeAddress, pSourceAddress, SizeOfCopy);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		;
	}
	MmUnlockPages(pMdl);
	IoFreeMdl(pMdl);
	return TRUE;
}

/*
MmBuildMdlForNonPagedPool 不能与描述内核堆栈上分配的缓冲区的 MDL 一起使用。
若要生成描述内核堆栈缓冲区的 MDL，驱动程序必须调用 MmProbeAndLockPages。
这是因为内核堆栈页可以交易，除非它们被探测并锁定。 即使驱动程序保证内核堆栈无法分页，此规则也适用。
由于 MDL 描述的页面已不可分页且已映射到系统地址空间，因此驱动程序不得尝试使用 MmProbeAndLockPages 例程锁定它们，
也不得尝试使用 MmMapLockedPagesSpecifyCache 例程创建其他系统地址空间映射。
同样，驱动程序不得尝试使用 MmUnlockPages 例程解锁页面，也不得尝试使用 MmUnmapLockedPages 例程释放现有的系统地址空间映射。
如果驱动程序对 MmBuildMdlForNonPagedPool 生成的 MDL 执行上述任何非法操作，则生成的行为是不定义的。
*/
//读取内存
NTSTATUS MyReadMemory(IN PVOID BaseAddress, PVOID buffer, IN SIZE_T BufferSize, PULONG NumberOfBytesReaded, PEPROCESS pEProcess, UINT32 MDL_Flag)
{
	if (!buffer || !BaseAddress || !pEProcess || BufferSize == 0)
	{
		DbgPrint("MyReadMemory:invalid parameter:%p %p %p %d  \n", buffer, BaseAddress, pEProcess, BufferSize);
		return STATUS_UNSUCCESSFUL;
	}


	KAPC_STATE apc; PMDL temp_pMdl = NULL;  PVOID systemVirtalAddress = NULL;
	BOOLEAN battach = FALSE; BOOLEAN bmapLockPages = FALSE; BOOLEAN bProbAndLockPages = FALSE;
	__try
	{
		//创建一个MDL
		temp_pMdl = IoAllocateMdl(buffer, BufferSize, FALSE, FALSE, NULL);
		//temp_pMdl = MmCreateMdl(NULL, buffer, BufferSize);
		if (temp_pMdl)
		{
			DbgPrint("11111111111111111111\n");

			MmBuildMdlForNonPagedPool(temp_pMdl);//!!!!!!!!!!!!!!!!!!!
			MmProbeAndLockPages(temp_pMdl, KernelMode, IoWriteAccess); bProbAndLockPages = TRUE;
			DbgPrint("222222222222222222222\n");
            //systemVirtalAddress = MmMapLockedPages(temp_pMdl, KernelMode);out dated
			systemVirtalAddress = MmMapLockedPagesSpecifyCache(temp_pMdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);bmapLockPages = TRUE;
			//把mdl安全映射到系统空间，一个mdl不能被映射多次
			// A driver must not try to create more than one system-address-space mapping for an MDL.
			//systemVirtalAddress = MmGetSystemAddressForMdlSafe(temp_pMdl, NormalPagePriority);
			if (systemVirtalAddress)
			{
				KeStackAttachProcess(pEProcess, &apc); battach = TRUE;
				ProbeForRead(BaseAddress, BufferSize, sizeof(CHAR));
				RtlCopyMemory(systemVirtalAddress, BaseAddress, BufferSize);
				KeUnstackDetachProcess(&apc); battach = FALSE;

				//KeStackAttachProcess(IoGetCurrentProcess(), &apc); battach = TRUE;
				//ProbeForWrite(buffer, BufferSize, sizeof(CHAR));
				//RtlCopyMemory(buffer, systemVirtalAddress, BufferSize);
				//KeUnstackDetachProcess(&apc); battach = FALSE;

				MmUnmapLockedPages(systemVirtalAddress, temp_pMdl); bmapLockPages = FALSE;
				MmUnlockPages(temp_pMdl); bProbAndLockPages = FALSE;
				IoFreeMdl(temp_pMdl);
			}
			else
			{
				DbgPrint("MmGetSystemAddressForMdlSafe failed \n");
			}
		}
		else
		{
			DbgPrint("MmCreateMdl failed \n");
		}
	}
	__except (1) {
		DbgPrint("无法访问地址:systemVirtalAddress:%p src:%p size:%llu \n", systemVirtalAddress, BaseAddress, BufferSize);
		if (battach)
		{
			KeUnstackDetachProcess(&apc);
		}

		if (systemVirtalAddress && bmapLockPages)
			MmUnmapLockedPages(systemVirtalAddress, temp_pMdl);

		if (temp_pMdl && bProbAndLockPages)
		{
			MmUnlockPages(temp_pMdl);
			IoFreeMdl(temp_pMdl);
		}

		return STATUS_UNSUCCESSFUL;
	}

	return STATUS_SUCCESS;
}

NTSTATUS RtlSuperCopyMemory(IN VOID UNALIGNED* Dst,
	IN CONST VOID UNALIGNED* Src,
	IN ULONG Length)
{
	//MDL是一个对物理内存的描述，负责把虚拟内存映射到物理内存
	PMDL pmdl = IoAllocateMdl(Dst, Length, 0, 0, NULL);//分配mdl
	if (pmdl == NULL)
		return STATUS_UNSUCCESSFUL;

	MmBuildMdlForNonPagedPool(pmdl);//build mdl
	unsigned int* Mapped = (unsigned int*)MmMapLockedPages(pmdl, KernelMode);//锁住内存
	if (!Mapped) {
		IoFreeMdl(pmdl);
		return STATUS_UNSUCCESSFUL;
	}

	//KIRQL kirql = KeRaiseIrqlToDpcLevel();
	ProbeForWrite((CONST PVOID)Mapped, Length, sizeof(CHAR));
	RtlCopyMemory(Mapped, Src, Length);
	//KeLowerIrql(kirql);

	MmUnmapLockedPages((PVOID)Mapped, pmdl);
	IoFreeMdl(pmdl);

	return STATUS_SUCCESS;
}


NTSTATUS MyWriteMemory(IN PVOID BaseAddress, PVOID WriteBytes, IN SIZE_T BufferSize, PEPROCESS EProcess)
{
	KeAttachProcess(EProcess);
	if (BufferSize == 1 && (((PUCHAR)WriteBytes)[0] == 0xcc))
	{
		DbgPrint("MyWriteMemory:set breakpoint at:%p \n", BaseAddress);
	}
	__try
	{
		ProbeForWrite((CONST PVOID)BaseAddress, BufferSize, sizeof(CHAR));
		KIRQL tempIrql = WPOFF();
		RtlCopyMemory((CONST PVOID)BaseAddress, WriteBytes, BufferSize);
		WPON(tempIrql);
	}
	__except (1)
	{
		KeDetachProcess();
		return STATUS_UNSUCCESSFUL;
	}

	KeDetachProcess();
	return STATUS_SUCCESS;
}
```

`HyperHideDrv/Utils.h`:

```h
#pragma once
#ifndef _NTIFS_H
#define _NTIFS_H
#include <ntifs.h>
#endif // !_NTIFS_H


#include "Ntstructs.h"
#include "Hider.h"


typedef struct _NTAPI_OFFSETS
{
	ULONG SeAuditProcessCreationInfoOffset;
	ULONG BypassProcessFreezeFlagOffset;
	ULONG ThreadHideFromDebuggerFlagOffset;
	ULONG ThreadBreakOnTerminationFlagOffset;
	ULONG PicoContextOffset;
	ULONG RestrictSetThreadContextOffset;
}NTAPI_OFFSETS;

template <typename T>
PEPROCESS PidToProcess(T Pid)
{
	PEPROCESS Process;
	PsLookupProcessByProcessId((HANDLE)Pid, &Process);
	return Process;
}

PEPROCESS GetCsrssProcess();

ULONG64 GetPteAddress(ULONG64 Address);

PVOID FindSignature(PVOID Memory, ULONG64 Size, PCSZ Pattern, PCSZ Mask);

BOOLEAN GetProcessInfo(CONST CHAR* Name, _Out_ ULONG64& ImageSize, _Out_ PVOID& ImageBase);

PEPROCESS GetProcessByName(WCHAR* ProcessName);

BOOLEAN RtlUnicodeStringContains(PUNICODE_STRING Str, PUNICODE_STRING SubStr, BOOLEAN CaseInsensitive);

BOOLEAN GetSectionData(CONST CHAR* ModuleName, CONST CHAR* SectionName, ULONG64& SectionSize, PVOID& SectionBaseAddress);

BOOLEAN ClearBypassProcessFreezeFlag(PEPROCESS Process);

BOOLEAN ClearThreadHideFromDebuggerFlag(PEPROCESS Process);

PVOID GetExportedFunctionAddress(PEPROCESS Process, PVOID ModuleBase, CONST CHAR* ExportedFunctionName);

BOOLEAN ClearProcessBreakOnTerminationFlag(Hider::PHIDDEN_PROCESS HiddenProcess);

BOOLEAN ClearThreadBreakOnTerminationFlags(PEPROCESS TargetProcess);

VOID SaveProcessDebugFlags(Hider::PHIDDEN_PROCESS HiddenProcess);

VOID SaveProcessHandleTracing(Hider::PHIDDEN_PROCESS HiddenProcess);

BOOLEAN IsPicoContextNull(PETHREAD TargetThread);

BOOLEAN IsSetThreadContextRestricted(PEPROCESS TargetProcess);

BOOLEAN GetOffsets();

PVOID GetUserModeModule(PEPROCESS Process, CONST WCHAR* ModuleName, BOOLEAN IsWow64);

UNICODE_STRING PsQueryFullProcessImageName(PEPROCESS TargetProcess);

ULONG GetProcessIDFromThreadHandle(HANDLE ThreadHandle);

ULONG GetProcessIDFromProcessHandle(HANDLE ProcessHandle);

UCHAR* GetProcessNameFromProcessHandle(HANDLE ProcessHandle);


//뗍혤코닸
NTSTATUS MyReadMemory(IN PVOID BaseAddress, PVOID buffer, IN SIZE_T BufferSize, PULONG NumberOfBytesReaded, PEPROCESS pEProcess, UINT32 MDL_Flag);
NTSTATUS MyWriteMemory(IN PVOID BaseAddress, PVOID WriteBytes, IN SIZE_T BufferSize, PEPROCESS EProcess);

NTSTATUS RtlSuperCopyMemory(IN VOID UNALIGNED* Dst,
	IN CONST VOID UNALIGNED* Src,
	IN ULONG Length);

BOOLEAN ReadMemory1(IN PVOID BaseAddress, PVOID buffer, IN SIZE_T BufferSize, PULONG NumberOfBytesReaded, PEPROCESS pEProcess);
BOOLEAN ReadMemory2(IN PVOID BaseAddress, PVOID buffer, IN SIZE_T BufferSize, PULONG NumberOfBytesReaded, PEPROCESS pEProcess);
```

`HyperHideDrv/dbgk1to2.c`:

```c
//#include "KernelDbgStruct.h"

#include "dbgk1to2.h"
//#include "KernelStruct1.h"
#include <ntimage.h>
#include<ntstrsafe.h>
#include"Log.h"
#include "DRRWE.h"
#include "dbgtool.h"
#include "Txoo.h" 
#include "ActiveProcessDbgList.h"
//#include "Utils.h"

POBJECT_TYPE* g_DbgkDebugObjectType = 0;

#ifndef _DBGKTYPES_H
#define _DBGKTYPES_H

//
// Dependencies
//



//
// Debug Object Access Masks
//
#define DEBUG_OBJECT_WAIT_STATE_CHANGE      0x0001
#define DEBUG_OBJECT_ADD_REMOVE_PROCESS     0x0002
#define DEBUG_OBJECT_SET_INFORMATION        0x0004
#define DEBUG_OBJECT_ALL_ACCESS             (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x0F)

//
// Debug Event Flags
//
#define DEBUG_EVENT_READ                  (0x01)
#define DEBUG_EVENT_NOWAIT                (0x02)
#define DEBUG_EVENT_INACTIVE              (0x04)
#define DEBUG_EVENT_RELEASE               (0x08)
#define DEBUG_EVENT_PROTECT_FAILED        (0x10)
#define DEBUG_EVENT_SUSPEND               (0x20)

//
// NtCreateDebugObject Flags
//
#define DBGK_KILL_PROCESS_ON_EXIT         (0x1)
#define DBGK_ALL_FLAGS                    (DBGK_KILL_PROCESS_ON_EXIT)

typedef enum _LPC_TYPE
{
	LPC_NEW_MESSAGE,
	LPC_REQUEST1,
	LPC_REPLY1,
	LPC_DATAGRAM1,
	LPC_LOST_REPLY1,
	LPC_PORT_CLOSED1,
	LPC_CLIENT_DIED1,
	LPC_EXCEPTION1,
	LPC_DEBUG_EVENT1,
	LPC_ERROR_EVENT1,
	LPC_CONNECTION_REQUEST1,
	LPC_CONNECTION_REFUSED,
	LPC_MAXIMUM
} LPC_TYPE;

//
// Debug Object Information Classes for NtQueryDebugObject
//
typedef enum _DEBUGOBJECTINFOCLASS
{
	DebugObjectUnusedInformation,
	DebugObjectKillProcessOnExitInformation
} DEBUGOBJECTINFOCLASS, * PDEBUGOBJECTINFOCLASS;



//
// Debug Object Information Structures
//
typedef struct _DEBUG_OBJECT_KILL_PROCESS_ON_EXIT_INFORMATION
{
	ULONG KillProcessOnExit;
} DEBUG_OBJECT_KILL_PROCESS_ON_EXIT_INFORMATION, * PDEBUG_OBJECT_KILL_PROCESS_ON_EXIT_INFORMATION;

#ifndef NTOS_MODE_USER


#endif






#ifndef NTOS_MODE_USER



#endif

#endif
#ifndef _DBGFUNC
#define _DBGFUNC
//NTSTATUS PsLookupProcessByProcessId(_In_ HANDLE ProcessId, _Out_ PEPROCESS *Process);
NTKERNELAPI NTSTATUS PsLookupThreadByThreadId(_In_ HANDLE ThreadId, _Outptr_ PETHREAD* Thread);

EXTERN_C NTSTATUS ObCreateObject(
	__in KPROCESSOR_MODE ProbeMode,
	__in POBJECT_TYPE ObjectType,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in KPROCESSOR_MODE OwnershipMode,
	__inout_opt PVOID ParseContext,
	__in ULONG ObjectBodySize,
	__in ULONG PagedPoolCharge,
	__in ULONG NonPagedPoolCharge,
	__out PVOID* Object
);

VOID SetDbgMsgNotify(BOOLEAN IsLoad);
p_save_handlentry PmainList;

typedef NTSTATUS(__fastcall*
	pfDbgkpSetProcessDebugObject)(
		IN PEPROCESS_S Process,
		IN PDEBUG_OBJECT DebugObject,
		IN NTSTATUS MsgStatus,
		IN PETHREAD LastThread);

typedef NTSTATUS(__fastcall* pfMmGetFileNameForAddress)(PIMAGE_NT_HEADERS pnt, PUNICODE_STRING modname);
typedef NTSTATUS(__fastcall* pfDbgkpPostFakeProcessCreateMessages)(
	IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT DebugObject,
	IN PETHREAD* pLastThread
	);
NTSTATUS NTAPI DbgkClearProcessDebugObject(IN PEPROCESS_S Process, IN PDEBUG_OBJECT SourceDebugObject OPTIONAL);
NTSTATUS __fastcall DbgkpSendApiMessage_2(IN OUT PDBGKM_MSG ApiMsg, IN BOOLEAN SuspendProcess);
BOOLEAN DbgkpSuppressDbgMsg(IN PTEB64 Teb);
VOID NTAPI DbgkpWakeTarget(IN PDEBUG_EVENT DebugEvent);

EXTERN_C
NTKERNELAPI UCHAR* PsGetProcessImageFileName(__in PEPROCESS Process);

#define ProbeForWriteGenericType(Ptr, Type)                                    \
	do {                                                                       \
	if ((ULONG_PTR)(Ptr) + sizeof(Type) - 1 < (ULONG_PTR)(Ptr) ||          \
	(ULONG_PTR)(Ptr) + sizeof(Type) - 1 >= (ULONG_PTR)MmUserProbeAddress) { \
	ExRaiseAccessViolation();                                          \
								}                                                                      \
		*(volatile Type *)(Ptr) = *(volatile Type *)(Ptr);                     \
							} while (0)

#define ProbeForWriteHandle(Ptr) ProbeForWriteGenericType(Ptr, HANDLE)

#define PspSetProcessFlag(Flags, Flag) \
	RtlInterlockedSetBitsDiscardReturn (Flags, Flag)
void ZwFlushInstructionCache(HANDLE process, ULONG64 UNKNOW, ULONG64 UNKNOW1);
ULONG64 fc_DbgkGetAdrress(PUNICODE_STRING64 funcstr);
typedef NTSTATUS
(*OBINSERTOBJECT)(
	__in PVOID Object,
	__inout_opt PACCESS_STATE PassedAccessState,
	__in_opt ACCESS_MASK DesiredAccess,
	__in ULONG ObjectPointerBias,
	__out_opt PVOID* NewObject,
	__out_opt PHANDLE Handle
	);

typedef
VOID
(__fastcall*
	PfDbgkpFreeDebugEvent)(IN PDEBUG_EVENT DebugEvent);

typedef
LONG(__fastcall* pfDbgkpWakeTarget)(PVOID P);

typedef NTSTATUS(__stdcall* OBCREATEOBJECT)(
	__in KPROCESSOR_MODE ProbeMode,
	__in POBJECT_TYPE ObjectType,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in KPROCESSOR_MODE OwnershipMode,
	__inout_opt PVOID ParseContext,
	__in ULONG ObjectBodySize,
	__in ULONG PagedPoolCharge,
	__in ULONG NonPagedPoolCharge,
	__out PVOID* Object
	);
typedef NTSTATUS
(*OBOPENOBJECTBYPOINTER)(
	__in PVOID Object,
	__in ULONG HandleAttributes,
	__in_opt PACCESS_STATE PassedAccessState,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_TYPE ObjectType,
	__in KPROCESSOR_MODE AccessMode,
	__out PHANDLE Handle
	);


typedef NTSTATUS
(*ObDuplicateObject1)(
	IN PEPROCESS_S SourceProcess,
	IN HANDLE SourceHandle,
	IN PEPROCESS_S TargetProcess OPTIONAL,
	OUT PHANDLE TargetHandle OPTIONAL,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	IN ULONG Options,
	IN KPROCESSOR_MODE PreviousMode
	);
typedef PETHREAD(__fastcall* PsGetNextProcessThreadx)(PEPROCESS_S process, PETHREAD THREAD);
typedef NTSTATUS(__fastcall* DbgkpPostModuleMessagesx)(PEPROCESS_S process, PKTHREAD THREAD, PDEBUG_OBJECT debug);
typedef NTSTATUS(__fastcall* KeThawAllThreadsx)();
typedef __int64(__fastcall* pfPsThawProcess)(PEPROCESS process, __int64 a2);
pfPsThawProcess PsThawProcess = 0;
typedef char(__fastcall* pfPsFreezeProcess)(PEPROCESS process, char a2);
pfPsFreezeProcess PsFreezeProcess = 0;

typedef NTSTATUS(__fastcall* PsResumeThreadx)(IN PETHREAD Thread, OUT PULONG PreviousSuspendCount OPTIONAL);
typedef NTSTATUS(__fastcall* PsSuspendThreadx)(IN PETHREAD_S Thread, OUT PULONG PreviousSuspendCount OPTIONAL);
typedef NTSTATUS(__fastcall* MmGetFileNameForSectionx)(IN PVOID Thread, OUT POBJECT_NAME_INFORMATION* FileName OPTIONAL);
typedef NTSTATUS(__fastcall* PsTerminateProcessx)(IN PEPROCESS_S Process, NTSTATUS STATUS);

typedef INT64(__fastcall* pfnPsSynchronizeWithThreadInsertion)(__int64 a1, __int64 a2);
pfnPsSynchronizeWithThreadInsertion PsSynchronizeWithThreadInsertion = 0;
//proxyDbgkpSendApiMessage DbgkpSendApiMessage;

typedef void(__fastcall* pfDbgkSendSystemDllMessages)(PETHREAD pethread, PDEBUG_OBJECT pdebugobj, PDBGKM_MSG pdbgMsg);
pfDbgkSendSystemDllMessages DbgkSendSystemDllMessages;

typedef PVOID(__fastcall* pfPsQuerySystemDllInfo)(int index);
pfPsQuerySystemDllInfo PsQuerySystemDllInfo = 0;

typedef NTSTATUS(__fastcall* PsGetNextProcessx)(POBJECT_TYPE object);

typedef NTSTATUS(__fastcall*
	proxyDbgkpQueueMessage)(
		IN PEPROCESS_S Process,
		IN PETHREAD Thread,
		IN OUT PDBGKM_MSG ApiMsg,
		IN ULONG Flags,
		IN PDEBUG_OBJECT TargetDebugObject
		);
typedef NTSTATUS
(__fastcall*
	proxyDbgkpSendApiMessage)(
		IN ULONG SuspendProcess, IN OUT PDBGKM_MSG ApiMsg);
typedef NTSTATUS(__fastcall* pfLpcRequestWaitReplyPortEx)(PVOID64 port, PPORT_MESSAGE Message, PPORT_MESSAGE Buffer);
pfLpcRequestWaitReplyPortEx LpcRequestWaitReplyPortEx;
typedef NTSTATUS(__fastcall* KeFreezeAllThreadsx)();


NTSYSAPI PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(_In_ PVOID Base);


typedef LONG(*EXSYSTEMEXCEPTIONFILTER)(VOID);
typedef VOID(__fastcall* KiCheckForKernelApcDelivery1)();

PsGetNextProcessx PsGetNextProcess;
PsTerminateProcessx PsTerminateProcess;
MmGetFileNameForSectionx MmGetFileNameForSection = 0;
KeThawAllThreadsx KeThawAllThreads;
PsGetNextProcessThreadx PsGetNextProcessThread;
DbgkpPostModuleMessagesx DbgkpPostModuleMessages;
EXSYSTEMEXCEPTIONFILTER  ExSystemExceptionFilter;
//OBINSERTOBJECT ObInsertObject;
//OBCREATEOBJECT ObCreateObject;
//OBOPENOBJECTBYPOINTER ObOpenObjectByPointer;
PsResumeThreadx PsResumeThread;
PsSuspendThreadx PsSuspendThread;
FAST_MUTEX DbgkFastMutex;
PFAST_MUTEX DbgkFastMutex2;
ULONG64 DbgkpProcessDebugPortMutex;
ObDuplicateObject1 ObDuplicateObject;
KiCheckForKernelApcDelivery1 KiCheckForKernelApcDelivery12;
POBJECT_TYPE_S DbgkDebugObjectType;
POBJECT_TYPE_S* NewDbgObject;
POBJECT_TYPE_S* ObTypeIndexTable = 0;
ULONG64* PspSystemDlls;
ULONG64 PspNotifyEnableMask;
PDEBUG_OBJECT g_pdebugObj = 0;
DEBUG_OBJECT g_debugObj = { 0 };

DbgkpPostFakeThreadMessagesx DbgkpPostFakeThreadMessages = 0;
KeFreezeAllThreadsx KeFreezeAllThreads;
proxyDbgkpSendApiMessage DbgkpSendApiMessage;
proxyDbgkpQueueMessage DbgkpQueueMessage;
pfMmGetFileNameForAddress MmGetFileNameForAddress;
pfDbgkpPostFakeProcessCreateMessages DbgkpPostFakeProcessCreateMessages;
pfDbgkpSetProcessDebugObject DbgkpSetProcessDebugObject;
pfDbgkpWakeTarget DbgkpWakeTarget_2;
typedef VOID(*pfnDbgkpMarkProcessPeb)(PEPROCESS_S Process);
pfnDbgkpMarkProcessPeb originalDbgkpMarkProcessPeb;

typedef BOOLEAN(__fastcall* pfPsTestProtectedProcessIncompatibility)(__int64 a1, __int64 a2, __int64 a3);
pfPsTestProtectedProcessIncompatibility PsTestProtectedProcessIncompatibility = 0;

typedef __int64(__fastcall* pfPsRequestDebugSecureProcess)(__int64 a1, unsigned __int8 a2);
pfPsRequestDebugSecureProcess PsRequestDebugSecureProcess = 0;

typedef char(__fastcall* pfDbgkpSuspendProcess)(PEPROCESS_S ps);
pfDbgkpSuspendProcess DbgkpSuspendProcess;

#endif

//根据线程ID返回线程ETHREAD，失败返回NULL
PETHREAD LookupThread(HANDLE Tid)
{
	PETHREAD ethread;
	if (NT_SUCCESS(PsLookupThreadByThreadId(Tid, &ethread)))
		return ethread;
	else
		return NULL;
}

PETHREAD g_pethreadArray[128] = { "" };
UINT32 g_threadCount = 0;

//枚举指定进程中的线程
void EnumThread(PEPROCESS Process)
{
	g_threadCount = 0;
	ULONG i = 0, c = 0;
	PETHREAD ethrd = NULL;
	PEPROCESS eproc = NULL;
	for (i = 4; i < 262144; i = i + 4) // 一般来说没有超过100000的PID和TID
	{
		ethrd = LookupThread((HANDLE)i);
		if (ethrd != NULL)
		{
			//获得线程所属进程
			eproc = IoThreadToProcess(ethrd);
			if (eproc == Process)
			{
				//打印出ETHREAD和TID
				DbgPrint("线程: ETHREAD=%p TID=%ld\n", ethrd, (ULONG)PsGetThreadId(ethrd));
				g_pethreadArray[g_threadCount] = ethrd;
				g_threadCount++;
			}
			ObDereferenceObject(ethrd);
		}
	}
}

VOID __fastcall
proxyDbgkpCloseObject(
	IN PEPROCESS_S Process,
	IN PVOID Object,
	IN ACCESS_MASK GrantedAccess,
	IN ULONG_PTR ProcessHandleCount,
	IN ULONG_PTR SystemHandleCount
)
/*++

Routine Description:

Called by the object manager when a handle is closed to the object.

Arguments:

Process - Process doing the close
Object - Debug object being deleted
GrantedAccess - Access ranted for this handle
ProcessHandleCount - Unused and unmaintained by OB
SystemHandleCount - Current handle count for this object

Return Value:

None.

--*/
{
	PDEBUG_OBJECT DebugObject = Object;
	PDEBUG_EVENT DebugEvent;
	PLIST_ENTRY ListPtr;
	BOOLEAN Deref;

	PAGED_CODE();

	UNREFERENCED_PARAMETER(GrantedAccess);
	UNREFERENCED_PARAMETER(ProcessHandleCount);

	DbgPrint("proxyDbgkpCloseObject\n");

	//
	// If this isn't the last handle then do nothing.
	//
	if (SystemHandleCount > 1) {
		return;
	}

	ExAcquireFastMutex(&DebugObject->Mutex);

	//
	// Mark this object as going away and wake up any processes that are waiting.
	//
	DebugObject->Flags |= DEBUG_OBJECT_DELETE_PENDING;

	//
	// Remove any events and queue them to a temporary queue
	//
	ListPtr = DebugObject->EventList.Flink;
	InitializeListHead(&DebugObject->EventList);

	ExReleaseFastMutex(&DebugObject->Mutex);

	//
	// Wake anyone waiting. They need to leave this object alone now as its deleting
	//
	KeSetEvent(&DebugObject->EventsPresent, 0, FALSE);

	//
	// Loop over all processes and remove the debug port from any that still have it.
	// Debug port propagation was disabled by setting the delete pending flag above so we only have to do this
	// once. No more refs can appear now.
	//
	ExAcquireFastMutex(&DbgkFastMutex);
	Deref = Port_RemoveDbgItem(NULL, DebugObject);
	ExReleaseFastMutex(&DbgkFastMutex);


	if (Deref) {
		//	DbgkpMarkProcessPeb(Process);
		//
		// If the caller wanted process deletion on debugger dying (old interface) then kill off the process.
		//
		if (DebugObject->Flags & DEBUG_OBJECT_KILL_ON_CLOSE) {
			//PsTerminateProcess(Process, STATUS_DEBUGGER_INACTIVE);
		}
		ObDereferenceObject(DebugObject);
	}
	/*
		for (Process = PsGetNextProcess(NULL);
			Process != NULL;
			Process = PsGetNextProcess(Process)) {

			if (Process->Pcb.newdbgport == DebugObject)

			{
				Deref = FALSE;
				ExAcquireFastMutex(&DbgkFastMutex);
				if (Process->Pcb.newdbgport == DebugObject) {
					Process->Pcb.newdbgport = NULL;
					Deref = TRUE;
				}
				ExReleaseFastMutex(&DbgkFastMutex);


				if (Deref) {
				//	DbgkpMarkProcessPeb(Process);
					//
					// If the caller wanted process deletion on debugger dying (old interface) then kill off the process.
					//
					if (DebugObject->Flags&DEBUG_OBJECT_KILL_ON_CLOSE) {
						PsTerminateProcess(Process, STATUS_DEBUGGER_INACTIVE);
					}
					ObDereferenceObject(DebugObject);
				}
			}
		}*/
		//
		// Wake up all the removed threads.
		//
	while (ListPtr != &DebugObject->EventList) {
		DebugEvent = CONTAINING_RECORD(ListPtr, DEBUG_EVENT, EventList);
		ListPtr = ListPtr->Flink;
		DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
		DbgkpWakeTarget(DebugEvent);
	}

}

BOOLEAN
proxyDbgkpSuspendProcess(PEPROCESS ps)
{
	DbgPrint("DbgkpSuspendProcess\n");
	if ((((PEPROCESS_S)PsGetCurrentProcess())->Flags &
		PS_PROCESS_FLAGS_PROCESS_DELETE) == 0) {
		//KeEnterCriticalRegion();
		//if (PsFreezeProcess(ps, 0))
			{
				DbgPrint("PsFreezeProcess ok\n");
				return TRUE;
			}
			//KeLeaveCriticalRegion();
	}
	return FALSE;
}
VOID
NTAPI
DbgkpResumeProcess(PEPROCESS ps, __int64 a)
{
	PAGED_CODE();
	DbgPrint("DbgkpResumeProcess\n");
	//KeEnterCriticalRegion();
	//PsThawProcess(ps, 0);
}

HANDLE
FASTCALL
DbgkpSectionToFileHandle(IN PVOID Section)
{
	NTSTATUS Status;
	POBJECT_NAME_INFORMATION FileName;
	OBJECT_ATTRIBUTES ObjectAttributes;
	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE Handle;
	PAGED_CODE();

	Status = MmGetFileNameForSection(Section, &FileName);
	if (!NT_SUCCESS(Status) || !FileName)
	{
		DbgPrint("DbgkpSectionToFileHandle failed \n");
		return NULL;
	}

	InitializeObjectAttributes(&ObjectAttributes,
		&(FileName->Name),
		OBJ_CASE_INSENSITIVE |
		OBJ_FORCE_ACCESS_CHECK |
		OBJ_KERNEL_HANDLE,
		NULL,
		NULL);

	Status = ZwOpenFile(&Handle,
		GENERIC_READ | SYNCHRONIZE,
		&ObjectAttributes,
		&IoStatusBlock,
		FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
		FILE_SYNCHRONOUS_IO_NONALERT);

	ExFreePool(FileName);
	if (!NT_SUCCESS(Status)) return NULL;
	return Handle;
}


VOID
__fastcall
proxyDbgkExitThread(IN NTSTATUS ExitStatus)
{
	DbgPrint("proxyDbgkExitThread\n");
	DBGKM_MSG ApiMessage;
	PDBGKM_EXIT_THREAD ExitThread = &ApiMessage.ExitThread;
	PEPROCESS_S Process = PsGetCurrentProcess();
	PETHREAD Thread = PsGetCurrentThread();
	BOOLEAN Suspended;
	PAGED_CODE();

	//if (!Process->Pcb.newdbgport) {
	//	return;
	//}
	//if (!Port_GetPort(Process)) {
	//	DbgPrint("proxyDbgkExitThread: Port_GetPort false\n");
	//	return;
	//}
	//if (((PETHREAD_S)PsGetCurrentThread())->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_DEADTHREAD) {
	//	DbgPrint("proxyDbgkExitThread: CrossThreadFlags PS_CROSS_THREAD_FLAGS_DEADTHREAD\n");
	//	return;
	//}


	ExitThread->ExitStatus = ExitStatus;


	ApiMessage.h.u1.Length = sizeof(DBGKM_MSG) << 16 |
		(8 + sizeof(DBGKM_EXIT_THREAD));
	ApiMessage.h.u2.ZeroInit = 0;
	ApiMessage.h.u2.s2.Type = LPC_DEBUG_EVENT;
	ApiMessage.ApiNumber = DbgKmExitThreadApi;


	Suspended = proxyDbgkpSuspendProcess(Process);

	DbgPrint("proxyDbgkExitThread: DbgkpSendApiMessage_2\n");
	DbgkpSendApiMessage_2(&ApiMessage, FALSE);

	if (Suspended) DbgkpResumeProcess(Process, 0);
}



typedef void (*OriginalproxyDbgkExitProcess)(IN NTSTATUS ExitStatus);
OriginalproxyDbgkExitProcess originalproxyDbgkExitProcess;

VOID
__fastcall
proxyDbgkExitProcess(IN NTSTATUS ExitStatus)
{
	DbgPrint("proxyDbgkExitProcess\n");
	DBGKM_MSG ApiMessage;
	PDBGKM_EXIT_PROCESS ExitProcess = &ApiMessage.ExitProcess;
	PEPROCESS_S Process = PsGetCurrentProcess();
	PETHREAD Thread = PsGetCurrentThread();
	PAGED_CODE();

	//if (!Process->Pcb.newdbgport) {
	//	return;
	//}


	//if (!Port_GetPort(Process)) {
	//	DbgPrint("proxyDbgkExitProcess: Port_GetPort false\n");
	//	return;
	//}

	//if (((PETHREAD_S)PsGetCurrentThread())->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_DEADTHREAD) {
	//	DbgPrint("proxyDbgkExitProcess: CrossThreadFlags PS_CROSS_THREAD_FLAGS_DEADTHREAD\n");
	//	return;
	//}


	ExitProcess->ExitStatus = ExitStatus;

	ApiMessage.h.u1.Length = sizeof(DBGKM_MSG) << 16 |
		(8 + sizeof(DBGKM_EXIT_PROCESS));
	ApiMessage.h.u2.ZeroInit = 0;
	ApiMessage.h.u2.s2.Type = LPC_DEBUG_EVENT;
	ApiMessage.ApiNumber = DbgKmExitProcessApi;

	KeQuerySystemTime(&Process->ExitTime);
	DbgPrint("proxyDbgkExitProcess:DbgkpSendApiMessage_2\n");
	DbgkpSendApiMessage_2(&ApiMessage, FALSE);
}


typedef
VOID
(*pfPspExitThread)(
	IN NTSTATUS ExitStatus
	); pfPspExitThread originalproxyPspExitThread;


VOID __fastcall
proxyPspExitThread(
	IN NTSTATUS ExitStatus
)
{
	DbgPrint("PspExitThread\n");


	PETHREAD_S Thread = PsGetCurrentThread();
	PEPROCESS_S Process = IoThreadToProcess(Thread);
	if (Process)
	{
		UCHAR* Name = PsGetProcessImageFileName(Process);
		if (Name)
		{
			if (strcmp(Name, "chrome.exe") == 0 || strcmp(Name, "x64dbg.exe") == 0)
			{
				DbgPrint("proxyPspExitThread:currentProcess:%s\n", Name);
				if (((PTEB64)Thread->Tcb.Teb)->DbgSsReserved)
				{
					DbgPrint("((PTEB64)Thread->Tcb.Teb)->DbgSsReserved[0]:%x\n", ((PTEB64)Thread->Tcb.Teb)->DbgSsReserved[0]);
					((PTEB64)Thread->Tcb.Teb)->DbgSsReserved[0] = 0;
					((PTEB64)Thread->Tcb.Teb)->DbgSsReserved[1] = 0;
				}
				//Process->ActiveThreads--;
				BOOLEAN LastThread = FALSE;
				if (Process->ActiveThreads == 1) {
					LastThread = TRUE;
				}
				//
				// If we need to send debug messages then do so.
				//

				//if (Port_GetPort(Process)) {
				//if (Process->DebugPort != NULL) {
					//
					// Don't report system thread exit to the debugger as we don't report them.
					//
				if (!IS_SYSTEM_THREAD(Thread)) {
					ULONG u1; ULONG u2;
					proxyDbgkpCloseObject(Process, g_pdebugObj, DEBUG_ALL_ACCESS, &u1, &u2);
					if (LastThread) {
						Port_RemoveDbgItem(Process, Port_GetPort(Process));
						//Process->DebugPort = NULL;
						proxyDbgkExitProcess(Process->ExitStatus);
						DbgPrint("proxyDbgkExitProcess SET Process->DebugPort NULL\n");
					}
					else {
						Port_RemoveDbgItem(Process, Port_GetPort(Process));
						//Process->DebugPort = NULL;
						proxyDbgkExitThread(ExitStatus);
						DbgPrint("proxyDbgkExitThread SET Process->DebugPort NULL\n");
					}
				}
				//}
			}
		}
	}

	return originalproxyPspExitThread(ExitStatus);
}

//
//VOID __fastcall
//DbgkCreateThread(
//	PETHREAD_S Thread
//)
//{
//	DBGKM_MSG m;
//	PDBGKM_CREATE_THREAD CreateThreadArgs;
//	PDBGKM_CREATE_PROCESS CreateProcessArgs;
//	PEPROCESS_S Process;
//	PDBGKM_LOAD_DLL LoadDllArgs;
//	NTSTATUS status;
//	PIMAGE_NT_HEADERS NtHeaders;
//	ULONG OldFlags;
//
//	ULONG	index;
//	PMODULE_INFO ModuleInfo;
//	PDEBUG_OBJECT DebugObject;
//	PSYSTEM_DLL	SystemDll;
//	PVOID	Object;
//	PFILE_OBJECT FileObject;
//	PKTHREAD	CurrentThread;
//
//	Process = (PEPROCESS_S)Thread->Tcb.Process;
//
//	OldFlags = PspSetProcessFlag(&Process->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED | PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE);
//
//	if ((OldFlags & PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE) == 0 &&
//		(*(ULONG64*)PspNotifyEnableMask & 0x1))
//	{
//
//		IMAGE_INFO_EX ImageInfoEx;
//		PUNICODE_STRING ImageName;
//		POBJECT_NAME_INFORMATION FileNameInfo;
//
//		//
//		// notification of main .exe
//		//
//
//		ImageInfoEx.ImageInfo.Properties = 0;
//		ImageInfoEx.ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
//		ImageInfoEx.ImageInfo.ImageBase = Process->SectionBaseAddress;
//		ImageInfoEx.ImageInfo.ImageSize = 0;
//
//		try {
//			NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
//
//			if (NtHeaders) {
//				ImageInfoEx.ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER(NtHeaders, SizeOfImage);
//			}
//		} except(EXCEPTION_EXECUTE_HANDLER) {
//			ImageInfoEx.ImageInfo.ImageSize = 0;
//		}
//		ImageInfoEx.ImageInfo.ImageSelector = 0;
//		ImageInfoEx.ImageInfo.ImageSectionNumber = 0;
//
//		PsReferenceProcessFilePointer((PEPROCESS)Process, &FileObject);
//		status = SeLocateProcessImageName((PEPROCESS)Process, &ImageName);
//		if (!NT_SUCCESS(status))
//		{
//			ImageName = NULL;
//		}
//
//		PsCallImageNotifyRoutines(
//			ImageName,
//			Process->UniqueProcessId,
//			FileObject,
//			&ImageInfoEx);
//
//		if (ImageName)
//		{
//			//因为在SeLocateProcessImageName中为ImageName申请了内存，所以要在此处释放掉
//			ExFreePoolWithTag(ImageName, 0);
//		}
//
//		//PsReferenceProcessFilePointer增加了引用计数
//		ObfDereferenceObject(FileObject);
//
//		index = 0;
//		while (index < 2)
//		{
//			ModuleInfo = (PMODULE_INFO)PsQuerySystemDllInfo(index);
//			if (ModuleInfo != NULL)
//			{
//				ImageInfoEx.ImageInfo.Properties = 0;
//				ImageInfoEx.ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
//				ImageInfoEx.ImageInfo.ImageBase = ModuleInfo->BaseOfDll;
//				ImageInfoEx.ImageInfo.ImageSize = 0;
//
//				try {
//					NtHeaders = RtlImageNtHeader(ModuleInfo->BaseOfDll);
//					if (NtHeaders)
//					{
//						ImageInfoEx.ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER(NtHeaders, SizeOfImage);
//					}
//				}except(EXCEPTION_EXECUTE_HANDLER) {
//					ImageInfoEx.ImageInfo.ImageSize = 0;
//				}
//
//				ImageInfoEx.ImageInfo.ImageSelector = 0;
//				ImageInfoEx.ImageInfo.ImageSectionNumber = 0;
//
//				//实际就是PspSystemDlls
//				SystemDll = (PSYSTEM_DLL)((ULONG)ModuleInfo - 0x8);
//				Object = ObFastReferenceObject(&SystemDll->FastRef);
//				if (Object == NULL)
//				{
//					CurrentThread = (PKTHREAD)PsGetCurrentThread();
//					KeEnterCriticalRegionThread(CurrentThread);
//
//					ExAcquirePushLockShared(&SystemDll->Lock);
//
//					//由于系统模块不可能得不到，所以逆向发现win7没做判断
//					Object = ObFastReferenceObjectLocked(&SystemDll->FastRef);
//
//					ExReleasePushLockShared(&SystemDll->Lock);
//
//					KeLeaveCriticalRegionThread(CurrentThread);
//
//				}
//
//				FileObject = MmGetFileObjectForSection(Object);
//
//				if (Object != NULL)
//				{
//					ObFastDereferenceObject(
//						&SystemDll->FastRef,
//						Object);
//				}
//
//				PsCallImageNotifyRoutines(
//					&SystemDll->ModuleInfo.FileName,
//					Process->UniqueProcessId,
//					FileObject,
//					&ImageInfoEx);
//
//				ObfDereferenceObject(FileObject);
//			}
//
//			index++;
//		}
//	}
//
//	DebugObject = (PDEBUG_OBJECT)Process->DebugPort;
//
//	if (DebugObject == NULL) {
//		return;
//	}
//
//	if ((OldFlags & PS_PROCESS_FLAGS_CREATE_REPORTED) == 0)
//	{
//
//		CreateThreadArgs = &m.CreateProcess.InitialThread;
//		CreateThreadArgs->SubSystemKey = 0;
//
//		CreateProcessArgs = &m.CreateProcess;
//		CreateProcessArgs->SubSystemKey = 0;
//		CreateProcessArgs->FileHandle = DbgkpSectionToFileHandle(
//			Process->SectionObject
//		);
//		CreateProcessArgs->BaseOfImage = Process->SectionBaseAddress;
//		CreateThreadArgs->StartAddress = NULL;
//		CreateProcessArgs->DebugInfoFileOffset = 0;
//		CreateProcessArgs->DebugInfoSize = 0;
//
//		try {
//
//			NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
//
//			if (NtHeaders) {
//
//				CreateThreadArgs->StartAddress = (PVOID)(DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER(NtHeaders, ImageBase) +
//					DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER(NtHeaders, AddressOfEntryPoint));
//
//				CreateProcessArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
//				CreateProcessArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
//			}
//		} except(EXCEPTION_EXECUTE_HANDLER) {
//			CreateThreadArgs->StartAddress = NULL;
//			CreateProcessArgs->DebugInfoFileOffset = 0;
//			CreateProcessArgs->DebugInfoSize = 0;
//		}
//
//		DBGKM_FORMAT_API_MSG(m, DbgKmCreateProcessApi, sizeof(*CreateProcessArgs));
//
//		DbgkpSendApiMessage_2(&m, FALSE);
//
//		if (CreateProcessArgs->FileHandle != NULL) {
//			ObCloseHandle(CreateProcessArgs->FileHandle, KernelMode);
//		}
//
//		proxyDbgkSendSystemDllMessages(
//			NULL,
//			NULL,
//			&m);
//	}
//	else {
//
//		CreateThreadArgs = &m.u.CreateThread;
//		CreateThreadArgs->SubSystemKey = 0;
//		CreateThreadArgs->StartAddress = Thread->Win32StartAddress;
//
//		DBGKM_FORMAT_API_MSG(m, DbgKmCreateThreadApi, sizeof(*CreateThreadArgs));
//
//		DbgkpSendApiMessage(&m, TRUE);
//	}
//
//	if (Thread->ClonedThread == TRUE)
//	{
//		DbgkpPostModuleMessages(
//			Process,
//			Thread,
//			NULL);
//	}
//}

VOID
__fastcall
proxyDbgkUnMapViewOfSection(IN PEPROCESS_S PROCESS, IN PVOID BaseAddress)
{
	DBGKM_MSG ApiMessage;
	PDBGKM_UNLOAD_DLL UnloadDll = &ApiMessage.UnloadDll;
	PEPROCESS Process = PsGetCurrentProcess();
	PETHREAD_S Thread = PsGetCurrentThread();
	DbgProcess dbgmsg = { 0 };
	PTEB64	Teb;
	PAGED_CODE();
	/*
		dbgmsg.DebugProcess = PROCESS;
		if (Debug_FindMyNeedData(&dbgmsg)==FALSE)
		{
			return ori_pslp5(PROCESS, BaseAddress);
		}*/

	if ((ExGetPreviousMode() == KernelMode))
	{
		DbgPrint("proxyDbgkUnMapViewOfSection:ExGetPreviousMode KernelMode\n");
		return;
	}
	if (!Port_GetPort(PROCESS))
	{
		return;
	}

	DbgPrint("proxyDbgkUnMapViewOfSection:Port_GetPort ok\n");

	if (Thread->Tcb.SystemThread != TRUE &&
		Thread->Tcb.ApcStateIndex != 0x1)
	{
		Teb = (PTEB64)Thread->Tcb.Teb;
	}
	else {
		Teb = NULL;
	}

	if (Teb != NULL && Process == PROCESS)
	{
		if (!DbgkpSuppressDbgMsg(Teb))
		{
			//
		}
		else {
			//暂停调试消息的话就退出
			return;
		}
	}


	UnloadDll->BaseAddress = BaseAddress;


	ApiMessage.h.u1.Length = sizeof(DBGKM_MSG) << 16 |
		(8 + sizeof(DBGKM_UNLOAD_DLL));
	ApiMessage.h.u2.ZeroInit = 0;
	ApiMessage.h.u2.s2.Type = LPC_DEBUG_EVENT;
	ApiMessage.ApiNumber = DbgKmUnloadDllApi;

	DbgPrint("proxyDbgkUnMapViewOfSection:DbgkpSendApiMessage_2 ok\n");
	DbgkpSendApiMessage_2(&ApiMessage, FALSE);
}


VOID
__fastcall
proxyDbgkMapViewOfSection(IN PVOID Processs,
	IN PVOID Section,
	IN ULONG64 BaseAddress
)
{
	DbgProcess dbgmsg = { 0 };
	DBGKM_MSG ApiMessage;
	PDBGKM_LOAD_DLL LoadDll = &ApiMessage.LoadDll;
	PEPROCESS_S Process = PsGetCurrentProcess();
	PETHREAD_S Thread = PsGetCurrentThread();
	PIMAGE_NT_HEADERS NtHeader;
	PTEB64 TEB = (PTEB64)Thread->Tcb.Teb;
	PAGED_CODE();

	/*dbgmsg.DebugProcess = Processs;
	if (Debug_FindMyNeedData(&dbgmsg) == FALSE){
		return ori_pslp6(Processs, Section, BaseAddress);

	}*/

	if ((ExGetPreviousMode() == KernelMode))
	{
		return;
	}

	if (!Port_GetPort(Processs))
	{
		return;
	}

	if (Thread->Tcb.SystemThread != TRUE &&
		Thread->Tcb.ApcStateIndex != 0x1)
	{
		TEB = (PTEB64)Thread->Tcb.Teb;
	}
	else {
		TEB = NULL;
		return;
	}

	if (TEB != NULL && Processs == Process)
	{
		if (!DbgkpSuppressDbgMsg(TEB))
		{
			//
		}
		else {
			//暂停调试消息的话就退出
			DbgPrint("proxyDbgkMapViewOfSection:暂停调试消息的话就退出\n");
			return;
		}
	}

	LoadDll->FileHandle = DbgkpSectionToFileHandle(Section);
	LoadDll->BaseOfDll = BaseAddress;
	LoadDll->DebugInfoFileOffset = 0;
	LoadDll->DebugInfoSize = 0;
	LoadDll->NamePointer = &TEB->NtTib.ArbitraryUserPointer;

	NtHeader = RtlImageNtHeader(BaseAddress);
	if (NtHeader)
	{
		LoadDll->DebugInfoFileOffset = NtHeader->FileHeader.
			PointerToSymbolTable;
		LoadDll->DebugInfoSize = NtHeader->FileHeader.NumberOfSymbols;
	}

	ApiMessage.h.u1.Length = sizeof(DBGKM_MSG) << 16 |
		(8 + sizeof(DBGKM_LOAD_DLL));
	ApiMessage.h.u2.ZeroInit = 0;
	ApiMessage.h.u2.s2.Type = LPC_DEBUG_EVENT;
	ApiMessage.ApiNumber = DbgKmLoadDllApi;


	DbgkpSendApiMessage_2(&ApiMessage, FALSE);

	ObCloseHandle(LoadDll->FileHandle, KernelMode);
}

BOOLEAN DbgkpSuppressDbgMsg(
	IN PTEB64 Teb)
{
	BOOLEAN bSuppress;
	try {
		bSuppress = (BOOLEAN)Teb->SuppressDebugMsg;
	}except(EXCEPTION_EXECUTE_HANDLER) {
		bSuppress = FALSE;
	}
	return bSuppress;
}

ULONG GetProcessIDFromProcessHandle(HANDLE ProcessHandle)
{
	ULONG Pid = 0;
	PEPROCESS Process;
	if (NT_SUCCESS(ObReferenceObjectByHandle(ProcessHandle, 0, *PsProcessType, ExGetPreviousMode(), (PVOID*)&Process, NULL)))
	{
		Pid = (ULONG)(ULONG_PTR)PsGetProcessId(Process);
		ObDereferenceObject(Process);
	}
	return Pid;
}

NTSTATUS __fastcall proxyNtCreateDebugObject(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags
)
{
	DbgPrint("proxyNtCreateDebugObject\n");

	p_save_handlentry Padd = NULL;

	NTSTATUS status;
	HANDLE Handle;
	PDEBUG_OBJECT DebugObject;
	KPROCESSOR_MODE        PreviousMode;

	PreviousMode = ExGetPreviousMode();

	try {
		if (PreviousMode != KernelMode) {
			ProbeForWriteHandle(DebugObjectHandle);

			//*DebugObjectHandle = *DebugObjectHandle;
		}
		*DebugObjectHandle = NULL;

	} except(ExSystemExceptionFilter()) {
		return GetExceptionCode();
	}

	if (Flags & ~DEBUG_KILL_ON_CLOSE) {
		return STATUS_INVALID_PARAMETER;
	}

	/*
		Padd = querylist(PmainList, PsGetCurrentProcessId(), PsGetCurrentProcess());
		if (Padd == NULL)
		{
			DbgPrint("proxyNtCreateDebugObject");
			return ori_pslp40(DebugObjectHandle, DesiredAccess, ObjectAttributes, Flags);

		}*/

		//创建调试对象
	status = ObCreateObject(
		PreviousMode,
		*NewDbgObject,
		ObjectAttributes,
		PreviousMode,
		NULL,
		sizeof(DEBUG_OBJECT),
		0,
		0,
		(PVOID*)&DebugObject);


	if (!NT_SUCCESS(status)) {
		DbgPrint("ObCreateObject failed\n");
		return status;
	}
	//初始化调试对象
	ExInitializeFastMutex(&DebugObject->Mutex);
	InitializeListHead(&DebugObject->EventList);
	KeInitializeEvent(&DebugObject->EventsPresent, NotificationEvent, FALSE);

	if (Flags & DEBUG_KILL_ON_CLOSE) {
		DebugObject->Flags = DEBUG_OBJECT_KILL_ON_CLOSE;
	}
	else {
		DebugObject->Flags = 0;
	}

	g_debugObj = *DebugObject;//保存DebugObjet
	g_pdebugObj = &g_debugObj;//保存DebugObjet addr

	status = ObInsertObject(
		DebugObject,
		NULL,
		DesiredAccess,
		0,
		NULL,
		&Handle);
	if (!NT_SUCCESS(status)) {
		DbgPrint("ObInsertObject failed\n");
		return status;
	}

	PEPROCESS ps;
	NTSTATUS status1 = PsLookupProcessByProcessId(PsGetCurrentProcessId(), &ps);
	if (NT_SUCCESS(status1))
	{
		UCHAR* Name = PsGetProcessImageFileName(ps);
		DbgPrint("proxyNtCreateDebugObject:PsGetProcessImageFileName:%s\n", Name);
		ObDereferenceObject(ps);
	}

	try {
		*DebugObjectHandle = Handle;
	} except(ExSystemExceptionFilter()) {
		status = GetExceptionCode();
	}

	DbgPrint("proxyNtCreateDebugObject:*DebugObjectHandle:%p\n", *DebugObjectHandle);

	//g_pdebugObj = DebugObject;
	DbgPrint("proxyNtCreateDebugObject:g_pdebugObj:%p\n", g_pdebugObj);

	Padd = querylist(PmainList, PsGetCurrentProcessId(), PsGetCurrentProcess());
	if (Padd == NULL)
	{
		DbgPrint("proxyNtCreateDebugObject:insertlist\n");
		insertlist(PsGetCurrentProcessId(), PsGetCurrentProcess(), PmainList);
	}


	return status;
}

VOID SendForWarExcept_Thread() {

	DBGKM_MSG ApiMessage = { 0 };
	PDBGKM_CREATE_THREAD CreateThreadArgs = &ApiMessage.CreateThread;


	ApiMessage.h.u1.Length = sizeof(DBGKM_MSG) << 16 |
		(8 + sizeof(DBGKM_CREATE_THREAD));
	ApiMessage.h.u2.ZeroInit = 0;
	ApiMessage.h.u2.s2.Type = LPC_DEBUG_EVENT;
	ApiMessage.ApiNumber = DbgKmCreateThreadApi;

	CreateThreadArgs->StartAddress = 0x1008611;
	CreateThreadArgs->SubSystemKey = 0;
	DbgPrint("SendForWarExcept_Thread: DbgkpSendApiMessage_2\n");
	DbgkpSendApiMessage_2(&ApiMessage, FALSE);

}

BOOLEAN __fastcall MarkDbgProcess() {
	PEPROCESS_S Process = PsGetCurrentProcess();
	PDbgPortList DbgList = NULL;

	DbgList = Port_FindProcessList(Process, NULL);
	if (DbgList != NULL && MmIsAddressValid(DbgList) == TRUE && DbgList->markdbg == FALSE)
	{

		InterlockedExchange8(&DbgList->markdbg, TRUE);
		//	Process->Pcb.Unused3 = TRUE;
		SendForWarExcept_Thread(); //SendCreateThreadMsg

		return TRUE;

	}
	else {


		return FALSE;
	}
}

NTSTATUS
NTAPI
proxyNtRemoveProcessDebug(IN HANDLE ProcessHandle,
	IN HANDLE DebugHandle)
{
	DbgPrint("proxyNtRemoveProcessDebug \n");
	DbgProcess dbgmsg = { 0 };
	PEPROCESS_S Process;
	PDEBUG_OBJECT DebugObject;
	KPROCESSOR_MODE PreviousMode = ExGetPreviousMode();
	NTSTATUS Status;
	PAGED_CODE();
	PDbgProcess pdbgmsg = NULL;

	PEPROCESS ps;
	NTSTATUS status1 = PsLookupProcessByProcessId(PsGetCurrentProcessId(), &ps);
	if (NT_SUCCESS(status1))
		if (ps)
		{
			UCHAR* Name = PsGetProcessImageFileName(ps);
			if (Name)
			{
				if (_stricmp(Name, "TslGame.exe") == 0)
				{
					DbgPrint("proxyNtRemoveProcessDebug:currentProcess:%s\n", Name);
					return STATUS_DEBUGGER_INACTIVE;
				}
			}
		}

	/*dbgmsg.DbgHanle = DebugHandle;
	pdbgmsg = Debug_FindMyNeedData(&dbgmsg);
	if (pdbgmsg == FALSE)
	{

		return ori_pslp44(ProcessHandle, DebugHandle);

	}*/
	Status = ObReferenceObjectByHandle(ProcessHandle,
		PROCESS_SUSPEND_RESUME,
		*PsProcessType,
		PreviousMode,
		(PVOID*)&Process,
		NULL);
	if (!NT_SUCCESS(Status)) return Status;


	Status = ObReferenceObjectByHandle(DebugHandle,
		DEBUG_OBJECT_ADD_REMOVE_PROCESS,
		*NewDbgObject,
		PreviousMode,
		(PVOID*)&DebugObject,
		NULL);
	/*Status = ObReferenceObjectByHandle(DebugHandle,
	DEBUG_OBJECT_ADD_REMOVE_PROCESS,
	*(ULONG64*)DbgkDebugObjectType,
	PreviousMode,
	(PVOID*)&DebugObject,
	NULL);*/
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("proxyNtRemoveProcessDebug:DEBUG_OBJECT_ADD_REMOVE_PROCESS failed with status:%p \n", Status, DebugObject);
		ObDereferenceObject(Process);
		return Status;
	}

	DbgPrint("DbgkClearProcessDebugObject \n");
	Status = DbgkClearProcessDebugObject(Process, DebugObject);

	//	Debug_ExFreeItem(pdbgmsg);
	ObDereferenceObject(Process);
	ObDereferenceObject(DebugObject);
	return Status;
}

typedef NTSTATUS(*OriginalNtDebugContinue)(
	IN HANDLE DebugObjectHandle,
	IN PCLIENT_ID ClientId,
	IN NTSTATUS ContinueStatus);
OriginalNtDebugContinue originalNtDebugContinue;

NTSTATUS
NTAPI
proxyNtDebugContinue(IN HANDLE DebugHandle,
	IN PCLIENT_ID AppClientId,
	IN NTSTATUS ContinueStatus)
{
	//return originalNtDebugContinue(DebugHandle, AppClientId, ContinueStatus);

	NTSTATUS Status;
	PDEBUG_OBJECT DebugObject;
	PDEBUG_EVENT DebugEvent, FoundDebugEvent;
	KPROCESSOR_MODE PreviousMode;
	CLIENT_ID Clid;
	PLIST_ENTRY Entry;
	BOOLEAN GotEvent;

	PreviousMode = ExGetPreviousMode();

	try {
		if (PreviousMode != KernelMode) {
			ProbeForRead(AppClientId, sizeof(CLIENT_ID), sizeof(ULONG));
		}
		Clid = *AppClientId;

	} except(ExSystemExceptionFilter()) {
		return GetExceptionCode();
	}

	//判断继续操作的类型，此函数就这里和wrk中的不同而已
	switch (ContinueStatus) {
	case DBG_EXCEPTION_NOT_HANDLED:
	case DBG_CONTINUE:
	case DBG_TERMINATE_PROCESS:
		break;
	default:
		return STATUS_INVALID_PARAMETER;
	}

	//得到调试对象
	Status = ObReferenceObjectByHandle(
		DebugHandle,
		0x1,
		*NewDbgObject,
		PreviousMode,
		(PVOID*)&DebugObject,
		NULL);

	if (!NT_SUCCESS(Status)) {
		return Status;
	}

	//如果获得指定的调试消息就设置为ture，初始化时为false
	GotEvent = FALSE;
	//保存寻找到调试消息的变量
	FoundDebugEvent = NULL;

	//这个锁很重要
	ExAcquireFastMutex(&DebugObject->Mutex);

	for (Entry = DebugObject->EventList.Flink;
		Entry != &DebugObject->EventList;
		Entry = Entry->Flink) {

		DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);

		//这里几个判断就是为了找到指定消息
		if (DebugEvent->ClientId.UniqueProcess == Clid.UniqueProcess) {
			//如果还没有寻找到，进入if
			if (!GotEvent) {
				//这里的DEBUG_EVENT_READ是表示这个消息有没有没读取过，也就是说有没有被处理过。
				//如果被处理过，而且确实是我们要找的消息，那么就从消息链中移除，并保存，然后
				//设置标记说找到了。这里DEBUG_EVENT_READ的意义十分重要，解读它我是逆向了
				//NtWaitForDebugEvent函数才知晓了这个意义
				if (DebugEvent->ClientId.UniqueThread == Clid.UniqueThread &&
					(DebugEvent->Flags & 0x1) != 0) {
					RemoveEntryList(Entry);
					FoundDebugEvent = DebugEvent;
					GotEvent = TRUE;
				}
			}
			else {
				//会进入这里说明我们已经找到了指定的消息，并且此调试事件链表还不是空的，
				//那么这里就设置完成获取的这个事件；注意，这里这样写是非常有意义的，至于
				//为何要等到分析NtWaitForDebugEvent的时候再揭晓
				DebugEvent->Flags &= ~0x4;
				KeSetEvent(&DebugObject->EventsPresent, 0, FALSE);
				break;
			}
		}
	}

	ExReleaseFastMutex(&DebugObject->Mutex);

	ObfDereferenceObject(DebugObject);

	if (GotEvent) {
		//找到的话，这个消息也就算彻底完成任务了。注意这里的DbgkpWakeTarget函数里，一般非阻塞消息
		//是直接释放所占内存的
		FoundDebugEvent->ApiMsg.ReturnedStatus = ContinueStatus;
		FoundDebugEvent->Status = STATUS_SUCCESS;
		DbgkpWakeTarget(FoundDebugEvent);
	}
	else {
		Status = STATUS_INVALID_PARAMETER;
	}

	return Status;
}



NTSTATUS
__fastcall
proxyDbgkOpenProcessDebugPort(IN PEPROCESS_S Process,
	IN KPROCESSOR_MODE PreviousMode,
	OUT HANDLE* DebugHandle)
{
	struct _DMA_ADAPTER* v7 = 0;
	PDEBUG_OBJECT DebugObject;
	NTSTATUS Status;
	DbgProcess dbgmsg = { 0 };
	PAGED_CODE();
	/*
		dbgmsg.DebugProcess = Process;
		if (Debug_FindMyNeedData(&dbgmsg)==FALSE)
		{
			return ori_pslp4(Process, PreviousMode, DebugHandle);
		}
	*/

	//if (!Process->Pcb.newdbgport) return STATUS_PORT_NOT_SET;

	if (!Port_IsPort(Process)) return STATUS_PORT_NOT_SET;


	ExAcquireFastMutex(&DbgkFastMutex);

	//DebugObject = Process->Pcb.newdbgport;
	DebugObject = Port_GetPort(Process);
	if (DebugObject)
	{
		v7 = *(struct _DMA_ADAPTER**)DebugObject;
		if (v7)
		{
			ObReferenceObject(DebugObject);
		}
	}

	ExReleaseFastMutex(&DbgkFastMutex);


	if (!DebugObject) return STATUS_PORT_NOT_SET;


	Status = ObOpenObjectByPointer((PVOID)DebugObject,
		PreviousMode == KernelMode ? 0x200 : 0,
		0,
		MAXIMUM_ALLOWED,
		*NewDbgObject,
		PreviousMode,
		DebugHandle);

	if (!NT_SUCCESS(Status))
	{
		//HalPutDmaAdapter(v7);
		return Status;
	}

	ObDereferenceObject(DebugObject);


	return Status;
}

VOID
proxyDbgkCopyProcessDebugPort(
	IN PEPROCESS_S TargetProcess,
	IN PEPROCESS_S SourceProcess
	, IN ULONG64 unknow, IN ULONG64 unknow1
)

{
	PDEBUG_OBJECT DebugObject;
	p_save_handlentry Padd = NULL;

	PAGED_CODE();

	/*Padd = querylist(PmainList, PsGetCurrentProcessId(), PsGetCurrentProcess());
	if (Padd == NULL)
	{
		return ori_pslp2(TargetProcess, SourceProcess, unknow, unknow1);

	}*/

	//TargetProcess->Pcb.newdbgport = NULL; // New process. Needs no locks.


	if (Port_IsPort(SourceProcess))

		//if (SourceProcess->Pcb.newdbgport != NULL) 
	{
		ExAcquireFastMutex(&DbgkFastMutex);
		//DebugObject = SourceProcess->Pcb.newdbgport;
		DebugObject = Port_GetPort(SourceProcess);
		if (DebugObject != NULL && (SourceProcess->Flags & PS_PROCESS_FLAGS_NO_DEBUG_INHERIT) == 0) {
			//
			// We must not propagate a debug port thats got no handles left.
			//
			ExAcquireFastMutex(&DebugObject->Mutex);

			//
			// If the object is delete pending then don't propagate this object.
			//
			if ((DebugObject->Flags & DEBUG_OBJECT_DELETE_PENDING) == 0) {
				ObReferenceObject(DebugObject);

				//TargetProcess->Pcb.newdbgport = DebugObject;
				Port_SetPort(TargetProcess, DebugObject);
			}

			ExReleaseFastMutex(&DebugObject->Mutex);
		}
		ExReleaseFastMutex(&DbgkFastMutex);
	}
}


VOID
__fastcall
proxyDbgkpDeleteObject(IN PVOID DebugObject)
{
	PAGED_CODE();

	DbgPrint("proxyDbgkpDeleteObject\n");

	ASSERT(IsListEmpty(&((PDEBUG_OBJECT)DebugObject)->EventList));
}

VOID
NTAPI
DbgkpFreeDebugEvent(IN PDEBUG_EVENT DebugEvent)
{
	PHANDLE Handle = NULL;
	PAGED_CODE();


	switch (DebugEvent->ApiMsg.ApiNumber)
	{

	case DbgKmCreateProcessApi:


		Handle = &DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle;
		break;


	case DbgKmLoadDllApi:


		Handle = &DebugEvent->ApiMsg.u.LoadDll.FileHandle;

	default:
		break;
	}

	if ((Handle) && (*Handle)) ObCloseHandle(*Handle, KernelMode);


	ObDereferenceObject(DebugEvent->Process);
	ObDereferenceObject(DebugEvent->Thread);
	ExFreePoolWithTag(DebugEvent, 'EgbD');
}

VOID
NTAPI
DbgkpWakeTarget(IN PDEBUG_EVENT DebugEvent)
{
	PETHREAD_S Thread = DebugEvent->Thread;
	PAGED_CODE();


	if (DebugEvent->Flags & DEBUG_EVENT_SUSPEND) PsResumeThread(Thread, NULL);


	if (DebugEvent->Flags & DEBUG_EVENT_RELEASE)
	{

		ExReleaseRundownProtection(&Thread->RundownProtect);
	}


	if (DebugEvent->Flags & DEBUG_EVENT_NOWAIT)
	{

		DbgkpFreeDebugEvent(DebugEvent);
	}
	else
	{

		KeSetEvent(&DebugEvent->ContinueEvent, IO_NO_INCREMENT, FALSE);
	}
}

POBJECT_TYPE CreateNewObjectType(POBJECT_TYPE_S* OrigDebugObjectType)
{
	NTSTATUS					status;
	POBJECT_TYPE_S				NewObjectType;

	UNICODE_STRING				usObjectTypeName, usFuncName;
	OBCREATEOBJECTTYPE			ObCreateObjectType;
	OBJECT_TYPE_INITIALIZER_S	Object_Type_Init = { 0 };

	NewObjectType = NULL;

	if (OrigDebugObjectType == NULL || *OrigDebugObjectType == NULL || ObTypeIndexTable == NULL)
	{
		if (!OrigDebugObjectType)
		{
			DbgPrint("OrigDebugObjectType is null\n");
		}
		if (!ObTypeIndexTable)
		{
			DbgPrint("ObTypeIndexTable is null\n");
		}

		return NULL;
	}


	RtlInitUnicodeString(&usObjectTypeName, L"VV-DBG");
	RtlInitUnicodeString(&usFuncName, L"ObCreateObjectType");
	ObCreateObjectType = (OBCREATEOBJECTTYPE)MmGetSystemRoutineAddress(&usFuncName);
	if (ObCreateObjectType == NULL)
	{
		return NULL;
	}

	memset(&Object_Type_Init, 0x00, sizeof(OBJECT_TYPE_INITIALIZER_S));
	memcpy(&Object_Type_Init, &(*OrigDebugObjectType)->TypeInfo, sizeof(OBJECT_TYPE_INITIALIZER_S));
	Object_Type_Init.DeleteProcedure = &proxyDbgkpDeleteObject;
	Object_Type_Init.CloseProcedure = &proxyDbgkpCloseObject;
	Object_Type_Init.ValidAccessMask = 0x1f000f;
	status = ObCreateObjectType(&usObjectTypeName, &Object_Type_Init, NULL, &NewObjectType);
	if (status == STATUS_OBJECT_NAME_COLLISION)
	{
		ULONG Index = 2;
		while (ObTypeIndexTable[Index])
		{
			if (RtlCompareUnicodeString(&ObTypeIndexTable[Index]->Name, &usObjectTypeName, FALSE) == 0)
			{
				return (POBJECT_TYPE)ObTypeIndexTable[Index];
			}
			Index++;
		}
	}

	return (POBJECT_TYPE)NewObjectType;
}

#include "Log.h"
int initDbgk() {
	InitDbgPortList();
	PmainList = createlist();//创建记录DBG工具的链表

	ExSystemExceptionFilter = fc_DbgkGetAdrress(L"ExSystemExceptionFilter");
	//ObInsertObject = fc_DbgkGetAdrress(L"ObInsertObject");
	//ObCreateObject = fc_DbgkGetAdrress(L"ObCreateObject");
	//ObOpenObjectByPointer = fc_DbgkGetAdrress(L"ObOpenObjectByPointer");
	KiCheckForKernelApcDelivery12 = fc_DbgkGetAdrress(L"KiCheckForKernelApcDelivery");
	if (!ExSystemExceptionFilter)
	{
		DbgPrint("get ExSystemExceptionFilter failed\n");
		return -1;
	}
	if (!KiCheckForKernelApcDelivery12)
	{
		DbgPrint("get KiCheckForKernelApcDelivery12 failed\n");
		return -2;
	}
	if (!ExSystemExceptionFilter || !KiCheckForKernelApcDelivery12)
	{
		DbgPrint("initDbgk failed\n");
		return -3;
	}

	ExInitializeFastMutex(&DbgkFastMutex);
	DbgkFastMutex2 = (PFAST_MUTEX)DbgkpProcessDebugPortMutex;

	NewDbgObject = g_DbgkDebugObjectType;

	//NewDbgObject =*(ULONG64*)DbgkDebugObjectType; 

	//NewDbgObject = CreateNewObjectType(g_DbgkDebugObjectType);

	if (NewDbgObject == NULL) {

		DbgPrint("NewDbgObject is NULL");
		return -4;
	}
	return 0;

}

NTSTATUS __fastcall
DbgkpQueueMessage_2(
	IN PEPROCESS_S Process,
	IN PETHREAD_S Thread,
	IN OUT PDBGKM_APIMSG ApiMsg,
	IN ULONG Flags,
	IN PDEBUG_OBJECT TargetDebugObject
)
{
	PDEBUG_EVENT DebugEvent;
	DEBUG_EVENT StaticDebugEvent;
	PDEBUG_OBJECT DebugObject;
	NTSTATUS Status;
	DbgProcess dbgmsg = { 0 };
	/*
		dbgmsg.DebugProcess = Process;
		if (Debug_FindMyNeedData(&dbgmsg)==FALSE)
		{
			return ori_pslp11(Process, Thread, ApiMsg, Flags, TargetDebugObject);
		}*/
	PAGED_CODE();

	if (Flags & DEBUG_EVENT_NOWAIT) {
		DbgPrint("DEBUG_EVENT_NOWAIT !!!!!!!!!!!!!!!!!!!!!!!\n");
		DebugEvent = ExAllocatePoolWithQuotaTag(NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
			sizeof(*DebugEvent),
			'EgbD');
		if (DebugEvent == NULL) {
			DbgPrint("STATUS_INSUFFICIENT_RESOURCES\n");
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		DebugEvent->Flags = Flags | DEBUG_EVENT_INACTIVE;
		ObReferenceObject(Process);
		ObReferenceObject(Thread);
		DebugEvent->BackoutThread = PsGetCurrentThread();
		DebugObject = TargetDebugObject;
	}
	else {
		DbgPrint("DEBUG_EVENT_WAIT\n");
		DebugEvent = &StaticDebugEvent;
		DebugEvent->Flags = Flags;
		ExAcquireFastMutex(&DbgkFastMutex);

		//DebugObject = Process->Pcb.newdbgport;
		//DebugObject = Process->Pcb.newdbgport;
		DebugObject = Port_GetPort(Process);
		//
		// See if this create message has already been sent.
		//
		if (ApiMsg->ApiNumber == DbgKmCreateThreadApi ||
			ApiMsg->ApiNumber == DbgKmCreateProcessApi) {
			if (Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG) {
				//DebugObject = NULL;
				DbgPrint("DbgKmCreateThreadApi !!!!!!!!!!!!!!!!!!!!!!!\n");
			}
		}
		if (ApiMsg->ApiNumber == DbgKmLoadDllApi &&
			Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG &&
			Flags & 0x40) {
			//DebugObject = NULL;
			DbgPrint("DbgKmLoadDllApi !!!!!!!!!!!!!!!!!!!!!!!\n");
		}
		//
		// See if this exit message is for a thread that never had a create
		//
		if (ApiMsg->ApiNumber == DbgKmExitThreadApi ||
			ApiMsg->ApiNumber == DbgKmExitProcessApi) {
			if (Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG) {
				//DebugObject = NULL;
				DbgPrint("DbgKmExitThreadApi !!!!!!!!!!!!!!!!!!!!!!!\n");
			}
		}

		KeInitializeEvent(&DebugEvent->ContinueEvent, SynchronizationEvent, FALSE);

	}


	DebugEvent->Process = Process;
	DebugEvent->Thread = Thread;
	DebugEvent->ApiMsg = *ApiMsg;
	DebugEvent->ClientId = Thread->Cid;

	if (DebugObject == NULL) {
		Status = STATUS_PORT_NOT_SET;
		DbgPrint("STATUS_PORT_NOT_SET !!!!!!!!!!!!!!!!!!!!!!!\n");
	}
	else {

		//
		// We must not use a debug port thats got no handles left.
		//
		ExAcquireFastMutex(&DebugObject->Mutex);
		DbgPrint("ExAcquireFastMutex !!!!!!!!!!!!!!!!!!!!!!!\n");
		//
		// If the object is delete pending then don't use this object.
		//
		if ((DebugObject->Flags & DEBUG_OBJECT_DELETE_PENDING) == 0) {
			InsertTailList(&DebugObject->EventList, &DebugEvent->EventList);
			//
			// Set the event to say there is an unread event in the object
			//
			DbgPrint("DEBUG_OBJECT_DELETE_PENDING\n");
			if ((Flags & DEBUG_EVENT_NOWAIT) == 0) {
				KeSetEvent(&DebugObject->EventsPresent, 0, FALSE);
				DbgPrint("KeSetEvent DebugObject->EventsPresent\n");
			}
			Status = STATUS_SUCCESS;
		}
		else {
			DbgPrint("STATUS_DEBUGGER_INACTIVE !!!!!!!!!!!!!!!!!!!!!!!\n");
			Status = STATUS_DEBUGGER_INACTIVE;
		}

		ExReleaseFastMutex(&DebugObject->Mutex);
	}


	if ((Flags & DEBUG_EVENT_NOWAIT) == 0) {
		ExReleaseFastMutex(&DbgkFastMutex);

		if (NT_SUCCESS(Status)) {
			KeWaitForSingleObject(&DebugEvent->ContinueEvent,
				Executive,
				KernelMode,
				FALSE,
				NULL);

			Status = DebugEvent->Status;
			*ApiMsg = DebugEvent->ApiMsg;
		}
	}
	else {
		if (!NT_SUCCESS(Status)) {
			ObDereferenceObject(Process);
			ObDereferenceObject(Thread);
			ExFreePool(DebugEvent);
		}
	}

	return Status;
}

NTSTATUS
__fastcall
DbgkpSendApiMessage_2(IN OUT PDBGKM_MSG ApiMsg,
	IN BOOLEAN SuspendProcess)
{
	NTSTATUS Status;
	BOOLEAN Suspended = FALSE;
	PAGED_CODE();

	PVOID  addr = 0; PVOID  caller = 0;
	RtlGetCallersAddress(&addr, &caller);
	DbgPrint("DbgkpSendApiMessage_2:callerAddr:%p caller:%s \n", addr, caller);
	/* Suspend process if required */
	if (SuspendProcess)
	{
		Suspended = proxyDbgkpSuspendProcess(NtCurrentProcess());
	}

	/* Set return status */
	ApiMsg->ReturnedStatus = STATUS_PENDING;

	/* Set create process reported state */
	PspSetProcessFlag(&((PEPROCESS_S)PsGetCurrentProcess())->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);

	DbgPrint("DbgkpSendApiMessage_2:DbgkpQueueMessage_2 \n");
	/* Send the LPC command */
	Status = DbgkpQueueMessage_2(PsGetCurrentProcess(),
		PsGetCurrentThread(),
		ApiMsg,
		((SuspendProcess & 0x2) << 0x5),
		NULL);

	/* Flush the instruction cache */
	ZwFlushInstructionCache(NtCurrentProcess(), NULL, 0);

	DbgPrint("DbgkpSendApiMessage_2:DbgkpResumeProcess(PsGetCurrentProcess(), 0);\n");
	/* Resume the process if it was suspended */
	if (Suspended) DbgkpResumeProcess(PsGetCurrentProcess(), 0);
	return Status;
}

NTSTATUS
NTAPI
DbgkpSendApiMessageLpc(IN OUT PDBGKM_MSG Message,
	IN PVOID Port,
	IN BOOLEAN SuspendProcess)
{
	NTSTATUS Status;
	UCHAR Buffer[PORT_MAXIMUM_MESSAGE_LENGTH];
	BOOLEAN Suspended = FALSE;
	PAGED_CODE();

	if (SuspendProcess) Suspended = proxyDbgkpSuspendProcess(NtCurrentProcess());


	Message->ReturnedStatus = STATUS_PENDING;


	PspSetProcessFlag(&((PEPROCESS_S)PsGetCurrentProcess())->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);


	Status = LpcRequestWaitReplyPortEx(Port,
		(PPORT_MESSAGE)Message,
		(PPORT_MESSAGE)&Buffer[0]);


	ZwFlushInstructionCache(NtCurrentProcess(), NULL, 0);


	if (NT_SUCCESS(Status)) RtlCopyMemory(Message, Buffer, sizeof(DBGKM_MSG));

	DbgPrint("DbgkpSendApiMessageLpc:DbgkpResumeProcess \n");
	if (Suspended) DbgkpResumeProcess(NtCurrentProcess(), 0);
	return Status;
}

BOOLEAN
__fastcall
proxyDbgkForwardException(IN PEXCEPTION_RECORD ExceptionRecord,
	IN BOOLEAN DebugPort,
	IN BOOLEAN SecondChance)
{
	DbgPrint("==================proxyDbgkForwardException start================== \n");
	DBGKM_MSG ApiMessage;
	PDBGKM_EXCEPTION DbgKmException = &ApiMessage.Exception;
	NTSTATUS Status = TRUE;
	PEPROCESS_S Process = PsGetCurrentProcess();
	PVOID Port = NULL;
	DbgProcess dbgmsg = { 0 };
	BOOLEAN UseLpc = FALSE;
	PAGED_CODE();

	/*
		dbgmsg.DebugProcess = Process;
		if (Debug_FindMyNeedData(&dbgmsg) == NULL)
		{
			DbgPrint("proxyDbgkForwardException");
			ori_pslp3(ExceptionRecord, DebugPort, SecondChance);
		}
	*/

	/* Setup the API Message */
	ApiMessage.h.u1.Length = sizeof(DBGKM_MSG) << 16 |
		(8 + sizeof(DBGKM_EXCEPTION));
	ApiMessage.h.u2.ZeroInit = 0;
	ApiMessage.h.u2.s2.Type = LPC_DEBUG_EVENT;
	ApiMessage.ApiNumber = DbgKmExceptionApi;

	/* Check if this is to be sent on the debug port */
	if (DebugPort)
	{
		/* Use the debug port, unless the thread is being hidden */
	//	Port = Process->Pcb.newdbgport;
		Port = Port_GetPort(Process);
		// Process->Pcb.newdbgport;
		DbgPrint("proxyDbgkForwardException:pid:%d Port_GetPort:%p \n", PsGetCurrentProcessId(), DebugPort);
	}
	else
	{
		/* Otherwise, use the exception port */
		Port = Process->ExceptionPortData;
		ApiMessage.h.u2.ZeroInit = 0;
		ApiMessage.h.u2.s2.Type = LPC_EXCEPTION;
		UseLpc = TRUE;
		DbgPrint("proxyDbgkForwardException:DebugPort is null \n");
	}
	DbgPrint("异常\n");
	/* Break out if there's no port */
	if (!Port) return FALSE;
	MarkDbgProcess();
	/* Fill out the exception information */
	DbgKmException->ExceptionRecord = *ExceptionRecord;
	DbgKmException->FirstChance = !SecondChance;

	/* Check if we should use LPC */
	if (UseLpc)
	{
		DbgPrint("proxyDbgkForwardException:DbgkpSendApiMessageLpc \n");
		/* Send the message on the LPC Port */
		Status = DbgkpSendApiMessageLpc(&ApiMessage, Port, DebugPort);
	}
	else
	{
		DbgPrint("proxyDbgkForwardException:DbgkpSendApiMessage_2 \n");
		/* Use native debug object */
		Status = DbgkpSendApiMessage_2(&ApiMessage, DebugPort);
	}

	/* Check if we failed, and for a debug port, also check the return status */
	if (!(NT_SUCCESS(Status)) ||
		((DebugPort) &&
			(!(NT_SUCCESS(ApiMessage.ReturnedStatus)) ||
				(ApiMessage.ReturnedStatus == DBG_EXCEPTION_NOT_HANDLED))))
	{
		/* Fail */
		DbgPrint("==================proxyDbgkForwardException end with Fail================== \n");
		return FALSE;
	}

	/* Otherwise, we're ok */
	DbgPrint("==================proxyDbgkForwardException end with OK================== \n");
	return TRUE;
}

//NTSTATUS
//NTAPI
//DbgkpPostFakeThreadMessages_2(IN PEPROCESS_S Process,
//IN PDEBUG_OBJECT DebugObject,
//IN PETHREAD StartThread,
//OUT PETHREAD *FirstThread,
//OUT PETHREAD *LastThread)
//{
//	PETHREAD_S pFirstThread = NULL, ThisThread, OldThread = NULL, pLastThread;
//	NTSTATUS Status = STATUS_UNSUCCESSFUL;
//	BOOLEAN IsFirstThread;
//	ULONG Flags;
//	DBGKM_MSG ApiMessage;
//	PDBGKM_CREATE_THREAD CreateThread = &ApiMessage.CreateThread;
//	PDBGKM_CREATE_PROCESS CreateProcess = &ApiMessage.CreateProcess;
//	BOOLEAN First;
//	PIMAGE_NT_HEADERS NtHeader;
//	PAGED_CODE();
//
//
//
//	if (StartThread)
//	{
//
//		IsFirstThread = FALSE;
//		pFirstThread = StartThread;
//		ThisThread = StartThread;
//
//
//		ObReferenceObject(StartThread);
//	}
//	else
//	{
//
//		ThisThread = PsGetNextProcessThread(Process, NULL);
//		IsFirstThread = TRUE;
//	}
//
//
//	do
//	{
//
//		if (OldThread) ObDereferenceObject(OldThread);
//
//
//		pLastThread = ThisThread;
//		ObReferenceObject(ThisThread);
//		if (ExAcquireRundownProtection(&ThisThread->RundownProtect))
//		{
//
//			Flags = DEBUG_EVENT_RELEASE | DEBUG_EVENT_NOWAIT;
//
//
//			if (!ThisThread->SystemThread)
//			{
//
//				if (NT_SUCCESS(PsSuspendThread(ThisThread, NULL)))
//				{
//
//					Flags |= DEBUG_EVENT_SUSPEND;
//				}
//			}
//		}
//		else
//		{
//
//			Flags = DEBUG_EVENT_PROTECT_FAILED | DEBUG_EVENT_NOWAIT;
//		}
//
//
//		RtlZeroMemory(&ApiMessage, sizeof(ApiMessage));
//
//
//		if ((IsFirstThread) &&
//			!(Flags & DEBUG_EVENT_PROTECT_FAILED) &&
//			!(ThisThread->SystemThread))
//		{
//
//			First = TRUE;
//		}
//		else
//		{
//
//			First = FALSE;
//		}
//
//
//		if (First)
//		{
//
//			ApiMessage.ApiNumber = DbgKmCreateProcessApi;
//
//
//			if (Process->SectionObject)
//			{
//
//				CreateProcess->FileHandle =
//					DbgkpSectionToFileHandle(Process->SectionObject);
//			}
//			else
//			{
//
//				CreateProcess->FileHandle = NULL;
//			}
//
//
//			CreateProcess->BaseOfImage = Process->SectionBaseAddress;
//
//
//			NtHeader = RtlImageNtHeader(Process->SectionBaseAddress);
//			if (NtHeader)
//			{
//
//				CreateProcess->DebugInfoFileOffset = NtHeader->FileHeader.
//					PointerToSymbolTable;
//				CreateProcess->DebugInfoSize = NtHeader->FileHeader.
//					NumberOfSymbols;
//			}
//		}
//		else
//		{
//
//			ApiMessage.ApiNumber = DbgKmCreateThreadApi;
//			CreateThread->StartAddress = ThisThread->StartAddress;
//		}
//
//
//
//		Status = DbgkpQueueMessage_2(Process,
//			ThisThread,
//			&ApiMessage,
//			Flags,
//			DebugObject);
//		if (!NT_SUCCESS(Status))
//		{
//
//			if (Flags & DEBUG_EVENT_SUSPEND) PsResumeThread(ThisThread, NULL);
//
//
//			if (Flags & DEBUG_EVENT_RELEASE)
//			{
//
//				ExReleaseRundownProtection(&ThisThread->RundownProtect);
//			}
//
//
//			if ((ApiMessage.ApiNumber == DbgKmCreateProcessApi) &&
//				(CreateProcess->FileHandle))
//			{
//
//				ObCloseHandle(CreateProcess->FileHandle, KernelMode);
//			}
//
//
//			ObDereferenceObject(ThisThread);
//			break;
//		}
//
//
//		if (First)
//		{
//
//			IsFirstThread = FALSE;
//
//
//			ObReferenceObject(ThisThread);
//			pFirstThread = ThisThread;
//		}
//
//
//		ThisThread = PsGetNextProcessThread(Process, ThisThread);
//		OldThread = pLastThread;
//	} while (ThisThread);
//
//
//	if (!NT_SUCCESS(Status))
//	{
//
//		if (pFirstThread) ObDereferenceObject(pFirstThread);
//		if (pLastThread) ObDereferenceObject(pLastThread);
//		return Status;
//	}
//
//
//	if (!pFirstThread) return STATUS_UNSUCCESSFUL;
//
//
//	*FirstThread = pFirstThread;
//	*LastThread = pLastThread;
//	return Status;
//}
//NTSTATUS
//NTAPI
//DbgkpPostFakeModuleMessages(IN PEPROCESS_S Process,
//IN PETHREAD Thread,
//IN PDEBUG_OBJECT DebugObject)
//{
//	PPEB Peb = Process->Peb;
//	PPEB_LDR_DATA LdrData;
//	PLDR_DATA_TABLE_ENTRY LdrEntry;
//	PLIST_ENTRY ListHead, NextEntry;
//	DBGKM_MSG ApiMessage;
//	PDBGKM_LOAD_DLL LoadDll = &ApiMessage.LoadDll;
//	ULONG i;
//	PIMAGE_NT_HEADERS NtHeader;
//	UNICODE_STRING ModuleName;
//	OBJECT_ATTRIBUTES ObjectAttributes;
//	IO_STATUS_BLOCK IoStatusBlock;
//	NTSTATUS Status;
//	PAGED_CODE();
//
//
//
//	if (!Peb) return STATUS_SUCCESS;
//
//
//	LdrData = Peb->Ldr;
//	ListHead = &LdrData->InLoadOrderModuleList;
//	NextEntry = ListHead->Flink;
//
//	i = 0;
//	while ((NextEntry != ListHead) && (i < 500))
//	{
//
//		if (!i)
//		{
//
//			NextEntry = NextEntry->Flink;
//			i++;
//			continue;
//		}
//
//
//		LdrEntry = CONTAINING_RECORD(NextEntry,
//			LDR_DATA_TABLE_ENTRY,
//			InLoadOrderLinks);
//
//
//		RtlZeroMemory(&ApiMessage, sizeof(DBGKM_MSG));
//		ApiMessage.ApiNumber = DbgKmLoadDllApi;
//
//
//		LoadDll->BaseOfDll = LdrEntry->DllBase;
//		LoadDll->NamePointer = NULL;
//
//		NtHeader = RtlImageNtHeader(LoadDll->BaseOfDll);
//		if (NtHeader)
//		{
//
//			LoadDll->DebugInfoFileOffset = NtHeader->FileHeader.
//				PointerToSymbolTable;
//			LoadDll->DebugInfoSize = NtHeader->FileHeader.NumberOfSymbols;
//		}
//
//
//
//		Status = MmGetFileNameForAddress(NtHeader, &ModuleName);
//		if (NT_SUCCESS(Status))
//		{
//
//			InitializeObjectAttributes(&ObjectAttributes,
//				&ModuleName,
//				OBJ_FORCE_ACCESS_CHECK |
//				OBJ_KERNEL_HANDLE |
//				OBJ_CASE_INSENSITIVE,
//				NULL,
//				NULL);
//
//
//			Status = ZwOpenFile(&LoadDll->FileHandle,
//				GENERIC_READ | SYNCHRONIZE,
//				&ObjectAttributes,
//				&IoStatusBlock,
//				FILE_SHARE_READ |
//				FILE_SHARE_WRITE |
//				FILE_SHARE_DELETE,
//				FILE_SYNCHRONOUS_IO_NONALERT);
//			if (!NT_SUCCESS(Status)) LoadDll->FileHandle = NULL;
//
//
//			ExFreePool(ModuleName.Buffer);
//		}
//
//
//
//		if (DebugObject == NULL
//			)
//		{
//
//			DbgkpSendApiMessage_2(&ApiMessage, 0x3);
//		}
//
//		else{
//			Status = DbgkpQueueMessage_2(Process,
//				Thread,
//				&ApiMessage,
//				DEBUG_EVENT_NOWAIT,
//				DebugObject);
//
//		}
//		if (!NT_SUCCESS(Status))
//		{
//
//			if (LoadDll->FileHandle) ObCloseHandle(LoadDll->FileHandle,
//				KernelMode);
//		}
//
//
//		NextEntry = NextEntry->Flink;
//		i++;
//	}
//
//
//	return STATUS_SUCCESS;
//}


/*
PVOID PsQuerySystemDllInfo(
	ULONG index)
{
	PVOID64	DllInfo;

	DllInfo = (PVOID64)PspSystemDlls[index];
	if (DllInfo != NULL &&
		*(PVOID*)((char*)DllInfo + 0x28) != 0)
	{
		return (PVOID)((ULONG64)DllInfo + 0x10);
	}

	return NULL;
}
*/

VOID proxyDbgkSendSystemDllMessages_1(
	PETHREAD_S	Thread,
	PDEBUG_OBJECT	DebugObject,
	PDBGKM_MSG	ApiMsg
)
{
	NTSTATUS	status;

	HANDLE		FileHandle;

	ULONG		index;
	PTEB64		Teb;
	PEPROCESS_S	Process;
	PETHREAD_S	CurrentThread;
	PMODULE_INFO	DllInfo;
	BOOLEAN		bSource;
	KAPC_STATE ApcState;
	PIMAGE_NT_HEADERS NtHeaders;

	IO_STATUS_BLOCK	IoStackBlock;
	OBJECT_ATTRIBUTES	ObjectAttr;

	if (Thread)
	{
		Process = Thread->Tcb.Process;
	}
	else {
		Process = PsGetCurrentProcess();
	}

	CurrentThread = (PETHREAD)PsGetCurrentThread();
	index = 0;
	do
	{
		if (index >= 2)
		{
			break;
		}
		DllInfo = (PMODULE_INFO)PsQuerySystemDllInfo(index);
		if (DllInfo != NULL)
		{
			ApiMsg->LoadDll.DebugInfoFileOffset = 0;
			ApiMsg->LoadDll.DebugInfoSize = 0;
			ApiMsg->LoadDll.FileHandle = NULL;

			Teb = NULL;

			ApiMsg->LoadDll.BaseOfDll = DllInfo->BaseOfDll;

			if (Thread && index != 0)
			{
				bSource = TRUE;
				KeStackAttachProcess((PEPROCESS)Process, &ApcState);
			}
			else {
				bSource = FALSE;
			}

			NtHeaders = RtlImageNtHeader(DllInfo->BaseOfDll);
			if (NtHeaders != NULL)
			{
				ApiMsg->LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
				ApiMsg->LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
			}

			if (Thread == 0)
			{
				if (!IS_SYSTEM_THREAD(CurrentThread) &&
					CurrentThread->Tcb.ApcStateIndex != 1)
				{
					Teb = (PTEB64)CurrentThread->Tcb.Teb;
				}

				if (Teb)
				{
					RtlStringCbCopyW(Teb->StaticUnicodeBuffer, 261 * sizeof(wchar_t), DllInfo->Buffer);
					Teb->NtTib.ArbitraryUserPointer = Teb->StaticUnicodeBuffer;
					ApiMsg->LoadDll.NamePointer = (PVOID)&Teb->NtTib.ArbitraryUserPointer;
				}
			}

			if (bSource == TRUE)
			{
				KeUnstackDetachProcess(&ApcState);
			}

			InitializeObjectAttributes(
				&ObjectAttr,
				&DllInfo->FileName,
				OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
				NULL,
				NULL);

			status = ZwOpenFile(
				&FileHandle,
				GENERIC_READ | SYNCHRONIZE,
				&ObjectAttr,
				&IoStackBlock,
				FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
				FILE_SYNCHRONOUS_IO_NONALERT);
			if (!NT_SUCCESS(status))
			{
				FileHandle = NULL;
			}


			ApiMsg->h.u1.Length = sizeof(DBGKM_MSG) << 16 |
				(8 + sizeof(DBGKM_LOAD_DLL));
			ApiMsg->h.u2.ZeroInit = 0;
			ApiMsg->h.u2.s2.Type = LPC_DEBUG_EVENT;
			ApiMsg->ApiNumber = DbgKmLoadDllApi;


			if (Thread == NULL)
			{
				DbgPrint("proxyDbgkSendSystemDllMessages_1:DbgkpSendApiMessage_2\n");
				DbgkpSendApiMessage_2(ApiMsg, 0x3);
				if (FileHandle != NULL)
				{
					ObCloseHandle(FileHandle, KernelMode);
				}
				if (Teb != NULL)
				{
					Teb->NtTib.ArbitraryUserPointer = NULL;

				}
			}
			else {
				status = DbgkpQueueMessage_2(
					Process,
					Thread,
					ApiMsg,
					DEBUG_EVENT_NOWAIT,
					DebugObject);
				if (!NT_SUCCESS(status))
				{
					if (FileHandle != NULL)
					{
						ObCloseHandle(FileHandle, KernelMode);
					}
				}
			}
		}
		index++;
	} while (TRUE);
}

VOID proxyDbgkSendSystemDllMessages(
	PETHREAD_S		Thread,
	PDEBUG_OBJECT	DebugObject,
	PDBGKM_MSG	ApiMsg
)
{
	NTSTATUS	status;
	HANDLE		FileHandle;
	ULONG		index;
	PTEB64		Teb;
	PEPROCESS_S	Process;
	PETHREAD_S	CurrentThread;
	PMODULE_INFO	DllInfo;
	BOOLEAN		bSource;
	KAPC_STATE ApcState;
	PIMAGE_NT_HEADERS NtHeaders;

	IO_STATUS_BLOCK	IoStackBlock;
	OBJECT_ATTRIBUTES	ObjectAttr;

	if (Thread)
	{
		Process = (PEPROCESS_S)Thread->Tcb.Process;
	}
	else {
		Process = (PEPROCESS_S)PsGetCurrentProcess();
	}
	CurrentThread = (PETHREAD_S)PsGetCurrentThread();
	index = 0;
	do
	{
		if (index >= 1)
		{
			break;
		}
		DllInfo = (PMODULE_INFO)PsQuerySystemDllInfo(index);
		if (DllInfo != NULL)
		{
			if (index == 1 && Process->WoW64Process == 0)
			{
				break;
			}

			//ApiMsg->LoadDll;
			Teb = NULL;

			ApiMsg->LoadDll.BaseOfDll = DllInfo->BaseOfDll;
			DbgPrint("ApiMsg->LoadDll.BaseOfDll:%p\n", ApiMsg->LoadDll.BaseOfDll);
			if (Thread && index != 0)
			{
				bSource = TRUE;
				KeStackAttachProcess((PRKPROCESS)Process, &ApcState);
				NtHeaders = RtlImageNtHeader(DllInfo->BaseOfDll);
				DbgPrint("NtHeaders:%p\n", NtHeaders);
				if (NtHeaders != NULL)
				{
					ApiMsg->LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
					ApiMsg->LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
				}
			}
			else
			{
				bSource = FALSE;
			}

			if (Thread == 0)
			{

				if (CurrentThread->Tcb.SystemThread != TRUE &&
					CurrentThread->Tcb.ApcStateIndex != 1)
				{
					Teb = (PTEB64)CurrentThread->Tcb.Teb;
				}

				if (Teb)
				{
					RtlStringCbCopyW(Teb->StaticUnicodeBuffer, 261 * sizeof(wchar_t), DllInfo->Buffer);
					Teb->NtTib.ArbitraryUserPointer = Teb->StaticUnicodeBuffer;
					ApiMsg->LoadDll.NamePointer = (PVOID)&Teb->NtTib.ArbitraryUserPointer;
				}
			}

			if (bSource == TRUE)
			{
				KeUnstackDetachProcess(&ApcState);
			}

			InitializeObjectAttributes(
				&ObjectAttr,
				&DllInfo->FileName,
				OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
				NULL,
				NULL);

			status = ZwOpenFile(
				&FileHandle,
				GENERIC_READ | SYNCHRONIZE,
				&ObjectAttr,
				&IoStackBlock,
				FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
				FILE_SYNCHRONOUS_IO_NONALERT);
			if (!NT_SUCCESS(status))
			{
				FileHandle = NULL;
			}
			ApiMsg->h.u1.Length = 0x500028;
			ApiMsg->h.u2.ZeroInit = 8;
			ApiMsg->ApiNumber = DbgKmLoadDllApi;
			if (Thread == NULL)
			{
				DbgPrint("proxyDbgkSendSystemDllMessages:DbgkpSendApiMessage_2\n");
				DbgkpSendApiMessage_2(ApiMsg, 0x3);
				if (FileHandle != NULL)
				{
					ObCloseHandle(FileHandle, KernelMode);
				}
				if (Teb != NULL)
				{
					Teb->NtTib.ArbitraryUserPointer = NULL;

				}
			}
			else {
				status = DbgkpQueueMessage_2(
					Process,
					Thread,
					ApiMsg,
					0x2,
					DebugObject);
				if (!NT_SUCCESS(status))
				{
					if (FileHandle != NULL)
					{
						ObCloseHandle(FileHandle, KernelMode);
					}
				}
			}
		}
		index++;
	} while (TRUE);
}

typedef BOOLEAN(*__stdcall pfExAcquireRundownProtection_0)(PEX_RUNDOWN_REF RunRef);
pfExAcquireRundownProtection_0 ExAcquireRundownProtection_0;

NTSTATUS DbgkpPostFakeThreadMessages_2(
	PEPROCESS_S	Process,
	PDEBUG_OBJECT	DebugObject,
	PETHREAD	StartThread,
	PETHREAD* pFirstThread,
	PETHREAD* pLastThread
)
{
	NTSTATUS status;
	PETHREAD_S Thread, FirstThread, LastThread, CurrentThread;
	DBGKM_MSG ApiMsg;	//上面分析的一个未知的结构体，应该就是DBGKM_APIMSG类型的结构
	BOOLEAN First = TRUE;
	BOOLEAN IsFirstThread;
	PIMAGE_NT_HEADERS NtHeaders;
	ULONG Flags;
	KAPC_STATE ApcState;

	status = STATUS_UNSUCCESSFUL;

	LastThread = FirstThread = NULL;

	CurrentThread = KeGetCurrentThread();

	if (StartThread == 0)
	{
		StartThread = PsGetNextProcessThread(Process, NULL);
		First = TRUE;
	}
	else {
		First = FALSE;
		FirstThread = StartThread;
		ObfReferenceObject(StartThread);
	}

	for (Thread = StartThread;
		Thread != NULL;
		Thread = PsGetNextProcessThread(Process, Thread))
	{
		Flags = DEBUG_EVENT_NOWAIT;

		if (LastThread != 0)
		{
			ObfDereferenceObject(LastThread);
		}

		LastThread = Thread;
		ObfReferenceObject(Thread);

		if (ExAcquireRundownProtection(&Thread->RundownProtect))
		{
			if (Thread->ThreadInserted == 0)
			{
				continue;
			}

			Flags |= DEBUG_EVENT_RELEASE;
			if (!IS_SYSTEM_THREAD(Thread))
			{
				status = PsSuspendThread((PETHREAD)Thread, 0);
				if (NT_SUCCESS(status))
				{
					Flags |= DEBUG_EVENT_SUSPEND;
				}
			}
		}
		else {
			Flags |= DEBUG_EVENT_PROTECT_FAILED;
		}

		//每次构造一个DBGKM_APIMSG结构
		memset(&ApiMsg, 0, sizeof(DBGKM_MSG));
		if (First && ((Flags & DEBUG_EVENT_PROTECT_FAILED) == 0))
		{
			//进程的第一个线程才会到这里
			IsFirstThread = TRUE;
			ApiMsg.ApiNumber = DbgKmCreateProcessApi;
			if (Process->SectionObject)
			{
				//DbgkpSectionToFileHandle函数是返回一个模块的句柄
				ApiMsg.CreateProcess.FileHandle = DbgkpSectionToFileHandle(Process->SectionObject);
			}
			else {
				ApiMsg.CreateProcess.FileHandle = NULL;
			}
			ApiMsg.CreateProcess.BaseOfImage = Process->SectionBaseAddress;
			ApiMsg.CreateProcess.InitialThread.StartAddress = Thread->StartAddress;

			KeStackAttachProcess(Process, &ApcState);

			__try {				
				NtHeaders = RtlImageNtHeader(Process->Peb->ImageBaseAddress);
				if (NtHeaders)
				{
					ApiMsg.CreateProcess.BaseOfImage = NtHeaders->OptionalHeader.ImageBase;
					ApiMsg.CreateProcess.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
					ApiMsg.CreateProcess.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
				}
			}except(EXCEPTION_EXECUTE_HANDLER) {
				ApiMsg.CreateProcess.InitialThread.StartAddress = NULL;
				ApiMsg.CreateProcess.DebugInfoFileOffset = 0;
				ApiMsg.CreateProcess.DebugInfoSize = 0;
			}
			KeUnstackDetachProcess(&ApcState);
		}
		else {
			IsFirstThread = FALSE;
			ApiMsg.ApiNumber = DbgKmCreateThreadApi;
			ApiMsg.CreateThread.StartAddress = Thread->StartAddress;
		}

		status = DbgkpQueueMessage_2(
			Process,
			Thread,
			&ApiMsg,
			Flags,
			DebugObject);

		if (!NT_SUCCESS(status))
		{
			if (Flags & DEBUG_EVENT_SUSPEND)
			{
				PsResumeThread(Thread, NULL);
			}

			if (Flags & DEBUG_EVENT_RELEASE)
			{
				ExReleaseRundownProtection(&Thread->RundownProtect);
			}

			if (ApiMsg.ApiNumber == DbgKmCreateProcessApi && ApiMsg.CreateProcess.FileHandle != NULL)
			{
				ObCloseHandle(ApiMsg.CreateProcess.FileHandle, KernelMode);
			}

			ObfDereferenceObject(Thread);
			break;

		}
		else if (IsFirstThread) {
			First = FALSE;
			ObfReferenceObject(Thread);
			FirstThread = Thread;
			proxyDbgkSendSystemDllMessages(Thread, DebugObject, &ApiMsg);
		}
	}

	if (!NT_SUCCESS(status)) {
		if (FirstThread)
		{
			ObfDereferenceObject(FirstThread);
		}
		if (LastThread != NULL)
		{
			ObfDereferenceObject(LastThread);
		}
	}
	else {
		if (FirstThread) {
			*pFirstThread = FirstThread;
			*pLastThread = LastThread;
		}
		else {

			if (LastThread != NULL)
			{
				ObfDereferenceObject(LastThread);
			}
			status = STATUS_UNSUCCESSFUL;
		}
	}
	return status;
}

typedef  UINT64  _QWORD;
typedef  UINT32  _DWORD;

__int64 DbgkpSetProcessDebugObject_asm(ULONG_PTR BugCheckParameter1, PRKEVENT Event, int a3, ...)
{
	struct _KTHREAD* v3; // r13
	int v4; // edi
	void* v7; // rbx
	__int64 v8; // r14
	struct _KEVENT* v9; // r14
	__int64 v10; // rbx
	int v11; // eax
	__int64 v12; // r13
	__int64 v13; // rcx
	_QWORD* v14; // rax
	struct _KEVENT** v15 = 0; // rax
	_QWORD* v16; // rax
	int v17; // eax
	PVOID v18; // rcx
	__int64 v19; // rax
	PVOID Object; // [rsp+30h] [rbp-30h] BYREF
	struct _KTHREAD* v22; // [rsp+38h] [rbp-28h]
	PKGUARDED_MUTEX Mutex; // [rsp+40h] [rbp-20h]
	PVOID P; // [rsp+48h] [rbp-18h] BYREF
	PVOID* v25; // [rsp+50h] [rbp-10h]
	char v26; // [rsp+A8h] [rbp+48h]
	char v27; // [rsp+B0h] [rbp+50h]
	void* v28; // [rsp+B8h] [rbp+58h] BYREF
	va_list va; // [rsp+B8h] [rbp+58h]
	va_list va1; // [rsp+C0h] [rbp+60h] BYREF

	va_start(va1, a3);
	va_start(va, a3);
	v28 = va_arg(va1, void*);
	v3 = KeGetCurrentThread();
	Object = 0i64;
	v25 = &P;
	P = &P;
	v4 = a3;
	v22 = v3;
	v26 = 1;
	v27 = 0;
	if (a3 >= 0)
	{
		v7 = v28;
		v4 = 0;
	}
	else
	{
		v7 = 0i64;
		v28 = 0i64;
	}
	if (v4 >= 0)
	{
		ExAcquireFastMutex(&DbgkpProcessDebugPortMutex);
		while (1)
		{
			if (*(_QWORD*)(BugCheckParameter1 + 1400))
			{
				v4 = -1073741752;
				v27 = 1;
				goto LABEL_11;
			}
			*(_QWORD*)(BugCheckParameter1 + 1400) = Event;
			ObfReferenceObjectWithTag(v7, 0x4F676244u);
			v27 = 1;
			v8 = PsGetNextProcessThread(BugCheckParameter1, v7);
			if (!v8)
				goto LABEL_11;
			*(_QWORD*)(BugCheckParameter1 + 1400) = 0i64;
			KeReleaseGuardedMutex(&DbgkpProcessDebugPortMutex);
			v27 = 0;
			ObfDereferenceObjectWithTag(v7, 0x4F676244u);
			DbgPrint("asm DbgkpPostFakeThreadMessages\n");
			v4 = DbgkpPostFakeThreadMessages(BugCheckParameter1, Event, v8, &Object, (void**)va);
			if (v4 < 0)
				break;
			ObfDereferenceObjectWithTag(Object, 0x4F676244u);
			ExAcquireFastMutex(&DbgkpProcessDebugPortMutex);
			v7 = v28;
		}
		v7 = 0i64;
		v28 = 0i64;
	}
LABEL_11:
	Mutex = (PKGUARDED_MUTEX)&Event[1];
	ExAcquireFastMutex((PFAST_MUTEX)&Event[1]);
	if (v4 >= 0)
	{
		if ((Event[4].Header.LockNV & 1) != 0)
		{
			*(_QWORD*)(BugCheckParameter1 + 1400) = 0i64;
			v4 = -1073740972;
		}
		else
		{
			_InterlockedOr((volatile signed __int32*)(BugCheckParameter1 + 1124), 3u);
			ObfReferenceObject(Event);
			v7 = v28;
		}
	}
	v9 = (struct _KEVENT*)Event[3].Header.WaitListHead.Flink;
	if (v9 == (struct _KEVENT*)&Event[3].Header.WaitListHead)
		goto LABEL_37;
	do
	{
		v10 = (__int64)v9;
		v9 = *(struct _KEVENT**)&v9->Header.Lock;
		v11 = *(_DWORD*)(v10 + 76);
		if ((v11 & 4) == 0 || *(struct _KTHREAD**)(v10 + 80) != v3)
			continue;
		v12 = *(_QWORD*)(v10 + 64);
		if (v4 < 0)
		{
			if (v9->Header.WaitListHead.Flink != (LIST_ENTRY*)v10
				|| (v15 = *(struct _KEVENT***)(v10 + 8), *v15 != (struct _KEVENT*)v10))
			{
			LABEL_45:
				__fastfail(3u);
			}
			*v15 = v9;
			v9->Header.WaitListHead.Flink = (LIST_ENTRY*)v15;
			goto LABEL_30;
		}
		if ((v11 & 0x10) != 0)
		{
			_InterlockedOr((volatile signed __int32*)(v12 + 1296), 0x80u);
			v13 = *(_QWORD*)v10;
			if (*(_QWORD*)(*(_QWORD*)v10 + 8i64) != v10)
				goto LABEL_45;
			v14 = *(_QWORD**)(v10 + 8);
			if (*v14 != v10)
				goto LABEL_45;
			*v14 = v13;
			*(_QWORD*)(v13 + 8) = v14;
		LABEL_30:
			v16 = v25;
			if (*v25 != &P)
				goto LABEL_45;
			*(_QWORD*)v10 = &P;
			*(_QWORD*)(v10 + 8) = v16;
			*v16 = v10;
			v25 = (PVOID*)v10;
			goto LABEL_32;
		}
		if (v26)
		{
			*(_DWORD*)(v10 + 76) = v11 & 0xFFFFFFFB;
			KeSetEvent(Event, 0, 0);
			v26 = 0;
		}
		*(_QWORD*)(v10 + 80) = 0i64;
		_InterlockedOr((volatile signed __int32*)(v12 + 1296), 0x40u);
	LABEL_32:
		v17 = *(_DWORD*)(v10 + 76);
		if ((v17 & 8) != 0)
		{
			*(_DWORD*)(v10 + 76) = v17 & 0xFFFFFFF7;
			ExReleaseRundownProtection((PEX_RUNDOWN_REF)(v12 + 1272));
		}
		v3 = v22;
	} while (v9 != (struct _KEVENT*)&Event[3].Header.WaitListHead);
	v7 = v28;
LABEL_37:
	KeReleaseGuardedMutex(Mutex);
	if (v27)
		KeReleaseGuardedMutex(&DbgkpProcessDebugPortMutex);
	if (v7)
		ObfDereferenceObjectWithTag(v7, 0x4F676244u);
	while (1)
	{
		v18 = P;
		if (P == &P)
			break;
		if (*((PVOID**)P + 1) != &P)
			goto LABEL_45;
		v19 = *(_QWORD*)P;
		if (*(PVOID*)(*(_QWORD*)P + 8i64) != P)
			goto LABEL_45;
		P = *(PVOID*)P;
		*(_QWORD*)(v19 + 8) = &P;
		DbgkpWakeTarget(v18);
	}
	if (v4 >= 0)
		originalDbgkpMarkProcessPeb(BugCheckParameter1);
	return (unsigned int)v4;
}



NTSTATUS __fastcall
DbgkpSetProcessDebugObject_2(//反汇编OK
	IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT DebugObject,
	IN NTSTATUS MsgStatus,
	IN PETHREAD LastThread
)
{
	DbgPrint("================================DbgkpSetProcessDebugObject_2============================================\n");
	PEPROCESS ps;
	NTSTATUS status1 = PsLookupProcessByProcessId(PsGetCurrentProcessId(), &ps);
	if (NT_SUCCESS(status1))
	{
		UCHAR* Name = PsGetProcessImageFileName(ps);
		DbgPrint("DbgkpSetProcessDebugObject_2:currentProcess:%s\n", Name);
		ObDereferenceObject(ps);
		Name = PsGetProcessImageFileName(Process);
		DbgPrint("DbgkpSetProcessDebugObject_2:targetProcess:%s\n", Name);
	}
	DbgPrint("DbgkpSetProcessDebugObject_2:DebugObject:%p \n", DebugObject);

	NTSTATUS Status;
	PETHREAD ThisThread;
	LIST_ENTRY TempList;
	PLIST_ENTRY Entry;
	PDEBUG_EVENT DebugEvent;
	BOOLEAN First;
	PETHREAD_S Thread;
	BOOLEAN GlobalHeld;
	PETHREAD FirstThread;

	PAGED_CODE();

	ThisThread = PsGetCurrentThread();

	InitializeListHead(&TempList);

	First = TRUE;
	GlobalHeld = FALSE;

	if (!NT_SUCCESS(MsgStatus))
	{
		DbgPrint("DbgkpSetProcessDebugObject_2:MsgStatus:%p \n", MsgStatus);
		LastThread = NULL;
		Status = MsgStatus;
	}
	else
	{
		Status = STATUS_SUCCESS;
	}

	if (NT_SUCCESS(Status))
	{
		while (1)
		{
			GlobalHeld = TRUE;
			ExAcquireFastMutex(&DbgkFastMutex);
			/*if (Process->Pcb.newdbgport!= NULL)
			 {
				 Status = STATUS_PORT_ALREADY_SET;
				 break;
			 }*/
			if (Port_IsPort(Process))
			{
				DbgPrint("DbgkpSetProcessDebugObject_2:STATUS_PORT_ALREADY_SET \n");
				Status = STATUS_PORT_ALREADY_SET;
				break;
			}
			if (Port_SetPort(Process, DebugObject))
			{
				DbgPrint("DbgkpSetProcessDebugObject_2:Port_SetPort ok: Process:%p DebugObject:%p \n", Process, DebugObject);
				//Process->DebugPort = DebugObject;
				//g_pdebugObj = DebugObject;
			}
			//	Port_FindProcessList:FFFFE00C904D3080


			//DbgkpSetProcessDebugObject_2:Port_GetPort:Process:FFFFE00C904D3080 DebugObject : FFFFE00C8C834B20

			if (Port_GetPort(Process))
			{
				DbgPrint("DbgkpSetProcessDebugObject_2:Port_GetPort:Process:%p DebugObject:%p \n", Process, Port_GetPort(Process));
			}

			//Process->Pcb.newdbgport = DebugObject;
			//DbgPrint("DbgkpSetProcessDebugObject_2:Process->DebugPort:%p\n", Process->DebugPort);
			DbgPrint("DbgkpSetProcessDebugObject_2:LastThread:%p \n", LastThread);
			ObReferenceObject(LastThread);
			Thread = PsGetNextProcessThread(Process, LastThread);
			if (Thread != NULL)
			{
				//Process->DebugPort = NULL; /*------ DebugPort -----------*/
				//Process->Pcb.newdbgport = NULL;
				//DbgPrint("DbgkpSetProcessDebugObject_2:Port_RemoveDbgItem Process:%p \n", Process); 
				//Port_RemoveDbgItem(Process, NULL);
				KeReleaseGuardedMutex(&DbgkFastMutex);
				GlobalHeld = FALSE;
				ObDereferenceObject(LastThread);
				Status = DbgkpPostFakeThreadMessages_2(
					Process,
					DebugObject,
					Thread,
					&FirstThread,
					&LastThread);
				if (!NT_SUCCESS(Status))
				{
					LastThread = NULL;
					break;
				}
				ObDereferenceObject(FirstThread);
				//ExAcquireFastMutex(&DbgkFastMutex);
			}
			else
			{
				DbgPrint("DbgkpSetProcessDebugObject_2:break \n");
				break;
			}
		}
	}

	ExAcquireFastMutex(&DebugObject->Mutex);
	if (NT_SUCCESS(Status))
	{
		if ((DebugObject->Flags & DEBUG_OBJECT_DELETE_PENDING) == 0) {
			PspSetProcessFlag(&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT | PS_PROCESS_FLAGS_CREATE_REPORTED);
			ObReferenceObject(DebugObject);//Process->NoDebugInherit 为1就表示有调试了。
		}
		else
		{
			//	Process->Pcb.newdbgport = NULL; /*------ DebugPort -----------*/
			DbgPrint("DbgkpSetProcessDebugObject_2:Port_RemoveDbgItem STATUS_DEBUGGER_INACTIVE \n");
			Port_RemoveDbgItem(Process, NULL);
			Status = STATUS_DEBUGGER_INACTIVE;
		}
	}

	for (Entry = DebugObject->EventList.Flink;
		Entry != &DebugObject->EventList;
		)
	{
		DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);
		Entry = Entry->Flink;

		if ((DebugEvent->Flags & DEBUG_EVENT_INACTIVE) != 0 && DebugEvent->BackoutThread == ThisThread) {
			Thread = DebugEvent->Thread;

			if (NT_SUCCESS(Status) && !IS_SYSTEM_THREAD(Thread))
			{
				if ((DebugEvent->Flags & DEBUG_EVENT_PROTECT_FAILED) != 0) {
					PspSetProcessFlag(&Thread->CrossThreadFlags,
						PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG);
					RemoveEntryList(&DebugEvent->EventList);
					InsertTailList(&TempList, &DebugEvent->EventList);
				}
				else {

					if (First) {
						DebugEvent->Flags &= ~DEBUG_EVENT_INACTIVE;
						KeSetEvent(&DebugObject->EventsPresent, 0, FALSE);
						First = FALSE;
					}

					DebugEvent->BackoutThread = NULL;
					PspSetProcessFlag(&Thread->CrossThreadFlags,
						PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG);

				}
			}
			else
			{
				DbgPrint("DbgkpSetProcessDebugObject_2:RemoveEntryList:%p \n", &DebugEvent->EventList);
				RemoveEntryList(&DebugEvent->EventList);
				InsertTailList(&TempList, &DebugEvent->EventList);
			}

			if (DebugEvent->Flags & DEBUG_EVENT_RELEASE) {
				DebugEvent->Flags &= ~DEBUG_EVENT_RELEASE;
				ExReleaseRundownProtection(&Thread->RundownProtect);
			}

		}
	}

	KeReleaseGuardedMutex(&DebugObject->Mutex);

	if (GlobalHeld) {
		KeReleaseGuardedMutex(&DbgkFastMutex);
	}

	if (LastThread != NULL) {
		ObDereferenceObject(LastThread);
	}

	while (!IsListEmpty(&TempList)) {
		Entry = RemoveHeadList(&TempList);
		DebugEvent = CONTAINING_RECORD(Entry, DEBUG_EVENT, EventList);
		DbgkpWakeTarget(DebugEvent);
	}

	if (NT_SUCCESS(Status)) {
		//originalDbgkpMarkProcessPeb(Process);
		MarkDbgProcess();
	}

	return STATUS_SUCCESS;
}

NTSTATUS DbgkpPostFakeProcessCreateMessages_2(
	IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT DebugObject,
	IN PETHREAD* pLastThread
)
{
	NTSTATUS	status;
	KAPC_STATE	ApcState;
	PETHREAD	StartThread, Thread;
	PETHREAD	LastThread;

	//收集所有线程创建的消息
	StartThread = 0;
	status = DbgkpPostFakeThreadMessages_2(
		Process,
		DebugObject,
		NULL,
		&Thread,
		&LastThread);
	if (NT_SUCCESS(status))
	{
		DbgPrint("DbgkpPostFakeProcessCreateMessages_2:DbgkpPostFakeThreadMessages_2 ok DbgkpPostModuleMessages \n");
		KeStackAttachProcess(Process, &ApcState);
		//收集模块创建的消息
		DbgkpPostModuleMessages(Process, Thread, DebugObject);
		KeUnstackDetachProcess(&ApcState);
		ObfDereferenceObject(Thread);
	}
	else {
		LastThread = 0;
		DbgPrint("DbgkpPostFakeProcessCreateMessages_2:DbgkpPostFakeThreadMessages_2 failed \n");
	}
	*pLastThread = LastThread;

	return	status;
}

VOID
NTAPI
DbgkpConvertKernelToUserStateChange(IN PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
	IN PDEBUG_EVENT DebugEvent)
{
	WaitStateChange->AppClientId = DebugEvent->ClientId;

	switch (DebugEvent->ApiMsg.ApiNumber)
	{
	case DbgKmCreateProcessApi:
	{
		DbgPrint("DbgKmCreateProcessApi\n");
		//WaitStateChange->StateInfo.CreateThread.NewThread.StartAddress =
		//	DebugEvent->ApiMsg.u.CreateThread.StartAddress;
		//WaitStateChange->StateInfo.CreateThread.NewThread.SubSystemKey =
		//	DebugEvent->ApiMsg.u.CreateThread.SubSystemKey;

		WaitStateChange->NewState = DbgCreateProcessStateChange;
		WaitStateChange->StateInfo.CreateProcessInfo.NewProcess =
			DebugEvent->ApiMsg.u.CreateProcessInfo;

		DbgPrint("DebugEvent->ApiMsg.u.CreateProcessInfo.BaseOfImage:%p \n", DebugEvent->ApiMsg.u.CreateProcessInfo.BaseOfImage);
		DbgPrint("DebugEvent->ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress:%p \n", DebugEvent->ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress);


		WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess = DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle;

		DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
		break;
	}

	case DbgKmCreateThreadApi:
	{
		DbgPrint("DbgKmCreateThreadApi\n");
		WaitStateChange->NewState = DbgCreateThreadStateChange;

		WaitStateChange->StateInfo.CreateThread.NewThread.StartAddress =
			DebugEvent->ApiMsg.u.CreateThread.StartAddress;
		WaitStateChange->StateInfo.CreateThread.NewThread.SubSystemKey =
			DebugEvent->ApiMsg.u.CreateThread.SubSystemKey;
		break;
	}

	case DbgKmExceptionApi:
	{
		DbgPrint("DbgKmExceptionApi\n");
		if ((NTSTATUS)DebugEvent->ApiMsg.u.Exception.ExceptionRecord.ExceptionCode ==
			STATUS_BREAKPOINT)
		{
			WaitStateChange->NewState = DbgBreakpointStateChange;
		}
		else if ((NTSTATUS)DebugEvent->ApiMsg.u.Exception.ExceptionRecord.ExceptionCode ==
			STATUS_SINGLE_STEP)
		{
			WaitStateChange->NewState = DbgSingleStepStateChange;
		}
		else
		{
			WaitStateChange->NewState = DbgExceptionStateChange;
		}

		WaitStateChange->StateInfo.Exception.ExceptionRecord =
			DebugEvent->ApiMsg.u.Exception.ExceptionRecord;

		WaitStateChange->StateInfo.Exception.FirstChance =
			DebugEvent->ApiMsg.u.Exception.FirstChance;
		break;
	}

	case DbgKmExitProcessApi:
	{
		DbgPrint("DbgKmExitProcessApi\n");
		WaitStateChange->NewState = DbgExitProcessStateChange;
		WaitStateChange->StateInfo.ExitProcess.ExitStatus =
			DebugEvent->ApiMsg.u.ExitProcess.ExitStatus;
		break;
	}

	case DbgKmExitThreadApi:
	{
		DbgPrint("DbgKmExitThreadApi\n");
		WaitStateChange->NewState = DbgExitThreadStateChange;
		WaitStateChange->StateInfo.ExitThread.ExitStatus =
			DebugEvent->ApiMsg.u.ExitThread.ExitStatus;
		break;
	}

	case DbgKmLoadDllApi:
	{
		DbgPrint("DbgKmLoadDllApi\n");
		WaitStateChange->NewState = DbgLoadDllStateChange;
		WaitStateChange->StateInfo.LoadDll = DebugEvent->ApiMsg.u.LoadDll;
		if (DebugEvent->ApiMsg.u.LoadDll.NamePointer)
		{
			DbgPrint("WaitStateChange->StateInfo.LoadDll.NamePointer:%s \n", WaitStateChange->StateInfo.LoadDll.NamePointer);
		}

		DebugEvent->ApiMsg.u.LoadDll.FileHandle = NULL;
		break;
	}

	case DbgKmUnloadDllApi:
	{
		DbgPrint("DbgKmUnloadDllApi\n");
		WaitStateChange->NewState = DbgUnloadDllStateChange;
		WaitStateChange->StateInfo.UnloadDll.BaseAddress =
			DebugEvent->ApiMsg.u.UnloadDll.BaseAddress;
		break;
	}

	default:

		ASSERT(FALSE);
	}
}

VOID
NTAPI
DbgkpOpenHandles(IN PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
	IN PEPROCESS Process,
	IN PETHREAD Thread)
{
	NTSTATUS Status;
	HANDLE Handle;
	PHANDLE DupHandle;
	PAGED_CODE();

	switch (WaitStateChange->NewState)
	{
	case DbgCreateThreadStateChange:
	{
		Status = ObOpenObjectByPointer(Thread,
			0,
			NULL,
			THREAD_ALL_ACCESS,
			*PsThreadType,
			KernelMode,
			&Handle);
		if (NT_SUCCESS(Status))
		{
			WaitStateChange->
				StateInfo.CreateThread.HandleToThread = Handle;
		}
		return;
	}

	case DbgCreateProcessStateChange:
	{
		Status = ObOpenObjectByPointer(Thread,
			0,
			NULL,
			THREAD_ALL_ACCESS,
			*PsThreadType,
			KernelMode,
			&Handle);
		if (NT_SUCCESS(Status))
		{

			WaitStateChange->
				StateInfo.CreateProcessInfo.HandleToThread = Handle;
		}

		Status = ObOpenObjectByPointer(Process,
			0,
			NULL,
			PROCESS_ALL_ACCESS,
			*PsProcessType,
			KernelMode,
			&Handle);
		if (NT_SUCCESS(Status))
		{
			WaitStateChange->
				StateInfo.CreateProcessInfo.HandleToProcess = Handle;
		}

		DupHandle = &WaitStateChange->
			StateInfo.CreateProcessInfo.NewProcess.FileHandle;
		break;
	}

	case DbgLoadDllStateChange:
	{
		DupHandle = &WaitStateChange->StateInfo.LoadDll.FileHandle;
		break;
	}

	default:
		return;
	}


	Handle = *DupHandle;
	if (Handle)
	{

		Status = ObDuplicateObject(PsGetCurrentProcess(),
			Handle,
			PsGetCurrentProcess(),
			DupHandle,
			0,
			0,
			DUPLICATE_SAME_ACCESS,
			KernelMode);
		if (!NT_SUCCESS(Status)) *DupHandle = NULL;


		ObCloseHandle(Handle, KernelMode);
	}
}



NTSTATUS
NTAPI
DbgkClearProcessDebugObject(IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT SourceDebugObject OPTIONAL)
{
	PDEBUG_OBJECT DebugObject = NULL;
	PDEBUG_EVENT DebugEvent;
	LIST_ENTRY TempList;
	PLIST_ENTRY NextEntry;
	PAGED_CODE();

	DbgPrint("=====================DbgkClearProcessDebugObject====================\n");

	ExAcquireFastMutex(&DbgkFastMutex);


	//DebugObject = Process->Pcb.newdbgport;

	DebugObject = Port_GetPort(Process);
	if ((DebugObject) &&
		((DebugObject == SourceDebugObject) ||
			(SourceDebugObject == NULL)))
	{

		//	Process->Pcb.newdbgport = NULL;
		Port_RemoveDbgItem(Process, NULL);
		ExReleaseFastMutex(&DbgkFastMutex);
		originalDbgkpMarkProcessPeb(Process);
		DbgPrint("DbgkClearProcessDebugObject:Port_RemoveDbgItem \n");
	}
	else
	{
		ExReleaseFastMutex(&DbgkFastMutex);
		DbgPrint("DbgkClearProcessDebugObject:STATUS_PORT_NOT_SET \n");
		return STATUS_PORT_NOT_SET;
	}

	InitializeListHead(&TempList);


	ExAcquireFastMutex(&DebugObject->Mutex);

	NextEntry = DebugObject->EventList.Flink;
	while (NextEntry != &DebugObject->EventList)
	{

		DebugEvent = CONTAINING_RECORD(NextEntry, DEBUG_EVENT, EventList);
		NextEntry = NextEntry->Flink;


		if (DebugEvent->Process == Process)
		{

			RemoveEntryList(&DebugEvent->EventList);
			InsertTailList(&TempList, &DebugEvent->EventList);
		}
	}


	ExReleaseFastMutex(&DebugObject->Mutex);


	ObDereferenceObject(DebugObject);

	while (!IsListEmpty(&TempList))
	{

		NextEntry = RemoveHeadList(&TempList);
		DebugEvent = CONTAINING_RECORD(NextEntry, DEBUG_EVENT, EventList);


		DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
		DbgkpWakeTarget(DebugEvent);
	}


	return STATUS_SUCCESS;
}


#define MK_FP( seg,ofs )( (void _seg * )( seg ) +( void near * )( ofs ))





typedef NTSTATUS(*OriginalNtWaitForDebugEvent)(
	IN HANDLE DebugObjectHandle,
	IN BOOLEAN Alertable,
	IN PLARGE_INTEGER Timeout OPTIONAL,
	OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange
	);
OriginalNtWaitForDebugEvent originalNtWaitForDebugEvent;

FORCEINLINE PKTRAP_FRAME PspGetThreadTrapFrame(PETHREAD_S Thread)
{
#define KERNEL_STACK_CONTROL_LENGTH sizeof(KERNEL_STACK_CONTROL)  
#define KTRAP_FRAME_LENGTH sizeof(KTRAP_FRAME)  

	ULONG64 InitialStack;
	PKERNEL_STACK_CONTROL StackControl;
	__try {
		InitialStack = (ULONG64)Thread->Tcb.InitialStack;
		StackControl = (PKERNEL_STACK_CONTROL)InitialStack;
		if (StackControl == NULL)
		{
			DbgPrint("StackControl Thread:%p Is NULL!", Thread);
			return NULL;
		}
		if (MmIsAddressValid(&StackControl->Previous.StackBase) == FALSE)
		{
			return NULL;
		}
		while (StackControl->Previous.StackBase != 0)
		{
			InitialStack = StackControl->Previous.InitialStack;
			StackControl = (PKERNEL_STACK_CONTROL)InitialStack;
		}

	}except(EXCEPTION_EXECUTE_HANDLER) {
		return NULL;

	}



	return (PKTRAP_FRAME)(InitialStack - KTRAP_FRAME_LENGTH);
}
NTSTATUS AddAllThreadContextToList(PEPROCESS_S Process) {
	PETHREAD CurrentThread = KeGetCurrentThread();

	PKTRAP_FRAME pframe = NULL;
	PETHREAD_S Thread = NULL;

	THREAD_dr_List t = { 0 };
	PPROCESS_List PList = NULL;
	if (Process != NULL)
	{
		PList = Dr_AddProcessToList(Process);
	}
	else
	{
		return FALSE;
	}

	Thread = PsGetNextProcessThread(Process, NULL);
	DbgPrint("Process : %p\n", Process);
	while (Thread != NULL) {
		DbgPrint("Thread : %p\n", Thread);

		if (Thread != NULL) {
			if (ExAcquireRundownProtection(&Thread->RundownProtect))
			{
				pframe = PspGetThreadTrapFrame(Thread);

				//Thread->Tcb.TrapFrame;

				DbgPrint("Thread Frame: %p\n", pframe);

				if (MmIsAddressValid(pframe) == TRUE)
				{
					/*t.Dr0 = ((PLARGE_INTEGER)(pframe->Dr0))->LowPart;
					t.Dr1 = HIDWORD(pframe->Dr1);
					t.Dr2 = HIDWORD(pframe->Dr2);
					t.Dr3 = HIDWORD(pframe->Dr3);
					t.Dr6 = HIDWORD(pframe->Dr6);
					t.Dr7 = HIDWORD(pframe->Dr7);*/
					t.Dr0 = ((PLARGE_INTEGER)(&pframe->Dr0))->LowPart;
					t.Dr1 = ((PLARGE_INTEGER)(&pframe->Dr1))->LowPart;
					t.Dr2 = ((PLARGE_INTEGER)(&pframe->Dr2))->LowPart;
					t.Dr3 = ((PLARGE_INTEGER)(&pframe->Dr3))->LowPart;
					t.Dr6 = ((PLARGE_INTEGER)(&pframe->Dr6))->LowPart;
					t.Dr7 = ((PLARGE_INTEGER)(&pframe->Dr7))->LowPart;
					t.eflag = pframe->EFlags;
					//	pframe->EFlags |= 0x100;;

					//Clear Thread Context
					pframe->Dr0 = 0;
					pframe->Dr1 = 0;
					pframe->Dr2 = 0;
					pframe->Dr3 = 0;
					pframe->Dr6 = 0;
					pframe->Dr7 = 0;

					t.Thread = Thread;
					Dr_AddThreadStructToList(PList, &t);
					DbgPrint("thread: %p dr0: %d dr1 :%d dr2 :%d dr3 :%d dr6:%d dr7:%d\n", Thread, t.Dr0, t.Dr1, t.Dr2, t.Dr3, t.Dr6, t.Dr7);
				}
				else {
					/////////FIXME
				}

				ExReleaseRundownProtection(&Thread->RundownProtect);
			}
		}

		Thread = PsGetNextProcessThread(Process, Thread);
	}

	return STATUS_SUCCESS;
}

VOID GetCloseDbgtoolMsg(
	IN HANDLE hParentId,
	IN HANDLE hProcessId,
	IN BOOLEAN bCreate)
{
	p_save_handlentry Padd = NULL;
	if (!bCreate) {

		Padd = querylist(PmainList, hProcessId, NULL);
		if (Padd != NULL) {

			deletelist(Padd);//删除节点
		}

	}

}
VOID RemoveDbgtoolMsg(BOOLEAN  isload) {
	if (isload)
	{
		PsSetCreateProcessNotifyRoutine(GetCloseDbgtoolMsg, FALSE);

	}
	else
	{
		PsSetCreateProcessNotifyRoutine(GetCloseDbgtoolMsg, TRUE);

	}

}
VOID
MsgCreateUnThreadMsg(
	_In_ HANDLE ProcessId,
	_In_ HANDLE ThreadId,
	_In_ BOOLEAN Create
) {

	PEPROCESS_S Process = NULL;
	PETHREAD_S Thread = NULL;
	NTSTATUS st, st2 = NULL;

	if (PsGetCurrentProcess() != PsInitialSystemProcess)
	{
		st = PsLookupProcessByProcessId(ProcessId, &Process);


		if (NT_SUCCESS(st)) { ObDereferenceObject(Process); }
		else {
			return;
		}
		st2 = PsLookupThreadByThreadId(ThreadId, &Thread);
		if (NT_SUCCESS(st2)) { ObDereferenceObject(Thread); }
		else
		{
			return;
		}

		if (Create)
		{
			if (Port_IsPort(Process))
			{



				DBGKM_MSG ApiMessage = { 0 };
				PDBGKM_CREATE_THREAD CreateThreadArgs = &ApiMessage.CreateThread;


				ApiMessage.h.u1.Length = sizeof(DBGKM_MSG) << 16 |
					(8 + sizeof(DBGKM_CREATE_THREAD));
				ApiMessage.h.u2.ZeroInit = 0;
				ApiMessage.h.u2.s2.Type = LPC_DEBUG_EVENT;
				ApiMessage.ApiNumber = DbgKmCreateThreadApi;

				CreateThreadArgs->StartAddress = Thread->Win32StartAddress;
				CreateThreadArgs->SubSystemKey = 0;
				DbgPrint("MsgCreateUnThreadMsg:DbgkpSendApiMessage_2\n");
				DbgkpSendApiMessage_2(&ApiMessage, FALSE);
			}



		}
	}





}
VOID SetDbgMsgNotify(BOOLEAN IsLoad) {
	if (IsLoad)
	{
		PsSetCreateThreadNotifyRoutine(MsgCreateUnThreadMsg);

	}
	else {
		PsRemoveCreateThreadNotifyRoutine(MsgCreateUnThreadMsg);

	}


}

PETHREAD
PsGetNextProcessThread_wrk(
	IN PEPROCESS Process,
	IN PETHREAD_S Thread
)
/*++

Routine Description:

	This function is used to enumerate the threads in a process.


Arguments:

	Process - Process to enumerate
	Thread  - Thread to start enumeration from. This must have been obtained from previous call to
			  PsGetNextProcessThread. If NULL enumeration starts at the first non-terminating thread in the process.

Return Value:

	PETHREAD - Pointer to a non-terminated process thread or a NULL if there are non. This thread must be passed
			   either to another call to PsGetNextProcessThread or PsQuitNextProcessThread.

--*/
{
	PLIST_ENTRY ListEntry;
	PETHREAD NewThread, CurrentThread;

	PAGED_CODE();

	CurrentThread = PsGetCurrentThread();

	//PspLockProcessShared(Process, CurrentThread);

	for (ListEntry = (Thread == NULL) ? Process->ThreadListHead.Flink : Thread->ThreadListEntry.Flink;
		;
		ListEntry = ListEntry->Flink) {
		if (ListEntry != &Process->ThreadListHead) {
			NewThread = CONTAINING_RECORD(ListEntry, ETHREAD_S, ThreadListEntry);
			//
			// Don't reference a thread thats in its delete routine
			//
			if (ObReferenceObject(NewThread)) {
				break;
			}
		}
		else {
			NewThread = NULL;
			break;
		}
	}
	//PspUnlockProcessShared(Process, CurrentThread);

	if (Thread != NULL) {
		ObDereferenceObject(Thread);
	}
	return NewThread;
}

typedef USHORT _WORD;

//NTSTATUS __fastcall NtDebugActiveProcess(IN HANDLE ProcessHandle, IN HANDLE DebugHandle)
//{
//	char previousMode; // bp
//	NTSTATUS result; // eax
//	__int64 v5; // rcx
//	struct _KTHREAD_S* currentThread; // rax
//	struct _EX_RUNDOWN_REF* v7; // rdi
//	KPROCESS* v8; // rsi
//	NTSTATUS status; // ebx
//	unsigned __int64 v10; // rax
//	__int16 v11; // cx
//	unsigned __int64 v12; // rax
//	__int16 v13; // cx
//	BOOLEAN v14; // al
//	struct _KEVENT* v15; // rsi
//	PEPROCESS_S process; // [rsp+80h] [rbp+18h] BYREF
//	PDEBUG_OBJECT Object; // [rsp+88h] [rbp+20h] BYREF
//	PETHREAD lastThread;
//
//	process = 0i64;
//	previousMode = ((PKTHREAD_S)KeGetCurrentThread())->PreviousMode;
//	result = ObReferenceObjectByHandleWithTag(ProcessHandle, 0x800u, (POBJECT_TYPE)*PsProcessType, previousMode, 0x4F676244u, &process, 0i64);
//	if (result >= 0)
//	{
//		currentThread = KeGetCurrentThread();
//		v7 = (struct _EX_RUNDOWN_REF*)process;
//		v8 = currentThread->ApcState.Process;
//		if (process == v8 || process == PsInitialSystemProcess)
//		{
//			status = -1073741790;
//		}
//		else
//		{
//			LOBYTE(v5) = previousMode;
//			if ((unsigned __int8)PsTestProtectedProcessIncompatibility(v5, currentThread->ApcState.Process, process))
//			{
//				status = -1073740014;
//			}
//			else if ((v7[124].Count & 1) == 0 || (status = PsRequestDebugSecureProcess(v7), status >= 0))
//			{
//				v10 = v8[1].AffinityPadding[10];
//				if (!v10
//					|| (v11 = *(_WORD*)(v10 + 8), v11 != 332) && v11 != 452
//					|| (v12 = v7[176].Count) != 0 && ((v13 = *(_WORD*)(v12 + 8), v13 == 332) || v13 == 452))
//				{
//					Object = 0i64;
//					status = ObReferenceObjectByHandle(DebugHandle, 2u, DbgkDebugObjectType, previousMode, &Object, 0i64);
//					if (status >= 0)
//					{
//						v14 = ExAcquireRundownProtection_0(v7 + 139);
//						v15 = (struct _KEVENT*)Object;
//						if (v14)
//						{
//							result = DbgkpPostFakeProcessCreateMessages((ULONG_PTR)v7, Object, lastThread);
//							status = DbgkpSetProcessDebugObject((ULONG_PTR)v7, v15, result, 0i64);
//							ExReleaseRundownProtection(v7 + 139);
//						}
//						else
//						{
//							status = -1073741558;
//						}
//						HalPutDmaAdapter((PADAPTER_OBJECT)v15);
//					}
//				}
//				else
//				{
//					status = -1073741637;
//				}
//			}
//		}
//		ObfDereferenceObjectWithTag(v7, 0x4F676244u);
//		result = status;
//	}
//	return result;
//}


ULONG64 fc_DbgkGetAdrress(PUNICODE_STRING64 funcstr) {
	UNICODE_STRING64 usFuncName;
	RtlInitUnicodeString(&usFuncName, funcstr);
	return MmGetSystemRoutineAddress(&usFuncName);

}

```

`HyperHideDrv/dbgk1to2.h`:

```h
#include <ntifs.h>
#include "KernelDbgStruct.h"

EXTERN_C
BOOLEAN
__fastcall
proxyDbgkForwardException(IN PEXCEPTION_RECORD ExceptionRecord,
	IN BOOLEAN DebugPort,
	IN BOOLEAN SecondChance);

EXTERN_C
VOID
proxyDbgkCopyProcessDebugPort(
	IN PEPROCESS_S TargetProcess,
	IN PEPROCESS_S SourceProcess
	, IN ULONG64 unknow, IN ULONG64 unknow1
);

EXTERN_C
NTSTATUS
__fastcall
proxyDbgkOpenProcessDebugPort(IN PEPROCESS_S Process,
	IN KPROCESSOR_MODE PreviousMode,
	OUT HANDLE* DebugHandle);

EXTERN_C
NTSTATUS __fastcall
DbgkpSetProcessDebugObject_2(//럽삠긍OK
	IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT DebugObject,
	IN NTSTATUS MsgStatus,
	IN PETHREAD LastThread
);

typedef
NTSTATUS 
(*OriginalDbgkpSetProcessDebugObject)(//럽삠긍OK
	IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT DebugObject,
	IN NTSTATUS MsgStatus,
	IN PETHREAD LastThread
	); OriginalDbgkpSetProcessDebugObject originalDbgkpSetProcessDebugObject;

EXTERN_C
NTSTATUS __fastcall
DbgkpQueueMessage_2(
	IN PEPROCESS_S Process,
	IN PETHREAD_S Thread,
	IN OUT PDBGKM_APIMSG ApiMsg,
	IN ULONG Flags,
	IN PDEBUG_OBJECT TargetDebugObject
);

EXTERN_C
NTSTATUS __fastcall proxyNtCreateDebugObject(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags
);


EXTERN_C
NTSTATUS DbgkpPostFakeThreadMessages_2(

	PEPROCESS_S	Process,
	PDEBUG_OBJECT	DebugObject,
	PETHREAD	StartThread,
	PETHREAD* pFirstThread,
	PETHREAD* pLastThread
);
typedef
NTSTATUS(*OriginalDbgkpPostFakeThreadMessages)(

	PEPROCESS_S	Process,
	PDEBUG_OBJECT	DebugObject,
	PETHREAD	StartThread,
	PETHREAD* pFirstThread,
	PETHREAD* pLastThread
	);
OriginalDbgkpPostFakeThreadMessages originalDbgkpPostFakeThreadMessages;

EXTERN_C
VOID
__fastcall
proxyDbgkUnMapViewOfSection(IN PEPROCESS_S PROCESS, IN PVOID BaseAddress);

EXTERN_C
NTSTATUS
NTAPI
proxyNtDebugContinue(IN HANDLE DebugHandle,
	IN PCLIENT_ID AppClientId,
	IN NTSTATUS ContinueStatus);


EXTERN_C
NTSTATUS
NTAPI
proxyNtRemoveProcessDebug(IN HANDLE ProcessHandle,
	IN HANDLE DebugHandle);

EXTERN_C
VOID
__fastcall
proxyDbgkpDeleteObject(IN PVOID DebugObject);

EXTERN_C
VOID __fastcall
proxyDbgkpCloseObject(
	IN PEPROCESS_S Process,
	IN PVOID Object,
	IN ACCESS_MASK GrantedAccess,
	IN ULONG_PTR ProcessHandleCount,
	IN ULONG_PTR SystemHandleCount
);

EXTERN_C
VOID
__fastcall
proxyDbgkMapViewOfSection(IN PVOID Processs,
	IN PVOID Section,
	IN ULONG64 BaseAddress
);

EXTERN_C
VOID
__fastcall
proxyDbgkExitProcess(IN NTSTATUS ExitStatus);

EXTERN_C
VOID
__fastcall
proxyDbgkExitThread(IN NTSTATUS ExitStatus);

EXTERN_C
VOID __fastcall
proxyPspExitThread(
	IN NTSTATUS ExitStatus
);

typedef
VOID
(*pfPspExitThread)(
	IN NTSTATUS ExitStatus
	); 
EXTERN_C pfPspExitThread originalproxyPspExitThread;


typedef
NTSTATUS
(__fastcall* DbgkpPostFakeThreadMessagesx)(IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT DebugObject,
	IN PETHREAD StartThread,
	OUT PETHREAD* FirstThread,
	OUT PETHREAD* LastThread);
EXTERN_C  DbgkpPostFakeThreadMessagesx DbgkpPostFakeThreadMessages;

typedef NTSTATUS(__fastcall* pfDbgkpPostFakeProcessCreateMessages)(
	IN PEPROCESS_S Process,
	IN PDEBUG_OBJECT DebugObject,
	IN PETHREAD* pLastThread
	); EXTERN_C  pfDbgkpPostFakeProcessCreateMessages DbgkpPostFakeProcessCreateMessages;


typedef NTSTATUS(__fastcall*
	pfDbgkpSetProcessDebugObject)(
		IN PEPROCESS_S Process,
		IN PDEBUG_OBJECT DebugObject,
		IN NTSTATUS MsgStatus,
		IN PETHREAD LastThread); EXTERN_C  pfDbgkpSetProcessDebugObject DbgkpSetProcessDebugObject;

typedef INT64(__fastcall* pfnPsSynchronizeWithThreadInsertion)(__int64 a1, __int64 a2);
EXTERN_C  pfnPsSynchronizeWithThreadInsertion PsSynchronizeWithThreadInsertion;

typedef NTSTATUS(__fastcall* DbgkpPostModuleMessagesx)(PEPROCESS_S process, PKTHREAD THREAD, PDEBUG_OBJECT debug);
EXTERN_C  DbgkpPostModuleMessagesx DbgkpPostModuleMessages;

typedef void (__fastcall* pfDbgkSendSystemDllMessages)(PETHREAD pethread, PDEBUG_OBJECT pdebugobj, PDBGKM_MSG pdbgMsg);
EXTERN_C  pfDbgkSendSystemDllMessages DbgkSendSystemDllMessages;

typedef PETHREAD(__fastcall* PsGetNextProcessThreadx)(PEPROCESS_S process, PETHREAD THREAD);
//typedef PETHREAD(__fastcall* PsGetNextProcessThreadx)(PEPROCESS_wrk process, PKTHREAD THREAD);
EXTERN_C  PsGetNextProcessThreadx PsGetNextProcessThread;

typedef PVOID(__fastcall* pfPsQuerySystemDllInfo)(int index);
EXTERN_C  pfPsQuerySystemDllInfo PsQuerySystemDllInfo;

typedef BOOLEAN(__stdcall* pfExAcquireRundownProtection_0)(PEX_RUNDOWN_REF RunRef);
EXTERN_C  pfExAcquireRundownProtection_0 ExAcquireRundownProtection_0;

typedef NTSTATUS(__fastcall* PsSuspendThreadx)(IN PETHREAD_S Thread, OUT PULONG PreviousSuspendCount OPTIONAL);
EXTERN_C  PsSuspendThreadx PsSuspendThread;

typedef NTSTATUS(__fastcall* PsResumeThreadx)(IN PETHREAD Thread, OUT PULONG PreviousSuspendCount OPTIONAL);
EXTERN_C  PsResumeThreadx PsResumeThread;

typedef __int64(__fastcall* pfPsThawProcess)(PEPROCESS process, __int64 a2);
EXTERN_C  pfPsThawProcess PsThawProcess;

typedef char (__fastcall* pfPsFreezeProcess)(PEPROCESS process, char a2);
EXTERN_C  pfPsFreezeProcess PsFreezeProcess;

typedef NTSTATUS(__fastcall* MmGetFileNameForSectionx)(IN PVOID Thread, OUT POBJECT_NAME_INFORMATION* FileName OPTIONAL);
EXTERN_C  MmGetFileNameForSectionx MmGetFileNameForSection;

typedef BOOLEAN(__fastcall* pfPsTestProtectedProcessIncompatibility)(__int64 a1, __int64 a2, __int64 a3);
EXTERN_C  pfPsTestProtectedProcessIncompatibility PsTestProtectedProcessIncompatibility;

typedef __int64(__fastcall* pfPsRequestDebugSecureProcess)(__int64 a1, unsigned __int8 a2);
EXTERN_C  pfPsRequestDebugSecureProcess PsRequestDebugSecureProcess;

typedef NTSTATUS(__fastcall* pfLpcRequestWaitReplyPortEx)(PVOID64 port, PPORT_MESSAGE Message, PPORT_MESSAGE Buffer);
EXTERN_C  pfLpcRequestWaitReplyPortEx LpcRequestWaitReplyPortEx;

typedef char(__fastcall* pfDbgkpSuspendProcess)(PEPROCESS_S ps);
EXTERN_C  pfDbgkpSuspendProcess DbgkpSuspendProcess;

typedef void (*OriginalproxyDbgkExitProcess)(IN NTSTATUS ExitStatus);
EXTERN_C  OriginalproxyDbgkExitProcess originalproxyDbgkExitProcess;


typedef NTSTATUS
(*ObDuplicateObject1)(
	IN PEPROCESS_S SourceProcess,
	IN HANDLE SourceHandle,
	IN PEPROCESS_S TargetProcess OPTIONAL,
	OUT PHANDLE TargetHandle OPTIONAL,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	IN ULONG Options,
	IN KPROCESSOR_MODE PreviousMode
	);
EXTERN_C  ObDuplicateObject1 ObDuplicateObject;

typedef
VOID
(__fastcall*
	PfDbgkpFreeDebugEvent)(IN PDEBUG_EVENT DebugEvent);


typedef NTSTATUS(__stdcall* OBCREATEOBJECT)(
	__in KPROCESSOR_MODE ProbeMode,
	__in POBJECT_TYPE ObjectType,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in KPROCESSOR_MODE OwnershipMode,
	__inout_opt PVOID ParseContext,
	__in ULONG ObjectBodySize,
	__in ULONG PagedPoolCharge,
	__in ULONG NonPagedPoolCharge,
	__out PVOID* Object
	);

typedef
LONG(__fastcall* pfDbgkpWakeTarget)(PVOID P);
EXTERN_C  pfDbgkpWakeTarget DbgkpWakeTarget_2;

typedef VOID(*pfnDbgkpMarkProcessPeb)(PEPROCESS_S Process);
EXTERN_C  pfnDbgkpMarkProcessPeb originalDbgkpMarkProcessPeb;

EXTERN_C __int64 DbgkpSetProcessDebugObject_asm(ULONG_PTR BugCheckParameter1, PRKEVENT Event, int a3, ...);

EXTERN_C int  initDbgk();



```

`HyperHideDrv/dbgtool.h`:

```h

typedef struct _save_handlentry{
	struct _save_handlentry*head;
	HANDLE dbgProcessId;
	PEPROCESS dbgProcessStruct;

	struct _save_handlentry*next;

}_save_handlentry, *p_save_handlentry;

p_save_handlentry createlist();
p_save_handlentry insertlist(HANDLE dbgProcessId,
	PEPROCESS dbgProcessStruct, p_save_handlentry phead);
p_save_handlentry querylist(p_save_handlentry phead, HANDLE dbgProcessId, PEPROCESS dbgProcessStruct);
void deletelist(p_save_handlentry pclid);

```

`HyperHideDrv/myEthread.h`:

```h
#pragma once
#include <ntifs.h>

typedef struct _RTL_AVL_TREE
{
	/* 0x0000 */ struct _RTL_BALANCED_NODE* Root;
} RTL_AVL_TREE, * PRTL_AVL_TREE; /* size: 0x0008 */
typedef struct _MMSUPPORT_FLAGS                 // 15 elements, 0x4 bytes (sizeof)
{
	struct                                      // 6 elements, 0x1 bytes (sizeof)
	{
		/*0x000*/         UINT8        WorkingSetType : 3;        // 0 BitPosition
		/*0x000*/         UINT8        ModwriterAttached : 1;     // 3 BitPosition
		/*0x000*/         UINT8        TrimHard : 1;              // 4 BitPosition
		/*0x000*/         UINT8        MaximumWorkingSetHard : 1; // 5 BitPosition
		/*0x000*/         UINT8        ForceTrim : 1;             // 6 BitPosition
		/*0x000*/         UINT8        MinimumWorkingSetHard : 1; // 7 BitPosition
	};
	struct                                      // 4 elements, 0x1 bytes (sizeof)
	{
		/*0x001*/         UINT8        SessionMaster : 1;         // 0 BitPosition
		/*0x001*/         UINT8        TrimmerState : 2;          // 1 BitPosition
		/*0x001*/         UINT8        Reserved : 1;              // 3 BitPosition
		/*0x001*/         UINT8        PageStealers : 4;          // 4 BitPosition
	};
	/*0x002*/     UINT8        MemoryPriority : 8;            // 0 BitPosition
	struct                                      // 4 elements, 0x1 bytes (sizeof)
	{
		/*0x003*/         UINT8        WsleDeleted : 1;           // 0 BitPosition
		/*0x003*/         UINT8        VmExiting : 1;             // 1 BitPosition
		/*0x003*/         UINT8        ExpansionFailed : 1;       // 2 BitPosition
		/*0x003*/         UINT8        Available : 5;             // 3 BitPosition
	};
}MMSUPPORT_FLAGS, * PMMSUPPORT_FLAGS;
typedef struct _MMSUPPORT_INSTANCE
{
	/* 0x0000 */ unsigned long NextPageColor;
	/* 0x0004 */ unsigned long PageFaultCount;
	/* 0x0008 */ unsigned __int64 TrimmedPageCount;
	/* 0x0010 */ struct _MMWSL_INSTANCE* VmWorkingSetList;
	/* 0x0018 */ struct _LIST_ENTRY WorkingSetExpansionLinks;
	/* 0x0028 */ unsigned __int64 AgeDistribution[8];
	/* 0x0068 */ struct _KGATE* ExitOutswapGate;
	/* 0x0070 */ unsigned __int64 MinimumWorkingSetSize;
	/* 0x0078 */ unsigned __int64 WorkingSetLeafSize;
	/* 0x0080 */ unsigned __int64 WorkingSetLeafPrivateSize;
	/* 0x0088 */ unsigned __int64 WorkingSetSize;
	/* 0x0090 */ unsigned __int64 WorkingSetPrivateSize;
	/* 0x0098 */ unsigned __int64 MaximumWorkingSetSize;
	/* 0x00a0 */ unsigned __int64 PeakWorkingSetSize;
	/* 0x00a8 */ unsigned long HardFaultCount;
	/* 0x00ac */ unsigned short LastTrimStamp;
	/* 0x00ae */ unsigned short PartitionId;
	/* 0x00b0 */ unsigned __int64 SelfmapLock;
	/* 0x00b8 */ struct _MMSUPPORT_FLAGS Flags;
	/* 0x00bc */ long __PADDING__[1];
} MMSUPPORT_INSTANCE, * PMMSUPPORT_INSTANCE; /* size: 0x00c0 */
typedef struct _MMSUPPORT_SHARED
{
	/* 0x0000 */ volatile long WorkingSetLock;
	/* 0x0004 */ long GoodCitizenWaiting;
	/* 0x0008 */ unsigned __int64 ReleasedCommitDebt;
	/* 0x0010 */ unsigned __int64 ResetPagesRepurposedCount;
	/* 0x0018 */ void* WsSwapSupport;
	/* 0x0020 */ void* CommitReleaseContext;
	/* 0x0028 */ void* AccessLog;
	/* 0x0030 */ volatile unsigned __int64 ChargedWslePages;
	/* 0x0038 */ unsigned __int64 ActualWslePages;
	/* 0x0040 */ unsigned __int64 WorkingSetCoreLock;
	/* 0x0048 */ void* ShadowMapping;
	/* 0x0050 */ long __PADDING__[12];
} MMSUPPORT_SHARED, * PMMSUPPORT_SHARED; /* size: 0x0080 */
typedef struct _MMSUPPORT_FULL
{
	/* 0x0000 */ struct _MMSUPPORT_INSTANCE Instance;
	/* 0x00c0 */ struct _MMSUPPORT_SHARED Shared;
} MMSUPPORT_FULL, * PMMSUPPORT_FULL; /* size: 0x0140 */
typedef struct _PS_PROTECTION
{
	union
	{
		/* 0x0000 */ unsigned char Level;
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned char Type : 3; /* bit position: 0 */
			/* 0x0000 */ unsigned char Audit : 1; /* bit position: 3 */
			/* 0x0000 */ unsigned char Signer : 4; /* bit position: 4 */
		}; /* bitfield */
	}; /* size: 0x0001 */
} PS_PROTECTION, * PPS_PROTECTION; /* size: 0x0001 */
typedef union _PS_INTERLOCKED_TIMER_DELAY_VALUES
{
	union
	{
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned __int64 DelayMs : 30; /* bit position: 0 */
			/* 0x0000 */ unsigned __int64 CoalescingWindowMs : 30; /* bit position: 30 */
			/* 0x0000 */ unsigned __int64 Reserved : 1; /* bit position: 60 */
			/* 0x0000 */ unsigned __int64 NewTimerWheel : 1; /* bit position: 61 */
			/* 0x0000 */ unsigned __int64 Retry : 1; /* bit position: 62 */
			/* 0x0000 */ unsigned __int64 Locked : 1; /* bit position: 63 */
		}; /* bitfield */
		/* 0x0000 */ unsigned __int64 All;
	}; /* size: 0x0008 */
} PS_INTERLOCKED_TIMER_DELAY_VALUES, * PPS_INTERLOCKED_TIMER_DELAY_VALUES; /* size: 0x0008 */
typedef struct _JOBOBJECT_WAKE_FILTER
{
	/* 0x0000 */ unsigned long HighEdgeFilter;
	/* 0x0004 */ unsigned long LowEdgeFilter;
} JOBOBJECT_WAKE_FILTER, * PJOBOBJECT_WAKE_FILTER; /* size: 0x0008 */
typedef struct _PS_PROCESS_WAKE_INFORMATION
{
	/* 0x0000 */ unsigned __int64 NotificationChannel;
	/* 0x0008 */ unsigned long WakeCounters[7];
	/* 0x0024 */ struct _JOBOBJECT_WAKE_FILTER WakeFilter;
	/* 0x002c */ unsigned long NoWakeCounter;
} PS_PROCESS_WAKE_INFORMATION, * PPS_PROCESS_WAKE_INFORMATION; /* size: 0x0030 */
typedef struct _EX_PUSH_LOCK
{
	union
	{
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned __int64 Locked : 1; /* bit position: 0 */
			/* 0x0000 */ unsigned __int64 Waiting : 1; /* bit position: 1 */
			/* 0x0000 */ unsigned __int64 Waking : 1; /* bit position: 2 */
			/* 0x0000 */ unsigned __int64 MultipleShared : 1; /* bit position: 3 */
			/* 0x0000 */ unsigned __int64 Shared : 60; /* bit position: 4 */
		}; /* bitfield */
		/* 0x0000 */ unsigned __int64 Value;
		/* 0x0000 */ void* Ptr;
	}; /* size: 0x0008 */
} EX_PUSH_LOCK, * PEX_PUSH_LOCK; /* size: 0x0008 */
typedef struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES
{
	/* 0x0000 */ struct _RTL_AVL_TREE Tree;
	/* 0x0008 */ struct _EX_PUSH_LOCK Lock;
} PS_DYNAMIC_ENFORCED_ADDRESS_RANGES, * PPS_DYNAMIC_ENFORCED_ADDRESS_RANGES; /* size: 0x0010 */

typedef struct _KAFFINITY_EX
{
	/* 0x0000 */ unsigned short Count;
	/* 0x0002 */ unsigned short Size;
	/* 0x0004 */ unsigned long Reserved;
	/* 0x0008 */ unsigned __int64 Bitmap[20];
} KAFFINITY_EX, * PKAFFINITY_EX; /* size: 0x00a8 */

typedef union _KEXECUTE_OPTIONS
{
	union
	{
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned char ExecuteDisable : 1; /* bit position: 0 */
			/* 0x0000 */ unsigned char ExecuteEnable : 1; /* bit position: 1 */
			/* 0x0000 */ unsigned char DisableThunkEmulation : 1; /* bit position: 2 */
			/* 0x0000 */ unsigned char Permanent : 1; /* bit position: 3 */
			/* 0x0000 */ unsigned char ExecuteDispatchEnable : 1; /* bit position: 4 */
			/* 0x0000 */ unsigned char ImageDispatchEnable : 1; /* bit position: 5 */
			/* 0x0000 */ unsigned char DisableExceptionChainValidation : 1; /* bit position: 6 */
			/* 0x0000 */ unsigned char Spare : 1; /* bit position: 7 */
		}; /* bitfield */
		/* 0x0000 */ volatile unsigned char ExecuteOptions;
		/* 0x0000 */ unsigned char ExecuteOptionsNV;
	}; /* size: 0x0001 */
} KEXECUTE_OPTIONS, * PKEXECUTE_OPTIONS; /* size: 0x0001 */

typedef union _KSTACK_COUNT
{
	union
	{
		/* 0x0000 */ long Value;
		struct /* bitfield */
		{
			/* 0x0000 */ unsigned long State : 3; /* bit position: 0 */
			/* 0x0000 */ unsigned long StackCount : 29; /* bit position: 3 */
		}; /* bitfield */
	}; /* size: 0x0004 */
} KSTACK_COUNT, * PKSTACK_COUNT; /* size: 0x0004 */

typedef struct _KPROCESS
{
	/* 0x0000 */ struct _DISPATCHER_HEADER Header;
	/* 0x0018 */ struct _LIST_ENTRY ProfileListHead;
	/* 0x0028 */ unsigned __int64 DirectoryTableBase;
	/* 0x0030 */ struct _LIST_ENTRY ThreadListHead;
	/* 0x0040 */ unsigned long ProcessLock;
	/* 0x0044 */ unsigned long ProcessTimerDelay;
	/* 0x0048 */ unsigned __int64 DeepFreezeStartTime;
	/* 0x0050 */ struct _KAFFINITY_EX Affinity;
	/* 0x00f8 */ unsigned __int64 AffinityPadding[12];
	/* 0x0158 */ struct _LIST_ENTRY ReadyListHead;
	/* 0x0168 */ struct _SINGLE_LIST_ENTRY SwapListEntry;
	/* 0x0170 */ volatile struct _KAFFINITY_EX ActiveProcessors;
	/* 0x0218 */ unsigned __int64 ActiveProcessorsPadding[12];
	union
	{
		struct /* bitfield */
		{
			/* 0x0278 */ unsigned long AutoAlignment : 1; /* bit position: 0 */
			/* 0x0278 */ unsigned long DisableBoost : 1; /* bit position: 1 */
			/* 0x0278 */ unsigned long DisableQuantum : 1; /* bit position: 2 */
			/* 0x0278 */ unsigned long DeepFreeze : 1; /* bit position: 3 */
			/* 0x0278 */ unsigned long TimerVirtualization : 1; /* bit position: 4 */
			/* 0x0278 */ unsigned long CheckStackExtents : 1; /* bit position: 5 */
			/* 0x0278 */ unsigned long CacheIsolationEnabled : 1; /* bit position: 6 */
			/* 0x0278 */ unsigned long PpmPolicy : 3; /* bit position: 7 */
			/* 0x0278 */ unsigned long VaSpaceDeleted : 1; /* bit position: 10 */
			/* 0x0278 */ unsigned long ReservedFlags : 21; /* bit position: 11 */
		}; /* bitfield */
		/* 0x0278 */ volatile long ProcessFlags;
	}; /* size: 0x0004 */
	/* 0x027c */ unsigned long ActiveGroupsMask;
	/* 0x0280 */ char BasePriority;
	/* 0x0281 */ char QuantumReset;
	/* 0x0282 */ char Visited;
	/* 0x0283 */ union _KEXECUTE_OPTIONS Flags;
	/* 0x0284 */ unsigned short ThreadSeed[20];
	/* 0x02ac */ unsigned short ThreadSeedPadding[12];
	/* 0x02c4 */ unsigned short IdealProcessor[20];
	/* 0x02ec */ unsigned short IdealProcessorPadding[12];
	/* 0x0304 */ unsigned short IdealNode[20];
	/* 0x032c */ unsigned short IdealNodePadding[12];
	/* 0x0344 */ unsigned short IdealGlobalNode;
	/* 0x0346 */ unsigned short Spare1;
	/* 0x0348 */ volatile union _KSTACK_COUNT StackCount;
	/* 0x034c */ long Padding_0;
	/* 0x0350 */ struct _LIST_ENTRY ProcessListEntry;
	/* 0x0360 */ unsigned __int64 CycleTime;
	/* 0x0368 */ unsigned __int64 ContextSwitches;
	/* 0x0370 */ struct _KSCHEDULING_GROUP* SchedulingGroup;
	/* 0x0378 */ unsigned long FreezeCount;
	/* 0x037c */ unsigned long KernelTime;
	/* 0x0380 */ unsigned long UserTime;
	/* 0x0384 */ unsigned long ReadyTime;
	/* 0x0388 */ unsigned __int64 UserDirectoryTableBase;
	/* 0x0390 */ unsigned char AddressPolicy;
	/* 0x0391 */ unsigned char Spare2[71];
	/* 0x03d8 */ void* InstrumentationCallback;
	union
	{
		union
		{
			/* 0x03e0 */ unsigned __int64 SecureHandle;
			struct
			{
				struct /* bitfield */
				{
					/* 0x03e0 */ unsigned __int64 SecureProcess : 1; /* bit position: 0 */
					/* 0x03e0 */ unsigned __int64 Unused : 1; /* bit position: 1 */
				}; /* bitfield */
			} /* size: 0x0008 */ Flags;
		}; /* size: 0x0008 */
	} /* size: 0x0008 */ SecureState;
	/* 0x03e8 */ unsigned __int64 KernelWaitTime;
	/* 0x03f0 */ unsigned __int64 UserWaitTime;
	/* 0x03f8 */ unsigned __int64 EndPadding[8];
} KPROCESS, * PKPROCESS; /* size: 0x0438 */

typedef struct _EX_FAST_REF
{
	union
	{
		/* 0x0000 */ void* Object;
		/* 0x0000 */ unsigned __int64 RefCnt : 4; /* bit position: 0 */
		/* 0x0000 */ unsigned __int64 Value;
	}; /* size: 0x0008 */
} EX_FAST_REF, * PEX_FAST_REF; /* size: 0x0008 */

typedef struct _SE_AUDIT_PROCESS_CREATION_INFO
{
	/* 0x0000 */ struct _OBJECT_NAME_INFORMATION* ImageFileName;
} SE_AUDIT_PROCESS_CREATION_INFO, * PSE_AUDIT_PROCESS_CREATION_INFO; /* size: 0x0008 */

typedef struct _MMSUPPORT_FLAGS
{
	union
	{
		struct
		{
			struct /* bitfield */
			{
				/* 0x0000 */ unsigned char WorkingSetType : 3; /* bit position: 0 */
				/* 0x0000 */ unsigned char Reserved0 : 3; /* bit position: 3 */
				/* 0x0000 */ unsigned char MaximumWorkingSetHard : 1; /* bit position: 6 */
				/* 0x0000 */ unsigned char MinimumWorkingSetHard : 1; /* bit position: 7 */
			}; /* bitfield */
			struct /* bitfield */
			{
				/* 0x0001 */ unsigned char SessionMaster : 1; /* bit position: 0 */
				/* 0x0001 */ unsigned char TrimmerState : 2; /* bit position: 1 */
				/* 0x0001 */ unsigned char Reserved : 1; /* bit position: 3 */
				/* 0x0001 */ unsigned char PageStealers : 4; /* bit position: 4 */
			}; /* bitfield */
		}; /* size: 0x0002 */
		/* 0x0000 */ unsigned short u1;
	}; /* size: 0x0002 */
	/* 0x0002 */ unsigned char MemoryPriority;
	union
	{
		struct /* bitfield */
		{
			/* 0x0003 */ unsigned char WsleDeleted : 1; /* bit position: 0 */
			/* 0x0003 */ unsigned char SvmEnabled : 1; /* bit position: 1 */
			/* 0x0003 */ unsigned char ForceAge : 1; /* bit position: 2 */
			/* 0x0003 */ unsigned char ForceTrim : 1; /* bit position: 3 */
			/* 0x0003 */ unsigned char NewMaximum : 1; /* bit position: 4 */
			/* 0x0003 */ unsigned char CommitReleaseState : 2; /* bit position: 5 */
		}; /* bitfield */
		/* 0x0003 */ unsigned char u2;
	}; /* size: 0x0001 */
} MMSUPPORT_FLAGS, * PMMSUPPORT_FLAGS; /* size: 0x0004 */

typedef struct _ALPC_PROCESS_CONTEXT
{
	/* 0x0000 */ struct _EX_PUSH_LOCK Lock;
	/* 0x0008 */ struct _LIST_ENTRY ViewListHead;
	/* 0x0018 */ volatile unsigned __int64 PagedPoolQuotaCache;
} ALPC_PROCESS_CONTEXT, * PALPC_PROCESS_CONTEXT; /* size: 0x0020 */

typedef struct _EPROCESS_wrk
{
	/* 0x0000 */ struct _KPROCESS Pcb;
	/* 0x0438 */ struct _EX_PUSH_LOCK ProcessLock;
	/* 0x0440 */ void* UniqueProcessId;
	/* 0x0448 */ struct _LIST_ENTRY ActiveProcessLinks;
	/* 0x0458 */ struct _EX_RUNDOWN_REF RundownProtect;
	union
	{
		/* 0x0460 */ unsigned long Flags2;
		struct /* bitfield */
		{
			/* 0x0460 */ unsigned long JobNotReallyActive : 1; /* bit position: 0 */
			/* 0x0460 */ unsigned long AccountingFolded : 1; /* bit position: 1 */
			/* 0x0460 */ unsigned long NewProcessReported : 1; /* bit position: 2 */
			/* 0x0460 */ unsigned long ExitProcessReported : 1; /* bit position: 3 */
			/* 0x0460 */ unsigned long ReportCommitChanges : 1; /* bit position: 4 */
			/* 0x0460 */ unsigned long LastReportMemory : 1; /* bit position: 5 */
			/* 0x0460 */ unsigned long ForceWakeCharge : 1; /* bit position: 6 */
			/* 0x0460 */ unsigned long CrossSessionCreate : 1; /* bit position: 7 */
			/* 0x0460 */ unsigned long NeedsHandleRundown : 1; /* bit position: 8 */
			/* 0x0460 */ unsigned long RefTraceEnabled : 1; /* bit position: 9 */
			/* 0x0460 */ unsigned long PicoCreated : 1; /* bit position: 10 */
			/* 0x0460 */ unsigned long EmptyJobEvaluated : 1; /* bit position: 11 */
			/* 0x0460 */ unsigned long DefaultPagePriority : 3; /* bit position: 12 */
			/* 0x0460 */ unsigned long PrimaryTokenFrozen : 1; /* bit position: 15 */
			/* 0x0460 */ unsigned long ProcessVerifierTarget : 1; /* bit position: 16 */
			/* 0x0460 */ unsigned long RestrictSetThreadContext : 1; /* bit position: 17 */
			/* 0x0460 */ unsigned long AffinityPermanent : 1; /* bit position: 18 */
			/* 0x0460 */ unsigned long AffinityUpdateEnable : 1; /* bit position: 19 */
			/* 0x0460 */ unsigned long PropagateNode : 1; /* bit position: 20 */
			/* 0x0460 */ unsigned long ExplicitAffinity : 1; /* bit position: 21 */
			/* 0x0460 */ unsigned long ProcessExecutionState : 2; /* bit position: 22 */
			/* 0x0460 */ unsigned long EnableReadVmLogging : 1; /* bit position: 24 */
			/* 0x0460 */ unsigned long EnableWriteVmLogging : 1; /* bit position: 25 */
			/* 0x0460 */ unsigned long FatalAccessTerminationRequested : 1; /* bit position: 26 */
			/* 0x0460 */ unsigned long DisableSystemAllowedCpuSet : 1; /* bit position: 27 */
			/* 0x0460 */ unsigned long ProcessStateChangeRequest : 2; /* bit position: 28 */
			/* 0x0460 */ unsigned long ProcessStateChangeInProgress : 1; /* bit position: 30 */
			/* 0x0460 */ unsigned long InPrivate : 1; /* bit position: 31 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	union
	{
		/* 0x0464 */ unsigned long Flags;
		struct /* bitfield */
		{
			/* 0x0464 */ unsigned long CreateReported : 1; /* bit position: 0 */
			/* 0x0464 */ unsigned long NoDebugInherit : 1; /* bit position: 1 */
			/* 0x0464 */ unsigned long ProcessExiting : 1; /* bit position: 2 */
			/* 0x0464 */ unsigned long ProcessDelete : 1; /* bit position: 3 */
			/* 0x0464 */ unsigned long ManageExecutableMemoryWrites : 1; /* bit position: 4 */
			/* 0x0464 */ unsigned long VmDeleted : 1; /* bit position: 5 */
			/* 0x0464 */ unsigned long OutswapEnabled : 1; /* bit position: 6 */
			/* 0x0464 */ unsigned long Outswapped : 1; /* bit position: 7 */
			/* 0x0464 */ unsigned long FailFastOnCommitFail : 1; /* bit position: 8 */
			/* 0x0464 */ unsigned long Wow64VaSpace4Gb : 1; /* bit position: 9 */
			/* 0x0464 */ unsigned long AddressSpaceInitialized : 2; /* bit position: 10 */
			/* 0x0464 */ unsigned long SetTimerResolution : 1; /* bit position: 12 */
			/* 0x0464 */ unsigned long BreakOnTermination : 1; /* bit position: 13 */
			/* 0x0464 */ unsigned long DeprioritizeViews : 1; /* bit position: 14 */
			/* 0x0464 */ unsigned long WriteWatch : 1; /* bit position: 15 */
			/* 0x0464 */ unsigned long ProcessInSession : 1; /* bit position: 16 */
			/* 0x0464 */ unsigned long OverrideAddressSpace : 1; /* bit position: 17 */
			/* 0x0464 */ unsigned long HasAddressSpace : 1; /* bit position: 18 */
			/* 0x0464 */ unsigned long LaunchPrefetched : 1; /* bit position: 19 */
			/* 0x0464 */ unsigned long Background : 1; /* bit position: 20 */
			/* 0x0464 */ unsigned long VmTopDown : 1; /* bit position: 21 */
			/* 0x0464 */ unsigned long ImageNotifyDone : 1; /* bit position: 22 */
			/* 0x0464 */ unsigned long PdeUpdateNeeded : 1; /* bit position: 23 */
			/* 0x0464 */ unsigned long VdmAllowed : 1; /* bit position: 24 */
			/* 0x0464 */ unsigned long ProcessRundown : 1; /* bit position: 25 */
			/* 0x0464 */ unsigned long ProcessInserted : 1; /* bit position: 26 */
			/* 0x0464 */ unsigned long DefaultIoPriority : 3; /* bit position: 27 */
			/* 0x0464 */ unsigned long ProcessSelfDelete : 1; /* bit position: 30 */
			/* 0x0464 */ unsigned long SetTimerResolutionLink : 1; /* bit position: 31 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0468 */ union _LARGE_INTEGER CreateTime;
	/* 0x0470 */ unsigned __int64 ProcessQuotaUsage[2];
	/* 0x0480 */ unsigned __int64 ProcessQuotaPeak[2];
	/* 0x0490 */ unsigned __int64 PeakVirtualSize;
	/* 0x0498 */ unsigned __int64 VirtualSize;
	/* 0x04a0 */ struct _LIST_ENTRY SessionProcessLinks;
	union
	{
		/* 0x04b0 */ void* ExceptionPortData;
		/* 0x04b0 */ unsigned __int64 ExceptionPortValue;
		/* 0x04b0 */ unsigned __int64 ExceptionPortState : 3; /* bit position: 0 */
	}; /* size: 0x0008 */
	/* 0x04b8 */ struct _EX_FAST_REF Token;
	/* 0x04c0 */ unsigned __int64 MmReserved;
	/* 0x04c8 */ struct _EX_PUSH_LOCK AddressCreationLock;
	/* 0x04d0 */ struct _EX_PUSH_LOCK PageTableCommitmentLock;
	/* 0x04d8 */ struct _ETHREAD* RotateInProgress;
	/* 0x04e0 */ struct _ETHREAD* ForkInProgress;
	/* 0x04e8 */ struct _EJOB* volatile CommitChargeJob;
	/* 0x04f0 */ struct _RTL_AVL_TREE CloneRoot;
	/* 0x04f8 */ volatile unsigned __int64 NumberOfPrivatePages;
	/* 0x0500 */ volatile unsigned __int64 NumberOfLockedPages;
	/* 0x0508 */ void* Win32Process;
	/* 0x0510 */ struct _EJOB* volatile Job;
	/* 0x0518 */ void* SectionObject;
	/* 0x0520 */ void* SectionBaseAddress;
	/* 0x0528 */ unsigned long Cookie;
	/* 0x052c */ long Padding_1;
	/* 0x0530 */ struct _PAGEFAULT_HISTORY* WorkingSetWatch;
	/* 0x0538 */ void* Win32WindowStation;
	/* 0x0540 */ void* InheritedFromUniqueProcessId;
	/* 0x0548 */ volatile unsigned __int64 OwnerProcessId;
	/* 0x0550 */ struct _PEB* Peb;
	/* 0x0558 */ struct _MM_SESSION_SPACE* Session;
	/* 0x0560 */ void* Spare1;
	/* 0x0568 */ struct _EPROCESS_QUOTA_BLOCK* QuotaBlock;
	/* 0x0570 */ struct _HANDLE_TABLE* ObjectTable;
	/* 0x0578 */ void* DebugPort;
	/* 0x0580 */ struct _EWOW64PROCESS* WoW64Process;
	/* 0x0588 */ void* DeviceMap;
	/* 0x0590 */ void* EtwDataSource;
	/* 0x0598 */ unsigned __int64 PageDirectoryPte;
	/* 0x05a0 */ struct _FILE_OBJECT* ImageFilePointer;
	/* 0x05a8 */ unsigned char ImageFileName[15];
	/* 0x05b7 */ unsigned char PriorityClass;
	/* 0x05b8 */ void* SecurityPort;
	/* 0x05c0 */ struct _SE_AUDIT_PROCESS_CREATION_INFO SeAuditProcessCreationInfo;
	/* 0x05c8 */ struct _LIST_ENTRY JobLinks;
	/* 0x05d8 */ void* HighestUserAddress;
	/* 0x05e0 */ struct _LIST_ENTRY ThreadListHead;
	/* 0x05f0 */ volatile unsigned long ActiveThreads;
	/* 0x05f4 */ unsigned long ImagePathHash;
	/* 0x05f8 */ unsigned long DefaultHardErrorProcessing;
	/* 0x05fc */ long LastThreadExitStatus;
	/* 0x0600 */ struct _EX_FAST_REF PrefetchTrace;
	/* 0x0608 */ void* LockedPagesList;
	/* 0x0610 */ union _LARGE_INTEGER ReadOperationCount;
	/* 0x0618 */ union _LARGE_INTEGER WriteOperationCount;
	/* 0x0620 */ union _LARGE_INTEGER OtherOperationCount;
	/* 0x0628 */ union _LARGE_INTEGER ReadTransferCount;
	/* 0x0630 */ union _LARGE_INTEGER WriteTransferCount;
	/* 0x0638 */ union _LARGE_INTEGER OtherTransferCount;
	/* 0x0640 */ unsigned __int64 CommitChargeLimit;
	/* 0x0648 */ volatile unsigned __int64 CommitCharge;
	/* 0x0650 */ volatile unsigned __int64 CommitChargePeak;
	/* 0x0658 */ long Padding_2[10];
	/* 0x0680 */ struct _MMSUPPORT_FULL Vm;
	/* 0x07c0 */ struct _LIST_ENTRY MmProcessLinks;
	/* 0x07d0 */ unsigned long ModifiedPageCount;
	/* 0x07d4 */ long ExitStatus;
	/* 0x07d8 */ struct _RTL_AVL_TREE VadRoot;
	/* 0x07e0 */ void* VadHint;
	/* 0x07e8 */ unsigned __int64 VadCount;
	/* 0x07f0 */ volatile unsigned __int64 VadPhysicalPages;
	/* 0x07f8 */ unsigned __int64 VadPhysicalPagesLimit;
	/* 0x0800 */ struct _ALPC_PROCESS_CONTEXT AlpcContext;
	/* 0x0820 */ struct _LIST_ENTRY TimerResolutionLink;
	/* 0x0830 */ struct _PO_DIAG_STACK_RECORD* TimerResolutionStackRecord;
	/* 0x0838 */ unsigned long RequestedTimerResolution;
	/* 0x083c */ unsigned long SmallestTimerResolution;
	/* 0x0840 */ union _LARGE_INTEGER ExitTime;
	/* 0x0848 */ struct _INVERTED_FUNCTION_TABLE* InvertedFunctionTable;
	/* 0x0850 */ struct _EX_PUSH_LOCK InvertedFunctionTableLock;
	/* 0x0858 */ unsigned long ActiveThreadsHighWatermark;
	/* 0x085c */ unsigned long LargePrivateVadCount;
	/* 0x0860 */ struct _EX_PUSH_LOCK ThreadListLock;
	/* 0x0868 */ void* WnfContext;
	/* 0x0870 */ struct _EJOB* ServerSilo;
	/* 0x0878 */ unsigned char SignatureLevel;
	/* 0x0879 */ unsigned char SectionSignatureLevel;
	/* 0x087a */ struct _PS_PROTECTION Protection;
	struct /* bitfield */
	{
		/* 0x087b */ unsigned char HangCount : 3; /* bit position: 0 */
		/* 0x087b */ unsigned char GhostCount : 3; /* bit position: 3 */
		/* 0x087b */ unsigned char PrefilterException : 1; /* bit position: 6 */
	}; /* bitfield */
	union
	{
		/* 0x087c */ unsigned long Flags3;
		struct /* bitfield */
		{
			/* 0x087c */ unsigned long Minimal : 1; /* bit position: 0 */
			/* 0x087c */ unsigned long ReplacingPageRoot : 1; /* bit position: 1 */
			/* 0x087c */ unsigned long Crashed : 1; /* bit position: 2 */
			/* 0x087c */ unsigned long JobVadsAreTracked : 1; /* bit position: 3 */
			/* 0x087c */ unsigned long VadTrackingDisabled : 1; /* bit position: 4 */
			/* 0x087c */ unsigned long AuxiliaryProcess : 1; /* bit position: 5 */
			/* 0x087c */ unsigned long SubsystemProcess : 1; /* bit position: 6 */
			/* 0x087c */ unsigned long IndirectCpuSets : 1; /* bit position: 7 */
			/* 0x087c */ unsigned long RelinquishedCommit : 1; /* bit position: 8 */
			/* 0x087c */ unsigned long HighGraphicsPriority : 1; /* bit position: 9 */
			/* 0x087c */ unsigned long CommitFailLogged : 1; /* bit position: 10 */
			/* 0x087c */ unsigned long ReserveFailLogged : 1; /* bit position: 11 */
			/* 0x087c */ unsigned long SystemProcess : 1; /* bit position: 12 */
			/* 0x087c */ unsigned long HideImageBaseAddresses : 1; /* bit position: 13 */
			/* 0x087c */ unsigned long AddressPolicyFrozen : 1; /* bit position: 14 */
			/* 0x087c */ unsigned long ProcessFirstResume : 1; /* bit position: 15 */
			/* 0x087c */ unsigned long ForegroundExternal : 1; /* bit position: 16 */
			/* 0x087c */ unsigned long ForegroundSystem : 1; /* bit position: 17 */
			/* 0x087c */ unsigned long HighMemoryPriority : 1; /* bit position: 18 */
			/* 0x087c */ unsigned long EnableProcessSuspendResumeLogging : 1; /* bit position: 19 */
			/* 0x087c */ unsigned long EnableThreadSuspendResumeLogging : 1; /* bit position: 20 */
			/* 0x087c */ unsigned long SecurityDomainChanged : 1; /* bit position: 21 */
			/* 0x087c */ unsigned long SecurityFreezeComplete : 1; /* bit position: 22 */
			/* 0x087c */ unsigned long VmProcessorHost : 1; /* bit position: 23 */
			/* 0x087c */ unsigned long VmProcessorHostTransition : 1; /* bit position: 24 */
			/* 0x087c */ unsigned long AltSyscall : 1; /* bit position: 25 */
			/* 0x087c */ unsigned long TimerResolutionIgnore : 1; /* bit position: 26 */
			/* 0x087c */ unsigned long DisallowUserTerminate : 1; /* bit position: 27 */
		}; /* bitfield */
	}; /* size: 0x0004 */
	/* 0x0880 */ long DeviceAsid;
	/* 0x0884 */ long Padding_3;
	/* 0x0888 */ void* SvmData;
	/* 0x0890 */ struct _EX_PUSH_LOCK SvmProcessLock;
	/* 0x0898 */ unsigned __int64 SvmLock;
	/* 0x08a0 */ struct _LIST_ENTRY SvmProcessDeviceListHead;
	/* 0x08b0 */ unsigned __int64 LastFreezeInterruptTime;
	/* 0x08b8 */ struct _PROCESS_DISK_COUNTERS* DiskCounters;
	/* 0x08c0 */ void* PicoContext;
	/* 0x08c8 */ void* EnclaveTable;
	/* 0x08d0 */ unsigned __int64 EnclaveNumber;
	/* 0x08d8 */ struct _EX_PUSH_LOCK EnclaveLock;
	/* 0x08e0 */ unsigned long HighPriorityFaultsAllowed;
	/* 0x08e4 */ long Padding_4;
	/* 0x08e8 */ struct _PO_PROCESS_ENERGY_CONTEXT* EnergyContext;
	/* 0x08f0 */ void* VmContext;
	/* 0x08f8 */ unsigned __int64 SequenceNumber;
	/* 0x0900 */ unsigned __int64 CreateInterruptTime;
	/* 0x0908 */ unsigned __int64 CreateUnbiasedInterruptTime;
	/* 0x0910 */ unsigned __int64 TotalUnbiasedFrozenTime;
	/* 0x0918 */ unsigned __int64 LastAppStateUpdateTime;
	struct /* bitfield */
	{
		/* 0x0920 */ unsigned __int64 LastAppStateUptime : 61; /* bit position: 0 */
		/* 0x0920 */ unsigned __int64 LastAppState : 3; /* bit position: 61 */
	}; /* bitfield */
	/* 0x0928 */ volatile unsigned __int64 SharedCommitCharge;
	/* 0x0930 */ struct _EX_PUSH_LOCK SharedCommitLock;
	/* 0x0938 */ struct _LIST_ENTRY SharedCommitLinks;
	union
	{
		struct
		{
			/* 0x0948 */ unsigned __int64 AllowedCpuSets;
			/* 0x0950 */ unsigned __int64 DefaultCpuSets;
		}; /* size: 0x0010 */
		struct
		{
			/* 0x0948 */ unsigned __int64* AllowedCpuSetsIndirect;
			/* 0x0950 */ unsigned __int64* DefaultCpuSetsIndirect;
		}; /* size: 0x0010 */
	}; /* size: 0x0010 */
	/* 0x0958 */ void* DiskIoAttribution;
	/* 0x0960 */ void* DxgProcess;
	/* 0x0968 */ unsigned long Win32KFilterSet;
	/* 0x096c */ long Padding_5;
	/* 0x0970 */ volatile union _PS_INTERLOCKED_TIMER_DELAY_VALUES ProcessTimerDelay;
	/* 0x0978 */ volatile unsigned long KTimerSets;
	/* 0x097c */ volatile unsigned long KTimer2Sets;
	/* 0x0980 */ volatile unsigned long ThreadTimerSets;
	/* 0x0984 */ long Padding_6;
	/* 0x0988 */ unsigned __int64 VirtualTimerListLock;
	/* 0x0990 */ struct _LIST_ENTRY VirtualTimerListHead;
	union
	{
		/* 0x09a0 */ struct _WNF_STATE_NAME WakeChannel;
		/* 0x09a0 */ struct _PS_PROCESS_WAKE_INFORMATION WakeInfo;
	}; /* size: 0x0030 */
	union
	{
		/* 0x09d0 */ unsigned long MitigationFlags;
		struct
		{
			struct /* bitfield */
			{
				/* 0x09d0 */ unsigned long ControlFlowGuardEnabled : 1; /* bit position: 0 */
				/* 0x09d0 */ unsigned long ControlFlowGuardExportSuppressionEnabled : 1; /* bit position: 1 */
				/* 0x09d0 */ unsigned long ControlFlowGuardStrict : 1; /* bit position: 2 */
				/* 0x09d0 */ unsigned long DisallowStrippedImages : 1; /* bit position: 3 */
				/* 0x09d0 */ unsigned long ForceRelocateImages : 1; /* bit position: 4 */
				/* 0x09d0 */ unsigned long HighEntropyASLREnabled : 1; /* bit position: 5 */
				/* 0x09d0 */ unsigned long StackRandomizationDisabled : 1; /* bit position: 6 */
				/* 0x09d0 */ unsigned long ExtensionPointDisable : 1; /* bit position: 7 */
				/* 0x09d0 */ unsigned long DisableDynamicCode : 1; /* bit position: 8 */
				/* 0x09d0 */ unsigned long DisableDynamicCodeAllowOptOut : 1; /* bit position: 9 */
				/* 0x09d0 */ unsigned long DisableDynamicCodeAllowRemoteDowngrade : 1; /* bit position: 10 */
				/* 0x09d0 */ unsigned long AuditDisableDynamicCode : 1; /* bit position: 11 */
				/* 0x09d0 */ unsigned long DisallowWin32kSystemCalls : 1; /* bit position: 12 */
				/* 0x09d0 */ unsigned long AuditDisallowWin32kSystemCalls : 1; /* bit position: 13 */
				/* 0x09d0 */ unsigned long EnableFilteredWin32kAPIs : 1; /* bit position: 14 */
				/* 0x09d0 */ unsigned long AuditFilteredWin32kAPIs : 1; /* bit position: 15 */
				/* 0x09d0 */ unsigned long DisableNonSystemFonts : 1; /* bit position: 16 */
				/* 0x09d0 */ unsigned long AuditNonSystemFontLoading : 1; /* bit position: 17 */
				/* 0x09d0 */ unsigned long PreferSystem32Images : 1; /* bit position: 18 */
				/* 0x09d0 */ unsigned long ProhibitRemoteImageMap : 1; /* bit position: 19 */
				/* 0x09d0 */ unsigned long AuditProhibitRemoteImageMap : 1; /* bit position: 20 */
				/* 0x09d0 */ unsigned long ProhibitLowILImageMap : 1; /* bit position: 21 */
				/* 0x09d0 */ unsigned long AuditProhibitLowILImageMap : 1; /* bit position: 22 */
				/* 0x09d0 */ unsigned long SignatureMitigationOptIn : 1; /* bit position: 23 */
				/* 0x09d0 */ unsigned long AuditBlockNonMicrosoftBinaries : 1; /* bit position: 24 */
				/* 0x09d0 */ unsigned long AuditBlockNonMicrosoftBinariesAllowStore : 1; /* bit position: 25 */
				/* 0x09d0 */ unsigned long LoaderIntegrityContinuityEnabled : 1; /* bit position: 26 */
				/* 0x09d0 */ unsigned long AuditLoaderIntegrityContinuity : 1; /* bit position: 27 */
				/* 0x09d0 */ unsigned long EnableModuleTamperingProtection : 1; /* bit position: 28 */
				/* 0x09d0 */ unsigned long EnableModuleTamperingProtectionNoInherit : 1; /* bit position: 29 */
				/* 0x09d0 */ unsigned long RestrictIndirectBranchPrediction : 1; /* bit position: 30 */
				/* 0x09d0 */ unsigned long IsolateSecurityDomain : 1; /* bit position: 31 */
			}; /* bitfield */
		} /* size: 0x0004 */ MitigationFlagsValues;
	}; /* size: 0x0004 */
	union
	{
		/* 0x09d4 */ unsigned long MitigationFlags2;
		struct
		{
			struct /* bitfield */
			{
				/* 0x09d4 */ unsigned long EnableExportAddressFilter : 1; /* bit position: 0 */
				/* 0x09d4 */ unsigned long AuditExportAddressFilter : 1; /* bit position: 1 */
				/* 0x09d4 */ unsigned long EnableExportAddressFilterPlus : 1; /* bit position: 2 */
				/* 0x09d4 */ unsigned long AuditExportAddressFilterPlus : 1; /* bit position: 3 */
				/* 0x09d4 */ unsigned long EnableRopStackPivot : 1; /* bit position: 4 */
				/* 0x09d4 */ unsigned long AuditRopStackPivot : 1; /* bit position: 5 */
				/* 0x09d4 */ unsigned long EnableRopCallerCheck : 1; /* bit position: 6 */
				/* 0x09d4 */ unsigned long AuditRopCallerCheck : 1; /* bit position: 7 */
				/* 0x09d4 */ unsigned long EnableRopSimExec : 1; /* bit position: 8 */
				/* 0x09d4 */ unsigned long AuditRopSimExec : 1; /* bit position: 9 */
				/* 0x09d4 */ unsigned long EnableImportAddressFilter : 1; /* bit position: 10 */
				/* 0x09d4 */ unsigned long AuditImportAddressFilter : 1; /* bit position: 11 */
				/* 0x09d4 */ unsigned long DisablePageCombine : 1; /* bit position: 12 */
				/* 0x09d4 */ unsigned long SpeculativeStoreBypassDisable : 1; /* bit position: 13 */
				/* 0x09d4 */ unsigned long CetUserShadowStacks : 1; /* bit position: 14 */
				/* 0x09d4 */ unsigned long AuditCetUserShadowStacks : 1; /* bit position: 15 */
				/* 0x09d4 */ unsigned long AuditCetUserShadowStacksLogged : 1; /* bit position: 16 */
				/* 0x09d4 */ unsigned long UserCetSetContextIpValidation : 1; /* bit position: 17 */
				/* 0x09d4 */ unsigned long AuditUserCetSetContextIpValidation : 1; /* bit position: 18 */
				/* 0x09d4 */ unsigned long AuditUserCetSetContextIpValidationLogged : 1; /* bit position: 19 */
				/* 0x09d4 */ unsigned long CetUserShadowStacksStrictMode : 1; /* bit position: 20 */
				/* 0x09d4 */ unsigned long BlockNonCetBinaries : 1; /* bit position: 21 */
				/* 0x09d4 */ unsigned long BlockNonCetBinariesNonEhcont : 1; /* bit position: 22 */
				/* 0x09d4 */ unsigned long AuditBlockNonCetBinaries : 1; /* bit position: 23 */
				/* 0x09d4 */ unsigned long AuditBlockNonCetBinariesLogged : 1; /* bit position: 24 */
				/* 0x09d4 */ unsigned long Reserved1 : 1; /* bit position: 25 */
				/* 0x09d4 */ unsigned long Reserved2 : 1; /* bit position: 26 */
				/* 0x09d4 */ unsigned long Reserved3 : 1; /* bit position: 27 */
				/* 0x09d4 */ unsigned long Reserved4 : 1; /* bit position: 28 */
				/* 0x09d4 */ unsigned long Reserved5 : 1; /* bit position: 29 */
				/* 0x09d4 */ unsigned long CetDynamicApisOutOfProcOnly : 1; /* bit position: 30 */
				/* 0x09d4 */ unsigned long UserCetSetContextIpValidationRelaxedMode : 1; /* bit position: 31 */
			}; /* bitfield */
		} /* size: 0x0004 */ MitigationFlags2Values;
	}; /* size: 0x0004 */
	/* 0x09d8 */ void* PartitionObject;
	/* 0x09e0 */ unsigned __int64 SecurityDomain;
	/* 0x09e8 */ unsigned __int64 ParentSecurityDomain;
	/* 0x09f0 */ void* CoverageSamplerContext;
	/* 0x09f8 */ void* MmHotPatchContext;
	/* 0x0a00 */ struct _RTL_AVL_TREE DynamicEHContinuationTargetsTree;
	/* 0x0a08 */ struct _EX_PUSH_LOCK DynamicEHContinuationTargetsLock;
	/* 0x0a10 */ struct _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES DynamicEnforcedCetCompatibleRanges;
	/* 0x0a20 */ unsigned long DisabledComponentFlags;
	/* 0x0a24 */ long __PADDING__[7];
} EPROCESS_wrk, * PEPROCESS_wrk; /* size: 0x0a40 */
```

`HyperHideDrv/struct.h`:

```h
#pragma once

//常量
#define MAX_PATH          260
/*==============================================================================*/
/*                                自定义结构                                    */
/*==============================================================================*/

 typedef struct _LIST_LINK  //自定义单向链表节点
 {
	 PVOID DataPtr;
	 PVOID Data;//附加数据
	 struct _LIST_LINK* next;
 } LIST_LINK, * PLIST_LINK;
 typedef struct _LIST_HEAD  //自定义单向链表头
 {
	 struct _LIST_LINK ListHead;
	 ULONG_PTR m_Size;

 } LIST_HEAD, * PLIST_HEAD;
 typedef struct _LIST_ARRAY//自定义动态数组
 {
	 PVOID DataPtr;//数组指针
	 ULONG_PTR m_CurrentNumber;//当前元素个数
	 ULONG_PTR m_Size;//数组容量个数

 }LIST_ARRAY, * PLIST_ARRAY;


 typedef struct _TZM {
	 UCHAR	Tzm;
	 int		Offset;
 }TZM, * PTZM;


 typedef struct _ADDRESS_NAME  //R3传入符号结构
 {
	 IN	char  Name[MAX_PATH];
	 PVOID Address;

 }ADDRESS_NAME, * PADDRESS_NAME;
```

`HyperHideDrv/vmintrin.asm`:

```asm
.CODE                                                                                                                                                                            
__vm_call proc
    mov rax,0CDAEFAEDBBAEBEEFh
    vmcall
    ret
__vm_call endp

__vm_call_ex proc
        mov  rax,0CDAEFAEDBBAEBEEFh ; Our vmcall indentitifer

        sub rsp, 30h
        mov qword ptr [rsp],       r10
        mov qword ptr [rsp + 8h],  r11
        mov qword ptr [rsp + 10h], r12
        mov qword ptr [rsp + 18h], r13
        mov qword ptr [rsp + 20h], r14
        mov qword ptr [rsp + 28h], r15

        mov r10, qword ptr [rsp + 58h]
        mov r11, qword ptr [rsp + 60h]
        mov r12, qword ptr [rsp + 68h]
        mov r13, qword ptr [rsp + 70h]
        mov r14, qword ptr [rsp + 78h]
        mov r15, qword ptr [rsp + 80h]

        vmcall
        mov r10, qword ptr [rsp]
        mov r11, qword ptr [rsp + 8h]
        mov r12, qword ptr [rsp + 10h]
        mov r13, qword ptr [rsp + 18h]
        mov r14, qword ptr [rsp + 20h]
        mov r15, qword ptr [rsp + 28h]
        add rsp, 30h

        ret
__vm_call_ex endp

END
```

`HyperHideDrv/vmintrin.h`:

```h
#pragma once

#ifndef _NTIFS_H
#define _NTIFS_H
#include <ntifs.h>
#endif // !_NTIFS_H

extern "C"
{
	bool __vm_call(unsigned __int64 vmcall_reason, unsigned __int64 rdx, unsigned __int64 r8, unsigned __int64 r9);
	bool __vm_call_ex(unsigned __int64 vmcall_reason, unsigned __int64 rdx, unsigned __int64 r8, unsigned __int64 r9, unsigned __int64 r10, unsigned __int64 r11, unsigned __int64 r12, unsigned __int64 r13, unsigned __int64 r14, unsigned __int64 r15);
	BOOLEAN __invept(unsigned __int32 Type, void* Descriptors);
}
```

`HyperHideDrv/wrRegstry.c`:

```c
#include "wrRegstry.h"

LARGE_INTEGER cookie = { 0 };

NTKERNELAPI UCHAR* PsGetProcessImageFileName(__in PEPROCESS Process);
NTKERNELAPI PVOID  PsGetProcessWow64Process(IN PEPROCESS Process);
NTKERNELAPI PVOID  PsGetProcessPeb(IN PEPROCESS Process);

NTSTATUS RegistryCallback(PVOID CallbackContext, PVOID Argument1, PVOID Argument2)
{
	NTSTATUS status = STATUS_SUCCESS;
	REG_NOTIFY_CLASS NotifyClass;
	PREG_SET_VALUE_KEY_INFORMATION PreSetValueInfo;
	PMyDriverStruct DriverInfo = NULL;

	PEPROCESS				process = NULL;
	KAPC_STATE				apc;

	PMDL temp_pMdl = NULL;
	PVOID temp_address1 = NULL;

	PMDL pMdl = NULL;
	PVOID pNewAddress = NULL;

	BOOLEAN IsWow64 = FALSE;
	ULONG64 Moudule_Address = 0;
	UNICODE_STRING usCurrentName = { 0 };
	UNICODE_STRING Target_MouduleName = { 0 };


	if (Argument1 == NULL || Argument2 == NULL)  return STATUS_SUCCESS;
	NotifyClass = (REG_NOTIFY_CLASS)(ULONG_PTR)Argument1;
	if (NotifyClass != RegNtPreSetValueKey)   return STATUS_SUCCESS;

	PreSetValueInfo = (PREG_SET_VALUE_KEY_INFORMATION)Argument2;
	if (PreSetValueInfo->Type != REG_BINARY || PreSetValueInfo->DataSize != sizeof(MyDriverStruct))    return STATUS_SUCCESS;
	DriverInfo = (PMyDriverStruct)PreSetValueInfo->Data;
	if (DriverInfo->Flag == 1)  //读内存
	{
		status = PsLookupProcessByProcessId((HANDLE)DriverInfo->Pid, &process);

		if (status != STATUS_SUCCESS || process == NULL)  return STATUS_SUCCESS;

		temp_pMdl = IoAllocateMdl((PVOID)DriverInfo->Buff, DriverInfo->Size, 0, 0, NULL);

		if (temp_pMdl != NULL)
		{
			MmBuildMdlForNonPagedPool(temp_pMdl);
			temp_address1 = MmMapLockedPages(temp_pMdl, KernelMode);
			if (temp_address1 != NULL)
			{
				if (DriverInfo->MDL_Flag == 0)  //不启动MDL读写
				{
					KeStackAttachProcess(process, &apc);
					if (MmIsAddressValid((PVOID)DriverInfo->Address))
					{
						RtlCopyMemory(temp_address1, (PVOID)DriverInfo->Address, DriverInfo->Size);//往内核地址里拷贝目标地址数据
					}
					KeUnstackDetachProcess(&apc);
					MmUnmapLockedPages(temp_address1, temp_pMdl);
					IoFreeMdl(temp_pMdl);
				}
				else if (DriverInfo->MDL_Flag == 1) //启动MDL读写
				{
					KeStackAttachProcess(process, &apc);
					if (MmIsAddressValid((PVOID)DriverInfo->Address))
					{
						pMdl = MmCreateMdl(NULL, (PVOID)DriverInfo->Address, DriverInfo->Size);
						if (pMdl != NULL)
						{
							MmBuildMdlForNonPagedPool(pMdl);
							pNewAddress = MmMapLockedPages(pMdl, KernelMode);
							if (pNewAddress != NULL)
							{
								RtlCopyMemory(temp_address1, pNewAddress, DriverInfo->Size);//往内核地址里拷贝目标地址数据
								MmUnmapLockedPages(pNewAddress, pMdl);
								IoFreeMdl(pMdl);
							}
							else
							{
								IoFreeMdl(pMdl);
							}
						}
					}
					KeUnstackDetachProcess(&apc);
					MmUnmapLockedPages(temp_address1, temp_pMdl);
					IoFreeMdl(temp_pMdl);
				}
				else
				{
					IoFreeMdl(temp_pMdl);
				}

			}
		}
		ObDereferenceObject(process);
	}
	else if (DriverInfo->Flag == 2) //写内存
	{
		status = PsLookupProcessByProcessId((HANDLE)DriverInfo->Pid, &process);
		if (status != STATUS_SUCCESS || process == NULL)  return STATUS_SUCCESS;
		temp_address1 = ExAllocatePool(NonPagedPool, DriverInfo->Size);
		if (temp_address1 != NULL)
		{
			RtlZeroMemory(temp_address1, DriverInfo->Size);
			RtlCopyMemory(temp_address1, (PVOID)DriverInfo->Buff, DriverInfo->Size);
			KeStackAttachProcess(process, &apc);
			if (MmIsAddressValid((PVOID)DriverInfo->Address))
			{
				pMdl = MmCreateMdl(NULL, (PVOID)DriverInfo->Address, DriverInfo->Size);
				if (pMdl != NULL)
				{
					MmBuildMdlForNonPagedPool(pMdl);
					pNewAddress = MmMapLockedPages(pMdl, KernelMode);
					if (pNewAddress != NULL)
					{
						RtlCopyMemory(pNewAddress, temp_address1, DriverInfo->Size);
						MmUnmapLockedPages(pNewAddress, pMdl);
						IoFreeMdl(pMdl);
					}
					else
					{
						IoFreeMdl(pMdl);
					}
				}
			}
			KeUnstackDetachProcess(&apc);
			ExFreePool(temp_address1);
		}
		ObDereferenceObject(process);
	}
	else if (DriverInfo->Flag == 3)//取模块地址
	{
		status = PsLookupProcessByProcessId((HANDLE)DriverInfo->Pid, &process);
		if (status != STATUS_SUCCESS || process == NULL)  return STATUS_SUCCESS;
		IsWow64 = (PsGetProcessWow64Process(process) != NULL) ? TRUE : FALSE;

		if (IsWow64)
		{
			temp_address1 = ExAllocatePool(NonPagedPool, DriverInfo->Size + (ULONG64)1);
			if (temp_address1 != NULL)
			{
				RtlZeroMemory(temp_address1, DriverInfo->Size + (ULONG64)1);
				RtlCopyMemory(temp_address1, (PVOID)DriverInfo->Address, DriverInfo->Size);
				KeStackAttachProcess(process, &apc);

				PPEB32 pPeb = (PPEB32)PsGetProcessWow64Process(process);
				RtlInitUnicodeString(&Target_MouduleName, (PWCHAR)temp_address1);
				for (PLIST_ENTRY32 pListEntry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)pPeb->Ldr)->InLoadOrderModuleList.Flink;
					pListEntry != &((PPEB_LDR_DATA32)pPeb->Ldr)->InLoadOrderModuleList;
					pListEntry = (PLIST_ENTRY32)pListEntry->Flink)
				{
					PLDR_DATA_TABLE_ENTRY32 LdrEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);
					if (LdrEntry->BaseDllName.Buffer == NULL) continue;
					RtlInitUnicodeString(&usCurrentName, (PWCHAR)LdrEntry->BaseDllName.Buffer);
					if (RtlEqualUnicodeString(&Target_MouduleName, &usCurrentName, TRUE))
					{
						Moudule_Address = (ULONG64)LdrEntry->DllBase;
						break;
					}
				}
				KeUnstackDetachProcess(&apc);
				ExFreePool(temp_address1);
				RtlCopyMemory((PVOID)DriverInfo->Buff, (PVOID)&Moudule_Address, sizeof(ULONG64));
			}
		}
		else
		{
			temp_address1 = ExAllocatePool(NonPagedPool, DriverInfo->Size + (ULONG64)1);
			if (temp_address1 != NULL)
			{
				RtlZeroMemory(temp_address1, DriverInfo->Size + (ULONG64)1);
				RtlCopyMemory(temp_address1, (PVOID)DriverInfo->Address, DriverInfo->Size);
				KeStackAttachProcess(process, &apc);

				PPEB64 pPeb = (PPEB64)PsGetProcessPeb(process);

				RtlInitUnicodeString(&Target_MouduleName, (PWCHAR)temp_address1);


				for (PLIST_ENTRY64 pListEntry = (PLIST_ENTRY64)((PPEB_LDR_DATA64)pPeb->Ldr)->InLoadOrderModuleList.Flink;
					pListEntry != &((PPEB_LDR_DATA64)pPeb->Ldr)->InLoadOrderModuleList;
					pListEntry = (PLIST_ENTRY64)pListEntry->Flink)
				{
					PLDR_DATA_TABLE_ENTRY64 LdrEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY64, InLoadOrderLinks);
					if (LdrEntry->BaseDllName.Buffer == NULL)     continue;

					RtlInitUnicodeString(&usCurrentName, (PWCHAR)LdrEntry->BaseDllName.Buffer);
					if (RtlEqualUnicodeString(&usCurrentName, &Target_MouduleName,TRUE))
					{
						Moudule_Address = LdrEntry->DllBase;
						break;
					}
				}
				KeUnstackDetachProcess(&apc);
				ExFreePool(temp_address1);
				RtlCopyMemory((PVOID)DriverInfo->Buff, (PVOID)&Moudule_Address, sizeof(ULONG64));
			}
		}
		ObDereferenceObject(process);
	}
	return STATUS_SUCCESS;
}




VOID DriverUnload1(_In_ PDRIVER_OBJECT DriverObject)
{
	CmUnRegisterCallback(cookie);
}

NTSTATUS DriverEntry1(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING  RegistryPath)
{
	NTSTATUS status = STATUS_SUCCESS;
	DriverObject->DriverUnload = DriverUnload1;
	status = CmRegisterCallback(RegistryCallback,NULL,&cookie);
	return status;
}
```

`HyperHideDrv/wrRegstry.h`:

```h
#pragma once
#include <ntifs.h>

#pragma pack(push,1)
typedef struct _MyDriverStruct 
{
	ULONG		Flag;		//标记
	ULONG		MDL_Flag;		//标记
	ULONG		Pid;		//target process
	ULONG64		Address;	//读取地址
	ULONG64		Buff;		//缓冲区指针
	ULONG		Size;		//需要读取大小
}MyDriverStruct, * PMyDriverStruct;
#pragma pack(pop)













#pragma pack(4)
typedef struct _PEB32
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG Ldr;
	ULONG ProcessParameters;
	ULONG SubSystemData;
	ULONG ProcessHeap;
	ULONG FastPebLock;
	ULONG AtlThunkSListPtr;
	ULONG IFEOKey;
	ULONG CrossProcessFlags;
	ULONG UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG ApiSetMap;
} PEB32, * PPEB32;


typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;


typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;
#pragma pack()


#pragma pack(8)
typedef struct _PEB64
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG64 Mutant;
	ULONG64 ImageBaseAddress;
	ULONG64 Ldr;
	ULONG64 ProcessParameters;
	ULONG64 SubSystemData;
	ULONG64 ProcessHeap;
	ULONG64 FastPebLock;
	ULONG64 AtlThunkSListPtr;
	ULONG64 IFEOKey;
	ULONG64 CrossProcessFlags;
	ULONG64 UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG64 ApiSetMap;
} PEB64, * PPEB64;


typedef struct _PEB_LDR_DATA64
{
	ULONG Length;
	BOOLEAN Initialized;
	ULONG64 SsHandle;
	LIST_ENTRY64 InLoadOrderModuleList;
	LIST_ENTRY64 InMemoryOrderModuleList;
	LIST_ENTRY64 InInitializationOrderModuleList;
	ULONG64 EntryInProgress;
} PEB_LDR_DATA64, * PPEB_LDR_DATA64;


typedef struct _LDR_DATA_TABLE_ENTRY64
{
	LIST_ENTRY64 InLoadOrderLinks;
	LIST_ENTRY64 InMemoryOrderModuleList;
	LIST_ENTRY64 InInitializationOrderModuleList;
	ULONG64 DllBase;
	ULONG64 EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING64 FullDllName;
	UNICODE_STRING64 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union
	{
		LIST_ENTRY64 HashLinks;
		ULONG64 SectionPointer;
	};
	ULONG CheckSum;
	union
	{
		ULONG TimeDateStamp;
		ULONG64 LoadedImports;
	};
	ULONG64 EntryPointActivationContext;
	ULONG64 PatchInformation;
} LDR_DATA_TABLE_ENTRY64, * PLDR_DATA_TABLE_ENTRY64;


#pragma pack()
```

`HyperHideDrv/获取汇编指令长度.h`:

```h
#ifndef INSN_LEN_H
#define INSN_LEN_H

/* References:
 * Intel 64 and IA-32 Architectures Software Developer's Manuals - Volume 2A Ch. 2
 * http://ref.x86asm.net
 * http://sandpile.org
 */

#ifdef __cplusplus
extern "C" {
#endif

#define Mod_M       0xc0
#define RM_M        0x7
#define Base_M      0x7
#define REX_W       0x8

#define MAX_INSN_LEN_x86    15
#define MAX_INSN_LEN_x86_32 MAX_INSN_LEN_x86
#define MAX_INSN_LEN_x86_64 MAX_INSN_LEN_x86

enum __bits { __b16, __b32, __b64 };

#ifdef __i386__
#define insn_len(insn)  insn_len_x86_32(insn)
#define MAX_INSN_LEN    MAX_INSN_LEN_x86_32
#elif defined(__x86_64__)
#define insn_len(insn)  insn_len_x86_64(insn)
#define MAX_INSN_LEN    MAX_INSN_LEN_x86_64
#endif

/* This function returns the length of an x86 instruction.
 * I assume that instruction is valid.
 */
static inline int __insn_len_x86(void *insn, enum __bits bits) {
	int len = 0, twobytes = 0, has_modrm = 0;
	enum __bits operand_bits = __b32, addr_bits = bits;
	unsigned char *c = (unsigned char*)insn, modrm, opcode;

	/* prefixes
	 *
	 * 0xf0, 0xf2, 0xf3, 0x2e, 0x36
	 * 0x3e, 0x26, 0x64, 0x65, 0x66, 0x67
	 */

	// skip prefixes
	while (*c == 0xf0 || *c == 0xf2 || *c == 0xf3 ||
	       *c == 0x2e || *c == 0x36 || *c == 0x3e || *c == 0x26 ||
	       (*c & 0xfc) == 0x64) {
		if (*c == 0x66) // 16bits operands
			operand_bits = __b16;
		if (*c == 0x67) // 16bits addressing (x86-32), 32bits addressing (x86-64)
			addr_bits = bits == __b32 ? __b16 : __b32;
		c++;
		len++;
	}

	if (bits == __b64 && (*c & 0xf0) == 0x40) { // x86-64 && REX byte
		if (*c & REX_W)
			operand_bits = __b64;
		c++;
		len++;
	}

	/* 0x9b prefix is used only by the following 1byte opcodes
	 *
	 * 0xd9 Mod != 11 Reg/Op = 110 or 111
	 * 0xdb ModR/M = 0xe2 or 0xe3
	 * 0xdd Reg/Op = 110 or 111
	 * 0xdf ModR/M = 0xe0
	 */

	// check for 2bytes opcodes (0x0f prefix)
	if (*c == 0x0f) {
		twobytes = 1;
		c++;
		len++;
	} else if (*c == 0x9b && // check 0x9b prefix
		   ( (c[1] == 0xd9 && (c[2] & Mod_M) != Mod_M && (c[2] & 0x30) == 0x30) ||
		     (c[1] == 0xdb && (c[2] == 0xe2 || c[2] == 0xe3)) ||
		     (c[1] == 0xdd && (c[2] & 0x30) == 0x30) ||
		     (c[1] == 0xdf && c[2] == 0xe0)
			   )) {
		c++;
		len++;
	}

	opcode = *c++;
	len++;

	/* 1byte opcodes that use ModR/M byte:
	 *
	 * 0x00 - 0x03, 0x08 - 0x0b,
	 * 0x10 - 0x13, 0x18 - 0x1b,
	 * 0x20 - 0x23, 0x28 - 0x2b,
	 * 0x30 - 0x33, 0x38 - 0x3b,
	 * 0x62, 0x63, 0x69, 0x6b,
	 * 0x80 - 0x8f, 0xc0, 0xc1,
	 * 0xc4 - 0xc7,
	 * 0xd0 - 0xd3, 0xd8 - 0xdf
	 * 0xf6, 0xf7, 0xfe, 0xff
	 */

	if (!twobytes &&
	    ((opcode & 0xf4) == 0 || (opcode & 0xf4) == 0x10 ||
	     (opcode & 0xf4) == 0x20 || (opcode & 0xf4) == 0x30 ||
	     opcode == 0x62 || opcode == 0x63 || opcode == 0x69 || opcode == 0x6b ||
	     (opcode & 0xf0) == 0x80 || opcode == 0xc0 || opcode == 0xc1 ||
	     (opcode & 0xfc) == 0xc4 || (opcode & 0xfc) == 0xd0 ||
	     (opcode & 0xf8) == 0xd8 || opcode == 0xf6 || opcode == 0xf7 ||
	     opcode == 0xfe || opcode == 0xff))
		has_modrm = 1;

	/* 2bytes opcodes that they *don't* use ModR/M byte:
	 *
	 * 0x05 - 0x09, 0x0b, 0x0e,
	 * 0x30 - 0x37, 0x77, 0x80 - 0x8f,
	 * 0xa0 - 0xa2, 0xa8 - 0xaa, 0xb9
	 * 0xc8 - 0xcf
	 */

	if (twobytes) {
		if (!((opcode >= 0x05 && opcode <= 0x09) || opcode == 0x0b ||
		      opcode == 0x0e || (opcode & 0xf8) == 0x30 || opcode == 0x77 ||
		      (opcode & 0xf0) == 0x80 || (opcode >= 0xa0 && opcode <= 0xa2) ||
		      (opcode >= 0xa8 && opcode <= 0xaa) || (opcode & 0xf8) == 0xc8 ||
		      opcode == 0xb9))
			has_modrm = 1;

		// 3bytes opcodes
		if (opcode == 0x38 || opcode == 0x3a) {
			c++;
			len++;
		}

		// 3DNow! opcode
		if (opcode == 0x0f)
			len++;
	}

	if (has_modrm) {
		len++;
		modrm = *c++;
		if (addr_bits != __b16 && (modrm & (Mod_M | RM_M)) == 5) // Mod = 00 R/M = 101
			len += 4;
		if (addr_bits == __b16 && (modrm & (Mod_M | RM_M)) == 6) // Mod = 00 R/M = 110 and 16bits addressing
			len += 2;
		if ((modrm & Mod_M) == 0x40) // Mod = 01
			len += 1;
		if ((modrm & Mod_M) == 0x80) // Mod = 10
			len += addr_bits == __b16 ? 2 : 4;

		// check SIB byte
		if (addr_bits != __b16 && (modrm & Mod_M) != Mod_M && (modrm & RM_M) == 4) { // if it has SIB
			len++;
			if ((modrm & Mod_M) == 0 && (*c & Base_M) == 5) // Mod = 00   SIB Base = 101
				len += 4;
			c++;
		}
	}

	/* Immediate operands
	 *
	 * 1byte opcode list:
	 *
	 * imm8 (1 byte)
	 *
	 * 0x04, 0x0c, 0x14, 0x1c, 0x24, 0x2c, 0x34, 0x3c, 0x6a, 0x6b, 0x70 - 0x7f,
	 * 0x80, 0x82, 0x83, 0xa8, 0xb0 - 0xb7, 0xc0, 0xc1, 0xc6, 0xcd, 0xd4,
	 * 0xd5, 0xe0 - 0xe7, 0xeb, 0xf6 (Reg/Op = 000 or Reg/Op = 001)
	 *
	 * imm16 (2 bytes)
	 *
	 * 0xc2, 0xca
	 *
	 * imm16/32 (2 bytes if operand_bits == __b16 else 4 bytes)
	 *
	 * 0x05, 0x0d, 0x15, 0x1d, 0x25, 0x2d, 0x35, 0x3d, 0x68, 0x69, 0x81, 0xa9
	 * 0xc7, 0xe8, 0xe9
	 *
	 * imm16/32/64 (2 bytes if operand_bits == __b16, 4 bytes if __b32, 8 bytes if __b64)
	 *
	 * 0xb8 - 0xbf, 0xf7 (Reg/Op = 000 or Reg/Op = 001)
	 *
	 * moffs (2 bytes if addr_bits == __b16, 4 bytes if __b32, 8 bytes if __b64)
	 *
	 * 0xa0, 0xa1, 0xa2, 0xa3
	 *
	 * others
	 *
	 * 0xea, 0x9a: imm16 + imm16/32
	 * 0xc8: imm16 + imm8
	 *
	 *
	 * 2bytes opcode list:
	 *
	 * imm8 (1 byte)
	 *
	 * 0x70 - 0x73, 0xa4, 0xac, 0xba, 0xc2, 0xc4 - 0xc6
	 *
	 * imm16/32 (2 bytes if operand_bits == __b16 else 4 bytes)
	 *
	 * 0x80 - 0x8f
	 *
	 *
	 * all 3bytes opcodes with 0x3a prefix have imm8
	 */
	if (!twobytes) { // 1byte opcodes
		// imm8
		if (((opcode & 7) == 4 && (opcode & 0xf0) <= 0x30) ||
		    opcode == 0x6a || opcode == 0x6b || (opcode & 0xf0) == 0x70 ||
		    opcode == 0x80 || opcode == 0x82 || opcode == 0x83 ||
		    opcode == 0xa8 || (opcode & 0xf8) == 0xb0 || opcode == 0xc0 ||
		    opcode == 0xc1 || opcode == 0xc6 || opcode == 0xcd ||
		    opcode == 0xd4 || opcode == 0xd5 || (opcode & 0xf8) == 0xe0 ||
		    opcode == 0xeb || (opcode == 0xf6 && (modrm & 0x30) == 0))
			len += 1;

		// imm16
		if (opcode == 0xc2 || opcode == 0xca)
			len += 2;

		// imm16/32
		if (((opcode & 7) == 5 && (opcode & 0xf0) <= 0x30) ||
		    opcode == 0x68 || opcode == 0x69 || opcode == 0x81 ||
		    opcode == 0xa9 || opcode == 0xc7 || opcode == 0xe8 ||
		    opcode == 0xe9)
			len += operand_bits == __b16 ? 2 : 4;

		// imm16/32/64
		if ((opcode & 0xf8) == 0xb8 || (opcode == 0xf7 && (modrm & 0x30) == 0))
			len += operand_bits == __b16 ? 2 : operand_bits == __b32 ? 4 : 8;

		// moffs
		if ((opcode & 0xfc) == 0xa0)
			len += addr_bits == __b16 ? 2 : addr_bits == __b32 ? 4 : 8;

		// others
		if (opcode == 0xea || opcode == 0x9a)
			len += 2 + (operand_bits == __b16 ? 2 : 4);
		if (opcode == 0xc8)
			len += 3;
	} else { // 2bytes opcodes
		// imm8
		if ((opcode & 0xfc) == 0x70 || opcode == 0xa4 ||
		    opcode == 0xac || opcode == 0xba || opcode == 0xc2 ||
		    (opcode >= 0xc4 && opcode <= 0xc6))
			len += 1;

		// imm16/32
		if ((opcode & 0xf0) == 0x80)
			len += operand_bits == __b16 ? 2 : 4;

		// 3bytes opcodes with 0x3a prefix
		if (opcode == 0x3a)
			len += 1;
	}

	// wrong length
	if (len > MAX_INSN_LEN_x86)
		len = 1;

	return len;
}

/*==============================================================================*/
/*                            获取32位指令长度                                  */
/*==============================================================================*/
static int insn_len_x86_32(void *insn) {
	return __insn_len_x86(insn, __b32);
}

/*==============================================================================*/
/*                            获取64位指令长度                                  */
/*==============================================================================*/
static int insn_len_x86_64(void *insn) {
	return __insn_len_x86(insn, __b64);
}






#ifdef __cplusplus
}
#endif

#endif
```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
```

`README.md`:

```md
# vt-debugger
vt框架使用的airhv,增加了自建调试体系部分,稍微修改下可以调试大部分游戏,给学习vt的同学参考
vt调试器:
1. ept hook.
2. 无痕int3.
3. 自建调试体系隐藏debugport.
4. 支持pdb符号自动下载，省去寻找特征码步骤,轻松兼容不同系统版本.
5. 5.zip文件是编译好的成品，后面会持续更新
6. 支持平台 win10 x64 intel architecture cpu.
7. 如果你在虚拟机里测试:虚拟机的配置:[内存>=4GB, cpu核心数>=2]

the soruce code is based in hyperhide, with less modify it can debug a lot games.
vt debugger:
1. ept hook.
2. invisible int3 breakpoint.
3. self constrcution of debug system hide debugport.
4. 4. download pdb automally, compatible with different system.
5. 5.zip file is compiled, it will update constantly
6. support platform win10 x64 intel architecture cpu.
7. if you test on virtual machine [virtual machine config:memory >=4GB, cpu core>=2]

![vtDebugger](https://user-images.githubusercontent.com/22963370/172332062-c2093279-8377-41ae-ace0-bc52a389b974.png)
![3 $`D%D1~HPNNLJ($05NKFE](https://user-images.githubusercontent.com/22963370/176587742-1e54b140-2180-4fb2-946f-0409c9364f2e.png)

```

`airhv/airhv-main/LICENSE`:

```
MIT License

Copyright (c) 2021 Air14

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`airhv/airhv-main/README.md`:

```md
# airhv

airhv is a simple hypervisor based on Intel VT-x mainly focused on ept hooking
## Features
* Ept support with mapping of 2MB pages (splitted dynamicly to 4KB pages if needed)
* Ability to run in VMWare which is using few IO ports for communication between vmtools and VMWare hypervisor
* Ability to handle various VM-exit cases: `CPUID` `RDTSC` `RDTSCP` `RDRAND` `RDSEED` `WBINVD/INVD` `IN/OUT` `XSETBV` `RDMSR` `WRMSR` `INVPCID` `MOV DR` `CR ACCESS` `EXCEPTIONS/NMI` `VMCALL` `INVLPG`  `GDTR/IDTR ACCESS` `LDTR/TR ACCESS`
* Ability to perform inline hooking via ept
* Included simple driver (airhvctrl) which is communicating with hypervisor via `VMCALL` to hook syscall (via ept).
It hooks NtCreateFile and every time user when tries to create a file named test.txt it prevents user from doing that.

## Future possible features
* Ability to run under AMD-SVM
* Ability to handle more VM-exit cases
* Ability to make hypervisor not detectable via counters (rdtsc,rdtscp)
* Ability to run nested VMs
* MSR_LSTAR hooking

## Compilation

Compile with Visual Studio 2019 (Requires [WDK](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk))

## Supported hardware
Intel processors with VT-x and EPT support

## Supported platforms
Windows 7 - Windows 10, x64 only

## License
airhv is under MIT license.  
Dependencies are licensed by their own licenses.

```

`airhv/airhv-main/airhv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30907.101
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "airhv", "airhv\airhv.vcxproj", "{CC497BEE-6B9E-4732-8B60-35DFE6526C28}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "airhvctrl", "airhvctrl\airhvctrl.vcxproj", "{98E8F109-6A08-4461-A245-42B7CE32A703}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug_Minimal|x64 = Debug_Minimal|x64
		Debug|x64 = Debug|x64
		Release_Minimal|x64 = Release_Minimal|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Debug_Minimal|x64.ActiveCfg = Debug_Minimal|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Debug_Minimal|x64.Build.0 = Debug_Minimal|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Debug_Minimal|x64.Deploy.0 = Debug_Minimal|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Debug|x64.ActiveCfg = Debug|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Debug|x64.Build.0 = Debug|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Debug|x64.Deploy.0 = Debug|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Release_Minimal|x64.ActiveCfg = Release_Minimal|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Release_Minimal|x64.Build.0 = Release_Minimal|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Release_Minimal|x64.Deploy.0 = Release_Minimal|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Release|x64.ActiveCfg = Release|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Release|x64.Build.0 = Release|x64
		{CC497BEE-6B9E-4732-8B60-35DFE6526C28}.Release|x64.Deploy.0 = Release|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Debug_Minimal|x64.ActiveCfg = Debug|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Debug_Minimal|x64.Build.0 = Debug|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Debug_Minimal|x64.Deploy.0 = Debug|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Debug|x64.ActiveCfg = Debug|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Debug|x64.Build.0 = Debug|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Debug|x64.Deploy.0 = Debug|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Release_Minimal|x64.ActiveCfg = Release_Minimal|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Release_Minimal|x64.Build.0 = Release_Minimal|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Release_Minimal|x64.Deploy.0 = Release_Minimal|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Release|x64.ActiveCfg = Release|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Release|x64.Build.0 = Release|x64
		{98E8F109-6A08-4461-A245-42B7CE32A703}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A387B9A7-546D-4699-8524-1E3CC92C3650}
	EndGlobalSection
EndGlobal

```

`airhv/airhv-main/airhv/airhv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug_Minimal|x64">
      <Configuration>Debug_Minimal</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_Minimal|x64">
      <Configuration>Release_Minimal</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{CC497BEE-6B9E-4732-8B60-35DFE6526C28}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>airhv</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
    <ProjectName>airhv</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_Minimal|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_Minimal|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_Minimal|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_Minimal|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <ShowIncludes>true</ShowIncludes>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_Minimal|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <ShowIncludes>true</ShowIncludes>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PreprocessorDefinitions>_MINIMAL;_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <ShowIncludes>true</ShowIncludes>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfLdr.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfDriverEntry.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_Minimal|x64'">
    <ClCompile>
      <ShowIncludes>true</ShowIncludes>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PreprocessorDefinitions>_MINIMAL;_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfLdr.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfDriverEntry.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ept.cpp" />
    <ClCompile Include="hypervisor_gateway.cpp" />
    <ClCompile Include="hypervisor_routines.cpp" />
    <ClCompile Include="invalidators.cpp" />
    <ClCompile Include="log.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="poolmanager.cpp" />
    <ClCompile Include="spinlock.cpp" />
    <ClCompile Include="vmcs.cpp" />
    <ClCompile Include="vmcall_handler.cpp" />
    <ClCompile Include="vmexit_handler.cpp" />
    <ClCompile Include="vmm.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="allocators.h" />
    <ClInclude Include="asm\vm_context.h" />
    <ClInclude Include="asm\vm_intrin.h" />
    <ClInclude Include="common.h" />
    <ClInclude Include="hypervisor_gateway.h" />
    <ClInclude Include="ia32\cpuid.h" />
    <ClInclude Include="ia32\cr.h" />
    <ClInclude Include="ia32\dr.h" />
    <ClInclude Include="ia32\ept.h" />
    <ClInclude Include="ia32\msr.h" />
    <ClInclude Include="ia32\mtrr.h" />
    <ClInclude Include="ia32\rflags.h" />
    <ClInclude Include="ia32\segment.h" />
    <ClInclude Include="ia32\vmcs.h" />
    <ClInclude Include="ia32\vmcs_encodings.h" />
    <ClInclude Include="hypervisor_routines.h" />
    <ClInclude Include="interrupt.h" />
    <ClInclude Include="invalidators.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="ntapi.h" />
    <ClInclude Include="poolmanager.h" />
    <ClInclude Include="vmcall_reason.h" />
    <ClInclude Include="vmcall_handler.h" />
    <ClInclude Include="vmexit_handler.h" />
    <ClInclude Include="vmm.h" />
    <ClInclude Include="xsave.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="asm\vm_context.asm" />
    <MASM Include="asm\vm_intrin.asm" />
    <MASM Include="lde\lde64.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`airhv/airhv-main/airhv/airhv.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="asm">
      <UniqueIdentifier>{73422af8-864e-442f-a192-be64adb0a0fc}</UniqueIdentifier>
    </Filter>
    <Filter Include="lde">
      <UniqueIdentifier>{136f69bf-5e7e-4a02-ab6a-1aef8e5a1207}</UniqueIdentifier>
    </Filter>
    <Filter Include="ia32">
      <UniqueIdentifier>{797b5b3d-b662-46aa-91a2-ba6aa5ce53d3}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ept.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmcs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="poolmanager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="spinlock.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hypervisor_routines.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmcall_handler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmexit_handler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hypervisor_gateway.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="invalidators.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmm.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="poolmanager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ntapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hypervisor_routines.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hypervisor_gateway.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ia32\cpuid.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="ia32\cr.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="ia32\dr.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="ia32\ept.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="ia32\msr.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="ia32\mtrr.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="ia32\rflags.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="ia32\vmcs.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="ia32\vmcs_encodings.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ia32\segment.h">
      <Filter>ia32</Filter>
    </ClInclude>
    <ClInclude Include="asm\vm_context.h">
      <Filter>asm</Filter>
    </ClInclude>
    <ClInclude Include="asm\vm_intrin.h">
      <Filter>asm</Filter>
    </ClInclude>
    <ClInclude Include="vmcall_handler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vmcall_reason.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vmexit_handler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="interrupt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="allocators.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="invalidators.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vmm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="xsave.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="lde\lde64.asm">
      <Filter>lde</Filter>
    </MASM>
    <MASM Include="asm\vm_context.asm">
      <Filter>asm</Filter>
    </MASM>
    <MASM Include="asm\vm_intrin.asm">
      <Filter>asm</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`airhv/airhv-main/airhv/airhv.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>WindowsRemoteDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_Minimal|x64'">
    <DebuggerFlavor>WindowsRemoteDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`airhv/airhv-main/airhv/allocators.h`:

```h
#pragma once
#include <ntddk.h>
#include "common.h"

/// <summary>
/// Allocate NonPagedPool with hypervisor tag, custom size
/// </summary>
/// <typeparam name="T"> Return type </typeparam>
/// <param name="size"> Size of allocation, base value is sizeof(T) </param>
/// <returns></returns>
template <typename T>
inline T allocate_pool(unsigned __int64 size)
{
    return (T)ExAllocatePoolWithTag(NonPagedPool, size, VMM_TAG);
}

/// <summary>
/// Allocate NonPagedPool size of T with hypervisor tag,
/// </summary>
/// <typeparam name="T"> Return type </typeparam>
/// <param name="size"> Size of allocation, base value is sizeof(T) </param>
/// <returns></returns>
template <typename T>
inline T* allocate_pool()
{
    return (T*)ExAllocatePoolWithTag(NonPagedPool, sizeof(T), VMM_TAG);
}

/// <summary>
/// Allocate Contignous memory size of T
/// </summary>
/// <typeparam name="T"> Return type </typeparam>
/// <returns></returns>
template <typename T>
inline T* allocate_contignous_memory()
{
    PHYSICAL_ADDRESS a;
    a.QuadPart = 0ULL - 1;
    return (T*)MmAllocateContiguousMemory(sizeof(T), a);
}

/// <summary>
/// Allocate Contignous memory custom size
/// </summary>
/// <typeparam name="T"> Return type </typeparam>
/// <returns></returns>
template <typename T>
inline T allocate_contignous_memory(unsigned __int64 size)
{
    PHYSICAL_ADDRESS a;
    a.QuadPart = 0ULL - 1;
    return (T)MmAllocateContiguousMemory(size, a);
}

/// <summary>
/// Free pool with tahg
/// </summary>
/// <param name="pool_address"> Base address of pool </param>
inline void free_pool(void* pool_address)
{
    ExFreePoolWithTag(pool_address, VMM_TAG);
}

/// <summary>
/// Free contignous memory
/// </summary>
/// <param name="memory_address"> Contignous memory base address </param>
inline void free_contignous_memory(void* memory_address)
{
    MmFreeContiguousMemory(memory_address);
}
```

`airhv/airhv-main/airhv/asm/vm_context.asm`:

```asm
.CODE                                                                                                                                                                            
extern ?vmexit_handler@@YA_NPEAU__vmexit_guest_registers@@@Z : proc
extern ?init_logical_processor@@YAXPEAX@Z : proc
extern ?return_rsp_for_vmxoff@@YA_KXZ : proc
extern ?return_rip_for_vmxoff@@YA_KXZ : proc

PUBLIC ?vmm_entrypoint@@YAXXZ
PUBLIC ?vmx_restore_state@@YAXXZ
PUBLIC ?vmx_save_state@@YAXXZ

SAVE_GP macro
        push    rax
        push    rcx
        push    rdx
        push    rbx
        push    -01h ; placeholder for rsp
        push    rbp 
        push    rsi
        push    rdi
        push    r8
        push    r9
        push    r10
        push    r11
        push    r12
        push    r13
        push    r14
        push    r15
endm
RESTORE_GP macro
        pop     r15
        pop     r14
        pop     r13
        pop     r12
        pop     r11
        pop     r10
        pop     r9
        pop     r8
        pop     rdi
        pop     rsi
        pop     rbp
        pop     rbx ; placeholder for rsp
        pop     rbx
        pop     rdx
        pop     rcx
        pop     rax
endm

?vmm_entrypoint@@YAXXZ proc
    SAVE_GP
    sub     rsp ,60h
    movdqa  xmmword ptr [rsp], xmm0
    movdqa  xmmword ptr [rsp+10h], xmm1
    movdqa  xmmword ptr [rsp+20h], xmm2
    movdqa  xmmword ptr [rsp+30h], xmm3
    movdqa  xmmword ptr [rsp+40h], xmm4
    movdqa  xmmword ptr [rsp+50h], xmm5
    mov     rcx, rsp
    sub     rsp,  20h
    call    ?vmexit_handler@@YA_NPEAU__vmexit_guest_registers@@@Z
    add     rsp, 20h
    movdqa  xmm0, xmmword ptr [rsp]
    movdqa  xmm1, xmmword ptr [rsp+10h]
    movdqa  xmm2, xmmword ptr [rsp+20h]
    movdqa  xmm3, xmmword ptr [rsp+30h]
    movdqa  xmm4, xmmword ptr [rsp+40h]
    movdqa  xmm5, xmmword ptr [rsp+50h]
    add     rsp,  60h
    cmp     al, 1
    jnz      exit
    RESTORE_GP
    vmresume
exit:
    sub rsp, 20h
    call ?return_rsp_for_vmxoff@@YA_KXZ
    add rsp, 20h

    push rax

    sub rsp, 20h
    call ?return_rip_for_vmxoff@@YA_KXZ
    add rsp, 20h

    push rax

    mov rcx,rsp
    mov rsp,[rcx+8h]
    mov rax,[rcx]
    push rax

    mov r15,[rcx+10h]
    mov r14,[rcx+18h]
    mov r13,[rcx+20h]
    mov r12,[rcx+28h]
    mov r11,[rcx+30h]
    mov r10,[rcx+38h]
    mov r9,[rcx+40h]
    mov r8,[rcx+48h]
    mov rdi,[rcx+50h]
    mov rsi,[rcx+58h]
    mov rbp,[rcx+60h]
    mov rbx,[rcx+70h]
    mov rdx,[rcx+78h]
    mov rax,[rcx+88h]
    mov rcx,[rcx+80h]

    ret
?vmm_entrypoint@@YAXXZ endp

?vmx_save_state@@YAXXZ PROC
    pushfq
    SAVE_GP
    sub rsp, 020h
    mov rcx, rsp
    call ?init_logical_processor@@YAXPEAX@Z
    int 3 ; we should never be here

?vmx_save_state@@YAXXZ ENDP

?vmx_restore_state@@YAXXZ PROC
	add rsp, 020h
	RESTORE_GP
    popfq
	ret
?vmx_restore_state@@YAXXZ ENDP

END
```

`airhv/airhv-main/airhv/asm/vm_context.h`:

```h
#pragma once
#include "vmexit_handler.h"

void vmm_entrypoint();
void vmx_restore_state();
void vmx_save_state();
```

`airhv/airhv-main/airhv/asm/vm_intrin.asm`:

```asm
.CODE                                                                                                                                                                            

__writecr2 proc
    mov cr2,rcx
    ret
__writecr2 endp

__read_ldtr proc
    sldt ax
    ret
__read_ldtr endp

__read_tr proc
    str ax
    ret
__read_tr endp

__read_cs proc
    mov ax, cs
    ret
__read_cs endp

__read_ss proc
    mov ax, ss
    ret
__read_ss endp

__read_ds proc
    mov ax, ds
    ret
__read_ds endp

__read_es proc
    mov ax, es              
    ret
__read_es endp

__read_fs proc
    mov ax, fs
    ret
__read_fs endp

__read_gs proc
    mov ax, gs
    ret
__read_gs endp

__sgdt proc
    sgdt qword ptr [rcx]
    ret
__sgdt endp

__sidt proc
    sidt qword ptr [rcx]
    ret
__sidt endp

__load_ar proc
    lar rax, rcx
    jz no_error
    xor rax, rax
no_error:
    ret
__load_ar endp

__vm_call proc
    mov rax,0CDAEFAEDBBAEBEEFh
    vmcall
    ret
__vm_call endp

__vm_call_ex proc
        mov  rax,0CDAEFAEDBBAEBEEFh ; Our vmcall indentitifer

        sub rsp, 30h
        mov qword ptr [rsp],       r10
        mov qword ptr [rsp + 8h],  r11
        mov qword ptr [rsp + 10h], r12
        mov qword ptr [rsp + 18h], r13
        mov qword ptr [rsp + 20h], r14
        mov qword ptr [rsp + 28h], r15

        mov r10, qword ptr [rsp + 58h]
        mov r11, qword ptr [rsp + 60h]
        mov r12, qword ptr [rsp + 68h]
        mov r13, qword ptr [rsp + 70h]
        mov r14, qword ptr [rsp + 78h]
        mov r15, qword ptr [rsp + 80h]

        vmcall
        mov r10, qword ptr [rsp]
        mov r11, qword ptr [rsp + 8h]
        mov r12, qword ptr [rsp + 10h]
        mov r13, qword ptr [rsp + 18h]
        mov r14, qword ptr [rsp + 20h]
        mov r15, qword ptr [rsp + 28h]
        add rsp, 30h

        ret
__vm_call_ex endp

__hyperv_vm_call proc
    vmcall
    ret
__hyperv_vm_call endp

__reload_gdtr PROC
	push rcx
	shl rdx, 48
	push rdx
	lgdt fword ptr [rsp+6]
	pop rax
	pop rax
	ret
__reload_gdtr ENDP


__reload_idtr PROC
	push rcx
	shl	 rdx, 48
	push rdx
	lidt fword ptr [rsp+6]
	pop	rax
	pop	rax
	ret
__reload_idtr ENDP

__invept PROC
    invept rcx,oword ptr[rdx]
    ret
__invept ENDP

__invvpid PROC
    invvpid rcx,oword ptr[rdx]
    ret
__invvpid ENDP

END
```

`airhv/airhv-main/airhv/asm/vm_intrin.h`:

```h
#pragma once
extern "C"
{
	unsigned short __read_ldtr(void);
	unsigned short __read_tr(void);
	unsigned short __read_cs(void);
	unsigned short __read_ss(void);
	unsigned short __read_ds(void);
	unsigned short __read_es(void);
	unsigned short __read_fs(void);
	unsigned short __read_gs(void);
	void __sgdt(void*);
	void __sidt(void*);
	unsigned __int32 __load_ar(unsigned __int16);
	bool __vm_call(unsigned __int64 vmcall_reason, unsigned __int64 rdx, unsigned __int64 r8, unsigned __int64 r9);
	bool __vm_call_ex(unsigned __int64 vmcall_reason, unsigned __int64 rdx, unsigned __int64 r8, unsigned __int64 r9, unsigned __int64 r10, unsigned __int64 r11, unsigned __int64 r12, unsigned __int64 r13, unsigned __int64 r14, unsigned __int64 r15);
	unsigned __int64 __hyperv_vm_call(unsigned __int64 param1, unsigned __int64 param2, unsigned __int64 param3);
	void __reload_gdtr(unsigned __int64 base, unsigned long limit);
	void __reload_idtr(unsigned __int64 base, unsigned long limit);
	void __invept(unsigned __int32 type, void* descriptors);
	void __invvpid(unsigned __int32 type, void* descriptors);
	void __writecr2(unsigned __int64 cr2);
	int __cdecl _rdseed16_step(unsigned __int16* return_value);
	int __cdecl _rdseed32_step(unsigned __int32* return_value);
	int __cdecl _rdseed64_step(unsigned __int64* return_value);
}
```

`airhv/airhv-main/airhv/common.h`:

```h
#pragma once
#include <ntddk.h>
#include "ia32\ept.h"
#include "poolmanager.h"
#include "ia32\exception.h"
#include "ia32\mtrr.h"
#include "ia32\rflags.h"

extern "C" size_t __fastcall LDE(const void* lpData, unsigned int size);

#define VMCALL_IDENTIFIER 0xCDAEFAEDBBAEBEEF
#define VMM_TAG 'vhra'
#define VMM_STACK_SIZE 0x6000

#define LARGE_PAGE_SIZE 0x200000
#define GET_PFN(_VAR_) (_VAR_ >> PAGE_SHIFT)

#define MASK_GET_HIGHER_32BITS(_ARG_)(_ARG_ & 0xffffffff00000000)
#define MASK_GET_LOWER_32BITS(_ARG_)(_ARG_ & 0xffffffff)
#define MASK_GET_LOWER_16BITS(_ARG_)(_ARG_ & 0xffff)
#define MASK_GET_LOWER_8BITS(_ARG_)(_ARG_ & 0xff)
#define MASK_32BITS 0xffffffff

struct __vmexit_guest_registers
{
    __m128 xmm[6];
    unsigned __int64 r15;
    unsigned __int64 r14;                  
    unsigned __int64 r13;
    unsigned __int64 r12;                  
    unsigned __int64 r11;
    unsigned __int64 r10;                  
    unsigned __int64 r9;
    unsigned __int64 r8;                   
    unsigned __int64 rdi;
    unsigned __int64 rsi;
    unsigned __int64 rbp;
    unsigned __int64 rsp;
    unsigned __int64 rbx;
    unsigned __int64 rdx;                  
    unsigned __int64 rcx;
    unsigned __int64 rax;
};

struct __ept_state
{
    LIST_ENTRY hooked_page_list;
    __mtrr_range_descriptor memory_range[100];
    unsigned __int32 enabled_memory_ranges;
    unsigned __int8 default_memory_type;
    __eptp* ept_pointer;
    __vmm_ept_page_table* ept_page_table;
    volatile long pml_lock;
};

struct __vmcs
{
    union
    {
        unsigned int all;
        struct
        {
            unsigned int revision_identifier : 31;
            unsigned int shadow_vmcs_indicator : 1;
        };
    } header;
    unsigned int abort_indicator;
    char data[0x1000 - 2 * sizeof(unsigned)];
};

struct __vcpu
{
    void* vmm_stack;

    __vmcs* vmcs;
    unsigned __int64 vmcs_physical;

    __vmcs* vmxon;
    unsigned __int64 vmxon_physical;

    struct __vmexit_info
    {
        __vmexit_guest_registers* guest_registers;

        unsigned __int64 guest_rip;

       __rflags guest_rflags;

        unsigned __int64 instruction_length;

        unsigned __int64 reason;

        unsigned __int64 qualification;

        unsigned __int64 instruction_information;

    }vmexit_info;

    struct __vcpu_status
    {
        unsigned __int64 vmx_on;
        unsigned __int64 vmm_launched;
    }vcpu_status;

    struct __vmx_off_state
    {
        unsigned __int64  vmx_off_executed;
        unsigned __int64  guest_rip;
        unsigned __int64  guest_rsp;
    }vmx_off_state;

    struct __vcpu_bitmaps
    {
        unsigned __int8* msr_bitmap;
        unsigned __int64 msr_bitmap_physical;

        unsigned __int8* io_bitmap_a;
        unsigned __int64 io_bitmap_a_physical;

        unsigned __int8* io_bitmap_b;
        unsigned __int64 io_bitmap_b_physical;
    }vcpu_bitmaps;
};

struct __vmm_context
{
    __vcpu** vcpu_table;
    pool_manager::__pool_manager* pool_manager;
    __ept_state* ept_state;

    unsigned __int32 processor_count;
    unsigned __int32 highest_basic_leaf;
    bool hv_presence;
};

extern __vmm_context* g_vmm_context;

namespace spinlock 
{
    bool try_lock(volatile long* lock);
    void lock(volatile long* lock);
    void unlock(volatile long* lock);
}
```

`airhv/airhv-main/airhv/ept.cpp`:

```cpp
#pragma warning( disable : 4201 4244)
#include <ntddk.h>
#include <intrin.h>
#include <stdlib.h>
#include "common.h"
#include "ia32\msr.h"
#include "ia32\vmcs_encodings.h"
#include "ia32\ept.h"
#include "log.h"
#include "hypervisor_routines.h"
#include "ia32\mtrr.h"
#include "allocators.h"

namespace ept
{
	/// <summary>
	/// Build mtrr map to track physical memory type
	/// </summary>
	void build_mtrr_map()
	{
		__mtrr_cap_reg mtrr_cap = { 0 };
		__mtrr_physbase_reg current_phys_base = { 0 };
		__mtrr_physmask_reg current_phys_mask = { 0 };
		__mtrr_def_type mtrr_def_type = { 0 };
		__mtrr_range_descriptor* descriptor;

		//
		// The memory type range registers (MTRRs) provide a mechanism for associating the memory types (see Section
		// 11.3, “Methods of Caching Available”) with physical - address ranges in system memory.They allow the processor to
		// optimize operations for different types of memory such as RAM, ROM, frame - buffer memory, and memory - mapped
		// I/O devices.They also simplify system hardware design by eliminating the memory control pins used for this func -
		// tion on earlier IA - 32 processors and the external logic needed to drive them.
		//

		mtrr_cap.all = __readmsr(IA32_MTRRCAP);
		mtrr_def_type.all = __readmsr(IA32_MTRR_DEF_TYPE);

		if (mtrr_def_type.mtrr_enabled == false)
		{
			g_vmm_context->ept_state->default_memory_type = MEMORY_TYPE_UNCACHEABLE;
			return;
		}

		g_vmm_context->ept_state->default_memory_type = mtrr_def_type.memory_type;

		if (mtrr_cap.smrr_support == true)
		{
			current_phys_base.all = __readmsr(IA32_SMRR_PHYSBASE);
			current_phys_mask.all = __readmsr(IA32_SMRR_PHYSMASK);

			if (current_phys_mask.valid && current_phys_base.type != mtrr_def_type.memory_type)
			{
				descriptor = &g_vmm_context->ept_state->memory_range[g_vmm_context->ept_state->enabled_memory_ranges++];
				descriptor->physcial_base_address = current_phys_base.physbase << PAGE_SHIFT;

				unsigned long bits_in_mask = 0;
				_BitScanForward64(&bits_in_mask, current_phys_mask.physmask << PAGE_SHIFT);

				descriptor->physcial_end_address = descriptor->physcial_base_address + ((1ULL << bits_in_mask) - 1ULL);
				descriptor->memory_type = (unsigned __int8)current_phys_base.type;
				descriptor->fixed_range = false;
			}
		}

		if (mtrr_cap.fixed_range_support == true && mtrr_def_type.fixed_range_mtrr_enabled)
		{
			constexpr auto k64_base = 0x0;
			constexpr auto k64_size = 0x10000;
			constexpr auto k16_base = 0x80000;
			constexpr auto k16_size = 0x4000;
			constexpr auto k4_base = 0xC0000;
			constexpr auto k4_size = 0x1000;

			__mtrr_fixed_range_type k64_types = { __readmsr(IA32_MTRR_FIX64K_00000) };

			for (unsigned int i = 0; i < 8; i++)
			{
				descriptor = &g_vmm_context->ept_state->memory_range[g_vmm_context->ept_state->enabled_memory_ranges++];
				descriptor->memory_type = k64_types.types[i];
				descriptor->physcial_base_address = k64_base + (k64_size * i);
				descriptor->physcial_end_address = k64_base + (k64_size * i) + (k64_size - 1);
				descriptor->fixed_range = true;
			}

			for (unsigned int i = 0; i < 2; i++)
			{
				__mtrr_fixed_range_type k16_types = { __readmsr(IA32_MTRR_FIX16K_80000 + i) };

				for (unsigned int j = 0; j < 8; j++)
				{
					descriptor = &g_vmm_context->ept_state->memory_range[g_vmm_context->ept_state->enabled_memory_ranges++];
					descriptor->memory_type = k16_types.types[j];
					descriptor->physcial_base_address = (k16_base + (i * k16_size * 8)) + (k16_size * j);
					descriptor->physcial_end_address = (k16_base + (i * k16_size * 8)) + (k16_size * j) + (k16_size - 1);
					descriptor->fixed_range = true;
				}
			}

			for (unsigned int i = 0; i < 8; i++)
			{
				__mtrr_fixed_range_type k4_types = { __readmsr(IA32_MTRR_FIX4K_C0000 + i) };

				for (unsigned int j = 0; j < 8; j++)
				{
					descriptor = &g_vmm_context->ept_state->memory_range[g_vmm_context->ept_state->enabled_memory_ranges++];
					descriptor->memory_type = k4_types.types[j];
					descriptor->physcial_base_address = (k4_base + (i * k4_size * 8)) + (k4_size * j);
					descriptor->physcial_end_address = (k4_base + (i * k4_size * 8)) + (k4_size * j) + (k4_size - 1);
					descriptor->fixed_range = true;
				}
			}
		}

		//
		// Indicates the number of variable ranges
		// implemented on the processor.
		for (int i = 0; i < mtrr_cap.range_register_number; i++)
		{
			//
			// The first entry in each pair (IA32_MTRR_PHYSBASEn) defines the base address and memory type for the range;
			// the second entry(IA32_MTRR_PHYSMASKn) contains a mask used to determine the address range.The “n” suffix
			// is in the range 0 through m–1 and identifies a specific register pair.
			//
			current_phys_base.all = __readmsr(IA32_MTRR_PHYSBASE0 + (i * 2));
			current_phys_mask.all = __readmsr(IA32_MTRR_PHYSMASK0 + (i * 2));

			//
			// If range is enabled
			if (current_phys_mask.valid && current_phys_base.type != mtrr_def_type.memory_type)
			{
				descriptor = &g_vmm_context->ept_state->memory_range[g_vmm_context->ept_state->enabled_memory_ranges++];

				//
				// Calculate base address, physbase is truncated by 12 bits so we have to left shift it by 12
				//
				descriptor->physcial_base_address = current_phys_base.physbase << PAGE_SHIFT;

				//
				// Index of first bit set to one determines how much do we have to bit shift to get size of range
				// physmask is truncated by 12 bits so we have to left shift it by 12
				//
				unsigned long bits_in_mask = 0;
				_BitScanForward64(&bits_in_mask, current_phys_mask.physmask << PAGE_SHIFT);

				//
				// Calculate the end of range specified by mtrr
				//
				descriptor->physcial_end_address = descriptor->physcial_base_address + ((1ULL << bits_in_mask) - 1ULL);

				//
				// Get memory type of range
				//
				descriptor->memory_type = (unsigned __int8)current_phys_base.type;
				descriptor->fixed_range = false;
			}
		}
	}

	/// <summary>
	/// Get page cache memory type
	/// </summary>
	/// <param name="pfn"></param>
	/// <param name="is_large_page"></param>
	/// <returns></returns>
	unsigned __int8 get_memory_type(unsigned __int64 pfn, bool is_large_page)
	{
		unsigned __int64 page_start_address = is_large_page == true ? pfn * LARGE_PAGE_SIZE : pfn * PAGE_SIZE;
		unsigned __int64 page_end_address = is_large_page == true ? (pfn * LARGE_PAGE_SIZE) + (LARGE_PAGE_SIZE - 1) : (pfn * PAGE_SIZE) + (PAGE_SIZE - 1);
		unsigned __int8 memory_type = g_vmm_context->ept_state->default_memory_type;

		for (unsigned int i = 0; i < g_vmm_context->ept_state->enabled_memory_ranges; i++)
		{
			if (page_start_address >= g_vmm_context->ept_state->memory_range[i].physcial_base_address &&
				page_end_address <= g_vmm_context->ept_state->memory_range[i].physcial_end_address)
			{
				memory_type = g_vmm_context->ept_state->memory_range[i].memory_type;

				if (g_vmm_context->ept_state->memory_range[i].fixed_range == true)
					break;

				if (memory_type == MEMORY_TYPE_UNCACHEABLE)
					break;
			}
		}

		return memory_type;
	}

	/// <summary>
	/// Check if potential large page doesn't land on two or more different cache memory types
	/// </summary>
	/// <param name="pfn"></param>
	/// <returns></returns>
	bool is_valid_for_large_page(unsigned __int64 pfn)
	{
		unsigned __int64 page_start_address = pfn * LARGE_PAGE_SIZE;
		unsigned __int64 page_end_address = (pfn * LARGE_PAGE_SIZE) + (LARGE_PAGE_SIZE - 1);

		for (unsigned int i = 0; i < g_vmm_context->ept_state->enabled_memory_ranges; i++)
		{
			if (page_start_address <= g_vmm_context->ept_state->memory_range[i].physcial_end_address &&
				page_end_address > g_vmm_context->ept_state->memory_range[i].physcial_end_address)
				return false;

			else if (page_start_address < g_vmm_context->ept_state->memory_range[i].physcial_base_address &&
					 page_end_address >= g_vmm_context->ept_state->memory_range[i].physcial_base_address)
				return false;
		}

		return true;
	}

	/// <summary> 
	/// Setup page memory type
	/// </summary>
	/// <param name="entry"> Pointer to pml2 entry </param>
	/// <param name="pfn"> Page frame number </param>
	bool setup_pml2_entry(__ept_pde& entry, unsigned __int64 pfn)
	{
		entry.page_directory_entry.physical_address = pfn;
		
		if (is_valid_for_large_page(pfn) == true)
		{
			entry.page_directory_entry.memory_type = get_memory_type(pfn, true);
			return true;
		}

		else
		{
			void* split_buffer = pool_manager::request_pool<void*>(pool_manager::INTENTION_SPLIT_PML2, true, sizeof(__ept_dynamic_split));
			if (split_buffer == nullptr)
			{
				LogError("Failed to allocate split buffer");
				return false;
			}

			return split_pml2(split_buffer, pfn * LARGE_PAGE_SIZE);
		}
	}

	/// <summary>
	/// Create ept page table
	/// </summary>
	/// <returns> status </returns>
	bool create_ept_page_table()
	{
		PHYSICAL_ADDRESS max_size;
		max_size.QuadPart = MAXULONG64;

		g_vmm_context->ept_state->ept_page_table = allocate_contignous_memory<__vmm_ept_page_table>();
		if (g_vmm_context->ept_state->ept_page_table == NULL)
		{
			LogError("Failed to allocate memory for PageTable");
			return false;
		}

		__vmm_ept_page_table* page_table = g_vmm_context->ept_state->ept_page_table;
		RtlSecureZeroMemory(page_table, sizeof(__vmm_ept_page_table));

		//
		// Set all pages as rwx to prevent unwanted ept violation
		//
		page_table->pml4[0].physical_address = GET_PFN(MmGetPhysicalAddress(&page_table->pml3[0]).QuadPart);
		page_table->pml4[0].read = 1;
		page_table->pml4[0].write = 1;
		page_table->pml4[0].execute = 1;

		__ept_pdpte pdpte_template = { 0 };

		pdpte_template.read = 1;
		pdpte_template.write = 1;
		pdpte_template.execute = 1;

		__stosq((unsigned __int64*)&page_table->pml3[0], pdpte_template.all, 512);

		for (int i = 0; i < 512; i++)
			page_table->pml3[i].physical_address = GET_PFN(MmGetPhysicalAddress(&page_table->pml2[i][0]).QuadPart);

		__ept_pde pde_template = { 0 };

		pde_template.page_directory_entry.read = 1;
		pde_template.page_directory_entry.write = 1;
		pde_template.page_directory_entry.execute = 1;

		pde_template.page_directory_entry.large_page = 1;

		__stosq((unsigned __int64*)&page_table->pml2[0], pde_template.all, 512 * 512);

		for (int i = 0; i < 512; i++)
			for (int j = 0; j < 512; j++)
				if(setup_pml2_entry(page_table->pml2[i][j], (i * 512) + j) == false)
					return false;

		return true;
	}

	/// <summary>
	/// Initialize ept structure
	/// </summary>
	/// <returns></returns>
	bool initialize()
	{
		__eptp* ept_pointer = allocate_pool<__eptp*>(PAGE_SIZE);
		if (ept_pointer == NULL)
			return false;

		RtlSecureZeroMemory(ept_pointer, PAGE_SIZE);

		if (create_ept_page_table() == false)
			return false;

		ept_pointer->memory_type = g_vmm_context->ept_state->default_memory_type;

		// Indicates 4 level paging
		ept_pointer->page_walk_length = 3;

		ept_pointer->pml4_address = GET_PFN(MmGetPhysicalAddress(&g_vmm_context->ept_state->ept_page_table->pml4).QuadPart);

		g_vmm_context->ept_state->ept_pointer = ept_pointer;

		return true;
	}

	/// <summary>
	/// Get pml2 entry
	/// </summary>
	/// <param name="physical_address"></param>
	/// <returns> pointer to pml2 </returns>
	__ept_pde* get_pml2_entry(unsigned __int64 physical_address)
	{
		unsigned __int64 pml4_index = MASK_EPT_PML4_INDEX(physical_address);
		unsigned __int64 pml3_index = MASK_EPT_PML3_INDEX(physical_address);
		unsigned __int64 pml2_index = MASK_EPT_PML2_INDEX(physical_address);

		if (pml4_index > 0)
		{
			LogError("Address above 512GB is invalid");
			return nullptr;
		}

		return &g_vmm_context->ept_state->ept_page_table->pml2[pml3_index][pml2_index];
	}

	/// <summary>
	/// Get pml1 entry
	/// </summary>
	/// <param name="physical_address"></param>
	/// <returns></returns>
	__ept_pte* get_pml1_entry(unsigned __int64 physical_address)
	{
		unsigned __int64 pml4_index = MASK_EPT_PML4_INDEX(physical_address);
		unsigned __int64 pml3_index = MASK_EPT_PML3_INDEX(physical_address);
		unsigned __int64 pml2_index = MASK_EPT_PML2_INDEX(physical_address);

		if (pml4_index > 0)
		{
			LogError("Address above 512GB is invalid");
			return nullptr;
		}

		__ept_pde* pml2 = &g_vmm_context->ept_state->ept_page_table->pml2[pml3_index][pml2_index];
		if (pml2->page_directory_entry.large_page == 1)
		{
			return nullptr;
		}

		PHYSICAL_ADDRESS pfn;
		pfn.QuadPart = pml2->large_page.physical_address << PAGE_SHIFT;
		__ept_pte* pml1 = (__ept_pte*)MmGetVirtualForPhysical(pfn);

		if (pml1 == nullptr)
		{
			return nullptr;
		}

		pml1 = &pml1[MASK_EPT_PML1_INDEX(physical_address)];
		return pml1;
	}

	/// <summary>
	/// Split pml2 into 512 pml1 entries (From one 2MB page to 512 4KB pages)
	/// </summary>
	/// <param name="pre_allocated_buffer"> Pre allocated buffer for split </param>
	/// <param name="physical_address"></param>
	/// <returns> status </returns>
	bool split_pml2(void* pre_allocated_buffer, unsigned __int64 physical_address)
	{
		__ept_pde* entry = get_pml2_entry(physical_address);
		if (entry == NULL)
		{
			LogError("Invalid address passed");
			return false;
		}

		__ept_dynamic_split* new_split = (__ept_dynamic_split*)pre_allocated_buffer;
		RtlSecureZeroMemory(new_split, sizeof(__ept_dynamic_split));

		//
		// Set all pages as rwx to prevent unwanted ept violation
		//
		new_split->entry = entry;

		__ept_pte entry_template = { 0 };
		entry_template.read = 1;
		entry_template.write = 1;
		entry_template.execute = 1;
		entry_template.ept_memory_type = entry->page_directory_entry.memory_type;
		entry_template.ignore_pat = entry->page_directory_entry.ignore_pat;
		entry_template.suppress_ve = entry->page_directory_entry.suppressve;

		__stosq((unsigned __int64*)&new_split->pml1[0], entry_template.all, 512);
		for (int i = 0; i < 512; i++)
		{
			unsigned __int64 pfn = ((entry->page_directory_entry.physical_address * LARGE_PAGE_SIZE) >> PAGE_SHIFT) + i;
			new_split->pml1[i].physical_address = pfn;
			new_split->pml1[i].ept_memory_type = get_memory_type(pfn, false);
		}

		__ept_pde new_entry = { 0 };
		new_entry.large_page.read = 1;
		new_entry.large_page.write = 1;
		new_entry.large_page.execute = 1;

		new_entry.large_page.physical_address = MmGetPhysicalAddress(&new_split->pml1[0]).QuadPart >> PAGE_SHIFT;

		RtlCopyMemory(entry, &new_entry, sizeof(new_entry));

		return true;
	}

	/// <summary>
	/// Swap physcial pages and invalidate tlb
	/// </summary>
	/// <param name="entry_address"> Pointer to page table entry which we want to change </param>
	/// <param name="entry_value"> Pointer to page table entry which we want use to change </param>
	void swap_pml1(__ept_pte* entry_address, __ept_pte entry_value)
	{
		// Acquire the lock
		spinlock::lock(&g_vmm_context->ept_state->pml_lock);

		// Set the value
		entry_address->all = entry_value.all;

		// Release the lock
		spinlock::unlock(&g_vmm_context->ept_state->pml_lock);
	}

	/// <summary>
	/// Swap physcial pages and invalidate tlb
	/// </summary>
	/// <param name="entry_address"> Pointer to page table entry which we want to change </param>
	/// <param name="entry_value"> Pointer to page table entry which we want use to change </param>
	/// <param name="invalidation_type"> Specifiy if we want to invalidate single context or all contexts  </param>
	void swap_pml1_and_invalidate_tlb(__ept_pte* entry_address, __ept_pte entry_value, invept_type invalidation_type)
	{
		// Acquire the lock
		spinlock::lock(&g_vmm_context->ept_state->pml_lock);

		// Set the value
		entry_address->all = entry_value.all;

		// Invalidate the cache
		if (invalidation_type == INVEPT_SINGLE_CONTEXT)
		{
			invept_single_context(g_vmm_context->ept_state->ept_pointer->all);
		}
		else
		{
			invept_all_contexts();
		}
		// Release the lock
		spinlock::unlock(&g_vmm_context->ept_state->pml_lock);
	}

	/// <summary>
	/// Write an absolute jump, We aren't touching any register except stack so it's the most safest trampoline
	/// Size: 14 bytes
	/// </summary>
	/// <param name="target_buffer"> Pointer to trampoline buffer </param>
	/// <param name="destination_address"> Address of place where we want to jump </param>
	void hook_write_absolute_jump(unsigned __int8* target_buffer, unsigned __int64 destination_address)
	{
		// push lower 32 bits of destination address	
		target_buffer[0] = 0x68;
		*((unsigned __int32*)&target_buffer[1]) = (unsigned __int32)destination_address;

		// mov dword ptr [rsp + 4]
		target_buffer[5] = 0xc7;
		target_buffer[6] = 0x44;
		target_buffer[7] = 0x24;
		target_buffer[8] = 0x04;

		// higher 32 bits of destination address	
		*((unsigned __int32*)&target_buffer[9]) = (unsigned __int32)(destination_address >> 32);

		// ret
		target_buffer[13] = 0xc3;
	}

	/// <summary>
	/// Write relative jump,
	/// Size: 5 Bytes
	/// </summary>
	/// <param name="target_buffer"> Pointer to trampoline buffer </param>
	/// <param name="destination_address"> Address where we want to jump </param>
	/// <param name="source_address"> Address from which we want to jump </param>
	void hook_write_relative_jump(unsigned __int8* target_buffer, unsigned __int64 destination_address, unsigned __int64 source_address)
	{
		// destination - (source + sizeof instruction)
		__int32 jmp_value = destination_address - (source_address + 0x5);

		// relative jmp opcode
		target_buffer[0] = 0xe9;

		// set jmp offset
		*((__int32*)&target_buffer[1]) = jmp_value;
	}

	/// <summary>
	/// 
	/// </summary>
	/// <param name="hooked_page"> Pointer to __ept_hooked_page_info structure which holds info about hooked page </param>
	/// <param name="target_function"> Address of function which we want to hook </param>
	/// <param name="hooked_function"> Address of hooked version of function which we are hooking </param>
	/// <param name="origin_function"> Address used to call original function </param>
	/// <returns></returns>
	bool hook_instruction_memory(__ept_hooked_function_info* hooked_function_info, void* target_function, void* hooked_function,void* trampoline, void** origin_function)
	{
		unsigned __int64 hooked_instructions_size = 0;

		// Get offset of hooked function within page
		 unsigned __int64 page_offset = MASK_EPT_PML1_OFFSET((unsigned __int64)target_function);

		if (trampoline != 0)
		{
			hooked_instructions_size = 0;

			// If first 5 bytes of function are on 2 separate pages then return (Hypervisor doesn't support function hooking at page boundaries)
			if ((page_offset + 5) > PAGE_SIZE - 1)
			{
				LogError("Function at page boundary");
				return false;
			}

			while (hooked_instructions_size < 5)
			{
				hooked_instructions_size += LDE((unsigned __int8*)target_function + hooked_instructions_size, 64);
			}

			// If instructions to hook are on two seperate pages then stop hooking (Hypervisor doesn't support function hooking at page boundaries)
			if ((hooked_instructions_size + 5) > PAGE_SIZE - 1)
			{
				LogError("Function at page boundary");
				return false;
			}

			hooked_function_info->hook_size = hooked_instructions_size;

			hook_write_relative_jump(&hooked_function_info->fake_page_contents[page_offset], (unsigned __int64)trampoline, (unsigned __int64)target_function);

			RtlCopyMemory(hooked_function_info->first_trampoline_address, target_function, hooked_instructions_size);

			hook_write_absolute_jump(&hooked_function_info->first_trampoline_address[hooked_instructions_size], (unsigned __int64)target_function + hooked_instructions_size);

			*origin_function = hooked_function_info->first_trampoline_address;

			return hook_function(trampoline, hooked_function, nullptr, nullptr);
		}

		// If first 14 bytes of function are on 2 separate pages then return (Hypervisor doesn't support function hooking at page boundaries)
		if ((page_offset + 14) > PAGE_SIZE - 1)
		{
			LogError("Function at page boundary");
			return false;
		}

		// Get the full size of instructions necessary to copy
		while (hooked_instructions_size < 14)
			hooked_instructions_size += LDE((unsigned __int8*)target_function + hooked_instructions_size, 64);


		// If instructions to hook are on two seperate pages then return (Hypervisor doesn't support function hooking at page boundaries)
		if ((hooked_instructions_size + 14) > PAGE_SIZE - 1)
		{
			LogError("Function at page boundary");
			return false;
		}

		hooked_function_info->hook_size = hooked_instructions_size;

		//
		// Now it's trampoline so we don't have to store origin function
		if (origin_function == nullptr)
		{
			hook_write_absolute_jump(&hooked_function_info->fake_page_contents[page_offset], (unsigned __int64)hooked_function);

			return true;
		}

		// Copy overwritten instructions to trampoline buffer
		RtlCopyMemory(hooked_function_info->first_trampoline_address, target_function, hooked_instructions_size);

		// Add the absolute jump back to the original function.
		hook_write_absolute_jump(&hooked_function_info->first_trampoline_address[hooked_instructions_size], (unsigned __int64)target_function + hooked_instructions_size);

		// Return to user address of trampoline to call original function
		*origin_function = hooked_function_info->first_trampoline_address;

		// Write the absolute jump to our shadow page memory to jump to our hooked_page.
		hook_write_absolute_jump(&hooked_function_info->fake_page_contents[page_offset], (unsigned __int64)hooked_function);

		return true;
	}

	bool is_page_splitted(unsigned __int64 physical_address)
	{
		__ept_pde* entry = get_pml2_entry(physical_address);
		return !entry->page_directory_entry.large_page;
	}

	/// <summary>
	/// Perfrom a hook
	/// </summary>
	/// <param name="target_address" > Address of function which we want to hook </param>
	/// <param name="hook_function"> Address of hooked version of function which we are hooking </param>
	/// <param name="(Optional) trampoline">Address of code cave which is located in 2gb range of target function (Use only if you need smaller trampoline)</param>
	/// <param name="origin_function"> Address used to call original function </param>
	/// <returns></returns>
	bool hook_function(void* target_function, void* hooked_function,void* trampoline, void** origin_function)
	{
		unsigned __int64 physical_address = MmGetPhysicalAddress(target_function).QuadPart;

		//
		// Check if function exist in physical memory
		//
		if (physical_address == NULL)
		{
			LogError("Requested virtual memory doesn't exist in physical one");
			return false;
		}

		//
		// Check if page isn't already hooked
		//
		PLIST_ENTRY current = &g_vmm_context->ept_state->hooked_page_list;
		while (&g_vmm_context->ept_state->hooked_page_list != current->Flink)
		{
			current = current->Flink;
			__ept_hooked_page_info* hooked_page_info = CONTAINING_RECORD(current, __ept_hooked_page_info, hooked_page_list);

			if (hooked_page_info->pfn_of_hooked_page == GET_PFN(physical_address))
			{
				LogInfo("Page already hooked");

				__ept_hooked_function_info* hooked_function_info = pool_manager::request_pool<__ept_hooked_function_info*>(pool_manager::INTENTION_TRACK_HOOKED_FUNCTIONS, TRUE, sizeof(__ept_hooked_function_info));
				if (hooked_function_info == nullptr)
				{
					LogError("There is no pre-allocated pool for hooked function struct");
					return false;
				}

				//
				// If we are hooking code cave for second trampoline 
				// then origin function in null and we don't have to get pool for trampoline
				//
				if(origin_function != nullptr)
				{
					hooked_function_info->first_trampoline_address = pool_manager::request_pool<unsigned __int8*>(pool_manager::INTENTION_EXEC_TRAMPOLINE, TRUE, 100);
					if (hooked_function_info->first_trampoline_address == nullptr)
					{
						pool_manager::release_pool(hooked_function_info);
						LogError("There is no pre-allocated pool for trampoline");
						return false;
					}
				}

				hooked_function_info->virtual_address = target_function;

				hooked_function_info->second_trampoline_address = trampoline;

				hooked_function_info->fake_page_contents = hooked_page_info->fake_page_contents;

				if (hook_instruction_memory(hooked_function_info, target_function, hooked_function, trampoline, origin_function) == false)
				{
					if(hooked_function_info->first_trampoline_address != nullptr)
						pool_manager::release_pool(hooked_function_info->first_trampoline_address);
					pool_manager::release_pool(hooked_function_info);
					LogError("Hook failed");
					return false;
				}

				// Track all hooked functions within page
				InsertHeadList(&hooked_page_info->hooked_functions_list, &hooked_function_info->hooked_function_list);

				return true;
			}
		}

		if (is_page_splitted(physical_address) == false)
		{
			void* split_buffer = pool_manager::request_pool<void*>(pool_manager::INTENTION_SPLIT_PML2, true, sizeof(__ept_dynamic_split));
			if (split_buffer == nullptr)
			{
				LogError("There is no preallocated pool for split");
				return false;
			}

			if (split_pml2(split_buffer, physical_address) == false)
			{
				pool_manager::release_pool(split_buffer);
				LogError("Split failed");
				return false;
			}
		}

		__ept_pte* target_page = get_pml1_entry(physical_address);
		if (target_page == nullptr)
		{
			LogError("Failed to get PML1 entry of the target address");
			return false;
		}

		__ept_hooked_page_info* hooked_page_info = pool_manager::request_pool<__ept_hooked_page_info*>(pool_manager::INTENTION_TRACK_HOOKED_PAGES, true, sizeof(__ept_hooked_page_info));
		if (hooked_page_info == nullptr)
		{
			LogError("There is no preallocated pool for hooked page info");
			return false;
		}

		InitializeListHead(&hooked_page_info->hooked_functions_list);

		__ept_hooked_function_info* hooked_function_info = pool_manager::request_pool<__ept_hooked_function_info*>(pool_manager::INTENTION_TRACK_HOOKED_FUNCTIONS, true, sizeof(__ept_hooked_function_info));
		if (hooked_function_info == nullptr)
		{
			pool_manager::release_pool(hooked_page_info);
			LogError("There is no preallocated pool for hooked function info");
			return false;
		}

		//
		// If we are hooking code cave for second trampoline 
		// then origin function in null and we don't have to get pool for trampoline
		//
		if (origin_function != nullptr)
		{
			hooked_function_info->first_trampoline_address = pool_manager::request_pool<unsigned __int8*>(pool_manager::INTENTION_EXEC_TRAMPOLINE, TRUE, 100);
			if (hooked_function_info->first_trampoline_address == nullptr)
			{
				pool_manager::release_pool(hooked_page_info);
				pool_manager::release_pool(hooked_function_info);
				LogError("There is no pre-allocated pool for trampoline");
				return false;
			}
		}

		hooked_page_info->pfn_of_hooked_page = GET_PFN(physical_address);
		hooked_page_info->pfn_of_fake_page_contents = GET_PFN(MmGetPhysicalAddress(hooked_page_info->fake_page_contents).QuadPart);
		hooked_page_info->entry_address = target_page;

		hooked_page_info->entry_address->execute = 0;
		hooked_page_info->entry_address->read = 1;
		hooked_page_info->entry_address->write = 1;

		hooked_page_info->original_entry = *target_page;
		hooked_page_info->changed_entry = *target_page;

		hooked_page_info->changed_entry.read = 0;
		hooked_page_info->changed_entry.write = 0;
		hooked_page_info->changed_entry.execute = 1;

		hooked_page_info->changed_entry.physical_address = hooked_page_info->pfn_of_fake_page_contents;
		
		RtlCopyMemory(&hooked_page_info->fake_page_contents, PAGE_ALIGN(target_function), PAGE_SIZE);

		hooked_function_info->virtual_address = target_function;

		hooked_function_info->second_trampoline_address = trampoline;

		hooked_function_info->fake_page_contents = hooked_page_info->fake_page_contents;

		if(hook_instruction_memory(hooked_function_info, target_function, hooked_function, trampoline, origin_function) == false)
		{
			if (hooked_function_info->first_trampoline_address != nullptr)
				pool_manager::release_pool(hooked_function_info->first_trampoline_address);
			pool_manager::release_pool(hooked_function_info);
			pool_manager::release_pool(hooked_page_info);
			LogError("Hook failed");
			return false;
		}

		// Track all hooked functions
		InsertHeadList(&hooked_page_info->hooked_functions_list, &hooked_function_info->hooked_function_list);

		// Track all hooked pages
		InsertHeadList(&g_vmm_context->ept_state->hooked_page_list, &hooked_page_info->hooked_page_list);

		invept_single_context(g_vmm_context->ept_state->ept_pointer->all);

		return true;
	}

	/// <summary>
	/// Unhook single function
	/// </summary>
	/// <param name="virtual_address"></param>
	/// <returns></returns>
	bool unhook_function(unsigned __int64 virtual_address)
	{
		//
		// Check if function which we want to unhook exist in physical memory
		unsigned __int64 physical_address = MmGetPhysicalAddress((void*)virtual_address).QuadPart;
		if (physical_address == 0)
			return false;

		PLIST_ENTRY current_hooked_page = &g_vmm_context->ept_state->hooked_page_list;
		while (&g_vmm_context->ept_state->hooked_page_list != current_hooked_page->Flink)
		{
			current_hooked_page = current_hooked_page->Flink;
			__ept_hooked_page_info* hooked_page_info = CONTAINING_RECORD(current_hooked_page, __ept_hooked_page_info, hooked_page_list);

			//
			// Check if function pfn is equal to pfn saved in hooked page info
			if (hooked_page_info->pfn_of_hooked_page == GET_PFN(physical_address))
			{
				PLIST_ENTRY current_hooked_function;
				current_hooked_function = &hooked_page_info->hooked_functions_list;

				while (&hooked_page_info->hooked_functions_list != current_hooked_function->Flink)
				{
					current_hooked_function = current_hooked_function->Flink;
					__ept_hooked_function_info* hooked_function_info = CONTAINING_RECORD(current_hooked_function, __ept_hooked_function_info, hooked_function_list);
					
					unsigned __int64 function_page_offset = MASK_EPT_PML1_OFFSET(virtual_address);

					//
					// Check if the address of function which we want to unhook is 
					// the same as address of function in hooked function info struct
					//
					if (function_page_offset == MASK_EPT_PML1_OFFSET(hooked_function_info->virtual_address))
					{
						// Restore overwritten data
						RtlCopyMemory(&hooked_function_info->fake_page_contents[function_page_offset], hooked_function_info->virtual_address, hooked_function_info->hook_size);
						
						// If hook uses two trampolines unhook second one
						if (hooked_function_info->second_trampoline_address != nullptr)
							unhook_function((unsigned __int64)hooked_function_info->second_trampoline_address);

						RemoveEntryList(current_hooked_function);

						if(hooked_function_info->first_trampoline_address != nullptr)
							pool_manager::release_pool(hooked_function_info->first_trampoline_address);
						pool_manager::release_pool(hooked_function_info);

						//
						// If there is no more function hooks free hooked page info struct
						if (hooked_page_info->hooked_functions_list.Flink == hooked_page_info->hooked_functions_list.Blink)
						{
							hooked_page_info->original_entry.execute = 1;
							swap_pml1_and_invalidate_tlb(hooked_page_info->entry_address, hooked_page_info->original_entry, INVEPT_SINGLE_CONTEXT);

							RemoveEntryList(current_hooked_page);
							pool_manager::release_pool(hooked_page_info);
							return true;
						}

						invept_all_contexts();
						return true;
					}
				}
			}
		}
		return false;
	}

	/// <summary>
	/// Unhook all functions and invalidate tlb
	/// </summary>
	void unhook_all_functions()
	{
		PLIST_ENTRY current_hooked_page = g_vmm_context->ept_state->hooked_page_list.Flink;
		while (&g_vmm_context->ept_state->hooked_page_list != current_hooked_page)
		{
			__ept_hooked_page_info* hooked_entry = CONTAINING_RECORD(current_hooked_page, __ept_hooked_page_info, hooked_page_list);

			PLIST_ENTRY current_hooked_function;

			current_hooked_function = hooked_entry->hooked_functions_list.Flink;
			while (&hooked_entry->hooked_functions_list != current_hooked_function)
			{
				__ept_hooked_function_info* hooked_function_info = CONTAINING_RECORD(current_hooked_function, __ept_hooked_function_info, hooked_function_list);
				
				// If hook uses two trampolines unhook second one
				if (hooked_function_info->first_trampoline_address != nullptr)
					pool_manager::release_pool(hooked_function_info->first_trampoline_address);

				RemoveEntryList(current_hooked_function);

				current_hooked_function = current_hooked_function->Flink;

				pool_manager::release_pool(hooked_function_info);
			}

			// Restore original pte value
			hooked_entry->original_entry.execute = 1;
			swap_pml1_and_invalidate_tlb(hooked_entry->entry_address, hooked_entry->original_entry, INVEPT_SINGLE_CONTEXT);

			RemoveEntryList(current_hooked_page);

			current_hooked_page = current_hooked_page->Flink;

			pool_manager::release_pool(hooked_entry);
		}
	}
}
```

`airhv/airhv-main/airhv/hypervisor_gateway.cpp`:

```cpp
#pragma warning( disable : 4201)

#include <ntddk.h>
#include "ntapi.h"
#include "asm\vm_intrin.h"
#include "vmcall_reason.h"
#include "log.h"

#define IOCTL_POOL_MANAGER_ALLOCATE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

namespace hvgt 
{
	void broadcast_vmoff(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(Dpc);
		UNREFERENCED_PARAMETER(DeferredContext);

		__vm_call(VMCALL_VMXOFF, 0, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	void broadcast_invept_all_contexts(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(Dpc);
		UNREFERENCED_PARAMETER(DeferredContext);
		
		__vm_call(VMCALL_INVEPT_CONTEXT, true, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	void broadcast_invept_single_context(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(Dpc);
		UNREFERENCED_PARAMETER(DeferredContext); 
		
		__vm_call(VMCALL_INVEPT_CONTEXT, false, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	/// <summary>
	/// Turn off virtual machine
	/// </summary>
	void vmoff()
	{
		KeGenericCallDpc(broadcast_vmoff, NULL);
	}

	/// <summary>
	/// Invalidates mappings in the translation lookaside buffers (TLBs) 
	/// and paging-structure caches that were derived from extended page tables (EPT)
	/// </summary>
	/// <param name="invept_all"> If true invalidates all contexts otherway invalidate only single context (currently hv doesn't use more than 1 context)</param>
	void invept(bool invept_all)
	{
		if (invept_all == true) KeGenericCallDpc(broadcast_invept_all_contexts, NULL);
		else KeGenericCallDpc(broadcast_invept_single_context, NULL);
	}

	/// <summary>
	/// Set/Unset presence of hypervisor
	/// </summary>
	/// <param name="value"> If false, hypervisor is not visible via cpuid interface, If true, it become visible</param>
	void hypervisor_visible(bool value)
	{
		if (value == true)
			__vm_call(VMCALL_UNHIDE_HV_PRESENCE, 0, 0, 0);
		else
			__vm_call(VMCALL_HIDE_HV_PRESENCE, 0, 0, 0);
	}

	/// <summary>
	/// Unhook all functions and invalidate tlb
	/// </summary>
	/// <returns> status </returns>
	bool ept_unhook()
	{
		bool status = __vm_call(VMCALL_EPT_UNHOOK_FUNCTION, true, 0, 0);
		invept(false);
		return status;
	}

	/// <summary>
	/// Unhook single function and invalidate tlb
	/// </summary>
	/// <param name="function_address"></param>
	/// <returns> status </returns>
	bool ept_unhook(void* function_address)
	{
		bool status = __vm_call(VMCALL_EPT_UNHOOK_FUNCTION, false, (unsigned __int64)function_address, 0);
		invept(false);
		return status;
	}

	/// <summary>
	/// Hook function via ept and invalidates mappings
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void** origin_function)
	{
		bool status = __vm_call_ex(VMCALL_EPT_HOOK_FUNCTION, (unsigned __int64)target_address, (unsigned __int64)hook_function, 0, (unsigned __int64)origin_function, 0, 0, 0, 0, 0);
		invept(false);

		return status;
	}

	/// <summary>
	/// Hook function via ept and invalidates mappings
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="trampoline_address">Address of some memory which isn't used with size at least 13 and withing 2GB range of target function
	/// Use only if you can function you want to hook use relative offeset in first 13 bytes of it. For example if you want hook NtYieldExecution which
	/// size is 15 bytes you have to find a codecave witihn ntoskrnl.exe image with size atleast 13 bytes and pass it there</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void* trampoline_address, void** origin_function)
	{
		bool status = __vm_call_ex(VMCALL_EPT_HOOK_FUNCTION, (unsigned __int64)target_address, (unsigned __int64)hook_function,(unsigned __int64) trampoline_address, (unsigned __int64)origin_function, 0, 0, 0, 0, 0);
		invept(false);

		return status;
	}

	/// <summary>
	/// Check if we can communicate with hypervisor
	/// </summary>
	/// <returns> status </returns>
	bool test_vmcall()
	{
		return __vm_call(VMCALL_TEST, 0, 0, 0);
	}

	/// <summary>
	/// Send irp with information to allocate memory
	/// </summary>
	/// <returns> status </returns>
	bool perform_memory_allocation()
	{
		PDEVICE_OBJECT airhv_device_object;
		KEVENT event;
		PIRP irp;
		IO_STATUS_BLOCK io_status = { 0 };
		UNICODE_STRING airhv_name;
		PFILE_OBJECT file_object;

		RtlInitUnicodeString(&airhv_name, L"\\Device\\airhv");

		NTSTATUS status = IoGetDeviceObjectPointer(&airhv_name, 0, &file_object, &airhv_device_object);

		ObReferenceObjectByPointer(airhv_device_object, FILE_ALL_ACCESS, NULL, KernelMode);

		// We don't need this so we instantly dereference file object
		ObDereferenceObject(file_object);

		if (NT_SUCCESS(status) == false)
		{
			LogError("Couldn't get hypervisor device object pointer");
			return false;
		}

		KeInitializeEvent(&event, NotificationEvent, 0);
		irp = IoBuildDeviceIoControlRequest(IOCTL_POOL_MANAGER_ALLOCATE, airhv_device_object, 0, 0, 0, 0, 0, &event, &io_status);

		if (irp == NULL)
		{
			LogError("Couldn't create Irp");
			ObDereferenceObject(airhv_device_object);
			return false;
		}

		else
		{
			status = IofCallDriver(airhv_device_object, irp);

			if (status == STATUS_PENDING)
				KeWaitForSingleObject(&event, Executive, KernelMode, 0, 0);

			ObDereferenceObject(airhv_device_object);
			return true;
		}
	}
}
```

`airhv/airhv-main/airhv/hypervisor_gateway.h`:

```h
#pragma once
namespace hvgt
{
	/// <summary>
	/// Turn off virtual machine
	/// </summary>
	void vmoff();

	/// <summary>
	/// Invalidates mappings in the translation lookaside buffers (TLBs) 
	/// and paging-structure caches that were derived from extended page tables (EPT)
	/// </summary>
	/// <param name="invept_all"> If true invalidates all contexts otherway invalidate only single context (currently hv doesn't use more than 1 context)</param>
	void invept(bool invept_all);

	/// <summary>
	/// Set/Unset presence of hypervisor
	/// </summary>
	/// <param name="value"> If false, hypervisor is not visible via cpuid interface, If true, it become visible</param>
	void hypervisor_visible(bool value);

	/// <summary>
	/// Unhook all pages and invalidate tlb
	/// </summary>
	/// <returns> status </returns>
	bool ept_unhook();

	/// <summary>
	/// Unhook single page and invalidate tlb
	/// </summary>
	/// <param name="page_physcial_address"></param>
	/// <returns> status </returns>
	bool ept_unhook(void* function_address);

	/// <summary>
	/// Hook function via ept and invalidates mappings
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void** origin_function);

	/// <summary>
	/// Hook function via ept and invalidates mappings
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="trampoline_address">Address of codecave which is at least 14 bytes in size and in 2GB range of target function address
	/// Use only if function you want to hook uses some relatives jmps/moves in first 14 bytes</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void* trampoline_address, void** origin_function);

	/// <summary>
	/// Check if we can communicate with hypervisor
	/// </summary>
	/// <returns> status </returns>
	bool test_vmcall();

	/// <summary>
	/// Send irp with information to allocate memory
	/// </summary>
	/// <returns> status </returns>
	bool send_irp_perform_allocation();
}

```

`airhv/airhv-main/airhv/hypervisor_routines.cpp`:

```cpp
#pragma warning( disable : 4201 4244)

#include <ntddk.h>
#include <intrin.h>
#include "hypervisor_routines.h"
#include "ia32\cpuid.h"
#include "asm\vm_context.h"
#include "ia32\cr.h"
#include "ia32\msr.h"
#include "ia32\vmcs.h"
#include "log.h"
#include "ntapi.h"
#include "ia32\vmcs_encodings.h"
#include "vmcall_handler.h"
#include "interrupt.h"
#include "allocators.h"
#include "asm/vm_intrin.h"

#define NON_CANONICIAL_ADDRESS_END 0xFFFF800000000000
#define NON_CANONICIAL_ADDRESS_START 0x0000800000000000

namespace hv 
{
	volatile long vmcs_dump_lock = 0;

	/// <summary>
	/// Inject interrupt/exception to guest system
	/// </summary>
	/// <param name="vector"></param>
	/// <param name="type"></param>
	/// <param name="error_code"></param>
	/// <param name="deliver_error_code"></param>
	void inject_interruption(unsigned __int32 vector, unsigned __int32 type, unsigned __int32 error_code, bool deliver_error_code)
	{
		__vmentry_interrupt_info interrupt = { 0 };

		interrupt.interruption_type = type;
		interrupt.interrupt_vector = vector;
		interrupt.deliver_error_code = deliver_error_code;
		interrupt.valid = 1;

		if(type == INTERRUPT_TYPE_SOFTWARE_EXCEPTION || type == INTERRUPT_TYPE_PRIVILEGED_SOFTWARE_INTERRUPT || type == INTERRUPT_TYPE_SOFTWARE_INTERRUPT)
			hv::vmwrite<unsigned __int64>(CONTROL_VM_ENTRY_INSTRUCTION_LENGTH, hv::vmread(VM_EXIT_INSTRUCTION_LENGTH));

		if (deliver_error_code == true)
			hv::vmwrite<unsigned __int64>(CONTROL_VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);

		hv::vmwrite<unsigned __int64>(CONTROL_VM_ENTRY_INTERRUPTION_INFORMATION_FIELD, interrupt.all);
	}

	/// <summary>
	/// Write to reset io port to perform hard reset
	/// </summary>
	void hard_reset()
	{
		__reset_control_register reset_register;
		reset_register.all = __inbyte(RESET_IO_PORT);

		//
		// Reset CPU bit set, determines type of reset based on:
		//        - System Reset = 0; soft reset by activating INIT# for 16 PCI clocks.
		//        - System Reset = 1; then hard reset by activating PLTRST# and SUS_STAT#.
		//        - System Reset = 1; main power well reset.
		//

		reset_register.reset_cpu = 1;
		reset_register.system_reset = 1;

		__outbyte(RESET_IO_PORT, reset_register.all);
	}

	/// <summary>
	/// Swap cr3 with current process dtb
	/// </summary>
	/// <returns> old cr3 </returns>
	unsigned __int64 swap_context()
	{
		__nt_kprocess* current_process;

		current_process = (__nt_kprocess*)IoGetCurrentProcess();
		unsigned __int64 current_cr3 = __readcr3();
		unsigned __int64 guest_cr3 = current_process->DirectoryTableBase;

		__writecr3(guest_cr3);
		return current_cr3;
	}

	/// <summary>
	/// Restore cr3
	/// </summary>
	/// <param name="old_cr3"></param>
	void restore_context(unsigned __int64 old_cr3)
	{
		__writecr3(old_cr3);
	}

	/// <summary>
	/// Get system directory table base
	/// </summary>
	/// <returns></returns>
	unsigned __int64 get_system_directory_table_base()
	{
		return ((__nt_kprocess*)PsInitialSystemProcess)->DirectoryTableBase;
	}

	/// <summary>
	/// Read vmcs field
	/// </summary>
	/// <param name="vmcs_field"></param>
	/// <returns></returns>
	unsigned __int64 vmread(unsigned __int64 vmcs_field)
	{
		unsigned __int64 value;
		__vmx_vmread(vmcs_field, &value);
		return value;
	}

	/// <summary>
	/// Check if address is canonicial (level 4 paging)
	/// </summary>
	/// <param name="address"></param>
	/// <returns></returns>
	bool is_address_canonical(unsigned __int64 address)
	{
		if (address < NON_CANONICIAL_ADDRESS_END && address > NON_CANONICIAL_ADDRESS_START)
			return false;
		return true;
	}

	/// <summary>
	/// 
	/// </summary>
	/// <returns> Return current guest privilage level</returns>
	unsigned __int8 get_guest_cpl()
	{
		return vmread(GUEST_CS_SELECTOR) & 3;
	}

	/// <summary>
	/// Set 1 msr in msr bitmap
	/// </summary>
	/// <param name="msr"> Msr number </param>
	/// <param name="vcpu"> Pointer to current vcpu </param>
	/// <param name="read"> If set vmexit occur on reading this msr </param>
	/// <param name="write"> If set vmexit occur on writing to this msr </param>
	/// <param name="value"> If true set msr bit else clear </param>
	void set_msr_bitmap(unsigned __int32 msr, __vcpu* vcpu, bool read, bool write, bool value)
	{
		unsigned __int16 bitmap_position;
		unsigned __int8 bitmap_bit;

		if (msr <= 0x1FFF)
		{
			bitmap_position = msr / 8;
			bitmap_bit = msr % 8;

			//
			// Read access for msr 0x0 to 0x1FFF located at the MSR-bitmap address
			if (read == true)
			{
				if (value == true)
					*(vcpu->vcpu_bitmaps.msr_bitmap + bitmap_position) |= (1 << bitmap_bit);

				else
					*(vcpu->vcpu_bitmaps.msr_bitmap + bitmap_position) &= ~(1 << bitmap_bit);
			}

			//
			// Write access for msr 0x0 to 0x1FFF located at the MSR-bitmap address plus 1024
			else if (write == true)
			{
				if (value == true)
					*(vcpu->vcpu_bitmaps.msr_bitmap + bitmap_position + 1024) |= (1 << bitmap_bit);

				else
					*(vcpu->vcpu_bitmaps.msr_bitmap + bitmap_position + 1024) &= ~(1 << bitmap_bit);
			}
		}

		else if (msr >= 0xC0000000 && msr <= 0xC0001FFF)
		{
			msr -= 0xC0000000;
			bitmap_position = msr / 8;
			bitmap_bit = msr % 8;

			//
			// Read access for msr 0xC0000000 to 0xC0001FFF located at the MSR-bitmap address plus 2048
			if (read == true)
			{
				if (value == true)
					*(vcpu->vcpu_bitmaps.msr_bitmap + bitmap_position + 2048) |= (1 << bitmap_bit);

				else
					*(vcpu->vcpu_bitmaps.msr_bitmap + bitmap_position + 2048) &= ~(1 << bitmap_bit);
			}

			//
			// Write access for msr 0xC0000000 to 0xC0001FFF located at the MSR-bitmap address plus 2048
			else if (write == true)
			{
				if (value == true)
					*(vcpu->vcpu_bitmaps.msr_bitmap + bitmap_position + 3072) |= (1 << bitmap_bit);
				else
					*(vcpu->vcpu_bitmaps.msr_bitmap + bitmap_position + 3072) &= ~(1 << bitmap_bit);
			}
		}

		else
		{
			LogError("Bad msr number");
			return;
		}
	}


	/// <summary>
	/// Set or unset bit in io port bitmap
	/// </summary>
	/// <param name="io_port"> IO port which you want to set</param>
	/// <param name="vcpu"> Pointer to current vcpu </param>
	/// <param name="value"> If true then set bit else unset bit</param>
	void set_io_bitmap(unsigned __int16 io_port, __vcpu* vcpu, bool value)
	{
		unsigned __int16 bitmap_position;
		unsigned __int8 bitmap_bit;

		//
		// IO ports from 0x8000 to 0xFFFF are encoded in io bitmap b
		if (io_port >= 0x8000)
		{
			io_port -= 0x8000;
			bitmap_position = io_port / 8;
			bitmap_bit = io_port % 8;

			if (value == true)
				*(vcpu->vcpu_bitmaps.io_bitmap_b + bitmap_position) |= (1 << bitmap_bit);
			else
				*(vcpu->vcpu_bitmaps.io_bitmap_b + bitmap_position) &= ~(1 << bitmap_bit);
		}

		//
		// IO ports from 0 to 0x7fff are encoded in io bitmap b
		else
		{
			bitmap_position = io_port / 8;
			bitmap_bit = io_port % 8;

			if (value == true)
				*(vcpu->vcpu_bitmaps.io_bitmap_a + bitmap_position) |= (1 << bitmap_bit);
			else
				*(vcpu->vcpu_bitmaps.io_bitmap_a + bitmap_position) &= ~(1 << bitmap_bit);
		}
	}

	/// <summary>
	/// Used to get address passed by user in inpvcid
	/// </summary>
	/// <param name="guest_registers"></param>
	/// <returns></returns>
	unsigned __int64 get_guest_address(__vcpu* vcpu)
	{
		__vmexit_instruction_information2 instruction_information;

		instruction_information.all = vcpu->vmexit_info.instruction_information;

		unsigned __int64 displacement = vcpu->vmexit_info.qualification;

		unsigned __int64 base_value = !instruction_information.base_reg_invalid ? *(&vcpu->vmexit_info.guest_registers->rax - instruction_information.base_reg) : 0;

		unsigned __int64 index_value = !instruction_information.index_reg_invalid ? *(&vcpu->vmexit_info.guest_registers->rax - instruction_information.index_reg) : 0;

		index_value = index_value * (1ULL << instruction_information.scaling);

		unsigned __int64 segment_base = hv::vmread(GUEST_ES_BASE + (instruction_information.segment_register << 1));

		unsigned __int64 guest_address = displacement + base_value + index_value + segment_base;

		return guest_address;
	}

	/// <summary>
	/// Check if cpu support virtualization
	/// </summary>
	/// <returns></returns>
	bool virtualization_support()
	{
		__cpuid_info cpuid = { 0 };
		__cpuid(&cpuid.cpu_info[0], 1);
		return cpuid.cpuid_eax_01.feature_information_ecx.virtual_machine_extensions;
	}

	/// <summary>
	/// Disable vmx operation
	/// </summary>
	/// <returns></returns>
	void disable_vmx_operation()
	{
		__cr4 cr4 = { 0 };
		__ia32_feature_control_msr feature_msr = { 0 };
		cr4.all = __readcr4();
		cr4.vmx_enable = 0;
		__writecr4(cr4.all);
	}

	/// <summary>
	/// Dump whole vmcs structure
	/// </summary>
	void dump_vmcs()
	{
		spinlock::lock(&vmcs_dump_lock);

		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,"-----------------------------------VMCS CORE %u DUMP-----------------------------------\r\n",KeGetCurrentProcessorIndex());

		// Natural Guest Register State Fields
		LogDump("GUEST_CR0: 0x%llX", vmread(GUEST_CR0));
		LogDump("GUEST_CR3: 0x%llX", vmread(GUEST_CR3));
		LogDump("GUEST_CR4: 0x%llX", vmread(GUEST_CR4));
		LogDump("GUEST_ES_BASE: 0x%llX", vmread(GUEST_ES_BASE));
		LogDump("GUEST_CS_BASE: 0x%llX", vmread(GUEST_CS_BASE));
		LogDump("GUEST_SS_BASE: 0x%llX", vmread(GUEST_SS_BASE));
		LogDump("GUEST_DS_BASE: 0x%llX", vmread(GUEST_DS_BASE));
		LogDump("GUEST_FS_BASE: 0x%llX", vmread(GUEST_FS_BASE));
		LogDump("GUEST_GS_BASE: 0x%llX", vmread(GUEST_GS_BASE));
		LogDump("GUEST_LDTR_BASE: 0x%llX", vmread(GUEST_LDTR_BASE));
		LogDump("GUEST_TR_BASE: 0x%llX", vmread(GUEST_TR_BASE));
		LogDump("GUEST_GDTR_BASE: 0x%llX", vmread(GUEST_GDTR_BASE));
		LogDump("GUEST_IDTR_BASE: 0x%llX", vmread(GUEST_IDTR_BASE));
		LogDump("GUEST_DR7: 0x%llX", vmread(GUEST_DR7));
		LogDump("GUEST_RSP: 0x%llX", vmread(GUEST_RSP));
		LogDump("GUEST_RIP: 0x%llX", vmread(GUEST_RIP));
		LogDump("GUEST_RFLAGS: 0x%llX", vmread(GUEST_RFLAGS));
		LogDump("GUEST_SYSENTER_ESP: 0x%llX", vmread(GUEST_SYSENTER_ESP));
		LogDump("GUEST_SYSENTER_EIP: 0x%llX", vmread(GUEST_SYSENTER_EIP));
		LogDump("GUEST_S_CET: 0x%llX", vmread(GUEST_S_CET));
		LogDump("GUEST_SSP: 0x%llX", vmread(GUEST_SSP));
		LogDump("GUEST_INTERRUPT_SSP_TABLE_ADDR: 0x%llX", vmread(GUEST_INTERRUPT_SSP_TABLE_ADDR));

		// 64-bit Guest Register State Fields
		LogDump("GUEST_VMCS_LINK_POINTER: 0x%llX", vmread(GUEST_VMCS_LINK_POINTER));
		LogDump("GUEST_DEBUG_CONTROL: 0x%llX", vmread(GUEST_DEBUG_CONTROL));
		LogDump("GUEST_PAT: 0x%llX", vmread(GUEST_PAT));
		LogDump("GUEST_EFER: 0x%llX", vmread(GUEST_EFER));
		LogDump("GUEST_PERF_GLOBAL_CONTROL: 0x%llX", vmread(GUEST_PERF_GLOBAL_CONTROL));
		LogDump("GUEST_PDPTE0: 0x%llX", vmread(GUEST_PDPTE0));
		LogDump("GUEST_PDPTE1: 0x%llX", vmread(GUEST_PDPTE1));
		LogDump("GUEST_PDPTE2: 0x%llX", vmread(GUEST_PDPTE2));
		LogDump("GUEST_PDPTE3: 0x%llX", vmread(GUEST_PDPTE3));
		LogDump("GUEST_BNDCFGS: 0x%llX", vmread(GUEST_BNDCFGS));
		LogDump("GUEST_RTIT_CTL: 0x%llX", vmread(GUEST_RTIT_CTL));
		LogDump("GUEST_PKRS: 0x%llX", vmread(GUEST_PKRS));

		// 32-Bit Guest Register State Fields
		LogDump("GUEST_ES_LIMIT: 0x%llX", vmread(GUEST_ES_LIMIT));
		LogDump("GUEST_CS_LIMIT: 0x%llX", vmread(GUEST_CS_LIMIT));
		LogDump("GUEST_SS_LIMIT: 0x%llX", vmread(GUEST_SS_LIMIT));
		LogDump("GUEST_DS_LIMIT: 0x%llX", vmread(GUEST_DS_LIMIT));
		LogDump("GUEST_FS_LIMIT: 0x%llX", vmread(GUEST_FS_LIMIT));
		LogDump("GUEST_GS_LIMIT: 0x%llX", vmread(GUEST_GS_LIMIT));
		LogDump("GUEST_LDTR_LIMIT: 0x%llX", vmread(GUEST_LDTR_LIMIT));
		LogDump("GUEST_TR_LIMIT: 0x%llX", vmread(GUEST_TR_LIMIT));
		LogDump("GUEST_GDTR_LIMIT: 0x%llX", vmread(GUEST_GDTR_LIMIT));
		LogDump("GUEST_IDTR_LIMIT: 0x%llX", vmread(GUEST_IDTR_LIMIT));
		LogDump("GUEST_ES_ACCESS_RIGHTS: 0x%llX", vmread(GUEST_ES_ACCESS_RIGHTS));
		LogDump("GUEST_CS_ACCESS_RIGHTS: 0x%llX", vmread(GUEST_CS_ACCESS_RIGHTS));
		LogDump("GUEST_SS_ACCESS_RIGHTS: 0x%llX", vmread(GUEST_SS_ACCESS_RIGHTS));
		LogDump("GUEST_DS_ACCESS_RIGHTS: 0x%llX", vmread(GUEST_DS_ACCESS_RIGHTS));
		LogDump("GUEST_FS_ACCESS_RIGHTS: 0x%llX", vmread(GUEST_FS_ACCESS_RIGHTS));
		LogDump("GUEST_GS_ACCESS_RIGHTS: 0x%llX", vmread(GUEST_GS_ACCESS_RIGHTS));
		LogDump("GUEST_LDTR_ACCESS_RIGHTS: 0x%llX", vmread(GUEST_LDTR_ACCESS_RIGHTS));
		LogDump("GUEST_TR_ACCESS_RIGHTS: 0x%llX", vmread(GUEST_TR_ACCESS_RIGHTS));
		LogDump("GUEST_INTERRUPTIBILITY_STATE: 0x%llX", vmread(GUEST_INTERRUPTIBILITY_STATE));
		LogDump("GUEST_ACTIVITY_STATE: 0x%llX", vmread(GUEST_ACTIVITY_STATE));
		LogDump("GUEST_SMBASE: 0x%llX", vmread(GUEST_SMBASE));
		LogDump("GUEST_SYSENTER_CS: 0x%llX", vmread(GUEST_SYSENTER_CS));
		LogDump("GUEST_VMX_PREEMPTION_TIMER_VALUE: 0x%llX", vmread(GUEST_VMX_PREEMPTION_TIMER_VALUE));

		// 16-Bit Guest Register State Fields
		LogDump("GUEST_ES_SELECTOR: 0x%llX", vmread(GUEST_ES_SELECTOR));
		LogDump("GUEST_CS_SELECTOR: 0x%llX", vmread(GUEST_CS_SELECTOR));
		LogDump("GUEST_SS_SELECTOR: 0x%llX", vmread(GUEST_SS_SELECTOR));
		LogDump("GUEST_DS_SELECTOR: 0x%llX", vmread(GUEST_DS_SELECTOR));
		LogDump("GUEST_FS_SELECTOR: 0x%llX", vmread(GUEST_FS_SELECTOR));
		LogDump("GUEST_GS_SELECTOR: 0x%llX", vmread(GUEST_GS_SELECTOR));
		LogDump("GUEST_LDTR_SELECTOR: 0x%llX", vmread(GUEST_LDTR_SELECTOR));
		LogDump("GUEST_TR_SELECTOR: 0x%llX", vmread(GUEST_TR_SELECTOR));
		LogDump("GUEST_GUEST_INTERRUPT_STATUS: 0x%llX", vmread(GUEST_GUEST_INTERRUPT_STATUS));
		LogDump("GUEST_PML_INDEX: 0x%llX", vmread(GUEST_PML_INDEX));

		// Natural Host Register State Fields
		LogDump("HOST_CR0: 0x%llX", vmread(HOST_CR0));
		LogDump("HOST_CR3: 0x%llX", vmread(HOST_CR3));
		LogDump("HOST_CR4: 0x%llX", vmread(HOST_CR4));
		LogDump("HOST_FS_BASE: 0x%llX", vmread(HOST_FS_BASE));
		LogDump("HOST_GS_BASE: 0x%llX", vmread(HOST_GS_BASE));
		LogDump("HOST_TR_BASE: 0x%llX", vmread(HOST_TR_BASE));
		LogDump("HOST_GDTR_BASE: 0x%llX", vmread(HOST_GDTR_BASE));
		LogDump("HOST_IDTR_BASE: 0x%llX", vmread(HOST_IDTR_BASE));
		LogDump("HOST_SYSENTER_ESP: 0x%llX", vmread(HOST_SYSENTER_ESP));
		LogDump("HOST_SYSENTER_EIP: 0x%llX", vmread(HOST_SYSENTER_EIP));
		LogDump("HOST_RSP: 0x%llX", vmread(HOST_RSP));
		LogDump("HOST_RIP: 0x%llX", vmread(HOST_RIP));
		LogDump("HOST_S_CET: 0x%llX", vmread(HOST_S_CET));
		LogDump("HOST_SSP: 0x%llX", vmread(HOST_SSP));
		LogDump("HOST_INTERRUPT_SSP_TABLE_ADDR: 0x%llX", vmread(HOST_INTERRUPT_SSP_TABLE_ADDR));

		// 64-bit Host Register State Fields
		LogDump("HOST_PAT: 0x%llX", vmread(HOST_PAT));
		LogDump("HOST_EFER: 0x%llX", vmread(HOST_EFER));
		LogDump("HOST_PERF_GLOBAL_CTRL: 0x%llX", vmread(HOST_PERF_GLOBAL_CTRL));
		LogDump("HOST_PKRS: 0x%llX", vmread(HOST_PKRS));

		// 32-bit Host Register State Fields
		LogDump("HOST_SYSENTER_CS: 0x%llX", vmread(HOST_SYSENTER_CS));

		// 16-bit Host Register State Fields
		LogDump("HOST_ES_SELECTOR: 0x%llX", vmread(HOST_ES_SELECTOR));
		LogDump("HOST_CS_SELECTOR: 0x%llX", vmread(HOST_CS_SELECTOR));
		LogDump("HOST_SS_SELECTOR: 0x%llX", vmread(HOST_SS_SELECTOR));
		LogDump("HOST_DS_SELECTOR: 0x%llX", vmread(HOST_DS_SELECTOR));
		LogDump("HOST_FS_SELECTOR: 0x%llX", vmread(HOST_FS_SELECTOR));
		LogDump("HOST_GS_SELECTOR: 0x%llX", vmread(HOST_GS_SELECTOR));
		LogDump("HOST_TR_SELECTOR: 0x%llX", vmread(HOST_TR_SELECTOR));

		// Natural Control Register State Fields
		LogDump("CONTROL_CR0_GUEST_HOST_MASK: 0x%llX", vmread(CONTROL_CR0_GUEST_HOST_MASK));
		LogDump("CONTROL_CR4_GUEST_HOST_MASK: 0x%llX", vmread(CONTROL_CR4_GUEST_HOST_MASK));
		LogDump("CONTROL_CR0_READ_SHADOW: 0x%llX", vmread(CONTROL_CR0_READ_SHADOW));
		LogDump("CONTROL_CR4_READ_SHADOW: 0x%llX", vmread(CONTROL_CR4_READ_SHADOW));
		LogDump("CONTROL_CR3_TARGET_VALUE_0: 0x%llX", vmread(CONTROL_CR3_TARGET_VALUE_0));
		LogDump("CONTROL_CR3_TARGET_VALUE_1: 0x%llX", vmread(CONTROL_CR3_TARGET_VALUE_1));
		LogDump("CONTROL_CR3_TARGET_VALUE_2: 0x%llX", vmread(CONTROL_CR3_TARGET_VALUE_2));
		LogDump("CONTROL_CR3_TARGET_VALUE_3: 0x%llX", vmread(CONTROL_CR3_TARGET_VALUE_3));

		// 64-bit Control Register State Fields
		LogDump("CONTROL_BITMAP_IO_A_ADDRESS: 0x%llX", vmread(CONTROL_BITMAP_IO_A_ADDRESS));
		LogDump("CONTROL_BITMAP_IO_B_ADDRESS: 0x%llX", vmread(CONTROL_BITMAP_IO_B_ADDRESS));
		LogDump("CONTROL_MSR_BITMAPS_ADDRESS: 0x%llX", vmread(CONTROL_MSR_BITMAPS_ADDRESS));
		LogDump("CONTROL_VMEXIT_MSR_STORE_ADDRESS: 0x%llX", vmread(CONTROL_VMEXIT_MSR_STORE_ADDRESS));
		LogDump("CONTROL_VMEXIT_MSR_LOAD_ADDRESS: 0x%llX", vmread(CONTROL_VMEXIT_MSR_LOAD_ADDRESS));
		LogDump("CONTROL_VMENTER_MSR_LOAD_ADDRESS: 0x%llX", vmread(CONTROL_VMENTER_MSR_LOAD_ADDRESS));
		LogDump("CONTROL_VMCS_EXECUTIVE_POINTER: 0x%llX", vmread(CONTROL_VMCS_EXECUTIVE_POINTER));
		LogDump("CONTROL_PML_ADDRESS: 0x%llX", vmread(CONTROL_PML_ADDRESS));
		LogDump("CONTROL_TSC_OFFSET: 0x%llX", vmread(CONTROL_TSC_OFFSET));
		LogDump("CONTROL_VIRTUAL_APIC_ADDRESS: 0x%llX", vmread(CONTROL_VIRTUAL_APIC_ADDRESS));
		LogDump("CONTROL_APIC_ACCESS_ADDRESS: 0x%llX", vmread(CONTROL_APIC_ACCESS_ADDRESS));
		LogDump("CONTROL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS: 0x%llX", vmread(CONTROL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS));
		LogDump("CONTROL_VM_FUNCTION_CONTROLS: 0x%llX", vmread(CONTROL_VM_FUNCTION_CONTROLS));
		LogDump("CONTROL_EPT_POINTER: 0x%llX", vmread(CONTROL_EPT_POINTER));
		LogDump("CONTROL_EOI_EXIT_BITMAP_0: 0x%llX", vmread(CONTROL_EOI_EXIT_BITMAP_0));
		LogDump("CONTROL_EOI_EXIT_BITMAP_1: 0x%llX", vmread(CONTROL_EOI_EXIT_BITMAP_1));
		LogDump("CONTROL_EOI_EXIT_BITMAP_2: 0x%llX", vmread(CONTROL_EOI_EXIT_BITMAP_2));
		LogDump("CONTROL_EOI_EXIT_BITMAP_3: 0x%llX", vmread(CONTROL_EOI_EXIT_BITMAP_3));
		LogDump("CONTROL_EPTP_LIST_ADDRESS: 0x%llX", vmread(CONTROL_EPTP_LIST_ADDRESS));
		LogDump("CONTROL_VMREAD_BITMAP_ADDRESS: 0x%llX", vmread(CONTROL_VMREAD_BITMAP_ADDRESS));
		LogDump("CONTROL_VMWRITE_BITMAP_ADDRESS: 0x%llX", vmread(CONTROL_VMWRITE_BITMAP_ADDRESS));
		LogDump("CONTROL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS: 0x%llX", vmread(CONTROL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS));
		LogDump("CONTROL_XSS_EXITING_BITMAP: 0x%llX", vmread(CONTROL_XSS_EXITING_BITMAP));
		LogDump("CONTROL_ENCLS_EXITING_BITMAP: 0x%llX", vmread(CONTROL_ENCLS_EXITING_BITMAP));
		LogDump("CONTROL_SUB_PAGE_PERMISSION_TABLE_POINTER: 0x%llX", vmread(CONTROL_SUB_PAGE_PERMISSION_TABLE_POINTER));
		LogDump("CONTROL_TSC_MULTIPLIER: 0x%llX", vmread(CONTROL_TSC_MULTIPLIER));
		LogDump("CONTROL_ENCLV_EXITING_BITMAP: 0x%llX", vmread(CONTROL_ENCLV_EXITING_BITMAP));

		// 32-bit Control Register State Fields
		LogDump("CONTROL_PIN_BASED_VM_EXECUTION_CONTROLS: 0x%llX", vmread(CONTROL_PIN_BASED_VM_EXECUTION_CONTROLS));
		LogDump("CONTROL_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS: 0x%llX", vmread(CONTROL_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS));
		LogDump("CONTROL_EXCEPTION_BITMAP: 0x%llX", vmread(CONTROL_EXCEPTION_BITMAP));
		LogDump("CONTROL_PAGE_FAULT_ERROR_CODE_MASK: 0x%llX", vmread(CONTROL_PAGE_FAULT_ERROR_CODE_MASK));
		LogDump("CONTROL_PAGE_FAULT_ERROR_CODE_MATCH: 0x%llX", vmread(CONTROL_PAGE_FAULT_ERROR_CODE_MATCH));
		LogDump("CONTROL_CR3_TARGET_COUNT: 0x%llX", vmread(CONTROL_CR3_TARGET_COUNT));
		LogDump("CONTROL_VM_EXIT_CONTROLS: 0x%llX", vmread(CONTROL_VM_EXIT_CONTROLS));
		LogDump("CONTROL_VM_EXIT_MSR_STORE_COUNT: 0x%llX", vmread(CONTROL_VM_EXIT_MSR_STORE_COUNT));
		LogDump("CONTROL_VM_EXIT_MSR_LOAD_COUNT: 0x%llX", vmread(CONTROL_VM_EXIT_MSR_LOAD_COUNT));
		LogDump("CONTROL_VM_ENTRY_CONTROLS: 0x%llX", vmread(CONTROL_VM_ENTRY_CONTROLS));
		LogDump("CONTROL_VM_ENTRY_MSR_LOAD_COUNT: 0x%llX", vmread(CONTROL_VM_ENTRY_MSR_LOAD_COUNT));
		LogDump("CONTROL_VM_ENTRY_INTERRUPTION_INFORMATION_FIELD: 0x%llX", vmread(CONTROL_VM_ENTRY_INTERRUPTION_INFORMATION_FIELD));
		LogDump("CONTROL_VM_ENTRY_EXCEPTION_ERROR_CODE: 0x%llX", vmread(CONTROL_VM_ENTRY_EXCEPTION_ERROR_CODE));
		LogDump("CONTROL_VM_ENTRY_INSTRUCTION_LENGTH: 0x%llX", vmread(CONTROL_VM_ENTRY_INSTRUCTION_LENGTH));
		LogDump("CONTROL_TPR_THRESHOLD: 0x%llX", vmread(CONTROL_TPR_THRESHOLD));
		LogDump("CONTROL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS: 0x%llX", vmread(CONTROL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS));
		LogDump("CONTROL_PLE_GAP: 0x%llX", vmread(CONTROL_PLE_GAP));
		LogDump("CONTROL_PLE_WINDOW: 0x%llX", vmread(CONTROL_PLE_WINDOW));

		// 16-bit Control Register State Fields
		LogDump("CONTROL_VIRTUAL_PROCESSOR_IDENTIFIER: 0x%llX", vmread(CONTROL_VIRTUAL_PROCESSOR_IDENTIFIER));
		LogDump("CONTROL_POSTED_INTERRUPT_NOTIFICATION_VECTOR: 0x%llX", vmread(CONTROL_POSTED_INTERRUPT_NOTIFICATION_VECTOR));
		LogDump("CONTROL_EPTP_INDEX: 0x%llX", vmread(CONTROL_EPTP_INDEX));

		// Natural Read only Register State Fields
		LogDump("EXIT_QUALIFICATION: 0x%llX", vmread(EXIT_QUALIFICATION));
		LogDump("IO_RCX: 0x%llX", vmread(IO_RCX));
		LogDump("IO_RSI: 0x%llX", vmread(IO_RSI));
		LogDump("IO_RDI: 0x%llX", vmread(IO_RDI));
		LogDump("IO_RIP: 0x%llX", vmread(IO_RIP));
		LogDump("GUEST_LINEAR_ADDRESS: 0x%llX", vmread(GUEST_LINEAR_ADDRESS));

		// 64-bit Read only Register State Fields
		LogDump("GUEST_PHYSICAL_ADDRESS: 0x%llX", vmread(GUEST_PHYSICAL_ADDRESS));

		// 32-bit Read only Register State Fields
		LogDump("VM_INSTRUCTION_ERROR: 0x%llX", vmread(VM_INSTRUCTION_ERROR));
		LogDump("EXIT_REASON: 0x%llX", vmread(EXIT_REASON));
		LogDump("VM_EXIT_INTERRUPTION_INFORMATION: 0x%llX", vmread(VM_EXIT_INTERRUPTION_INFORMATION));
		LogDump("VM_EXIT_INTERRUPTION_ERROR_CODE: 0x%llX", vmread(VM_EXIT_INTERRUPTION_ERROR_CODE));
		LogDump("IDT_VECTORING_INFORMATION_FIELD: 0x%llX", vmread(IDT_VECTORING_INFORMATION_FIELD));
		LogDump("IDT_VECTORING_ERROR_CODE: 0x%llX", vmread(IDT_VECTORING_ERROR_CODE));
		LogDump("VM_EXIT_INSTRUCTION_LENGTH: 0x%llX", vmread(VM_EXIT_INSTRUCTION_LENGTH));
		LogDump("VM_EXIT_INSTRUCTION_INFORMATION: 0x%llX", vmread(VM_EXIT_INSTRUCTION_INFORMATION));

		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "-----------------------------------VMCS CORE %u DUMP-----------------------------------\r\n", KeGetCurrentProcessorIndex());

		spinlock::unlock(&vmcs_dump_lock);
	}
}
```

`airhv/airhv-main/airhv/hypervisor_routines.h`:

```h
#pragma once
#include <ntddk.h>
#include "common.h"

enum __syscall_type
{
	SYSCALL_NT,
	SYSCALL_WIN32K
};

namespace hv 
{
	/// <summary>
	/// Check if cpu support virtualization
	/// </summary>
	/// <returns></returns>
	bool virtualization_support();

	/// <summary>
	/// Disable vmx operation
	/// </summary>
	/// <returns></returns>
	void disable_vmx_operation();

	/// <summary>
	/// Read vmcs field
	/// </summary>
	/// <param name="vmcs_field"></param>
	/// <returns></returns>
	unsigned __int64 vmread(unsigned __int64 vmcs_field);

	/// <summary>
	/// Dump whole vmcs structure
	/// </summary>
	void dump_vmcs();

	/// <summary>
	/// Set 1 msr in msr bitmap
	/// </summary>
	/// <param name="msr"> Msr number </param>
	/// <param name="vcpu"> Pointer to current vcpu </param>
	/// <param name="read"> If set vmexit occur on reading this msr </param>
	/// <param name="write"> If set vmexit occur on writing to this msr </param>
	/// <param name="value"> If true set msr bit else clear </param>
	void set_msr_bitmap(unsigned __int32 msr, __vcpu* vcpu, bool read, bool write, bool value);

	/// <summary>
	/// Set or unset bit in io port bitmap
	/// </summary>
	/// <param name="io_port"> IO port which you want to set</param>
	/// <param name="vcpu"> Pointer to current vcpu </param>
	/// <param name="value"> If true then set bit else unset bit</param>
	void set_io_bitmap(unsigned __int16 io_port, __vcpu* vcpu, bool value);

	/// <summary>
	/// 
	/// </summary>
	/// <returns> Return current guest privilage level</returns>
	unsigned __int8 get_guest_cpl();

	/// <summary>
	/// Swap cr3 with current process dtb
	/// </summary>
	/// <returns> old cr3 </returns>
	unsigned __int64 swap_context();

	/// <summary>
	/// Restore cr3
	/// </summary>
	/// <param name="old_cr3"></param>
	void restore_context(unsigned __int64 old_cr3);

	/// <summary>
	/// Check if address is canonicial (level 4 paging)
	/// </summary>
	/// <param name="address"></param>
	/// <returns></returns>
	bool is_address_canonical(unsigned __int64 address);

	/// <summary>
	/// Get system directory table base
	/// </summary>
	/// <returns></returns>
	unsigned __int64 get_system_directory_table_base();

	/// <summary>
	/// Inject interrupt/exception to guest system
	/// </summary>
	/// <param name="vector"></param>
	/// <param name="type"></param>
	/// <param name="error_code"></param>
	/// <param name="deliver_error_code"></param>
	void inject_interruption(unsigned __int32 vector, unsigned __int32 type, unsigned __int32 error_code, bool deliver_error_code);

	/// <summary>
	/// Write to reset io port to perform hard reset
	/// </summary>
	void hard_reset();

	/// <summary>
	/// Used to get address passed by user in inpvcid
	/// </summary>
	/// <param name="guest_registers"></param>
	/// <returns></returns>
	unsigned __int64 get_guest_address(__vcpu* vcpu);

	/// <summary>
	/// Write to vmcs field
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <param name="vmcs_field">Field number</param>
	/// <param name="value"> Value </param>
	template <typename T>
	void vmwrite(unsigned __int64 vmcs_field, T value)
	{
		__vmx_vmwrite(vmcs_field, (unsigned __int64)value);
	}
}
```

`airhv/airhv-main/airhv/ia32/cpuid.h`:

```h
#pragma once

#define QUERY_CPUID_BIT(x, b)        ((x) & (1 << b))
#define SET_CPUID_BIT(x, b)            (x = (x) | (1 << b))
#define CLR_CPUID_BIT(x, b)            ((x) & ~(1 << b))

#define CPUID_EXTENDED_FEATURES           0x00000007
#define CPUID_HV_VENDOR_AND_MAX_FUNCTIONS 0x40000000
#define CPUID_HV_INTERFACE                0x40000001
#define CPUID_PROCESSOR_FEATURES          0x00000001

union __cpuid_info
{
    struct
    {
        int cpu_info[4];
    };

    struct
    {
        unsigned __int32 eax;
        unsigned __int32 ebx;
        unsigned __int32 ecx;
        unsigned __int32 edx;
    };

    struct
    {
        union
        {
            unsigned __int32 flags;

            struct
            {
                unsigned __int32 stepping_id : 4;
                unsigned __int32 model : 4;
                unsigned __int32 family_id : 4;
                unsigned __int32 processor_type : 2;
                unsigned __int32 reserved1 : 2;
                unsigned __int32 extended_model_id : 4;
                unsigned __int32 extended_family_id : 8;
                unsigned __int32 reserved2 : 4;
            };
        } version_information;

        union
        {
            unsigned __int32 flags;

            struct
            {
                unsigned __int32 brand_index : 8;
                unsigned __int32 clflush_line_size : 8;
                unsigned __int32 max_addressable_ids : 8;
                unsigned __int32 initial_apic_id : 8;
            };
        } additional_information;

        union
        {
            unsigned __int32 flags;

            struct
            {
                unsigned __int32 streaming_simd_extensions_3 : 1;
                unsigned __int32 pclmulqdq_instruction : 1;
                unsigned __int32 ds_area_64bit_layout : 1;
                unsigned __int32 monitor_mwait_instruction : 1;
                unsigned __int32 cpl_qualified_debug_store : 1;
                unsigned __int32 virtual_machine_extensions : 1;
                unsigned __int32 safer_mode_extensions : 1;
                unsigned __int32 enhanced_intel_speedstep_technology : 1;
                unsigned __int32 thermal_monitor_2 : 1;
                unsigned __int32 supplemental_streaming_simd_extensions_3 : 1;
                unsigned __int32 l1_context_id : 1;
                unsigned __int32 silicon_debug : 1;
                unsigned __int32 fma_extensions : 1;
                unsigned __int32 cmpxchg16b_instruction : 1;
                unsigned __int32 xtpr_update_control : 1;
                unsigned __int32 perfmon_and_debug_capability : 1;
                unsigned __int32 reserved1 : 1;
                unsigned __int32 process_context_identifiers : 1;
                unsigned __int32 direct_cache_access : 1;
                unsigned __int32 sse41_support : 1;
                unsigned __int32 sse42_support : 1;
                unsigned __int32 x2apic_support : 1;
                unsigned __int32 movbe_instruction : 1;
                unsigned __int32 popcnt_instruction : 1;
                unsigned __int32 tsc_deadline : 1;
                unsigned __int32 aesni_instruction_extensions : 1;
                unsigned __int32 xsave_xrstor_instruction : 1;
                unsigned __int32 osx_save : 1;
                unsigned __int32 avx_support : 1;
                unsigned __int32 half_precision_conversion_instructions : 1;
                unsigned __int32 rdrand_instruction : 1;
                unsigned __int32 hypervisor_present : 1;
            };
        } feature_information_ecx;

        union
        {
            unsigned __int32 flags;

            struct
            {
                unsigned __int32 floating_point_unit_on_chip : 1;
                unsigned __int32 virtual_8086_mode_enhancements : 1;
                unsigned __int32 debugging_extensions : 1;
                unsigned __int32 page_size_extension : 1;
                unsigned __int32 timestamp_counter : 1;
                unsigned __int32 rdmsr_wrmsr_instructions : 1;
                unsigned __int32 physical_address_extension : 1;
                unsigned __int32 machine_check_exception : 1;
                unsigned __int32 cmpxchg8b : 1;
                unsigned __int32 apic_on_chip : 1;
                unsigned __int32 reserved1 : 1;
                unsigned __int32 sysenter_sysexit_instructions : 1;
                unsigned __int32 memory_type_range_registers : 1;
                unsigned __int32 page_global_bit : 1;
                unsigned __int32 machine_check_architecture : 1;
                unsigned __int32 conditional_move_instructions : 1;
                unsigned __int32 page_attribute_table : 1;
                unsigned __int32 page_size_extension_36bit : 1;
                unsigned __int32 processor_serial_number : 1;
                unsigned __int32 clflush : 1;
                unsigned __int32 reserved2 : 1;
                unsigned __int32 debug_store : 1;
                unsigned __int32 thermal_control_msrs_for_acpi : 1;
                unsigned __int32 mmx_support : 1;
                unsigned __int32 fxsave_fxrstor_instructions : 1;
                unsigned __int32 sse_support : 1;
                unsigned __int32 sse2_support : 1;
                unsigned __int32 self_snoop : 1;
                unsigned __int32 hyper_threading_technology : 1;
                unsigned __int32 thermal_monitor : 1;
                unsigned __int32 reserved3 : 1;
                unsigned __int32 pending_break_enable : 1;
            };
        } feature_information_edx;
    }cpuid_eax_01;

    struct
    {
        union
        {
            unsigned __int32 flags;

            struct
            {
                unsigned __int32 perf_mon_arch_ver_id : 8;
                unsigned __int32 gp_perf_mon_counter_number : 8;
                unsigned __int32 gp_perf_mon_counter_bit_width : 8;
                unsigned __int32 ebx_bit_vector_length : 8;
            };
        } feature_information_eax;

        union
        {
            unsigned __int32 flags;

            struct
            {
                unsigned __int32 core_cycles : 1;
                unsigned __int32 instructions_retired : 1;
                unsigned __int32 reference_cycles : 1;
                unsigned __int32 last_level_cache_references : 1;
                unsigned __int32 last_level_cache_misses : 1;
                unsigned __int32 branch_instructions_retired : 1;
                unsigned __int32 branch_misprediction_retired : 1;
                unsigned __int32 reserved : 25;
            };
        } feature_information_ebx;

        union
        {
            unsigned __int32 flags;

            struct
            {
                unsigned __int32 reserved : 32;
            };
        } feature_information_ecx;

        union
        {
            unsigned __int32 flags;

            struct
            {
                unsigned __int32 fixed_counters_number : 5;
                unsigned __int32 fixed_counters_number_bits : 8;
                unsigned __int32 reserved : 19;
            };
        } feature_information_edx;
    }cpuid_eax_0a;
};
```

`airhv/airhv-main/airhv/ia32/cr.h`:

```h
#pragma once

enum __cr_access_type 
{
    CR_ACCESS_MOV_TO_CR,
    CR_ACCESS_MOV_FROM_CR,
    CR_ACCESS_CLTS,
    CR_ACCESS_LMSW
};

union __cr_access_qualification 
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 cr_number : 4;
        unsigned __int64 access_type : 2;
        unsigned __int64 operand_type : 1;
        unsigned __int64 reserved1 : 1;
        unsigned __int64 register_type : 4;
        unsigned __int64 reserved2 : 4;
        unsigned __int64 source_data : 16;
        unsigned __int64 reserved3 : 32;
    };
};

union __cr_fixed
{
    unsigned __int64 all;
    struct
    {
        unsigned long low;
        long high;
    } split;
    struct
    {
        unsigned long low;
        long high;
    } u;
};

union __cr8
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 task_priority_level : 4;
        unsigned __int64 reserved : 59;
    };
};

union __cr0

{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 protection_enable : 1;
        unsigned __int64 monitor_coprocessor : 1;
        unsigned __int64 emulate_fpu : 1;
        unsigned __int64 task_switched : 1;
        unsigned __int64 extension_type : 1;
        unsigned __int64 numeric_error : 1;
        unsigned __int64 reserved_1 : 10;
        unsigned __int64 write_protect : 1;
        unsigned __int64 reserved_2 : 1;
        unsigned __int64 alignment_mask : 1;
        unsigned __int64 reserved_3 : 10;
        unsigned __int64 not_write_through : 1;
        unsigned __int64 cache_disable : 1;
        unsigned __int64 paging_enable : 1;
        unsigned __int64 reserved_4 : 32;
    };
};

union __cr2
{
    unsigned __int64 linear_address;
};

union __cr3
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 pcid : 12;
        unsigned __int64 page_frame_number : 36;
        unsigned __int64 reserved_1 : 12;
        unsigned __int64 reserved_2 : 3;
        unsigned __int64 pcid_invalidate : 1;
    };
};

union __cr4
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 virtual_mode_extensions : 1;
        unsigned __int64 protected_mode_virtual_interrupts : 1;
        unsigned __int64 timestamp_disable : 1;
        unsigned __int64 debugging_extensions : 1;
        unsigned __int64 page_size_extensions : 1;
        unsigned __int64 physical_address_extension : 1;
        unsigned __int64 machine_check_enable : 1;
        unsigned __int64 page_global_enable : 1;
        unsigned __int64 performance_monitoring_counter_enable : 1;
        unsigned __int64 os_fxsave_fxrstor_support : 1;
        unsigned __int64 os_xmm_exception_support : 1;
        unsigned __int64 usermode_instruction_prevention : 1;
        unsigned __int64 reserved_1 : 1;
        unsigned __int64 vmx_enable : 1;
        unsigned __int64 smx_enable : 1;
        unsigned __int64 reserved_2 : 1;
        unsigned __int64 fsgsbase_enable : 1;
        unsigned __int64 pcid_enable : 1;
        unsigned __int64 os_xsave : 1;
        unsigned __int64 reserved_3 : 1;
        unsigned __int64 smep_enable : 1;
        unsigned __int64 smap_enable : 1;
        unsigned __int64 protection_key_enable : 1;
    };
};

union __xcr0 
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 x87 : 1;
        unsigned __int64 sse : 1;
        unsigned __int64 avx : 1;
        unsigned __int64 bndreg : 1;
        unsigned __int64 bndcsr : 1;
        unsigned __int64 opmask : 1;
        unsigned __int64 zmm_hi256 : 1;
        unsigned __int64 hi16_zmm : 1;
        unsigned __int64 reserved1 : 1;
        unsigned __int64 pkru : 1;
        unsigned __int64 reserved2 : 1;
        unsigned __int64 cet_user_state : 1;
        unsigned __int64 cet_supervisor_state : 1;
        unsigned __int64 xaad : 1;
        unsigned __int64 reserved3 : 50;
    };
};
```

`airhv/airhv-main/airhv/ia32/dr.h`:

```h
#pragma once
union __dr6
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 breakpoint_condition : 4;
        unsigned __int64 reserved_1 : 8; // always 1
        unsigned __int64 reserved_2 : 1; // always 0
        unsigned __int64 debug_register_access_detected : 1;
        unsigned __int64 single_instruction : 1;
        unsigned __int64 task_switch : 1;
        unsigned __int64 restricted_transactional_memory : 1;
        unsigned __int64 reserved_3 : 15; // always 1
    };
};

union __dr7
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 local_breakpoint_0 : 1;
        unsigned __int64 global_breakpoint_0 : 1;
        unsigned __int64 local_breakpoint_1 : 1;
        unsigned __int64 global_breakpoint_1 : 1;
        unsigned __int64 local_breakpoint_2 : 1;
        unsigned __int64 global_breakpoint_2 : 1;
        unsigned __int64 local_breakpoint_3 : 1;
        unsigned __int64 global_breakpoint_3 : 1;
        unsigned __int64 local_exact_breakpoint : 1;
        unsigned __int64 global_exact_breakpoint : 1;
        unsigned __int64 reserved_1 : 1; // always 1
        unsigned __int64 restricted_transactional_memory : 1;
        unsigned __int64 reserved_2 : 1; // always 0
        unsigned __int64 general_detect : 1;
        unsigned __int64 reserved_3 : 2; // always 0
        unsigned __int64 read_write_0 : 2;
        unsigned __int64 length_0 : 2;
        unsigned __int64 read_write_1 : 2;
        unsigned __int64 length_1 : 2;
        unsigned __int64 read_write_2 : 2;
        unsigned __int64 length_2 : 2;
        unsigned __int64 read_write_3 : 2;
        unsigned __int64 length_3 : 2;
    };
};

```

`airhv/airhv-main/airhv/ia32/ept.h`:

```h
#pragma once
#include "invalidators.h"

#define MASK_EPT_PML1_OFFSET(_VAR_) ((unsigned __int64)_VAR_ & 0xFFFULL)
#define MASK_EPT_PML1_INDEX(_VAR_) ((_VAR_ & 0x1FF000ULL) >> 12)
#define MASK_EPT_PML2_INDEX(_VAR_) ((_VAR_ & 0x3FE00000ULL) >> 21)
#define MASK_EPT_PML3_INDEX(_VAR_) ((_VAR_ & 0x7FC0000000ULL) >> 30)
#define MASK_EPT_PML4_INDEX(_VAR_) ((_VAR_ & 0xFF8000000000ULL) >> 39)
#define CPU_BASED_MONITOR_TRAP_FLAG 0x08000000

union __eptp
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 memory_type : 3; 
		unsigned __int64 page_walk_length : 3;
		unsigned __int64 dirty_and_aceess_enabled : 1;
		unsigned __int64 reserved1 : 5; 
		unsigned __int64 pml4_address : 36;
		unsigned __int64 reserved2 : 16;
	};
};


// See Table 28-1. 
union __ept_pml4e
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 read : 1; // bit 0
		unsigned __int64 write : 1; // bit 1
		unsigned __int64 execute : 1; // bit 2
		unsigned __int64 reserved1 : 5; // bit 7:3 (Must be Zero)
		unsigned __int64 accessed : 1; // bit 8
		unsigned __int64 ignored1 : 1; // bit 9
		unsigned __int64 execute_for_usermode : 1; // bit 10
		unsigned __int64 ignored2 : 1; // bit 11
		unsigned __int64 physical_address : 36; // bit (N-1):12 or Page-Frame-Number
		unsigned __int64 reserved2 : 4; // bit 51:N
		unsigned __int64 ignored3 : 12; // bit 63:52
	};
};

// See Table 28-3
union __ept_pdpte
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 read : 1; // bit 0
		unsigned __int64 write : 1; // bit 1
		unsigned __int64 execute : 1; // bit 2
		unsigned __int64 reserved1 : 5; // bit 7:3 (Must be Zero)
		unsigned __int64 accessed : 1; // bit 8
		unsigned __int64 ignored1 : 1; // bit 9
		unsigned __int64 execute_for_usermode : 1; // bit 10
		unsigned __int64 ignored2 : 1; // bit 11
		unsigned __int64 physical_address : 36; // bit (N-1):12 or Page-Frame-Number
		unsigned __int64 reserved2 : 4; // bit 51:N
		unsigned __int64 ignored3 : 12; // bit 63:52
	};
};

// See Table 28-5
union __ept_pde {
	unsigned __int64 all;
	struct
	{
		unsigned __int64 read : 1; // bit 0
		unsigned __int64 write : 1; // bit 1
		unsigned __int64 execute : 1; // bit 2
		unsigned __int64 reserved1 : 5; // bit 7:3 (Must be Zero)
		unsigned __int64 accessed : 1; // bit 8
		unsigned __int64 ignored1 : 1; // bit 9
		unsigned __int64 execute_for_usermode : 1; // bit 10
		unsigned __int64 ignored2 : 1; // bit 11
		unsigned __int64 physical_address : 36; // bit (N-1):12 or Page-Frame-Number
		unsigned __int64 reserved2 : 4; // bit 51:N
		unsigned __int64 ignored3 : 12; // bit 63:52
	}large_page;
	struct
	{
		unsigned __int64 read : 1;
		unsigned __int64 write : 1;
		unsigned __int64 execute : 1;
		unsigned __int64 memory_type : 3;
		unsigned __int64 ignore_pat : 1;
		unsigned __int64 large_page : 1;
		unsigned __int64 accessed : 1;
		unsigned __int64 dirty : 1;
		unsigned __int64 execute_for_usermode : 1;
		unsigned __int64 reserved1 : 10;
		unsigned __int64 physical_address : 27;
		unsigned __int64 reserved2 : 15;
		unsigned __int64 suppressve : 1;
	}page_directory_entry;
};

// See Table 28-6																	 
union __ept_pte {
	unsigned __int64 all;
	struct
	{
		unsigned __int64 read : 1; // bit 0											 
		unsigned __int64 write : 1; // bit 1										 
		unsigned __int64 execute : 1; // bit 2
		unsigned __int64 ept_memory_type : 3; // bit 5:3 (EPT Memory type)
		unsigned __int64 ignore_pat : 1; // bit 6
		unsigned __int64 ignored1 : 1; // bit 7
		unsigned __int64 accessed_flag : 1; // bit 8	
		unsigned __int64 dirty_flag : 1; // bit 9
		unsigned __int64 execute_for_usermode : 1; // bit 10
		unsigned __int64 ignored2 : 1; // bit 11
		unsigned __int64 physical_address : 36; // bit (N-1):12 or Page-Frame-Number
		unsigned __int64 reserved : 4; // bit 51:N
		unsigned __int64 ignored3 : 11; // bit 62:52
		unsigned __int64 suppress_ve : 1; // bit 63
	};
};

struct __ept_dynamic_split
{
	DECLSPEC_ALIGN(PAGE_SIZE) __ept_pte pml1[512];

	__ept_pde* entry;

	LIST_ENTRY dynamic_split_list;
};

struct __vmm_ept_page_table
{
	DECLSPEC_ALIGN(PAGE_SIZE) __ept_pml4e pml4[512];

	DECLSPEC_ALIGN(PAGE_SIZE) __ept_pdpte pml3[512];

	DECLSPEC_ALIGN(PAGE_SIZE) __ept_pde pml2[512][512];
};

struct __ept_hooked_function_info 
{
	//
	// Linked list entires for each function hook.
	//
	LIST_ENTRY hooked_function_list;

	//
	// Pointer to page with our hooked functions
	//
	unsigned __int8* fake_page_contents;

	//
	// Size of hook
	//
	unsigned __int64 hook_size;

	//
	// Virtual address of function
	//
	void* virtual_address;

	//
	// Address to first trampoline used to call original function
	//
	unsigned __int8* first_trampoline_address;

	//
	// Address of code cave which is used to jmp to our hooked function
	//
	void* second_trampoline_address;
};

struct __ept_hooked_page_info
{
	//
	// Page with our hooked functions
	//
	DECLSPEC_ALIGN(PAGE_SIZE) unsigned __int8 fake_page_contents[PAGE_SIZE];

	//
	// Linked list entires for each page hook.
	//
	LIST_ENTRY hooked_page_list;

	//
	// Linked list entries for each function hook
	//
	LIST_ENTRY hooked_functions_list;

	//
	// The base address of the page. Used to find this structure in the list of page hooks
	//
	unsigned __int64 pfn_of_hooked_page;

	//
	// The base address of the page with fake contents. Used to swap page with fake contents
	//
	unsigned __int64 pfn_of_fake_page_contents;

	//
	// The page entry in the page tables that this page is targetting.
	//
	__ept_pte* entry_address;

	//
	// The original page entry
	// 
	__ept_pte original_entry;

	//
	// The changed page entry
	//
	__ept_pte changed_entry;
};

union __ept_violation
{
	unsigned __int64 all;
	struct
	{
		/**
		 * [Bit 0] Set if the access causing the EPT violation was a data read.
		 */
		unsigned __int64 read_access : 1;

		/**
		 * [Bit 1] Set if the access causing the EPT violation was a data write.
		 */
		unsigned __int64 write_access : 1;

		/**
		 * [Bit 2] Set if the access causing the EPT violation was an instruction fetch.
		 */
		unsigned __int64 execute_access : 1;

		/**
		 * [Bit 3] The logical-AND of bit 0 in the EPT paging-structure entries used to translate the guest-physical address of the
		 * access causing the EPT violation (indicates whether the guest-physical address was readable).
		 */
		unsigned __int64 ept_readable : 1;

		/**
		 * [Bit 4] The logical-AND of bit 1 in the EPT paging-structure entries used to translate the guest-physical address of the
		 * access causing the EPT violation (indicates whether the guest-physical address was writeable).
		 */
		unsigned __int64 ept_writeable : 1;

		/**
		 * [Bit 5] The logical-AND of bit 2 in the EPT paging-structure entries used to translate the guest-physical address of the
		 * access causing the EPT violation.
		 * If the "mode-based execute control for EPT" VM-execution control is 0, this indicates whether the guest-physical address
		 * was executable. If that control is 1, this indicates whether the guest-physical address was executable for
		 * supervisor-mode linear addresses.
		 */
		unsigned __int64 ept_executable : 1;

		/**
		 * [Bit 6] If the "mode-based execute control" VM-execution control is 0, the value of this bit is undefined. If that
		 * control is 1, this bit is the logical-AND of bit 10 in the EPT paging-structures entries used to translate the
		 * guest-physical address of the access causing the EPT violation. In this case, it indicates whether the guest-physical
		 * address was executable for user-mode linear addresses.
		 */
		unsigned __int64 ept_executable_for_usermode : 1;

		/**
		 * [Bit 7] Set if the guest linear-address field is valid. The guest linear-address field is valid for all EPT violations
		 * except those resulting from an attempt to load the guest PDPTEs as part of the execution of the MOV CR instruction.
		 */
		unsigned __int64 valid_guest_linear_address : 1;

		/**
		 * [Bit 8] If bit 7 is 1:
		 * - Set if the access causing the EPT violation is to a guest-physical address that is the translation of a linear
		 * address.
		 * - Clear if the access causing the EPT violation is to a paging-structure entry as part of a page walk or the update of
		 * an accessed or dirty bit.
		 * Reserved if bit 7 is 0 (cleared to 0).
		 */
		unsigned __int64 caused_by_translation : 1;

		/**
		 * [Bit 9] This bit is 0 if the linear address is a supervisor-mode linear address and 1 if it is a user-mode linear
		 * address. Otherwise, this bit is undefined.
		 *
		 * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
		 *          CR0.PG = 0, the translation of every linear address is a user-mode linear address and thus this bit will be 1.)
		 */
		unsigned __int64 usermode_linear_address : 1;

		/**
		 * [Bit 10] This bit is 0 if paging translates the linear address to a read-only page and 1 if it translates to a
		 * read/write page. Otherwise, this bit is undefined
		 *
		 * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
		 *          CR0.PG = 0, every linear address is read/write and thus this bit will be 1.)
		 */
		unsigned __int64 readable_writable_page : 1;

		/**
		 * [Bit 11] This bit is 0 if paging translates the linear address to an executable page and 1 if it translates to an
		 * execute-disable page. Otherwise, this bit is undefined.
		 *
		 * @remarks If bit 7 is 1, bit 8 is 1, and the processor supports advanced VM-exit information for EPT violations. (If
		 *          CR0.PG = 0, CR4.PAE = 0, or MSR_IA32_EFER.NXE = 0, every linear address is executable and thus this bit will be 0.)
		 */
		unsigned __int64 execute_disable_page : 1;

		/**
		 * [Bit 12] NMI unblocking due to IRET.
		 */
		unsigned __int64 nmi_unblocking : 1;
		unsigned __int64 reserved1 : 51;
	};
};

namespace ept
{
	/// <summary>
	/// Build mtrr map to track physical memory type
	/// </summary>
	void build_mtrr_map();

	/// <summary>
	/// Initialize ept structure
	/// </summary>
	/// <returns></returns>
	bool initialize();

	/// <summary>
	/// Change page physcial frame number and invalidate tlb
	/// </summary>
	/// <param name="entry_address"> Pointer to page table entry which we want to change </param>
	/// <param name="entry_value"> Pointer to page table entry which we want use to change </param>
	/// <param name="invalidate"> If true invalidates tlb after changning pte value </param>
	/// <param name="invalidation_type"> Specifiy if we want to invalidate single context or all contexts  </param>
	void swap_pml1_and_invalidate_tlb(__ept_pte* entry_address, __ept_pte entry_value, invept_type invalidation_type);

	/// <summary>
	/// Unhook all functions and invalidate tlb
	/// </summary>
	void unhook_all_functions();

	/// <summary>
	/// Perfrom a hook
	/// </summary>
	/// <param name="target_address" > Address of function which we want to hook </param>
	/// <param name="hook_function"> Address of hooked version of function which we are hooking </param>
	/// <param name="(Optional) trampoline"> Address of codecave which is located in 2gb range of target function (Use only if you need smaller trampoline)</param>
	/// <param name="origin_function"> Address used to call original function </param>
	/// <returns></returns>
	bool hook_function(void* target_address, void* hook_function, void* trampoline, void** origin_function);

	/// <summary>
	/// Unhook single function
	/// </summary>
	/// <param name="virtual_address"></param>
	/// <returns></returns>
	bool unhook_function(unsigned __int64 virtual_address);

	/// <summary>
	/// Swap physcial pages and invalidate tlb
	/// </summary>
	/// <param name="entry_address"> Pointer to page table entry which we want to change </param>
	/// <param name="entry_value"> Pointer to page table entry which we want use to change </param>
	void swap_pml1(__ept_pte* entry_address, __ept_pte entry_value);

	/// <summary>
	/// Split pml2 into 512 pml1 entries (From one 2MB page to 512 4KB pages)
	/// </summary>
	/// <param name="pre_allocated_buffer"> Pre allocated buffer for split </param>
	/// <param name="physical_address"></param>
	/// <returns> status </returns>
	bool split_pml2(void* pre_allocated_buffer, unsigned __int64 physical_address);
}
```

`airhv/airhv-main/airhv/ia32/exception.h`:

```h
#pragma once
union __exception_bitmap
{
    unsigned __int32 all;
    struct
    {
        unsigned __int32 divide_error : 1;
        unsigned __int32 debug : 1;
        unsigned __int32 nmi_interrupt : 1;
        unsigned __int32 breakpoint : 1;
        unsigned __int32 overflow : 1;
        unsigned __int32 bound : 1;
        unsigned __int32 invalid_opcode : 1;
        unsigned __int32 device_not_available : 1;
        unsigned __int32 double_fault : 1;
        unsigned __int32 coprocessor_segment_overrun : 1;
        unsigned __int32 invalid_tss : 1;
        unsigned __int32 segment_not_present : 1;
        unsigned __int32 stack_segment_fault : 1;
        unsigned __int32 general_protection : 1;
        unsigned __int32 page_fault : 1;
        unsigned __int32 x87_floating_point_error : 1;
        unsigned __int32 alignment_check : 1;
        unsigned __int32 machine_check : 1;
        unsigned __int32 simd_floating_point_error : 1;
        unsigned __int32 virtualization_exception : 1;
    };
};
```

`airhv/airhv-main/airhv/ia32/msr.h`:

```h
#pragma once
#include "common.h"

#define IA32_FEATURE_CONTROL 0x3A
#define IA32_VMX_BASIC 0x480
#define IA32_VMX_ENTRY_CTLS 0x484
#define IA32_VMX_CR0_FIXED0 0x486
#define IA32_VMX_CR0_FIXED1 0x487
#define IA32_VMX_CR4_FIXED0 0x488
#define IA32_VMX_CR4_FIXED1 0x489
#define IA32_VMX_TRUE_ENTRY_CTLS 0x490
#define IA32_VMX_TRUE_EXIT_CTLS 0x48F
#define IA32_VMX_EXIT_CTLS 0x483
#define IA32_VMX_TRUE_PINBASED_CTLS 0x48D
#define IA32_VMX_PINBASED_CTLS 0x481
#define IA32_VMX_TRUE_PROCBASED_CTLS 0x48E
#define IA32_VMX_PROCBASED_CTLS 0x482
#define IA32_VMX_PROCBASED_CTLS2 0x48B
#define IA32_DEBUGCTL 0x1D9
#define IA32_SYSENTER_CS 0x174
#define IA32_SYSENTER_ESP 0x175
#define IA32_SYSENTER_EIP 0x176
#define IA32_PERF_GLOBAL_CTRL 0x38F
#define IA32_PAT 0x277
#define IA32_EFER 0xC0000080
#define IA32_BNDCFGS 0xD90
#define IA32_RTIT_CTL 0x570
#define IA32_S_CET 0x6A2
#define IA32_INTERRUPT_SSP_TABLE_ADDR 0x6A8
#define IA32_XSS 0xDA0
#define IA32_PKRS 0x6E1
#define IA32_FS_BASE 0xC0000100
#define IA32_GS_BASE 0xC0000101
#define IA32_TSC_AUX 0xC0000103
#define IA32_MTRRCAP 0xFE
#define IA32_MTRR_DEF_TYPE 0x2FF
#define IA32_MTRR_PHYSBASE0 0x200
#define IA32_MTRR_PHYSMASK0 0x201
#define IA32_SMRR_PHYSBASE 0x1F2
#define IA32_SMRR_PHYSMASK 0x1F3
#define IA32_MTRR_FIX64K_00000 0x250
#define IA32_MTRR_FIX16K_80000 0x258
#define IA32_MTRR_FIX4K_C0000 0x268
#define IA32_LSTAR 0xC0000082
#define SYNTHETHIC_MSR_LOW 0x40000000
#define SYNTHETHIC_MSR_HI  0x400000F0
#define MSR_MASK_LOW ((unsigned __int64)(unsigned __int32) - 1)

union __msr
{
    unsigned __int64 all;
    struct
    {
        unsigned __int32 low;
        unsigned __int32 high;
    };
};

union __ia32_efer_t
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 syscall_enable : 1;
        unsigned __int64 reserved_0 : 7;
        unsigned __int64 long_mode_enable : 1;
        unsigned __int64 reserved_1 : 1;
        unsigned __int64 long_mode_active : 1;
        unsigned __int64 execute_disable : 1;
        unsigned __int64 reserved_2 : 52;
    };
};

union __ia32_feature_control_msr
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 lock : 1;
        unsigned __int64 vmxon_inside_smx : 1;
        unsigned __int64 vmxon_outside_smx : 1;
        unsigned __int64 reserved_0 : 5;
        unsigned __int64 senter_local : 6;
        unsigned __int64 senter_global : 1;
        unsigned __int64 reserved_1 : 1;
        unsigned __int64 sgx_launch_control_enable : 1;
        unsigned __int64 sgx_global_enable : 1;
        unsigned __int64 reserved_2 : 1;
        unsigned __int64 lmce : 1;
        unsigned __int64 system_reserved : 42;
    };
};

union __vmx_misc_msr_t
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 vmx_preemption_tsc_rate : 5;
        unsigned __int64 store_lma_in_vmentry_control : 1;
        unsigned __int64 activate_state_bitmap : 3;
        unsigned __int64 reserved_0 : 5;
        unsigned __int64 pt_in_vmx : 1;
        unsigned __int64 rdmsr_in_smm : 1;
        unsigned __int64 cr3_target_value_count : 9;
        unsigned __int64 max_msr_vmexit : 3;
        unsigned __int64 allow_smi_blocking : 1;
        unsigned __int64 vmwrite_to_any : 1;
        unsigned __int64 interrupt_mod : 1;
        unsigned __int64 reserved_1 : 1;
        unsigned __int64 mseg_revision_identifier : 32;
    };
};

union __vmx_basic_msr
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 vmcs_revision_identifier : 31;
        unsigned __int64 always_0 : 1;
        unsigned __int64 vmxon_region_size : 13;
        unsigned __int64 reserved_1 : 3;
        unsigned __int64 vmxon_physical_address_width : 1;
        unsigned __int64 dual_monitor_smi : 1;
        unsigned __int64 memory_type : 4;
        unsigned __int64 io_instruction_reporting : 1;
        unsigned __int64 true_controls : 1;
    };
};
```

`airhv/airhv-main/airhv/ia32/mtrr.h`:

```h
#pragma once
enum __mtrr_memory_types
{
	MEMORY_TYPE_UNCACHEABLE,
	MEMORY_TYPE_WRITE_COMBINING,
	MEMORY_TYPE_WRITE_THROUGH = 4,
	MEMORY_TYPE_WRITE_PROTECTED,
	MEMORY_TYPE_WRITE_BACK,
	MEMORY_TYPE_INVALID = 255,
};

struct __mtrr_range_descriptor
{
	unsigned __int64 physcial_base_address;
	unsigned __int64 physcial_end_address;
	unsigned __int8 memory_type;
	bool fixed_range;
};

union __mtrr_physmask_reg
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 reserved : 11;
		unsigned __int64 valid : 1;
		unsigned __int64 physmask : 36;
		unsigned __int64 reserved2 : 16;
	};
};

union __mtrr_physbase_reg
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 type : 8;
		unsigned __int64 reserved : 4;
		unsigned __int64 physbase : 36;
		unsigned __int64 reserved2 : 16;
	};
};

union __mtrr_cap_reg
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 range_register_number : 8;
		unsigned __int64 fixed_range_support : 1;
		unsigned __int64 reserved : 1;
		unsigned __int64 write_combining_support : 1;
		unsigned __int64 smrr_support : 1;
		unsigned __int64 reserved2 : 52;
	};
};

union __mtrr_def_type 
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 memory_type : 8;
		unsigned __int64 reserved1 : 2;
		unsigned __int64 fixed_range_mtrr_enabled : 1;
		unsigned __int64 mtrr_enabled : 1;
		unsigned __int64 reserved2 : 52;
	};
};

union __mtrr_fixed_range_type 
{
	unsigned __int64 all;
	struct
	{
		unsigned __int8 types[8];
	};
};
```

`airhv/airhv-main/airhv/ia32/rflags.h`:

```h
#pragma once

union __rflags
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 carry_flag : 1;
        unsigned __int64 read_as_1 : 1;
        unsigned __int64 parity_flag : 1;
        unsigned __int64 reserved_1 : 1;
        unsigned __int64 auxiliary_carry_flag : 1;
        unsigned __int64 reserved_2 : 1;
        unsigned __int64 zero_flag : 1;
        unsigned __int64 sign_flag : 1;
        unsigned __int64 trap_flag : 1;
        unsigned __int64 interrupt_enable_flag : 1;
        unsigned __int64 direction_flag : 1;
        unsigned __int64 overflow_flag : 1;
        unsigned __int64 io_privilege_level : 2;
        unsigned __int64 nested_task_flag : 1;
        unsigned __int64 reserved_3 : 1;
        unsigned __int64 resume_flag : 1;
        unsigned __int64 virtual_8086_mode_flag : 1;
        unsigned __int64 alignment_check_flag : 1;
        unsigned __int64 virtual_interrupt_flag : 1;
        unsigned __int64 virtual_interrupt_pending_flag : 1;
        unsigned __int64 identification_flag : 1;
    };
};
```

`airhv/airhv-main/airhv/ia32/segment.h`:

```h
#pragma once
enum __segment_registers
{
    ES = 0,
    CS,
    SS,
    DS,
    FS,
    GS,
    LDTR,
    TR
};

union __segment_access_rights
{
    struct
    {
        unsigned __int32 type : 4;
        unsigned __int32 descriptor_type : 1;
        unsigned __int32 dpl : 2;
        unsigned __int32 present : 1;
        unsigned __int32 reserved0 : 4;
        unsigned __int32 available : 1;
        unsigned __int32 long_mode : 1;
        unsigned __int32 default_big : 1;
        unsigned __int32 granularity : 1;
        unsigned __int32 unusable : 1;
        unsigned __int32 reserved1 : 15;
    };

    unsigned __int32 all;
};

struct __segment_descriptor
{
    unsigned __int16 limit_low;
    unsigned __int16 base_low;
    union
    {
        struct
        {
            unsigned __int32 base_middle : 8;
            unsigned __int32 type : 4;
            unsigned __int32 descriptor_type : 1;
            unsigned __int32 dpl : 2;
            unsigned __int32 present : 1;
            unsigned __int32 segment_limit_high : 4;
            unsigned __int32 system : 1;
            unsigned __int32 long_mode : 1;
            unsigned __int32 default_big : 1;
            unsigned __int32 granularity : 1;
            unsigned __int32 base_high : 8;
        };
    };

    unsigned __int32 base_upper;
    unsigned __int32 reserved;
};

union __segment_selector 
{
    unsigned short all;
    struct
    {
        unsigned short rpl : 2;
        unsigned short ti : 1;
        unsigned short index : 13;
    };
};

#pragma pack(push, 1)
struct __pseudo_descriptor64
{
    unsigned __int16 limit;
    unsigned __int64 base_address;
};
#pragma pack(pop)

#pragma pack(push, 1)
struct __pseudo_descriptor32
{
    unsigned __int16 limit;
    unsigned __int32 base_address;
};
#pragma pack(pop)
```

`airhv/airhv-main/airhv/ia32/vmcs.h`:

```h
#pragma once

union __vmx_secondary_processor_based_control
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 virtualize_apic_accesses : 1;
        unsigned __int64 enable_ept : 1;
        unsigned __int64 descriptor_table_exiting : 1;
        unsigned __int64 enable_rdtscp : 1;
        unsigned __int64 virtualize_x2apic : 1;
        unsigned __int64 enable_vpid : 1;
        unsigned __int64 wbinvd_exiting : 1;
        unsigned __int64 unrestricted_guest : 1;
        unsigned __int64 apic_register_virtualization : 1;
        unsigned __int64 virtual_interrupt_delivery : 1;
        unsigned __int64 pause_loop_exiting : 1;
        unsigned __int64 rdrand_exiting : 1;
        unsigned __int64 enable_invpcid : 1;
        unsigned __int64 enable_vmfunc : 1;
        unsigned __int64 vmcs_shadowing : 1;
        unsigned __int64 enable_encls_exiting : 1;
        unsigned __int64 rdseed_exiting : 1;
        unsigned __int64 enable_pml : 1;
        unsigned __int64 use_virtualization_exception : 1;
        unsigned __int64 conceal_vmx_from_pt : 1;
        unsigned __int64 enable_xsave_xrstor : 1;
        unsigned __int64 reserved_0 : 1;
        unsigned __int64 mode_based_execute_control_ept : 1;
        unsigned __int64 sub_page_write_permission_for_ept : 1;
        unsigned __int64 intel_pt_uses_guest_physical_address : 1;
        unsigned __int64 use_tsc_scaling : 1;
        unsigned __int64 enable_user_wait_and_pause : 1;
        unsigned __int64 enable_enclv_exiting : 1;
    };
};

union __vmx_primary_processor_based_control
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 reserved_0 : 2; 
        unsigned __int64 interrupt_window_exiting : 1;
        unsigned __int64 use_tsc_offsetting : 1;
        unsigned __int64 reserved_1 : 3;
        unsigned __int64 hlt_exiting : 1;
        unsigned __int64 reserved_2 : 1;
        unsigned __int64 invldpg_exiting : 1;
        unsigned __int64 mwait_exiting : 1;
        unsigned __int64 rdpmc_exiting : 1;
        unsigned __int64 rdtsc_exiting : 1;
        unsigned __int64 reserved_3 : 2;
        unsigned __int64 cr3_load_exiting : 1;
        unsigned __int64 cr3_store_exiting : 1;
        unsigned __int64 reserved_4 : 2;
        unsigned __int64 cr8_load_exiting : 1;
        unsigned __int64 cr8_store_exiting : 1;
        unsigned __int64 use_tpr_shadow : 1;
        unsigned __int64 nmi_window_exiting : 1;
        unsigned __int64 mov_dr_exiting : 1;
        unsigned __int64 unconditional_io_exiting : 1;
        unsigned __int64 use_io_bitmaps : 1;
        unsigned __int64 reserved_5 : 1;
        unsigned __int64 monitor_trap_flag : 1;
        unsigned __int64 use_msr_bitmaps : 1;
        unsigned __int64 monitor_exiting : 1;
        unsigned __int64 pause_exiting : 1;
        unsigned __int64 active_secondary_controls : 1;
    };
};

union __vmx_pinbased_control_msr
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 external_interrupt_exiting : 1;
        unsigned __int64 reserved_0 : 2;
        unsigned __int64 nmi_exiting : 1;
        unsigned __int64 reserved_1 : 1;
        unsigned __int64 virtual_nmis : 1;
        unsigned __int64 vmx_preemption_timer : 1;
        unsigned __int64 process_posted_interrupts : 1;
    };
};

union __vmx_true_control_settings
{
    unsigned __int64 all;
    struct
    {
        unsigned __int32 allowed_0_settings;
        unsigned __int32 allowed_1_settings;
    };
};

union __vmx_entry_control
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 reserved_0 : 2;
        unsigned __int64 load_dbg_controls : 1;
        unsigned __int64 reserved_1 : 6;
        unsigned __int64 ia32e_mode_guest : 1;
        unsigned __int64 entry_to_smm : 1;
        unsigned __int64 deactivate_dual_monitor_treament : 1;
        unsigned __int64 reserved_3 : 1;
        unsigned __int64 load_ia32_perf_global_control : 1;
        unsigned __int64 load_ia32_pat : 1;
        unsigned __int64 load_ia32_efer : 1;
        unsigned __int64 load_ia32_bndcfgs : 1;
        unsigned __int64 conceal_vmx_from_pt : 1;
        unsigned __int64 load_ia32_rtit_ctl : 1;
        unsigned __int64 load_cet_state : 1;
        unsigned __int64 load_pkrs : 1;
    };
};

union __interrupt_command_register
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 vector : 8;
        unsigned __int64 delivery_mode : 3;
        unsigned __int64 destination_mode : 1;
        unsigned __int64 delivery_status : 1;
        unsigned __int64 reserved_0 : 1;
        unsigned __int64 level : 1;
        unsigned __int64 trigger_mode : 1;
        unsigned __int64 reserved_1 : 2;
        unsigned __int64 destination_short : 2;
        unsigned __int64 reserved_3 : 35;
        unsigned __int64 destination : 8;
    };
};

union __vmx_exit_control
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 reserved_0 : 2;
        unsigned __int64 save_dbg_controls : 1;
        unsigned __int64 reserved_1 : 6;
        unsigned __int64 host_address_space_size : 1;
        unsigned __int64 reserved_2 : 2;
        unsigned __int64 load_ia32_perf_global_control : 1;
        unsigned __int64 reserved_3 : 2;
        unsigned __int64 ack_interrupt_on_exit : 1;
        unsigned __int64 reserved_4 : 2;
        unsigned __int64 save_ia32_pat : 1;
        unsigned __int64 load_ia32_pat : 1;
        unsigned __int64 save_ia32_efer : 1;
        unsigned __int64 load_ia32_efer : 1;
        unsigned __int64 save_vmx_preemption_timer_value : 1;
        unsigned __int64 clear_ia32_bndcfgs : 1;
        unsigned __int64 conceal_vmx_from_pt : 1;
        unsigned __int64 load_ia32_rtit_ctl : 1;
        unsigned __int64 load_cet_state : 1;
        unsigned __int64 load_pkrs : 1;
    };
};

union __vmx_pending_debug_exceptions 
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 b0 : 1;
        unsigned __int64 b1 : 1;
        unsigned __int64 b2 : 1;
        unsigned __int64 b3 : 1;
        unsigned __int64 reserved1 : 8;
        unsigned __int64 enabled_bp : 1;
        unsigned __int64 reserved2 : 1;
        unsigned __int64 bs : 1;
        unsigned __int64 reserved3 : 1;
        unsigned __int64 rtm : 1;
        unsigned __int64 reserved4 : 47;
    };

};

union __vmx_interruptibility_state
{
    unsigned __int64 all;
    struct
    {
        unsigned __int64 blocking_by_sti : 1;
        unsigned __int64 blocking_by_mov_ss : 1;
        unsigned __int64 blocking_by_smi : 1;
        unsigned __int64 blocking_by_nmi : 1;
        unsigned __int64 enclave_interruption : 1;
        unsigned __int64 reserved : 27;
    };
};

void fill_vmcs(__vcpu* vcpu, void* guest_rsp);
```

`airhv/airhv-main/airhv/ia32/vmcs_encodings.h`:

```h
#pragma once

#define VMCS_ENCODE_COMPONENT( access, type, width, index )    ( unsigned )( ( unsigned short )( access ) | \
                                                                        ( ( unsigned short )( index ) << 1 ) | \
                                                                        ( ( unsigned short )( type ) << 10 ) | \
                                                                        ( ( unsigned short )( width ) << 13 ) )


#define VMCS_ENCODE_COMPONENT_FULL( type, width, index )    VMCS_ENCODE_COMPONENT( full, type, width, index )
#define VMCS_ENCODE_COMPONENT_FULL_16( type, index )        VMCS_ENCODE_COMPONENT_FULL( type, word, index )
#define VMCS_ENCODE_COMPONENT_FULL_32( type, index )        VMCS_ENCODE_COMPONENT_FULL( type, doubleword, index )
#define VMCS_ENCODE_COMPONENT_FULL_64( type, index )        VMCS_ENCODE_COMPONENT_FULL( type, quadword, index )

enum __vmcs_access
{
    full = 0,
    high = 1
};

enum __vmcs_type
{
    control = 0,
    readonly,
    guest,
    host
};

enum __vmcs_width
{
    word = 0,
    quadword,
    doubleword,
    natural
};

enum __vmcs_fields
{
    // Natural Guest Register State Fields
    GUEST_CR0 = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 0),
    GUEST_CR3 = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 1),
    GUEST_CR4 = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 2),
    GUEST_ES_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 3),
    GUEST_CS_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 4),
    GUEST_SS_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 5),
    GUEST_DS_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 6),
    GUEST_FS_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 7),
    GUEST_GS_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 8),
    GUEST_LDTR_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 9),
    GUEST_TR_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 10),
    GUEST_GDTR_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 11),
    GUEST_IDTR_BASE = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 12),
    GUEST_DR7 = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 13),
    GUEST_RSP = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 14),
    GUEST_RIP = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 15),
    GUEST_RFLAGS = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 16),
    GUEST_PENDING_DEBUG_EXCEPTION = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 17),
    GUEST_SYSENTER_ESP = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 18),
    GUEST_SYSENTER_EIP = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 19),
    GUEST_S_CET = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 20),
    GUEST_SSP = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 21),
    GUEST_INTERRUPT_SSP_TABLE_ADDR = VMCS_ENCODE_COMPONENT_FULL(guest, natural, 22),

    // 64-bit Guest Register State Fields
    GUEST_VMCS_LINK_POINTER = VMCS_ENCODE_COMPONENT_FULL_64(guest, 0),
    GUEST_DEBUG_CONTROL = VMCS_ENCODE_COMPONENT_FULL_64(guest, 1),
    GUEST_PAT = VMCS_ENCODE_COMPONENT_FULL_64(guest, 2),
    GUEST_EFER = VMCS_ENCODE_COMPONENT_FULL_64(guest, 3),
    GUEST_PERF_GLOBAL_CONTROL = VMCS_ENCODE_COMPONENT_FULL_64(guest, 4),
    GUEST_PDPTE0 = VMCS_ENCODE_COMPONENT_FULL_64(guest, 5),
    GUEST_PDPTE1 = VMCS_ENCODE_COMPONENT_FULL_64(guest, 6),
    GUEST_PDPTE2 = VMCS_ENCODE_COMPONENT_FULL_64(guest, 7),
    GUEST_PDPTE3 = VMCS_ENCODE_COMPONENT_FULL_64(guest, 8),
    GUEST_BNDCFGS = VMCS_ENCODE_COMPONENT_FULL_64(guest, 9),
    GUEST_RTIT_CTL = VMCS_ENCODE_COMPONENT_FULL_64(guest, 10),
    GUEST_PKRS = VMCS_ENCODE_COMPONENT_FULL_64(guest, 11),

    // 32-Bit Guest Register State Fields
    GUEST_ES_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 0),
    GUEST_CS_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 1),
    GUEST_SS_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 2),
    GUEST_DS_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 3),
    GUEST_FS_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 4),
    GUEST_GS_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 5),
    GUEST_LDTR_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 6),
    GUEST_TR_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 7),
    GUEST_GDTR_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 8),
    GUEST_IDTR_LIMIT = VMCS_ENCODE_COMPONENT_FULL_32(guest, 9),
    GUEST_ES_ACCESS_RIGHTS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 10),
    GUEST_CS_ACCESS_RIGHTS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 11),
    GUEST_SS_ACCESS_RIGHTS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 12),
    GUEST_DS_ACCESS_RIGHTS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 13),
    GUEST_FS_ACCESS_RIGHTS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 14),
    GUEST_GS_ACCESS_RIGHTS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 15),
    GUEST_LDTR_ACCESS_RIGHTS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 16),
    GUEST_TR_ACCESS_RIGHTS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 17),
    GUEST_INTERRUPTIBILITY_STATE = VMCS_ENCODE_COMPONENT_FULL_32(guest, 18),
    GUEST_ACTIVITY_STATE = VMCS_ENCODE_COMPONENT_FULL_32(guest, 19),
    GUEST_SMBASE = VMCS_ENCODE_COMPONENT_FULL_32(guest, 20),
    GUEST_SYSENTER_CS = VMCS_ENCODE_COMPONENT_FULL_32(guest, 21),
    GUEST_VMX_PREEMPTION_TIMER_VALUE = VMCS_ENCODE_COMPONENT_FULL_32(guest, 23),

    // 16-Bit Guest Register State Fields
    GUEST_ES_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(guest, 0),
    GUEST_CS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(guest, 1),
    GUEST_SS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(guest, 2),
    GUEST_DS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(guest, 3),
    GUEST_FS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(guest, 4),
    GUEST_GS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(guest, 5),
    GUEST_LDTR_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(guest, 6),
    GUEST_TR_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(guest, 7),
    GUEST_GUEST_INTERRUPT_STATUS = VMCS_ENCODE_COMPONENT_FULL_16(guest, 8),
    GUEST_PML_INDEX = VMCS_ENCODE_COMPONENT_FULL_16(guest, 9),

    // Natural Host Register State Fields
    HOST_CR0 = VMCS_ENCODE_COMPONENT_FULL(host, natural, 0),
    HOST_CR3 = VMCS_ENCODE_COMPONENT_FULL(host, natural, 1),
    HOST_CR4 = VMCS_ENCODE_COMPONENT_FULL(host, natural, 2),
    HOST_FS_BASE = VMCS_ENCODE_COMPONENT_FULL(host, natural, 3),
    HOST_GS_BASE = VMCS_ENCODE_COMPONENT_FULL(host, natural, 4),
    HOST_TR_BASE = VMCS_ENCODE_COMPONENT_FULL(host, natural, 5),
    HOST_GDTR_BASE = VMCS_ENCODE_COMPONENT_FULL(host, natural, 6),
    HOST_IDTR_BASE = VMCS_ENCODE_COMPONENT_FULL(host, natural, 7),
    HOST_SYSENTER_ESP = VMCS_ENCODE_COMPONENT_FULL(host, natural, 8),
    HOST_SYSENTER_EIP = VMCS_ENCODE_COMPONENT_FULL(host, natural, 9),
    HOST_RSP = VMCS_ENCODE_COMPONENT_FULL(host, natural, 10),
    HOST_RIP = VMCS_ENCODE_COMPONENT_FULL(host, natural, 11),
    HOST_S_CET = VMCS_ENCODE_COMPONENT_FULL(host, natural, 12),
    HOST_SSP = VMCS_ENCODE_COMPONENT_FULL(host, natural, 13),
    HOST_INTERRUPT_SSP_TABLE_ADDR = VMCS_ENCODE_COMPONENT_FULL(host, natural, 14),

    // 64-bit Host Register State Fields
    HOST_PAT = VMCS_ENCODE_COMPONENT_FULL_64(host, 0),
    HOST_EFER = VMCS_ENCODE_COMPONENT_FULL_64(host, 1),
    HOST_PERF_GLOBAL_CTRL = VMCS_ENCODE_COMPONENT_FULL_64(host, 2),
    HOST_PKRS = VMCS_ENCODE_COMPONENT_FULL_64(host, 3),

    // 32-bit Host Register State Fields
    HOST_SYSENTER_CS = VMCS_ENCODE_COMPONENT_FULL_32(host, 0),

    // 16-bit Host Register State Fields
    HOST_ES_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(host, 0),
    HOST_CS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(host, 1),
    HOST_SS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(host, 2),
    HOST_DS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(host, 3),
    HOST_FS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(host, 4),
    HOST_GS_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(host, 5),
    HOST_TR_SELECTOR = VMCS_ENCODE_COMPONENT_FULL_16(host, 6),

    // Natural Control Register State Fields
    CONTROL_CR0_GUEST_HOST_MASK = VMCS_ENCODE_COMPONENT_FULL(control, natural, 0),
    CONTROL_CR4_GUEST_HOST_MASK = VMCS_ENCODE_COMPONENT_FULL(control, natural, 1),
    CONTROL_CR0_READ_SHADOW = VMCS_ENCODE_COMPONENT_FULL(control, natural, 2),
    CONTROL_CR4_READ_SHADOW = VMCS_ENCODE_COMPONENT_FULL(control, natural, 3),
    CONTROL_CR3_TARGET_VALUE_0 = VMCS_ENCODE_COMPONENT_FULL(control, natural, 4),
    CONTROL_CR3_TARGET_VALUE_1 = VMCS_ENCODE_COMPONENT_FULL(control, natural, 5),
    CONTROL_CR3_TARGET_VALUE_2 = VMCS_ENCODE_COMPONENT_FULL(control, natural, 6),
    CONTROL_CR3_TARGET_VALUE_3 = VMCS_ENCODE_COMPONENT_FULL(control, natural, 7),

    // 64-bit Control Register State Fields
    CONTROL_BITMAP_IO_A_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 0),
    CONTROL_BITMAP_IO_B_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 1),
    CONTROL_MSR_BITMAPS_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 2),
    CONTROL_VMEXIT_MSR_STORE_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 3),
    CONTROL_VMEXIT_MSR_LOAD_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 4),
    CONTROL_VMENTER_MSR_LOAD_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 5),
    CONTROL_VMCS_EXECUTIVE_POINTER = VMCS_ENCODE_COMPONENT_FULL_64(control, 6),
    CONTROL_PML_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 7),
    CONTROL_TSC_OFFSET = VMCS_ENCODE_COMPONENT_FULL_64(control, 8),
    CONTROL_VIRTUAL_APIC_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 9),
    CONTROL_APIC_ACCESS_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 10),
    CONTROL_POSTED_INTERRUPT_DESCRIPTOR_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 11),
    CONTROL_VM_FUNCTION_CONTROLS = VMCS_ENCODE_COMPONENT_FULL_64(control, 12),
    CONTROL_EPT_POINTER = VMCS_ENCODE_COMPONENT_FULL_64(control, 13),
    CONTROL_EOI_EXIT_BITMAP_0 = VMCS_ENCODE_COMPONENT_FULL_64(control, 14),
    CONTROL_EOI_EXIT_BITMAP_1 = VMCS_ENCODE_COMPONENT_FULL_64(control, 15),
    CONTROL_EOI_EXIT_BITMAP_2 = VMCS_ENCODE_COMPONENT_FULL_64(control, 16),
    CONTROL_EOI_EXIT_BITMAP_3 = VMCS_ENCODE_COMPONENT_FULL_64(control, 17),
    CONTROL_EPTP_LIST_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 18),
    CONTROL_VMREAD_BITMAP_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 19),
    CONTROL_VMWRITE_BITMAP_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 20),
    CONTROL_VIRTUALIZATION_EXCEPTION_INFORMATION_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(control, 21),
    CONTROL_XSS_EXITING_BITMAP = VMCS_ENCODE_COMPONENT_FULL_64(control, 22),
    CONTROL_ENCLS_EXITING_BITMAP = VMCS_ENCODE_COMPONENT_FULL_64(control, 23),
    CONTROL_SUB_PAGE_PERMISSION_TABLE_POINTER = VMCS_ENCODE_COMPONENT_FULL_64(control, 24),
    CONTROL_TSC_MULTIPLIER = VMCS_ENCODE_COMPONENT_FULL_64(control, 25),
    CONTROL_ENCLV_EXITING_BITMAP = VMCS_ENCODE_COMPONENT_FULL_64(control, 27),

    // 32-bit Control Register State Fields
    CONTROL_PIN_BASED_VM_EXECUTION_CONTROLS = VMCS_ENCODE_COMPONENT_FULL_32(control, 0),
    CONTROL_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS = VMCS_ENCODE_COMPONENT_FULL_32(control, 1),
    CONTROL_EXCEPTION_BITMAP = VMCS_ENCODE_COMPONENT_FULL_32(control, 2),
    CONTROL_PAGE_FAULT_ERROR_CODE_MASK = VMCS_ENCODE_COMPONENT_FULL_32(control, 3),
    CONTROL_PAGE_FAULT_ERROR_CODE_MATCH = VMCS_ENCODE_COMPONENT_FULL_32(control, 4),
    CONTROL_CR3_TARGET_COUNT = VMCS_ENCODE_COMPONENT_FULL_32(control, 5),
    CONTROL_VM_EXIT_CONTROLS = VMCS_ENCODE_COMPONENT_FULL_32(control, 6),
    CONTROL_VM_EXIT_MSR_STORE_COUNT = VMCS_ENCODE_COMPONENT_FULL_32(control, 7),
    CONTROL_VM_EXIT_MSR_LOAD_COUNT = VMCS_ENCODE_COMPONENT_FULL_32(control, 8),
    CONTROL_VM_ENTRY_CONTROLS = VMCS_ENCODE_COMPONENT_FULL_32(control, 9),
    CONTROL_VM_ENTRY_MSR_LOAD_COUNT = VMCS_ENCODE_COMPONENT_FULL_32(control, 10),
    CONTROL_VM_ENTRY_INTERRUPTION_INFORMATION_FIELD = VMCS_ENCODE_COMPONENT_FULL_32(control, 11),
    CONTROL_VM_ENTRY_EXCEPTION_ERROR_CODE = VMCS_ENCODE_COMPONENT_FULL_32(control, 12),
    CONTROL_VM_ENTRY_INSTRUCTION_LENGTH = VMCS_ENCODE_COMPONENT_FULL_32(control, 13),
    CONTROL_TPR_THRESHOLD = VMCS_ENCODE_COMPONENT_FULL_32(control, 14),
    CONTROL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS = VMCS_ENCODE_COMPONENT_FULL_32(control, 15),
    CONTROL_PLE_GAP = VMCS_ENCODE_COMPONENT_FULL_32(control, 16),
    CONTROL_PLE_WINDOW = VMCS_ENCODE_COMPONENT_FULL_32(control, 17),

    // 16-bit Control Register State Fields
    CONTROL_VIRTUAL_PROCESSOR_IDENTIFIER = VMCS_ENCODE_COMPONENT_FULL_16(control, 0),
    CONTROL_POSTED_INTERRUPT_NOTIFICATION_VECTOR = VMCS_ENCODE_COMPONENT_FULL_16(control, 1),
    CONTROL_EPTP_INDEX = VMCS_ENCODE_COMPONENT_FULL_16(control, 2),

    // Natural Read only Register State Fields
    EXIT_QUALIFICATION = VMCS_ENCODE_COMPONENT_FULL(readonly, natural, 0),
    IO_RCX = VMCS_ENCODE_COMPONENT_FULL(readonly, natural, 1),
    IO_RSI = VMCS_ENCODE_COMPONENT_FULL(readonly, natural, 2),
    IO_RDI = VMCS_ENCODE_COMPONENT_FULL(readonly, natural, 3),
    IO_RIP = VMCS_ENCODE_COMPONENT_FULL(readonly, natural, 4),
    GUEST_LINEAR_ADDRESS = VMCS_ENCODE_COMPONENT_FULL(readonly, natural, 5),

    // 64-bit Read only Register State Fields
    GUEST_PHYSICAL_ADDRESS = VMCS_ENCODE_COMPONENT_FULL_64(readonly,0),

    // 32-bit Read only Register State Fields
    VM_INSTRUCTION_ERROR = VMCS_ENCODE_COMPONENT_FULL_32(readonly, 0),
    EXIT_REASON = VMCS_ENCODE_COMPONENT_FULL_32(readonly, 1),
    VM_EXIT_INTERRUPTION_INFORMATION = VMCS_ENCODE_COMPONENT_FULL_32(readonly, 2),
    VM_EXIT_INTERRUPTION_ERROR_CODE = VMCS_ENCODE_COMPONENT_FULL_32(readonly, 3),
    IDT_VECTORING_INFORMATION_FIELD = VMCS_ENCODE_COMPONENT_FULL_32(readonly, 4),
    IDT_VECTORING_ERROR_CODE = VMCS_ENCODE_COMPONENT_FULL_32(readonly, 5),
    VM_EXIT_INSTRUCTION_LENGTH = VMCS_ENCODE_COMPONENT_FULL_32(readonly, 6),
    VM_EXIT_INSTRUCTION_INFORMATION = VMCS_ENCODE_COMPONENT_FULL_32(readonly, 7),
};


```

`airhv/airhv-main/airhv/interrupt.h`:

```h
#pragma once
#define RESET_IO_PORT 0xCF9

enum __exception_vectors
{
    EXCEPTION_VECTOR_DIVIDE_ERROR,
    EXCEPTION_VECTOR_SINGLE_STEP,
    EXCEPTION_VECTOR_NMII,
    EXCEPTION_VECTOR_BREAKPOINT,
    EXCEPTION_VECTOR_OVERFLOW,
    EXCEPTION_VECTOR_BOUND_RANGE_EXCEEDED,
    EXCEPTION_VECTOR_UNDEFINED_OPCODE,
    EXCEPTION_VECTOR_NO_MATH_COPROCESSOR,
    EXCEPTION_VECTOR_DOUBLE_FAULTT,
    EXCEPTION_VECTOR_RESERVED0,
    EXCEPTION_VECTOR_INVALID_TASK_SEGMENT_SELECTOR,
    EXCEPTION_VECTOR_SEGMENT_NOT_PRESENTT,
    EXCEPTION_VECTOR_STACK_SEGMENT_FAULT,
    EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT,
    EXCEPTION_VECTOR_PAGE_FAULT,
    EXCEPTION_VECTOR_RESERVED1,
    EXCEPTION_VECTOR_MATH_FAULT,
    EXCEPTION_VECTOR_ALIGNMENT_CHECK,
    EXCEPTION_VECTOR_MACHINE_CHECK,
    EXCEPTION_VECTOR_SIMD_FLOATING_POINT_NUMERIC_ERROR,
    EXCEPTION_VECTOR_VIRTUAL_EXCEPTION,
    EXCEPTION_VECTOR_RESERVED2,
    EXCEPTION_VECTOR_RESERVED3,
    EXCEPTION_VECTOR_RESERVED4,
    EXCEPTION_VECTOR_RESERVED5,
    EXCEPTION_VECTOR_RESERVED6,
    EXCEPTION_VECTOR_RESERVED7,
    EXCEPTION_VECTOR_RESERVED8,
    EXCEPTION_VECTOR_RESERVED9,
    EXCEPTION_VECTOR_RESERVED10,
    EXCEPTION_VECTOR_RESERVED11,
    EXCEPTION_VECTOR_RESERVED12
};

enum interrupt_type
{
    INTERRUPT_TYPE_EXTERNAL_INTERRUPT = 0,
    INTERRUPT_TYPE_RESERVED = 1,
    INTERRUPT_TYPE_NMI = 2,
    INTERRUPT_TYPE_HARDWARE_EXCEPTION = 3,
    INTERRUPT_TYPE_SOFTWARE_INTERRUPT = 4,
    INTERRUPT_TYPE_PRIVILEGED_SOFTWARE_INTERRUPT = 5,
    INTERRUPT_TYPE_SOFTWARE_EXCEPTION = 6,
    INTERRUPT_TYPE_OTHER_EVENT = 7
};

union __vmentry_interrupt_info
{
    unsigned __int32 all;
    struct
    {
        unsigned __int32 interrupt_vector : 8;
        unsigned __int32 interruption_type : 3;
        unsigned __int32 deliver_error_code : 1;
        unsigned __int32 reserved : 19;
        unsigned __int32 valid : 1;

    };
};

struct __vmentry_event_information
{
    __vmentry_interrupt_info interrupt_info;
    unsigned __int32 instruction_length;
    unsigned __int64 error_code;
};

union __vmexit_interrupt_info
{
    struct 
    {
        unsigned __int32 vector : 8;
        unsigned __int32 interruption_type : 3;
        unsigned __int32 error_code_valid : 1;
        unsigned __int32 nmi_unblocking : 1;
        unsigned __int32 reserved : 18;
        unsigned __int32 valid : 1;
    };
    unsigned __int32 all;
};

union __reset_control_register
{
    unsigned __int8 all;
    struct
    {
        unsigned __int8 reserved0 : 1;
        unsigned __int8 system_reset : 1;
        unsigned __int8 reset_cpu : 1;
        unsigned __int8 full_reset : 1;
        unsigned __int8 reserved1 : 4;
    };
};

```

`airhv/airhv-main/airhv/invalidators.cpp`:

```cpp
#pragma warning( disable : 4201)
#include "invalidators.h"
#include "asm\vm_intrin.h"

/// <summary>
/// Invept single context
/// </summary>
/// <param name="EptPointer"></param>
void invept_single_context(unsigned __int64 ept_pointer)
{
	__invept_descriptor descriptor = { 0 };
	descriptor.ept_pointer = ept_pointer;
	descriptor.reserved = 0;
	__invept(INVEPT_SINGLE_CONTEXT, &descriptor);
}

/// <summary>
/// Invept all contexts
/// </summary>
void invept_all_contexts()
{
	__invept_descriptor descriptor = { 0 };
	__invept(INVEPT_ALL_CONTEXTS, &descriptor);
}

/// <summary>
/// Invvpid invidual address
/// </summary>
/// <param name="linear_address"> Logical processor invalidates mappings for the linear address </param>
/// <param name="vpid"> Invalidates entries in the TLBs and paging-structure caches based on this vpid </param>
void invvpid_invidual_address(unsigned __int64 linear_address,unsigned __int8 vpid)
{
	__invvpid_descriptor descriptor = { 0 };
	descriptor.linear_address = linear_address;
	descriptor.vpid = vpid;

	__invvpid(INVVPID_INVIDUAL_ADDRESS,&descriptor);
}

/// <summary>
/// Invvpid single context
/// </summary>
/// <param name="vpid"> Invalidates entries in the TLBs and paging-structure caches based on this vpid </param>
void invvpid_single_context(unsigned __int8 vpid)
{
	__invvpid_descriptor descriptor = { 0 };
	descriptor.vpid = vpid;

	__invvpid(INVVPID_SINGLE_CONTEXT, &descriptor);
}

/// <summary>
/// Invvpid all contexts
/// </summary>
void invvpid_all_contexts()
{
	__invvpid_descriptor descriptor = { 0 };
	__invvpid(INVVPID_ALL_CONTEXTS, &descriptor);
}

/// <summary>
/// Invvpid single context except global translations
/// </summary>
/// <param name="vpid"> Invalidates entries in the TLBs and paging-structure caches based on this vpid </param>
void invvpid_single_context_except_global_translations(unsigned __int8 vpid)
{
	__invvpid_descriptor descriptor = { 0 };
	descriptor.vpid = vpid;
	return __invvpid(INVVPID_SINGLE_EXCEPT_GLOBAL_TRANSLATIONS, &descriptor);
}

```

`airhv/airhv-main/airhv/invalidators.h`:

```h
#pragma once
#include <ntddk.h>

struct __invept_descriptor
{
	unsigned __int64 ept_pointer;
	unsigned __int64 reserved;
};

struct __invpcid_descriptor 
{
	unsigned __int64 pcid : 12;
	unsigned __int64 reserved : 52;
	unsigned __int64 linear_address;
};

struct __invvpid_descriptor
{
	union
	{
		unsigned __int64 vpid : 16;
		unsigned __int64 reserved : 48;
	};

	unsigned __int64 linear_address;
};

enum invept_type
{
	INVEPT_SINGLE_CONTEXT = 0x00000001,
	INVEPT_ALL_CONTEXTS = 0x00000002
};

enum invvpid_type
{
	INVVPID_INVIDUAL_ADDRESS,
	INVVPID_SINGLE_CONTEXT,
	INVVPID_ALL_CONTEXTS,
	INVVPID_SINGLE_EXCEPT_GLOBAL_TRANSLATIONS
};

enum invpcid_type
{
	INVPCID_INVIDUAL_ADDRESS,
	INVPCID_SINGLE_CONTEXT,
	INVPCID_ALL_CONTEXTS,
	INVPCID_ALL_CONTEXTS_EXCEPT_GLOBAL_TRANSLATIONS
};

/// <summary>
/// Invept single context
/// </summary>
/// <param name="EptPointer"></param>
void invept_single_context(unsigned __int64 ept_pointer);

/// <summary>
/// Invept all contexts
/// </summary>
void invept_all_contexts();

/// <summary>
/// Invvpid invidual address
/// </summary>
/// <param name="linear_address"> Logical processor invalidates mappings for the linear address </param>
/// <param name="vpid"> Invalidates entries in the TLBs and paging-structure caches based on this vpid </param>
void invvpid_invidual_address(unsigned __int64 linear_address, unsigned __int8 vpid);

/// <summary>
/// Invvpid single context
/// </summary>
/// <param name="vpid"> Invalidates entries in the TLBs and paging-structure caches based on this vpid </param>
void invvpid_single_context(unsigned __int8 vpid);

/// <summary>
/// Invvpid all contexts
/// </summary>
void invvpid_all_contexts();

/// <summary>
/// Invvpid single context except global translations
/// </summary>
/// <param name="vpid"> Invalidates entries in the TLBs and paging-structure caches based on this vpid </param>
void invvpid_single_context_except_global_translations(unsigned __int8 vpid);

```

`airhv/airhv-main/airhv/lde/lde64.asm`:

```asm
;
; LDE64 x64 relocatable (Length Disassembler Engine) for 64 bits plateforms
; FREEWARE
;
; coded by BeatriX 
; beatrix2004(at)free(dot)fr
;
; release : 1.6 - 02-23-09 - thanks to Zool@nder for bugfix on 'pop ds'
; release : 1.5 - 01-14-09
; release : 1.4 - 09-02-08
; thanks to Av0id , cyberbob and lena151 for their remarks and advices
;
;   Syntax to disassemble 32 bits target:
;   mov edx, 0
;   mov rcx, Address2Disasm
;   call LDE
;
;   Syntax to disassemble 64 bits target:
;   mov edx, 64
;   mov rcx, Address2Disasm
;   call LDE
;
;******************************************************


.code
LDE proc

db 055h, 048h, 083h, 0ECh, 02Bh, 048h, 089h, 0E5h, 051h, 052h, 056h, 0E8h, 000h, 021h, 000h, 000h
db 0EFh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0E7h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 0E5h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 006h, 022h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 0AFh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0A7h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Fh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 0A5h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0C6h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0BFh, 02Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 065h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 086h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Fh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Fh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 017h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 025h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 046h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EFh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 0E7h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 0E5h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 006h, 021h, 000h, 000h, 000h, 000h, 000h, 000h
db 098h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 0AFh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 0A7h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 0A5h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 0C6h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 058h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 065h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 086h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 018h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 017h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 025h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 046h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 0D8h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 097h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 08Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 087h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 07Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 077h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 06Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 067h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 05Fh, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 028h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 020h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 018h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 010h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 008h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 0F8h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0F0h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 080h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 078h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 070h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 068h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 060h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 058h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 050h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 048h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 040h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 038h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 030h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 028h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 020h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 018h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 010h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 008h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0F8h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 016h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0A8h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0A0h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 026h, 000h, 000h, 000h, 000h, 000h, 000h, 00Ah, 027h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 098h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 0B5h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 006h, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 0A0h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 098h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 090h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 088h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 085h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 07Dh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 075h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 06Dh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 065h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 05Dh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 055h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 04Dh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 045h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 03Dh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 035h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 02Dh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 025h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 01Dh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 015h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 00Dh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 05Eh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 087h, 020h, 000h, 000h, 000h, 000h, 000h, 000h
db 068h, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 046h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0CFh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0C7h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0BFh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0B7h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0AFh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0A7h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 09Fh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 08Fh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 087h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 07Fh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0AEh, 01Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 080h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 078h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 070h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 068h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 060h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 058h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 050h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 048h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 040h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 038h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0F1h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 028h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 020h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 018h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 010h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 008h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 055h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 05Fh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 045h, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h, 04Fh, 01Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0E0h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0D8h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0D0h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0C8h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0C5h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0E6h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0B0h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0A8h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0A0h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 098h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 090h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 088h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 085h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 07Dh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 075h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 06Dh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 065h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 05Dh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 055h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 04Dh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 080h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 078h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 070h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 068h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 060h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 058h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 050h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 048h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 05Eh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 056h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 03Fh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0E8h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 006h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0FEh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 02Eh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0B4h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0DAh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0B8h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0A8h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 0A0h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 09Dh, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 088h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 068h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 060h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 050h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 048h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 0F2h, 024h, 000h, 000h, 000h, 000h, 000h, 000h, 022h, 025h, 000h, 000h, 000h, 000h, 000h, 000h
db 0B5h, 025h, 000h, 000h, 000h, 000h, 000h, 000h, 011h, 026h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Ah, 026h, 000h, 000h, 000h, 000h, 000h, 000h, 0D6h, 026h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Ah, 027h, 000h, 000h, 000h, 000h, 000h, 000h, 08Bh, 027h, 000h, 000h, 000h, 000h, 000h, 000h
db 005h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 0FDh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0F5h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0EDh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0E5h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0DDh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0D5h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0CDh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0EEh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0E6h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0B8h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0ADh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0A0h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 098h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 090h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 088h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 048h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 078h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0E7h, 022h, 000h, 000h, 000h, 000h, 000h, 000h, 029h, 023h, 000h, 000h, 000h, 000h, 000h, 000h
db 060h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 058h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0FBh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 040h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 038h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 030h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 028h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 020h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 018h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 077h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 091h, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0ABh, 01Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0D8h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 0D0h, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 0C8h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 0C0h, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 0B8h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0A8h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 087h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 090h, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Fh, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 047h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Fh, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 037h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DCh, 020h, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Fh, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 017h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Fh, 019h, 000h, 000h, 000h, 000h, 000h, 000h, 007h, 019h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 0F7h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 038h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 030h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 028h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 020h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 0AFh, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 0A7h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Fh, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Fh, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 087h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Fh, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 077h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 080h, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 078h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 070h, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 068h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 060h, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 058h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0A0h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0B9h, 021h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 01Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0EFh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 0E7h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CFh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 0C7h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BFh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 0B7h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 0AFh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 0A7h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 087h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 077h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 047h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 037h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 017h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Fh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 007h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 0F7h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EFh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 0E7h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CFh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 0C7h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BFh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 0B7h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 0AFh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 0A7h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Fh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ABh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 0A3h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Fh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 077h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 07Dh, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 001h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 01Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 04Fh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 047h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Fh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 048h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Fh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Fh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 007h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 0F7h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Eh, 016h, 000h, 000h, 000h, 000h, 000h, 000h, 026h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 010h, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 008h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 0F8h, 016h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FEh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 0F6h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EEh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 0E6h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DEh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 0D6h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CEh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 0C6h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BEh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 0B6h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Fh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 047h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Fh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 037h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Fh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Fh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 017h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Fh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 007h, 015h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 0F7h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 000h, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 0F8h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 0F0h, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Eh, 015h, 000h, 000h, 000h, 000h, 000h, 000h, 0C7h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 017h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 017h, 000h, 000h, 000h, 000h, 000h, 000h
db 0C0h, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 0B8h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 0B0h, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FEh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 087h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 066h, 01Bh, 000h, 000h, 000h, 000h, 000h, 000h, 077h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Fh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 047h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Fh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 037h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Fh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 038h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 0B5h, 018h, 000h, 000h, 000h, 000h, 000h, 000h, 017h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Fh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 007h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0F7h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EFh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0E7h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CFh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0C7h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BFh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 06Fh, 018h, 000h, 000h, 000h, 000h, 000h, 000h
db 0C0h, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0B8h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0B0h, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0A8h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0A0h, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 098h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 090h, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 088h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Fh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Fh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 047h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0E7h, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 037h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Fh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Fh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 017h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Fh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 007h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 0F7h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EFh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 0E7h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CFh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 0C7h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 067h, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 0B7h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 0AFh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 0A7h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 087h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 077h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DBh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 067h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 057h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 047h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 037h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 027h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 017h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Fh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 007h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EFh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0E7h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DFh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0D7h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CFh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0C7h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BFh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0B7h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0AFh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0A7h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Fh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 097h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 014h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 014h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Bh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Bh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 063h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 053h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Fh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 007h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FFh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Bh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 003h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FBh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0F3h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EBh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0E3h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CBh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0C3h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BBh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0B3h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 013h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 013h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Bh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 083h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Bh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 073h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Bh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 063h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 053h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Bh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 043h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Bh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 033h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Bh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 023h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Bh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 013h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Bh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 003h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 012h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 012h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 011h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 011h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 010h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 010h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 00Fh, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 00Eh, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 00Dh, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 005h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0FDh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 00Ch, 000h, 000h, 000h, 000h, 000h, 000h
db 0CBh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0C3h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BBh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0B3h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ABh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0A3h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Bh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 077h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 06Bh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 063h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Bh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 053h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 00Bh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 003h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FBh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 00Bh, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 00Bh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 003h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FBh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 00Ah, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Bh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 003h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FBh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 0F3h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 009h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 009h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 008h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 008h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 007h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 007h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 006h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 006h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 065h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 055h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 045h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 035h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 025h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 015h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 005h, 000h, 000h, 000h, 000h, 000h, 000h, 005h, 005h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FDh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 0F5h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 0EDh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 0E5h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DDh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 0D5h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CDh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 0C5h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BDh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 0B5h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ADh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 0A5h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Dh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 095h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 085h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 07Dh, 004h, 000h, 000h, 000h, 000h, 000h, 000h, 075h, 004h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ACh, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 0A4h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 09Ch, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 094h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 08Dh, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 0AFh, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 0B3h, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 074h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 06Ch, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 064h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Ch, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 054h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 04Dh, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 044h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 03Ch, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 034h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 02Ch, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 024h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 01Ch, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 014h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 00Dh, 001h, 000h, 000h, 000h, 000h, 000h, 000h, 004h, 001h, 000h, 000h, 000h, 000h, 000h, 000h
db 0FCh, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 0F4h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 0ECh, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 0E4h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 0DCh, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 0D4h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 0CCh, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 0C4h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 0BCh, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 0B4h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
db 05Eh, 051h, 08Fh, 045h, 023h, 089h, 055h, 01Eh, 0C6h, 045h, 022h, 000h, 0C7h, 045h, 002h, 020h
db 000h, 000h, 000h, 0C7h, 045h, 006h, 020h, 000h, 000h, 000h, 083h, 07Dh, 01Eh, 040h, 075h, 007h
db 0C7h, 045h, 006h, 040h, 000h, 000h, 000h, 048h, 08Bh, 045h, 023h, 048h, 00Fh, 0B6h, 008h, 048h
db 08Dh, 004h, 0CEh, 048h, 003h, 000h, 0FFh, 0D0h, 05Eh, 05Ah, 059h, 048h, 083h, 0F8h, 0FFh, 074h
db 007h, 048h, 08Bh, 045h, 023h, 048h, 029h, 0C8h, 048h, 083h, 0C4h, 02Bh, 05Dh, 0C3h, 0C7h, 045h
db 01Ah, 000h, 000h, 000h, 000h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 040h, 001h, 025h, 0C7h, 000h
db 000h, 000h, 0B9h, 040h, 000h, 000h, 000h, 048h, 031h, 0D2h, 0F7h, 0F1h, 089h, 045h, 00Ah, 083h
db 0F8h, 001h, 075h, 004h, 083h, 045h, 01Ah, 001h, 083h, 0F8h, 002h, 075h, 004h, 083h, 045h, 01Ah
db 004h, 089h, 055h, 00Eh, 0C1h, 0E0h, 006h, 048h, 001h, 0F0h, 048h, 005h, 000h, 020h, 000h, 000h
db 048h, 08Dh, 004h, 0D0h, 048h, 003h, 000h, 0FFh, 0D0h, 0C3h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h
db 040h, 001h, 083h, 0E0h, 038h, 0C1h, 0E8h, 003h, 089h, 045h, 016h, 0C3h, 0C3h, 083h, 07Dh, 006h
db 020h, 07Ch, 023h, 083h, 045h, 01Ah, 001h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 040h, 002h, 083h
db 0E0h, 007h, 089h, 045h, 012h, 083h, 07Dh, 012h, 005h, 075h, 00Ah, 083h, 07Dh, 00Ah, 000h, 075h
db 004h, 083h, 045h, 01Ah, 004h, 0C3h, 0C3h, 083h, 07Dh, 006h, 020h, 07Ch, 005h, 083h, 045h, 01Ah
db 004h, 0C3h, 0C3h, 083h, 07Dh, 006h, 010h, 075h, 005h, 083h, 045h, 01Ah, 002h, 0C3h, 0C3h, 0E8h
db 05Ah, 0FFh, 0FFh, 0FFh, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h
db 048h, 0FFh, 045h, 023h, 0C3h, 048h, 083h, 045h, 023h, 002h, 0C3h, 083h, 07Dh, 002h, 010h, 075h
db 006h, 0E8h, 0D9h, 0FFh, 0FFh, 0FFh, 0C3h, 0E8h, 051h, 002h, 000h, 000h, 0C3h, 083h, 07Dh, 01Eh
db 040h, 075h, 006h, 0E8h, 045h, 002h, 000h, 000h, 0C3h, 048h, 0FFh, 045h, 023h, 0C3h, 083h, 07Dh
db 002h, 020h, 07Ch, 006h, 048h, 083h, 045h, 023h, 005h, 0C3h, 048h, 083h, 045h, 023h, 003h, 0C3h
db 083h, 07Dh, 002h, 040h, 075h, 006h, 048h, 083h, 045h, 023h, 009h, 0C3h, 083h, 07Dh, 002h, 020h
db 075h, 006h, 048h, 083h, 045h, 023h, 005h, 0C3h, 048h, 083h, 045h, 023h, 003h, 0C3h, 0E8h, 08Ch
db 0FFh, 0FFh, 0FFh, 048h, 0FFh, 045h, 023h, 0C3h, 083h, 07Dh, 01Eh, 040h, 075h, 024h, 0C7h, 045h
db 002h, 040h, 000h, 000h, 000h, 048h, 0FFh, 045h, 023h, 048h, 08Bh, 045h, 023h, 048h, 00Fh, 0B6h
db 008h, 048h, 08Dh, 004h, 0CEh, 048h, 003h, 000h, 0FFh, 0D0h, 0C7h, 045h, 002h, 020h, 000h, 000h
db 000h, 0C3h, 048h, 0FFh, 045h, 023h, 0C3h, 083h, 07Dh, 01Eh, 040h, 075h, 025h, 048h, 0FFh, 045h
db 023h, 0FEh, 045h, 022h, 080h, 07Dh, 022h, 00Fh, 075h, 006h, 0E8h, 0BEh, 001h, 000h, 000h, 0C3h
db 048h, 08Bh, 045h, 023h, 048h, 00Fh, 0B6h, 008h, 048h, 08Dh, 004h, 0CEh, 048h, 003h, 000h, 0FFh
db 0D0h, 0C3h, 048h, 083h, 045h, 023h, 001h, 0C3h, 0FFh, 045h, 023h, 0FEh, 045h, 022h, 080h, 07Dh
db 022h, 00Fh, 075h, 006h, 0E8h, 094h, 001h, 000h, 000h, 0C3h, 048h, 08Bh, 045h, 023h, 048h, 00Fh
db 0B6h, 008h, 048h, 08Dh, 004h, 0CEh, 048h, 003h, 000h, 0FFh, 0D0h, 0C3h, 083h, 07Dh, 002h, 020h
db 07Ch, 00Bh, 0E8h, 0F8h, 0FEh, 0FFh, 0FFh, 048h, 083h, 045h, 023h, 004h, 0C3h, 0E8h, 0EDh, 0FEh
db 0FFh, 0FFh, 048h, 083h, 045h, 023h, 002h, 0C3h, 083h, 07Dh, 01Eh, 040h, 075h, 006h, 0E8h, 05Ah
db 001h, 000h, 000h, 0C3h, 048h, 083h, 045h, 023h, 002h, 0C3h, 048h, 083h, 045h, 023h, 004h, 0C3h
db 048h, 083h, 045h, 023h, 005h, 0C3h, 083h, 07Dh, 01Eh, 040h, 075h, 006h, 0E8h, 03Ch, 001h, 000h
db 000h, 0C3h, 0E8h, 0B8h, 0FEh, 0FFh, 0FFh, 0C3h, 0E8h, 011h, 0FEh, 0FFh, 0FFh, 083h, 07Dh, 00Ah
db 003h, 075h, 006h, 0E8h, 0A7h, 0FEh, 0FFh, 0FFh, 0C3h, 0E8h, 01Fh, 001h, 000h, 000h, 0C3h, 048h
db 083h, 045h, 023h, 003h, 0C3h, 083h, 07Dh, 006h, 040h, 075h, 006h, 048h, 083h, 045h, 023h, 009h
db 0C3h, 048h, 083h, 045h, 023h, 005h, 0C3h, 083h, 07Dh, 006h, 010h, 075h, 006h, 048h, 083h, 045h
db 023h, 003h, 0C3h, 083h, 07Dh, 006h, 020h, 075h, 006h, 048h, 083h, 045h, 023h, 005h, 0C3h, 048h
db 083h, 045h, 023h, 009h, 0C3h, 080h, 07Dh, 000h, 001h, 075h, 006h, 0E8h, 05Fh, 0FEh, 0FFh, 0FFh
db 0C3h, 0E8h, 0D7h, 000h, 000h, 000h, 0C3h, 080h, 07Dh, 000h, 001h, 075h, 006h, 0E8h, 04Dh, 0FEh
db 0FFh, 0FFh, 0C3h, 080h, 07Dh, 001h, 001h, 075h, 006h, 0E8h, 041h, 0FEh, 0FFh, 0FFh, 0C3h, 083h
db 07Dh, 002h, 010h, 075h, 006h, 0E8h, 035h, 0FEh, 0FFh, 0FFh, 0C3h, 0E8h, 0ADh, 000h, 000h, 000h
db 0C3h, 083h, 07Dh, 01Eh, 040h, 075h, 006h, 0E8h, 0A1h, 000h, 000h, 000h, 0C3h, 083h, 07Dh, 002h
db 020h, 075h, 006h, 048h, 083h, 045h, 023h, 007h, 0C3h, 048h, 083h, 045h, 023h, 005h, 0C3h, 0C3h
db 083h, 07Dh, 002h, 010h, 074h, 011h, 0E8h, 063h, 0FDh, 0FFh, 0FFh, 08Bh, 045h, 01Ah, 001h, 045h
db 023h, 048h, 083h, 045h, 023h, 006h, 0C3h, 0E8h, 052h, 0FDh, 0FFh, 0FFh, 08Bh, 045h, 01Ah, 001h
db 045h, 023h, 048h, 083h, 045h, 023h, 004h, 0C3h, 083h, 07Dh, 01Eh, 040h, 075h, 006h, 0E8h, 05Ah
db 000h, 000h, 000h, 0C3h, 083h, 07Dh, 002h, 020h, 075h, 006h, 048h, 083h, 045h, 023h, 007h, 0C3h
db 048h, 083h, 045h, 023h, 005h, 0C3h, 0E8h, 06Fh, 0FDh, 0FFh, 0FFh, 083h, 07Dh, 016h, 000h, 075h
db 006h, 0E8h, 0B9h, 0FDh, 0FFh, 0FFh, 0C3h, 0E8h, 031h, 000h, 000h, 000h, 0C3h, 083h, 07Dh, 01Eh
db 040h, 075h, 006h, 048h, 083h, 045h, 023h, 005h, 0C3h, 083h, 07Dh, 002h, 020h, 075h, 006h, 048h
db 083h, 045h, 023h, 005h, 0C3h, 048h, 083h, 045h, 023h, 003h, 0C3h, 080h, 07Dh, 000h, 001h, 075h
db 006h, 0E8h, 089h, 0FDh, 0FFh, 0FFh, 0C3h, 0E8h, 001h, 000h, 000h, 000h, 0C3h, 048h, 0B8h, 0FFh
db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 01Eh, 040h, 075h, 006h, 0E8h, 0EAh
db 0FFh, 0FFh, 0FFh, 0C3h, 0E8h, 066h, 0FDh, 0FFh, 0FFh, 048h, 083h, 045h, 023h, 001h, 0C3h, 083h
db 07Dh, 002h, 020h, 07Ch, 00Bh, 0E8h, 055h, 0FDh, 0FFh, 0FFh, 048h, 083h, 045h, 023h, 004h, 0C3h
db 0E8h, 04Ah, 0FDh, 0FFh, 0FFh, 048h, 083h, 045h, 023h, 002h, 0C3h, 0E8h, 09Eh, 0FCh, 0FFh, 0FFh
db 0E8h, 0E5h, 0FCh, 0FFh, 0FFh, 083h, 07Dh, 016h, 000h, 075h, 00Ch, 08Bh, 045h, 01Ah, 001h, 045h
db 023h, 048h, 083h, 045h, 023h, 003h, 0C3h, 083h, 07Dh, 016h, 001h, 075h, 006h, 0E8h, 09Bh, 0FFh
db 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 083h
db 07Dh, 002h, 020h, 07Ch, 034h, 0E8h, 064h, 0FCh, 0FFh, 0FFh, 0E8h, 0ABh, 0FCh, 0FFh, 0FFh, 083h
db 07Dh, 016h, 000h, 075h, 00Ch, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 006h
db 0C3h, 083h, 07Dh, 016h, 001h, 075h, 006h, 0E8h, 061h, 0FFh, 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah
db 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0E8h, 030h, 0FCh, 0FFh, 0FFh, 0E8h, 077h
db 0FCh, 0FFh, 0FFh, 083h, 07Dh, 016h, 000h, 075h, 00Ch, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h
db 083h, 045h, 023h, 004h, 0C3h, 083h, 07Dh, 016h, 001h, 075h, 006h, 0E8h, 02Dh, 0FFh, 0FFh, 0FFh
db 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0E8h, 0FCh, 0FBh
db 0FFh, 0FFh, 0E8h, 043h, 0FCh, 0FFh, 0FFh, 083h, 07Dh, 016h, 001h, 07Eh, 006h, 0E8h, 00Bh, 0FFh
db 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0E8h
db 026h, 0FCh, 0FFh, 0FFh, 083h, 07Dh, 016h, 006h, 07Eh, 006h, 0E8h, 0EEh, 0FEh, 0FFh, 0FFh, 0C3h
db 0E8h, 0C9h, 0FBh, 0FFh, 0FFh, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h
db 0C3h, 0E8h, 0B8h, 0FBh, 0FFh, 0FFh, 0E8h, 0FFh, 0FBh, 0FFh, 0FFh, 083h, 07Dh, 016h, 005h, 07Eh
db 006h, 0E8h, 0C7h, 0FEh, 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h
db 023h, 002h, 0C3h, 0E8h, 096h, 0FBh, 0FFh, 0FFh, 0E8h, 0DDh, 0FBh, 0FFh, 0FFh, 083h, 07Dh, 016h
db 000h, 075h, 01Ah, 083h, 07Dh, 00Ah, 003h, 00Fh, 085h, 0ACh, 000h, 000h, 000h, 083h, 07Dh, 00Eh
db 004h, 00Fh, 08Eh, 0A2h, 000h, 000h, 000h, 0E8h, 091h, 0FEh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h
db 001h, 075h, 01Ah, 083h, 07Dh, 00Ah, 003h, 00Fh, 085h, 08Ch, 000h, 000h, 000h, 083h, 07Dh, 00Eh
db 001h, 00Fh, 08Eh, 082h, 000h, 000h, 000h, 0E8h, 071h, 0FEh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h
db 002h, 075h, 010h, 083h, 07Dh, 00Ah, 003h, 00Fh, 085h, 06Ch, 000h, 000h, 000h, 0E8h, 05Bh, 0FEh
db 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 003h, 075h, 00Ch, 083h, 07Dh, 00Ah, 003h, 075h, 05Ah, 0E8h
db 049h, 0FEh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 004h, 075h, 00Ch, 083h, 07Dh, 00Ah, 003h, 075h
db 048h, 0E8h, 037h, 0FEh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 005h, 075h, 006h, 0E8h, 02Bh, 0FEh
db 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 006h, 075h, 00Ch, 083h, 07Dh, 00Ah, 003h, 075h, 02Ah, 0E8h
db 019h, 0FEh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 007h, 075h, 01Eh, 083h, 07Dh, 00Ah, 003h, 075h
db 018h, 083h, 07Dh, 01Eh, 040h, 075h, 00Ch, 083h, 07Dh, 00Eh, 000h, 074h, 00Ch, 0E8h, 0FBh, 0FDh
db 0FFh, 0FFh, 0C3h, 0E8h, 0F5h, 0FDh, 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h
db 083h, 045h, 023h, 002h, 0C3h, 0E8h, 0C4h, 0FAh, 0FFh, 0FFh, 0E8h, 00Bh, 0FBh, 0FFh, 0FFh, 083h
db 07Dh, 016h, 004h, 07Dh, 006h, 0E8h, 0D3h, 0FDh, 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h
db 023h, 048h, 083h, 045h, 023h, 003h, 0C3h, 0E8h, 0A2h, 0FAh, 0FFh, 0FFh, 0E8h, 0E9h, 0FAh, 0FFh
db 0FFh, 083h, 07Dh, 016h, 000h, 075h, 006h, 0E8h, 0B1h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h
db 002h, 075h, 006h, 0E8h, 0A5h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 003h, 075h, 006h, 0E8h
db 099h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 004h, 075h, 006h, 0E8h, 08Dh, 0FDh, 0FFh, 0FFh
db 0C3h, 083h, 07Dh, 016h, 005h, 075h, 006h, 0E8h, 081h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h
db 007h, 07Eh, 006h, 0E8h, 075h, 0FDh, 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h
db 083h, 045h, 023h, 002h, 0C3h, 0E8h, 090h, 0FAh, 0FFh, 0FFh, 083h, 07Dh, 016h, 000h, 075h, 006h
db 0E8h, 058h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 001h, 075h, 006h, 0E8h, 04Ch, 0FDh, 0FFh
db 0FFh, 0C3h, 083h, 07Dh, 016h, 002h, 075h, 011h, 0E8h, 021h, 0FAh, 0FFh, 0FFh, 083h, 07Dh, 00Ah
db 003h, 074h, 052h, 0E8h, 035h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 003h, 075h, 006h, 0E8h
db 029h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 004h, 075h, 011h, 0E8h, 0FEh, 0F9h, 0FFh, 0FFh
db 083h, 07Dh, 00Ah, 003h, 074h, 02Fh, 0E8h, 012h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 005h
db 075h, 006h, 0E8h, 006h, 0FDh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 006h, 075h, 011h, 0E8h, 0DBh
db 0F9h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 074h, 00Ch, 0E8h, 0EFh, 0FCh, 0FFh, 0FFh, 0C3h, 0E8h
db 0E9h, 0FCh, 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 003h
db 0C3h, 0E8h, 004h, 0FAh, 0FFh, 0FFh, 083h, 07Dh, 016h, 000h, 075h, 006h, 0E8h, 0CCh, 0FCh, 0FFh
db 0FFh, 0C3h, 083h, 07Dh, 016h, 001h, 075h, 006h, 0E8h, 0C0h, 0FCh, 0FFh, 0FFh, 0C3h, 083h, 07Dh
db 016h, 002h, 075h, 011h, 0E8h, 095h, 0F9h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 074h, 052h, 0E8h
db 0A9h, 0FCh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 003h, 075h, 006h, 0E8h, 09Dh, 0FCh, 0FFh, 0FFh
db 0C3h, 083h, 07Dh, 016h, 004h, 075h, 011h, 0E8h, 072h, 0F9h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h
db 074h, 02Fh, 0E8h, 086h, 0FCh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 005h, 075h, 006h, 0E8h, 07Ah
db 0FCh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 006h, 075h, 011h, 0E8h, 04Fh, 0F9h, 0FFh, 0FFh, 083h
db 07Dh, 00Ah, 003h, 074h, 00Ch, 0E8h, 063h, 0FCh, 0FFh, 0FFh, 0C3h, 0E8h, 05Dh, 0FCh, 0FFh, 0FFh
db 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 003h, 0C3h, 0E8h, 078h, 0F9h
db 0FFh, 0FFh, 083h, 07Dh, 016h, 000h, 075h, 006h, 0E8h, 040h, 0FCh, 0FFh, 0FFh, 0C3h, 083h, 07Dh
db 016h, 001h, 075h, 006h, 0E8h, 034h, 0FCh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 002h, 075h, 015h
db 0E8h, 009h, 0F9h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 00Fh, 084h, 07Bh, 000h, 000h, 000h, 0E8h
db 019h, 0FCh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 003h, 075h, 01Dh, 083h, 07Dh, 002h, 010h, 075h
db 011h, 0E8h, 0E8h, 0F8h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 074h, 05Eh, 0E8h, 0FCh, 0FBh, 0FFh
db 0FFh, 0C3h, 0E8h, 0F6h, 0FBh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 004h, 075h, 006h, 0E8h, 0EAh
db 0FBh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 005h, 075h, 006h, 0E8h, 0DEh, 0FBh, 0FFh, 0FFh, 0C3h
db 083h, 07Dh, 016h, 006h, 075h, 011h, 0E8h, 0B3h, 0F8h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 074h
db 029h, 0E8h, 0C7h, 0FBh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 007h, 075h, 017h, 083h, 07Dh, 002h
db 010h, 075h, 011h, 0E8h, 096h, 0F8h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 074h, 00Ch, 0E8h, 0AAh
db 0FBh, 0FFh, 0FFh, 0C3h, 0E8h, 0A4h, 0FBh, 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h
db 048h, 083h, 045h, 023h, 003h, 0C3h, 0E8h, 0BFh, 0F8h, 0FFh, 0FFh, 083h, 07Dh, 016h, 000h, 075h
db 015h, 0E8h, 068h, 0F8h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 00Fh, 085h, 0A0h, 000h, 000h, 000h
db 0E8h, 078h, 0FBh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 001h, 075h, 015h, 0E8h, 04Dh, 0F8h, 0FFh
db 0FFh, 083h, 07Dh, 00Ah, 003h, 00Fh, 085h, 085h, 000h, 000h, 000h, 0E8h, 05Dh, 0FBh, 0FFh, 0FFh
db 0C3h, 083h, 07Dh, 016h, 002h, 075h, 015h, 0E8h, 032h, 0F8h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h
db 00Fh, 085h, 06Ah, 000h, 000h, 000h, 0E8h, 042h, 0FBh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 003h
db 075h, 011h, 0E8h, 017h, 0F8h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 075h, 053h, 0E8h, 02Bh, 0FBh
db 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 004h, 075h, 006h, 0E8h, 01Fh, 0FBh, 0FFh, 0FFh, 0C3h, 083h
db 07Dh, 016h, 005h, 075h, 011h, 0E8h, 0F4h, 0F7h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 075h, 030h
db 0E8h, 008h, 0FBh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 006h, 075h, 011h, 0E8h, 0DDh, 0F7h, 0FFh
db 0FFh, 083h, 07Dh, 00Ah, 003h, 075h, 019h, 0E8h, 0F1h, 0FAh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h
db 007h, 07Fh, 007h, 0E8h, 0C6h, 0F7h, 0FFh, 0FFh, 0EBh, 006h, 0E8h, 0DEh, 0FAh, 0FFh, 0FFh, 0C3h
db 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0E8h, 0F9h, 0F7h, 0FFh
db 0FFh, 083h, 07Dh, 016h, 000h, 075h, 011h, 0E8h, 0A2h, 0F7h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h
db 075h, 051h, 0E8h, 0B6h, 0FAh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 001h, 075h, 011h, 0E8h, 08Bh
db 0F7h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 075h, 03Ah, 0E8h, 09Fh, 0FAh, 0FFh, 0FFh, 0C3h, 083h
db 07Dh, 016h, 002h, 075h, 011h, 0E8h, 074h, 0F7h, 0FFh, 0FFh, 083h, 07Dh, 00Ah, 003h, 075h, 023h
db 0E8h, 088h, 0FAh, 0FFh, 0FFh, 0C3h, 083h, 07Dh, 016h, 003h, 075h, 011h, 0E8h, 05Dh, 0F7h, 0FFh
db 0FFh, 083h, 07Dh, 00Ah, 003h, 075h, 00Ch, 0E8h, 071h, 0FAh, 0FFh, 0FFh, 0C3h, 0E8h, 06Bh, 0FAh
db 0FFh, 0FFh, 0C3h, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 048h
db 0FFh, 045h, 023h, 0C7h, 045h, 002h, 010h, 000h, 000h, 000h, 0FEh, 045h, 022h, 080h, 07Dh, 022h
db 00Fh, 075h, 006h, 0E8h, 045h, 0FAh, 0FFh, 0FFh, 0C3h, 048h, 08Bh, 045h, 023h, 048h, 00Fh, 0B6h
db 008h, 048h, 08Dh, 004h, 0CEh, 048h, 003h, 000h, 0FFh, 0D0h, 0C7h, 045h, 002h, 020h, 000h, 000h
db 000h, 0C3h, 048h, 0FFh, 045h, 023h, 0FEh, 045h, 022h, 080h, 07Dh, 022h, 00Fh, 075h, 006h, 0E8h
db 019h, 0FAh, 0FFh, 0FFh, 0C3h, 08Bh, 04Dh, 006h, 0D1h, 0E9h, 089h, 05Dh, 006h, 048h, 08Bh, 045h
db 023h, 048h, 00Fh, 0B6h, 008h, 048h, 08Dh, 004h, 0CEh, 048h, 003h, 000h, 0FFh, 0D0h, 08Bh, 05Dh
db 006h, 0D1h, 0E1h, 089h, 04Dh, 006h, 0C3h, 048h, 0FFh, 045h, 023h, 0FEh, 045h, 022h, 080h, 07Dh
db 022h, 00Fh, 075h, 006h, 0E8h, 0E4h, 0F9h, 0FFh, 0FFh, 0C3h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h
db 000h, 03Ch, 0A4h, 074h, 012h, 03Ch, 0A7h, 074h, 00Eh, 03Ch, 0AEh, 074h, 00Ah, 03Ch, 0AFh, 074h
db 006h, 03Ch, 00Fh, 074h, 002h, 0EBh, 004h, 0C6h, 045h, 000h, 001h, 048h, 08Bh, 045h, 023h, 048h
db 00Fh, 0B6h, 008h, 048h, 08Dh, 004h, 0CEh, 048h, 003h, 000h, 0FFh, 0D0h, 0C6h, 045h, 000h, 000h
db 0C3h, 048h, 0FFh, 045h, 023h, 0FEh, 045h, 022h, 080h, 07Dh, 022h, 00Fh, 075h, 006h, 0E8h, 09Ah
db 0F9h, 0FFh, 0FFh, 0C3h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 000h, 03Ch, 090h, 074h, 03Eh, 03Ch
db 0A4h, 074h, 03Ah, 03Ch, 0A5h, 074h, 036h, 03Ch, 0A6h, 074h, 032h, 03Ch, 0A7h, 074h, 02Eh, 03Ch
db 0AAh, 074h, 02Ah, 03Ch, 0ABh, 074h, 026h, 03Ch, 0ACh, 074h, 022h, 03Ch, 0ADh, 074h, 01Eh, 03Ch
db 0AEh, 074h, 01Ah, 03Ch, 0AFh, 074h, 016h, 03Ch, 06Ch, 074h, 012h, 03Ch, 06Dh, 074h, 00Eh, 03Ch
db 06Eh, 074h, 00Ah, 03Ch, 06Fh, 074h, 006h, 03Ch, 00Fh, 074h, 002h, 0EBh, 004h, 0C6h, 045h, 001h
db 001h, 048h, 08Bh, 045h, 023h, 048h, 00Fh, 0B6h, 008h, 048h, 08Dh, 004h, 0CEh, 048h, 003h, 000h
db 0FFh, 0D0h, 0C6h, 045h, 001h, 000h, 0C3h, 048h, 0FFh, 045h, 023h, 0FEh, 045h, 022h, 080h, 07Dh
db 022h, 00Fh, 075h, 006h, 0E8h, 024h, 0F9h, 0FFh, 0FFh, 0C3h, 048h, 08Bh, 045h, 023h, 048h, 00Fh
db 0B6h, 008h, 048h, 08Dh, 084h, 0CEh, 000h, 008h, 000h, 000h, 048h, 003h, 000h, 0FFh, 0D0h, 0C3h
db 048h, 0FFh, 045h, 023h, 0FEh, 045h, 022h, 080h, 07Dh, 022h, 00Fh, 075h, 006h, 0E8h, 0FBh, 0F8h
db 0FFh, 0FFh, 0C3h, 048h, 08Bh, 045h, 023h, 048h, 00Fh, 0B6h, 008h, 048h, 08Dh, 084h, 0CEh, 000h
db 010h, 000h, 000h, 048h, 003h, 000h, 0FFh, 0D0h, 0C3h, 048h, 0FFh, 045h, 023h, 0FEh, 045h, 022h
db 080h, 07Dh, 022h, 00Fh, 075h, 006h, 0E8h, 0D2h, 0F8h, 0FFh, 0FFh, 0C3h, 048h, 08Bh, 045h, 023h
db 048h, 00Fh, 0B6h, 008h, 048h, 08Dh, 084h, 0CEh, 000h, 018h, 000h, 000h, 048h, 003h, 000h, 0FFh
db 0D0h, 0C3h, 0C7h, 045h, 01Ah, 000h, 000h, 000h, 000h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 040h
db 001h, 03Dh, 0BFh, 000h, 000h, 000h, 07Fh, 011h, 0E8h, 0CDh, 0F5h, 0FFh, 0FFh, 083h, 07Dh, 016h
db 007h, 07Eh, 006h, 0E8h, 095h, 0F8h, 0FFh, 0FFh, 0C3h, 0E8h, 070h, 0F5h, 0FFh, 0FFh, 08Bh, 045h
db 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0C7h, 045h, 01Ah, 000h, 000h, 000h
db 000h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 040h, 001h, 03Dh, 0BFh, 000h, 000h, 000h, 07Fh, 017h
db 0E8h, 095h, 0F5h, 0FFh, 0FFh, 083h, 07Dh, 016h, 001h, 075h, 069h, 083h, 07Dh, 016h, 007h, 07Eh
db 063h, 0E8h, 057h, 0F8h, 0FFh, 0FFh, 0C3h, 03Dh, 0C0h, 000h, 000h, 000h, 07Ch, 056h, 089h, 0C2h
db 0C1h, 0EAh, 004h, 089h, 0C1h, 083h, 0E1h, 00Fh, 083h, 0FAh, 00Dh, 075h, 00Bh, 083h, 0F9h, 000h
db 074h, 042h, 0E8h, 036h, 0F8h, 0FFh, 0FFh, 0C3h, 083h, 0FAh, 00Eh, 075h, 037h, 083h, 0F9h, 002h
db 075h, 006h, 0E8h, 026h, 0F8h, 0FFh, 0FFh, 0C3h, 083h, 0F9h, 003h, 075h, 006h, 0E8h, 01Bh, 0F8h
db 0FFh, 0FFh, 0C3h, 083h, 0F9h, 006h, 075h, 006h, 0E8h, 010h, 0F8h, 0FFh, 0FFh, 0C3h, 083h, 0F9h
db 007h, 075h, 006h, 0E8h, 005h, 0F8h, 0FFh, 0FFh, 0C3h, 083h, 0F9h, 00Fh, 075h, 006h, 0E8h, 0FAh
db 0F7h, 0FFh, 0FFh, 0C3h, 0E8h, 0D5h, 0F4h, 0FFh, 0FFh, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h
db 083h, 045h, 023h, 002h, 0C3h, 0C7h, 045h, 01Ah, 000h, 000h, 000h, 000h, 048h, 08Bh, 045h, 023h
db 00Fh, 0B6h, 040h, 001h, 03Dh, 0BFh, 000h, 000h, 000h, 07Fh, 011h, 0E8h, 0FAh, 0F4h, 0FFh, 0FFh
db 083h, 07Dh, 016h, 007h, 07Eh, 032h, 0E8h, 0C2h, 0F7h, 0FFh, 0FFh, 0C3h, 03Dh, 0C0h, 000h, 000h
db 000h, 07Ch, 025h, 089h, 0C2h, 0C1h, 0EAh, 004h, 089h, 0C1h, 083h, 0E1h, 00Fh, 083h, 0FAh, 00Eh
db 075h, 00Bh, 083h, 0F9h, 009h, 074h, 011h, 0E8h, 0A1h, 0F7h, 0FFh, 0FFh, 0C3h, 083h, 0FAh, 00Fh
db 075h, 006h, 0E8h, 096h, 0F7h, 0FFh, 0FFh, 0C3h, 0E8h, 071h, 0F4h, 0FFh, 0FFh, 08Bh, 045h, 01Ah
db 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0C7h, 045h, 01Ah, 000h, 000h, 000h, 000h
db 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 040h, 001h, 03Dh, 0BFh, 000h, 000h, 000h, 07Fh, 01Fh, 0E8h
db 096h, 0F4h, 0FFh, 0FFh, 083h, 07Dh, 016h, 004h, 074h, 00Eh, 083h, 07Dh, 016h, 006h, 074h, 008h
db 083h, 07Dh, 016h, 007h, 07Fh, 002h, 0EBh, 041h, 0E8h, 050h, 0F7h, 0FFh, 0FFh, 0C3h, 03Dh, 0C0h
db 000h, 000h, 000h, 07Ch, 034h, 089h, 0C2h, 0C1h, 0EAh, 004h, 089h, 0C1h, 083h, 0E1h, 00Fh, 083h
db 0FAh, 00Eh, 075h, 015h, 083h, 0F9h, 008h, 07Dh, 020h, 083h, 0F9h, 003h, 074h, 01Bh, 083h, 0F9h
db 002h, 074h, 016h, 0E8h, 025h, 0F7h, 0FFh, 0FFh, 0C3h, 083h, 0FAh, 00Fh, 075h, 00Bh, 083h, 0F9h
db 008h, 07Ch, 006h, 0E8h, 015h, 0F7h, 0FFh, 0FFh, 0C3h, 0E8h, 0F0h, 0F3h, 0FFh, 0FFh, 08Bh, 045h
db 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0C7h, 045h, 01Ah, 000h, 000h, 000h
db 000h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 040h, 001h, 03Dh, 0BFh, 000h, 000h, 000h, 07Fh, 011h
db 0E8h, 015h, 0F4h, 0FFh, 0FFh, 083h, 07Dh, 016h, 007h, 07Eh, 022h, 0E8h, 0DDh, 0F6h, 0FFh, 0FFh
db 0C3h, 03Dh, 0C0h, 000h, 000h, 000h, 07Ch, 015h, 089h, 0C2h, 0C1h, 0EAh, 004h, 089h, 0C1h, 083h
db 0E1h, 00Fh, 083h, 0FAh, 00Dh, 075h, 006h, 0E8h, 0C1h, 0F6h, 0FFh, 0FFh, 0C3h, 0E8h, 09Ch, 0F3h
db 0FFh, 0FFh, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0C7h, 045h
db 01Ah, 000h, 000h, 000h, 000h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 040h, 001h, 03Dh, 0BFh, 000h
db 000h, 000h, 07Fh, 019h, 0E8h, 0C1h, 0F3h, 0FFh, 0FFh, 083h, 07Dh, 016h, 005h, 074h, 008h, 083h
db 07Dh, 016h, 007h, 07Fh, 002h, 0EBh, 032h, 0E8h, 081h, 0F6h, 0FFh, 0FFh, 0C3h, 03Dh, 0C0h, 000h
db 000h, 000h, 07Ch, 025h, 089h, 0C2h, 0C1h, 0EAh, 004h, 089h, 0C1h, 083h, 0E1h, 00Fh, 083h, 0FAh
db 00Ch, 075h, 00Bh, 083h, 0F9h, 008h, 07Ch, 011h, 0E8h, 060h, 0F6h, 0FFh, 0FFh, 0C3h, 083h, 0FAh
db 00Fh, 075h, 006h, 0E8h, 055h, 0F6h, 0FFh, 0FFh, 0C3h, 0E8h, 030h, 0F3h, 0FFh, 0FFh, 08Bh, 045h
db 01Ah, 001h, 045h, 023h, 048h, 083h, 045h, 023h, 002h, 0C3h, 0C7h, 045h, 01Ah, 000h, 000h, 000h
db 000h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h, 040h, 001h, 03Dh, 0BFh, 000h, 000h, 000h, 07Fh, 011h
db 0E8h, 055h, 0F3h, 0FFh, 0FFh, 083h, 07Dh, 016h, 007h, 07Eh, 027h, 0E8h, 01Dh, 0F6h, 0FFh, 0FFh
db 0C3h, 03Dh, 0C0h, 000h, 000h, 000h, 07Ch, 01Ah, 089h, 0C2h, 0C1h, 0EAh, 004h, 089h, 0C1h, 083h
db 0E1h, 00Fh, 083h, 0FAh, 00Dh, 075h, 00Bh, 083h, 0F9h, 009h, 074h, 006h, 0E8h, 0FCh, 0F5h, 0FFh
db 0FFh, 0C3h, 0E8h, 0D7h, 0F2h, 0FFh, 0FFh, 08Bh, 045h, 01Ah, 001h, 045h, 023h, 048h, 083h, 045h
db 023h, 002h, 0C3h, 0C7h, 045h, 01Ah, 000h, 000h, 000h, 000h, 048h, 08Bh, 045h, 023h, 00Fh, 0B6h
db 040h, 001h, 03Dh, 0BFh, 000h, 000h, 000h, 07Fh, 011h, 0E8h, 0FCh, 0F2h, 0FFh, 0FFh, 083h, 07Dh
db 016h, 007h, 07Eh, 052h, 0E8h, 0C4h, 0F5h, 0FFh, 0FFh, 0C3h, 03Dh, 0C0h, 000h, 000h, 000h, 07Ch
db 045h, 089h, 0C2h, 0C1h, 0EAh, 004h, 089h, 0C1h, 083h, 0E1h, 00Fh, 083h, 0FAh, 00Ch, 075h, 006h
db 0E8h, 0A8h, 0F5h, 0FFh, 0FFh, 0C3h, 083h, 0FAh, 00Dh, 075h, 006h, 0E8h, 09Dh, 0F5h, 0FFh, 0FFh
db 0C3h, 083h, 0FAh, 00Eh, 075h, 010h, 083h, 0F9h, 000h, 074h, 01Bh, 083h, 0F9h, 008h, 07Dh, 016h
db 0E8h, 088h, 0F5h, 0FFh, 0FFh, 0C3h, 083h, 0FAh, 00Fh, 075h, 00Bh, 083h, 0F9h, 008h, 07Ch, 006h
db 0E8h, 078h, 0F5h, 0FFh, 0FFh, 0C3h, 0E8h, 053h, 0F2h, 0FFh, 0FFh, 08Bh, 045h, 01Ah, 001h, 045h
db 023h, 048h, 083h, 045h, 023h, 002h, 0C3h

LDE endp
end
```

`airhv/airhv-main/airhv/log.cpp`:

```cpp
#define _NO_CRT_STDIO_INLINE
#include <ntifs.h>
#include <stdarg.h>
#include <ntstrsafe.h>
#include "log.h"

void LogPrint(__log_type type, const char* fmt, ...)
{
	char* LogType = NULL;
	LARGE_INTEGER SystemTime = {};
	LARGE_INTEGER LocalTime = {};
	TIME_FIELDS TimeFields = {};
	char TimeBuffer[20] = {};
	char MessageBuffer[412] = {};
	char* OutputFormat = NULL;
	char OutputBuffer[512] = {};
	va_list Args = {};

	switch (type)
	{
	case LOG_TYPE_DEBUG:
	{
		LogType = "[DEBUG]";
		break;
	}
	case LOG_TYPE_DUMP:
	{
		LogType = "[DUMP]";
		break;
	}
	case LOG_TYPE_ERROR:
	{
		LogType = "[ERROR]";
		;			break;
	}
	case LOG_TYPE_INFO:
	{
		LogType = "[INFORMATION]";
		break;
	}
	default:
	{
		break;
	}

	}

	KeQuerySystemTime(&SystemTime);
	ExSystemTimeToLocalTime(&SystemTime, &LocalTime);
	RtlTimeToTimeFields(&LocalTime, &TimeFields);

	RtlStringCchPrintfA(
		TimeBuffer,
		sizeof(TimeBuffer),
		"[%02hd:%02hd:%02hd.%03hd]",
		TimeFields.Hour,
		TimeFields.Minute,
		TimeFields.Second,
		TimeFields.Milliseconds);
 
	va_start(Args, fmt);
	RtlStringCchVPrintfA(MessageBuffer, sizeof(MessageBuffer), fmt, Args);
	va_end(Args);

	OutputFormat = "%s  %s  %s\r\n";

	RtlStringCchPrintfA(
		OutputBuffer,
		sizeof(OutputBuffer),
		OutputFormat,
		TimeBuffer,
		LogType,
		MessageBuffer);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "%s", OutputBuffer);
}
```

`airhv/airhv-main/airhv/log.h`:

```h
#pragma once
#define LogError(format, ...)  \
    LogPrint(LOG_TYPE_ERROR," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogDebug(format, ...)  \
    LogPrint(LOG_TYPE_DEBUG," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogDump(format, ...)  \
    LogPrint(LOG_TYPE_DUMP," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogInfo(format, ...)  \
    LogPrint(LOG_TYPE_INFO," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)

enum __log_type 
{
	LOG_TYPE_DEBUG,
	LOG_TYPE_ERROR,
	LOG_TYPE_DUMP,
	LOG_TYPE_INFO
};

void LogPrint(__log_type type, const char* fmt, ...);
```

`airhv/airhv-main/airhv/main.cpp`:

```cpp
#pragma warning( disable : 4201 4805)
#include <ntddk.h>
#include <intrin.h>
#include "log.h"
#include "ntapi.h"
#include "hypervisor_routines.h"
#include "hypervisor_gateway.h"
#include "vmm.h"

#define IOCTL_POOL_MANAGER_ALLOCATE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

__vmm_context* g_vmm_context = 0;

 VOID driver_unload(PDRIVER_OBJECT driver_object)
 {
	 UNICODE_STRING dos_device_name;
	 if(g_vmm_context != NULL)
	 {
		 if (g_vmm_context->vcpu_table[0]->vcpu_status.vmm_launched == true)
		 {
			 hvgt::ept_unhook();
			 hvgt::vmoff();
		 }
	 }

	 hv::disable_vmx_operation();
	 free_vmm_context();

	 RtlInitUnicodeString(&dos_device_name, L"\\DosDevices\\airhv");
	 IoDeleteSymbolicLink(&dos_device_name);
	 IoDeleteDevice(driver_object->DeviceObject);
 }

 NTSTATUS driver_create_close(_In_ PDEVICE_OBJECT device_object, _In_ PIRP irp)
 {
	 UNREFERENCED_PARAMETER(device_object);

	 irp->IoStatus.Status = STATUS_SUCCESS;
	 irp->IoStatus.Information = 0;

	 IoCompleteRequest(irp, IO_NO_INCREMENT);

	 return STATUS_SUCCESS;
 }

 NTSTATUS driver_ioctl_dispatcher(_In_ PDEVICE_OBJECT device_object, _In_ PIRP irp)
 {
	 UNREFERENCED_PARAMETER(device_object);
	 unsigned __int32 bytes_io = 0;
	 PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);
	 NTSTATUS status = STATUS_SUCCESS;

	 switch (stack->Parameters.DeviceIoControl.IoControlCode)
	 {
		 //
		 // Used by hypervisor control driver to perform allocations
		 //
		 case IOCTL_POOL_MANAGER_ALLOCATE:
		 {
			 status = pool_manager::perform_allocation();
			 break;
		 }
	 }

	 irp->IoStatus.Status = status;
	 irp->IoStatus.Information = bytes_io;

	 IoCompleteRequest(irp, IO_NO_INCREMENT);
	 return status;
 }

extern "C"
NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PCUNICODE_STRING reg) 
{
	UNREFERENCED_PARAMETER(reg);

	NTSTATUS status = STATUS_SUCCESS;
	PDEVICE_OBJECT device_object = NULL;
	UNICODE_STRING driver_name, dos_device_name;

	RtlInitUnicodeString(&driver_name, L"\\Device\\airhv");
	RtlInitUnicodeString(&dos_device_name, L"\\DosDevices\\airhv");

	status = IoCreateDevice(driver_object, 0, &driver_name, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &device_object);

	if (status == STATUS_SUCCESS)
	{
		driver_object->MajorFunction[IRP_MJ_CLOSE] = driver_create_close;
		driver_object->MajorFunction[IRP_MJ_CREATE] = driver_create_close;
		driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL] = driver_ioctl_dispatcher;

		driver_object->DriverUnload = driver_unload;
		driver_object->Flags |= DO_BUFFERED_IO;
		IoCreateSymbolicLink(&dos_device_name, &driver_name);
	}

	//
	// Check if our cpu support virtualization
	//
	if (!hv::virtualization_support()) {
		LogError("VMX operation is not supported on this processor.\n");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	//
	// Initialize and start virtual machine
	// If it fails turn off vmx and deallocate all structures
	//
	if(vmm_init() == false)
	{
		hv::disable_vmx_operation();
		free_vmm_context();
		LogError("Vmm initialization failed");
		return STATUS_FAILED_DRIVER_ENTRY;
	}

	return status;
}
```

`airhv/airhv-main/airhv/ntapi.h`:

```h
#pragma once
#include <ntddk.h>

struct __nt_kprocess
{
    DISPATCHER_HEADER Header;                                       //0x0
    LIST_ENTRY ProfileListHead;                                     //0x18
    ULONGLONG DirectoryTableBase;
};

extern "C"
{
    void NTAPI KeGenericCallDpc(_In_ PKDEFERRED_ROUTINE Routine, PVOID Context);
    void NTAPI KeSignalCallDpcDone(_In_ PVOID SystemArgument1);
    BOOLEAN NTAPI KeSignalCallDpcSynchronize(_In_ PVOID SystemArgument2);
}
```

`airhv/airhv-main/airhv/poolmanager.cpp`:

```cpp
#pragma warning( disable : 4201)
#include <intrin.h>
#include "poolmanager.h"
#include "common.h"
#include "log.h"
#include "allocators.h"

namespace pool_manager 
{
    /// <summary>
    /// Allocate pools and add them to pool table
    /// </summary>
    /// <param name="size">Size of pool</param>
    /// <param name="count">Number of pools to allocate</param>
    /// <param name="intention"></param>
    /// <returns></returns>
    bool allocate_pool(unsigned __int64 size, unsigned __int32 count, allocation_intention intention)
    {
        for (unsigned int i = 0; i < count; i++)
        {
            __pool_table* single_pool = ::allocate_pool<__pool_table>();
            if (single_pool == nullptr)
            {
                LogError("Memory allocation failed");
                return false;
            }
            RtlSecureZeroMemory(single_pool, sizeof(__pool_table));

            single_pool->address = ::allocate_pool<void*>(size);
            if (single_pool->address == nullptr)
            {
                LogError("Memory allocation failed");
                return false;
            }
            RtlSecureZeroMemory((void*)single_pool->address, size);

            single_pool->intention = intention;
            single_pool->is_busy = false;
            single_pool->size = size;

            InsertTailList(g_vmm_context->pool_manager->list_of_allocated_pools, &(single_pool->pool_list));
        }

        return true;
    }

    /// <summary>
    /// Request allocation
    /// </summary>
    /// <param name="size">Size of pool</param>
    /// <param name="count">Number of pools to allocate</param>
    /// <param name="intention"></param>
    /// <returns></returns>
    bool request_allocation(unsigned __int64 size, unsigned __int32 count, allocation_intention intention)
    {
        spinlock::lock(&g_vmm_context->pool_manager->lock_for_request_allocation);

        for (unsigned __int64 i = 0; i < 10; i++)
        {
            if (g_vmm_context->pool_manager->allocation_requests->size[i] == 0)
            {
                g_vmm_context->pool_manager->allocation_requests->count[i] = count;
                g_vmm_context->pool_manager->allocation_requests->size[i] = size;
                g_vmm_context->pool_manager->allocation_requests->intention[i] = intention;
                g_vmm_context->pool_manager->is_request_for_allocation_recived = true;
                break;
            }
        }

        spinlock::unlock(&g_vmm_context->pool_manager->lock_for_request_allocation);
        return g_vmm_context->pool_manager->is_request_for_allocation_recived;
    }

    /// <summary>
    /// Allocate all requested pools
    /// </summary>
    /// <returns></returns>
    bool perform_allocation()
    {
        bool status = true;

        if (g_vmm_context->pool_manager->is_request_for_allocation_recived == false)
        {
            LogInfo("No pending allocations");
            return status;
        }

        for (unsigned __int64 i = 0; i < 10; i++)
        {
            if (g_vmm_context->pool_manager->allocation_requests->size[i] != 0)
            {
                status = allocate_pool
                (
                    g_vmm_context->pool_manager->allocation_requests->size[i],
                    g_vmm_context->pool_manager->allocation_requests->count[i],
                    g_vmm_context->pool_manager->allocation_requests->intention[i]
                );

                if (status == false)
                {
                    LogError("Pool manager allocate and add to pool table failed");
                    break;
                }

                g_vmm_context->pool_manager->allocation_requests->size[i] = 0;
                g_vmm_context->pool_manager->allocation_requests->count[i] = 0;
                g_vmm_context->pool_manager->allocation_requests->intention[i] = INTENTION_NONE;

                LogInfo("Allocation successful");
            }
        }

        g_vmm_context->pool_manager->is_request_for_allocation_recived = false;

        return status;
    }

    /// <summary>
    /// Initalize pool manager struct and preallocate pools
    /// </summary>
    /// <returns> status </returns>
    bool initialize()
    {
        g_vmm_context->pool_manager = ::allocate_pool<__pool_manager>();
        if (g_vmm_context->pool_manager == nullptr)
        {
            LogError("Pool manager allocation failed");
            return false;
        }
        RtlSecureZeroMemory(g_vmm_context->pool_manager, sizeof(__pool_manager));

        g_vmm_context->pool_manager->allocation_requests = ::allocate_pool<__request_new_allocation>();
        if (g_vmm_context->pool_manager->allocation_requests == nullptr)
        {
            LogError("Allacation requests allocation failed");
            return false;
        }
        RtlSecureZeroMemory(g_vmm_context->pool_manager->allocation_requests, sizeof(__request_new_allocation));

        g_vmm_context->pool_manager->list_of_allocated_pools = ::allocate_pool<LIST_ENTRY>();
        if (g_vmm_context->pool_manager->list_of_allocated_pools == nullptr)
        {
            LogError("List of allocated pools allocation failed");
            return false;
        }
        RtlSecureZeroMemory(g_vmm_context->pool_manager->list_of_allocated_pools, sizeof(LIST_ENTRY));

        InitializeListHead(g_vmm_context->pool_manager->list_of_allocated_pools);

        if (request_allocation(sizeof(__ept_dynamic_split), 100, INTENTION_SPLIT_PML2) == false)
        {
            LogError("Pool mangaer request allocation Failed");
            return false;
        }

        if (request_allocation(sizeof(__ept_hooked_page_info), 100, INTENTION_TRACK_HOOKED_PAGES) == false)
        {
            LogError("Pool mangaer request allocation Failed");
            return false;
        }

        if (request_allocation(100, 100, INTENTION_EXEC_TRAMPOLINE) == false)
        {
            LogError("Pool mangaer request allocation Failed");
            return false;
        }

        if (request_allocation(sizeof(__ept_hooked_function_info), 100, INTENTION_TRACK_HOOKED_FUNCTIONS) == false)
        {
            LogError("Pool mangaer request allocation Failed");
            return false;
        }

        return perform_allocation();
    }
    /// <summary>
    /// Free all allocted pools
    /// </summary>
    void uninitialize()
    {
        PLIST_ENTRY current = 0;

        if (g_vmm_context->pool_manager->list_of_allocated_pools != nullptr)
        {
            current = g_vmm_context->pool_manager->list_of_allocated_pools;

            while (g_vmm_context->pool_manager->list_of_allocated_pools != current->Flink)
            {
                current = current->Flink;

                // Get the head of the record
                __pool_table* pool_table = (__pool_table*)CONTAINING_RECORD(current, __pool_table, pool_list);

                // Free the alloocated buffer
                free_pool(pool_table->address);

                // Free the record itself
                free_pool(pool_table);
            }

            free_pool(g_vmm_context->pool_manager->list_of_allocated_pools);
        }

        if (g_vmm_context->pool_manager->allocation_requests != nullptr)
        {
            free_pool(g_vmm_context->pool_manager->allocation_requests);
        }
    }

    /// <summary>
    /// Set information that pool is no longer used anymore
    /// </summary>
    /// <param name="address"></param>
    void release_pool(void* address)
    {
        PLIST_ENTRY current = 0;
        current = g_vmm_context->pool_manager->list_of_allocated_pools;

        spinlock::lock(&g_vmm_context->pool_manager->lock_for_reading_pool);
        while (g_vmm_context->pool_manager->list_of_allocated_pools != current->Flink)
        {
            current = current->Flink;

            // Get the head of the record
            __pool_table* pool_table = (__pool_table*)CONTAINING_RECORD(current, __pool_table, pool_list);

            if (address == pool_table->address)
            {
                RtlSecureZeroMemory(address, pool_table->size);
                pool_table->is_busy = false;
                pool_table->recycled = true;
                break;
            }
        }

        spinlock::unlock(&g_vmm_context->pool_manager->lock_for_reading_pool);
    }

    inline const char* intention_to_string(allocation_intention intention)
    {
        switch (intention)
        {
        case INTENTION_NONE:   return "None";
        case INTENTION_TRACK_HOOKED_PAGES:   return "Track Hooked Pages";
        case INTENTION_EXEC_TRAMPOLINE: return "Trampoline";
        case INTENTION_SPLIT_PML2: return "Split Pml2";
        case INTENTION_TRACK_HOOKED_FUNCTIONS: return "Trace Hooked Functions";
        default:      return "Unknown";
        }
    }

    /// <summary>
    /// Writes all information about allocated pools
    /// </summary>
    void dump_pools_info()
    {
        PLIST_ENTRY current = g_vmm_context->pool_manager->list_of_allocated_pools;

        spinlock::lock(&g_vmm_context->pool_manager->lock_for_reading_pool);

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "-----------------------------------POOL MANAGER DUMP-----------------------------------\r\n");

        while (g_vmm_context->pool_manager->list_of_allocated_pools != current->Flink)
        {
            current = current->Flink;

            // Get the head of the record
            __pool_table* pool_table = (__pool_table*)CONTAINING_RECORD(current, __pool_table, pool_list);

            LogDump("Address: 0x%X    Size: %llu    Intention: %s    Is Busy: %s    Recycled: %s",
                pool_table->address, pool_table->size, intention_to_string(pool_table->intention), pool_table->is_busy ? "Yes" : "No",
                pool_table->recycled ? "Yes" : "No");
        }

        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "-----------------------------------POOL MANAGER DUMP-----------------------------------\r\n");

        spinlock::unlock(&g_vmm_context->pool_manager->lock_for_reading_pool);
    }
}
```

`airhv/airhv-main/airhv/poolmanager.h`:

```h
#pragma once
#include <ntddk.h>

namespace pool_manager
{
    enum allocation_intention
    {
        INTENTION_NONE,
        INTENTION_TRACK_HOOKED_PAGES,
        INTENTION_EXEC_TRAMPOLINE,
        INTENTION_SPLIT_PML2,
        INTENTION_TRACK_HOOKED_FUNCTIONS
    };

    struct __request_new_allocation
    {
        unsigned __int64 size[10];
        unsigned __int32 count[10];
        allocation_intention intention[10];
    };

    struct __pool_manager
    {
        __request_new_allocation* allocation_requests;
        PLIST_ENTRY list_of_allocated_pools;
        volatile long lock_for_request_allocation;
        volatile long lock_for_reading_pool;
        bool is_request_for_allocation_recived;
    };

    struct __pool_table
    {
        void* address;
        unsigned __int64  size;
        allocation_intention intention;
        LIST_ENTRY pool_list;
        bool is_busy;
        bool recycled;
    };

    /// <summary>
    /// Writes all information about allocated pools
    /// </summary>
    void dump_pools_info();

    /// <summary>
    /// Request allocation
    /// </summary>
    /// <param name="size">Size of pool</param>
    /// <param name="count">Number of pools to allocate</param>
    /// <param name="intention"></param>
    /// <returns></returns>
    bool request_allocation(unsigned __int64 size, unsigned __int32 count, allocation_intention intention);

    /// <summary>
    /// Initalize pool manager struct and preallocate pools
    /// </summary>
    /// <returns> status </returns>
    bool initialize();

    /// <summary>
    /// Free all allocted pools
    /// </summary>
    void uninitialize();

    /// <summary>
    /// Set information that pool is no longer used by anyone and mark as recycled
    /// </summary>
    /// <param name="address"></param>
    void release_pool(void* address);

    /// <summary>
    /// Allocate all requested pools
    /// </summary>
    /// <returns></returns>
    bool perform_allocation();

    /// <summary>
    /// Returns pre allocated pool and request new one for allocation
    /// </summary>
    /// <param name="intention">Indicates what will be pool used for</param>
    /// <param name="new_pool">If set new pool will (with same properties) be requested to allocate</param>
    /// <param name="size">Only if new_pool is true. Size of new pool</param>
    /// <returns></returns>
    template <typename T>
    T request_pool(allocation_intention intention, bool new_pool, unsigned __int64 size)
    {
        PLIST_ENTRY current = 0;
        void* address = 0;
        bool is_recycled = false;
        __pool_table* pool_table;
        current = g_vmm_context->pool_manager->list_of_allocated_pools;

        spinlock::lock(&g_vmm_context->pool_manager->lock_for_reading_pool);

        while (g_vmm_context->pool_manager->list_of_allocated_pools != current->Flink)
        {
            current = current->Flink;

            // Get the head of the record
            pool_table = (__pool_table*)CONTAINING_RECORD(current, __pool_table, pool_list);

            if (pool_table->intention == intention && pool_table->is_busy == false)
            {
                pool_table->is_busy = true;
                is_recycled = pool_table->recycled;
                address = pool_table->address;
                break;
            }
        }

        spinlock::unlock(&g_vmm_context->pool_manager->lock_for_reading_pool);

        //
        // If pool which we got is recycled then we don't allocate
        // a new one because we don't want to overload memory, If there wasn't any preallocated pool
        // this function will send a request
        //
        if (new_pool == true && is_recycled == false)
            request_allocation(size, 1, intention);

        return (T)address;
    }
}

```

`airhv/airhv-main/airhv/spinlock.cpp`:

```cpp
#include <ntddk.h>

namespace spinlock 
{
	// This implementation is derived from Hvpp by Petr Benes
	//  - https://github.com/wbenny/hvpp
	// Based on my benchmarks, this simple implementation beats other (often
	// more complex) spinlock implementations - such as queue spinlocks, ticket
	// spinlocks, MCS locks.  The only difference between this implementation
	// and completely naive spinlock is the "backoff".
	//
	// Also, benefit of this implementation is that we can use it with
	// STL lock guards, e.g.: std::lock_guard.
	//
	// Look here for more information:
	//   - https://locklessinc.com/articles/locks/
	//   - https://github.com/cyfdecyf/spinlock

	static unsigned max_wait = 65536;

	bool try_lock(volatile long* lock_)
	{
		return (!(*lock_) && !_interlockedbittestandset(lock_, 0));
	}

	void lock(volatile long* lock_)
	{
		unsigned __int32 wait = 1;

		while (!try_lock(lock_))
		{
			for (unsigned __int32 i = 0; i < wait; ++i)
			{
				_mm_pause();
			}

			// Don't call "pause" too many times. If the wait becomes too big,
			// clamp it to the max_wait.

			if (wait * 2 > max_wait)
			{
				wait = max_wait;
			}
			else
			{
				wait = wait * 2;
			}
		}
	}

	void unlock(volatile long* lock_)
	{
		*lock_ = 0;
	}
}
```

`airhv/airhv-main/airhv/vmcall_handler.cpp`:

```cpp
#pragma warning( disable : 4201 4244 4805 4189)

#include <intrin.h>
#include "common.h"
#include "vmcall_handler.h"
#include "asm\vm_intrin.h"
#include "vmcall_reason.h"
#include "ia32\vmcs_encodings.h"
#include "ia32\msr.h"
#include "ia32\cr.h"
#include "vmexit_handler.h"
#include "hypervisor_routines.h"
#include "interrupt.h"

void restore_segment_registers()
{
	__writemsr(IA32_FS_BASE, hv::vmread(GUEST_FS_BASE));
	__writemsr(IA32_GS_BASE, hv::vmread(GUEST_GS_BASE));
	__reload_gdtr(hv::vmread(GUEST_GDTR_BASE), hv::vmread(GUEST_GDTR_LIMIT));
	__reload_idtr(hv::vmread(GUEST_IDTR_BASE), hv::vmread(GUEST_IDTR_LIMIT));
}

void call_vmxoff(__vcpu* vcpu)
{
	__writecr3(hv::vmread(GUEST_CR3));

	vcpu->vmx_off_state.guest_rip = vcpu->vmexit_info.guest_rip + vcpu->vmexit_info.instruction_length;
	vcpu->vmx_off_state.guest_rsp = vcpu->vmexit_info.guest_registers->rsp;
	vcpu->vmx_off_state.vmx_off_executed = true;

	restore_segment_registers();

	__vmx_off();

	__writecr4(__readcr4() & (~0x2000));
}

void vmexit_vmcall_handler(__vcpu* vcpu) 
{
	bool status = true;
	unsigned __int64 vmcall_reason = vcpu->vmexit_info.guest_registers->rcx;
	unsigned __int64 vmcall_parameter1 = vcpu->vmexit_info.guest_registers->rdx;
	unsigned __int64 vmcall_parameter2 = vcpu->vmexit_info.guest_registers->r8;
	unsigned __int64 vmcall_parameter3 = vcpu->vmexit_info.guest_registers->r9;

	//
	// These only if __vmcall_ex was called
	//
	unsigned __int64 vmcall_parameter4 = vcpu->vmexit_info.guest_registers->r10;
	unsigned __int64 vmcall_parameter5 = vcpu->vmexit_info.guest_registers->r11;
	unsigned __int64 vmcall_parameter6 = vcpu->vmexit_info.guest_registers->r12;
	unsigned __int64 vmcall_parameter7 = vcpu->vmexit_info.guest_registers->r13;
	unsigned __int64 vmcall_parameter8 = vcpu->vmexit_info.guest_registers->r14;
	unsigned __int64 vmcall_parameter9 = vcpu->vmexit_info.guest_registers->r15;

	//
	// Check if this vmcall belongs to us
	//
	if (vcpu->vmexit_info.guest_registers->rax != VMCALL_IDENTIFIER)
	{
		vcpu->vmexit_info.guest_registers->rax = __hyperv_vm_call(vcpu->vmexit_info.guest_registers->rcx, vcpu->vmexit_info.guest_registers->rdx, vcpu->vmexit_info.guest_registers->r8);
		return;
	}

	if (hv::get_guest_cpl() != 0) 
	{
		hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, 1);
		return;
	}

	switch (vmcall_reason)
	{
		case VMCALL_TEST:
		{
			adjust_rip(vcpu);
			break;
		}

		case VMCALL_VMXOFF:
		{
			call_vmxoff(vcpu);
			break;
		}

		case VMCALL_EPT_HOOK_FUNCTION:
		{
			 unsigned __int64 old_cr3 = hv::swap_context();

			status = ept::hook_function((void*)vmcall_parameter1, (void*)vmcall_parameter2, (void*)vmcall_parameter3, (void**)vmcall_parameter4);

			hv::restore_context(old_cr3);

			adjust_rip(vcpu);
			break;
		}

		case VMCALL_EPT_UNHOOK_FUNCTION:
		{
			unsigned __int64 old_cr3 = hv::swap_context();

			// If set unhook all pages
			if (vmcall_parameter1 == true)
			{
				ept::unhook_all_functions();
			}

			else
			{
				// Page physciall address
				status = ept::unhook_function(vmcall_parameter2);
			}

			hv::restore_context(old_cr3);

			adjust_rip(vcpu);
			break;
		}

		case VMCALL_INVEPT_CONTEXT:
		{
			// If set invept all contexts
			if (vmcall_parameter1 == true)
			{
				invept_all_contexts();
			}

			else 
			{
				invept_single_context(g_vmm_context->ept_state->ept_pointer->all);
			}

			adjust_rip(vcpu);
			break;
		}

		case VMCALL_DUMP_POOL_MANAGER:
		{
			pool_manager::dump_pools_info();
			adjust_rip(vcpu);
			break;
		}

		case VMCALL_DUMP_VMCS_STATE:
		{
			hv::dump_vmcs();
			adjust_rip(vcpu);
			break;
		}

		case VMCALL_HIDE_HV_PRESENCE:
		{
			g_vmm_context->hv_presence = false;
			adjust_rip(vcpu);
			break;
		}

		case VMCALL_UNHIDE_HV_PRESENCE:
		{
			g_vmm_context->hv_presence = true;
			adjust_rip(vcpu);
			break;
		}
	}

	vcpu->vmexit_info.guest_registers->rax = status;
}
```

`airhv/airhv-main/airhv/vmcall_handler.h`:

```h
#pragma once

struct __vmcall_hook_page
{
	void* target_adress;
	void* hook_function;
	void** origin_adress;
	void* code_cave;
	unsigned __int8 protection_mask;
	bool swap_context;
};

struct __vmcall_unhook_page
{
	unsigned __int64 physical_adress;
	bool unhook_all;
};

struct __vmcall_hook_msr_lstar
{
	unsigned __int64 new_lstar_value;
};

struct __vmcall_invept
{
	bool invept_all_context;
};

void restore_segment_registers();
void call_vmxoff(__vcpu* vcpu);
//void vmcall_operations(__vmexit_guest_registers_t* guest_regs);
void vmexit_vmcall_handler(__vcpu* vcpu);
```

`airhv/airhv-main/airhv/vmcall_reason.h`:

```h
#pragma once
enum vm_call_reasons
{
	VMCALL_TEST,
	VMCALL_VMXOFF,
	VMCALL_EPT_HOOK_FUNCTION,
	VMCALL_EPT_UNHOOK_FUNCTION,
	VMCALL_INVEPT_CONTEXT,
	VMCALL_DUMP_POOL_MANAGER,
	VMCALL_DUMP_VMCS_STATE,
	VMCALL_HIDE_HV_PRESENCE,
	VMCALL_UNHIDE_HV_PRESENCE
};
```

`airhv/airhv-main/airhv/vmcs.cpp`:

```cpp
#pragma warning( disable : 4201 4244)
#include <intrin.h>
#include "ia32\segment.h"
#include "common.h"
#include "ia32\vmcs.h"
#include "ia32\vmcs_encodings.h"
#include "ia32\msr.h"
#include "asm\vm_intrin.h"
#include "asm\vm_context.h"
#include "ia32\cr.h"
#include "log.h"
#include "hypervisor_routines.h"
/// <summary>
/// Derived from Intel Manuals Voulme 3 Section 24.6.2 Table 24-6. Definitions of Primary Processor-Based VM-Execution Controls
/// </summary>
/// <param name="primary_controls"></param>
void set_primary_controls(__vmx_primary_processor_based_control& primary_controls) 
{
	/**
	* If this control is 1, a VM exit occurs at the beginning of any instruction if RFLAGS.IF = 1 and
	* there are no other blocking of interrupts (see Section 24.4.2).
	*/
	primary_controls.interrupt_window_exiting = false;

	/**
	* This control determines whether executions of RDTSC, executions of RDTSCP, and executions
	* of RDMSR that read from the IA32_TIME_STAMP_COUNTER MSR return a value modified by
	* the TSC offset field (see Section 24.6.5 and Section 25.3).
	*/
	primary_controls.use_tsc_offsetting = false;

	/**
	* This control determines whether executions of HLT cause VM exits.
	*/
	primary_controls.hlt_exiting = false;

	/**
	* This determines whether executions of INVLPG cause VM exits.
	*/

#ifdef _MINIMAL
	primary_controls.invldpg_exiting = false;
#else
	primary_controls.invldpg_exiting = true;
#endif

	/**
	* This control determines whether executions of MWAIT cause VM exits.
	*/
	primary_controls.mwait_exiting = false;

	/**
	* This control determines whether executions of RDPMC cause VM exits.
	*/
	primary_controls.rdpmc_exiting = false;

	/**
	* This control determines whether executions of RDTSC and RDTSCP cause VM exits.
	*/
#ifdef _MINIMAL
	primary_controls.rdtsc_exiting = false;
#else
	primary_controls.rdtsc_exiting = true;
#endif

	/**
	* In conjunction with the CR3-target controls (see Section 24.6.7), this control determines
	* whether executions of MOV to CR3 cause VM exits. See Section 25.1.3.
	* The first processors to support the virtual-machine extensions supported only the 1-setting
	* of this control.
	*/
#ifdef _MINIMAL
	primary_controls.cr3_load_exiting = false;
#else
	primary_controls.cr3_load_exiting = true;
#endif

	/**
	* This control determines whether executions of MOV from CR3 cause VM exits.
	* The first processors to support the virtual-machine extensions supported only the 1-setting
	* of this control.
	*/
#ifdef _MINIMAL
	primary_controls.cr3_store_exiting = false;
#else
	primary_controls.cr3_store_exiting = true;
#endif

	/**
	* This control determines whether executions of MOV to CR8 cause VM exits.
	*/
	primary_controls.cr8_load_exiting = false;

	/**
	* This control determines whether executions of MOV from CR8 cause VM exits.
	*/
	primary_controls.cr8_store_exiting = false;

	/**
	* Setting this control to 1 enables TPR virtualization and other APIC-virtualization features. See
	* Chapter 29.
	*/
	primary_controls.use_tpr_shadow = false;

	/**
	* If this control is 1, a VM exit occurs at the beginning of any instruction if there is no virtual-
	* NMI blocking (see Section 24.4.2).
	*/
	primary_controls.nmi_window_exiting = false;

	/**
	* This control determines whether executions of MOV DR cause VM exits.
	*/
#ifdef _MINIMAL
	primary_controls.mov_dr_exiting = false;
#else
	primary_controls.mov_dr_exiting = true;
#endif

	/**
	* This control determines whether executions of I/O instructions (IN, INS/INSB/INSW/INSD, OUT,
	* and OUTS/OUTSB/OUTSW/OUTSD) cause VM exits.
	*/
	primary_controls.unconditional_io_exiting = false;

	/**
	* This control determines whether I/O bitmaps are used to restrict executions of I/O instructions
	(see Section 24.6.4 and Section 25.1.3).
	For this control, “0” means “do not use I/O bitmaps” and “1” means “use I/O bitmaps.” If the I/O
	bitmaps are used, the setting of the “unconditional I/O exiting” control is ignored
	*/
#ifdef _MINIMAL
	primary_controls.use_io_bitmaps = false;
#else
	primary_controls.use_io_bitmaps = true;
#endif

	/**
	* If this control is 1, the monitor trap flag debugging feature is enabled. See Section 25.5.2.
	*/
	primary_controls.monitor_trap_flag = false;

	/**
	* This control determines whether MSR bitmaps are used to control execution of the RDMSR
	* and WRMSR instructions (see Section 24.6.9 and Section 25.1.3).
	* For this control, “0” means “do not use MSR bitmaps” and “1” means “use MSR bitmaps.” If the
	* MSR bitmaps are not used, all executions of the RDMSR and WRMSR instructions cause
	* VM exits.
	*/
	primary_controls.use_msr_bitmaps = true;

	/**
	* This control determines whether executions of MONITOR cause VM exits.
	*/
	primary_controls.monitor_exiting = false;

	/**
	* This control determines whether executions of PAUSE cause VM exits.
	*/
	primary_controls.pause_exiting = false;

	/**
	* This control determines whether the secondary processor-based VM-execution controls are
	* used. If this control is 0, the logical processor operates as if all the secondary processor-based
	* VM-execution controls were also 0.
	*/
	primary_controls.active_secondary_controls = true;
}

/// <summary>
/// Derived from Intel Manuals Voulme 3 Section 24.6.2 Table 24-7. Definitions of Secondary Processor-Based VM-Execution Controls
/// </summary>
/// <param name="secondary_controls"></param>
void set_secondary_controls(__vmx_secondary_processor_based_control& secondary_controls) 
{
	/**
	* If this control is 1, the logical processor treats specially accesses to the page with the APIC-
	* access address. See Section 29.4.
	*/
	secondary_controls.virtualize_apic_accesses = false;

	/**
	* If this control is 1, extended page tables (EPT) are enabled. See Section 28.2.
	*/
	secondary_controls.enable_ept = true;

	/**
	* This control determines whether executions of LGDT, LIDT, LLDT, LTR, SGDT, SIDT, SLDT, and
	* STR cause VM exits.
	*/
#ifdef _MINIMAL
	secondary_controls.descriptor_table_exiting = false;
#else
	secondary_controls.descriptor_table_exiting = true;
#endif

	/**
	* If this control is 0, any execution of RDTSCP causes an invalid-opcode exception (#UD).
	*/
	secondary_controls.enable_rdtscp = true;

	/**
	* If this control is 1, the logical processor treats specially RDMSR and WRMSR to APIC MSRs (in
	* the range 800H–8FFH). See Section 29.5.
	*/
	secondary_controls.virtualize_x2apic = false;

	/**
	* If this control is 1, cached translations of linear addresses are associated with a virtual-
	* processor identifier (VPID). See Section 28.1.
	*/
	secondary_controls.enable_vpid = true;

	/**
	* This control determines whether executions of WBINVD cause VM exits.
	*/
#ifdef _MINIMAL
	secondary_controls.wbinvd_exiting = false;
#else
	secondary_controls.wbinvd_exiting = true;
#endif

	/**
	* This control determines whether guest software may run in unpaged protected mode or in real-
	* address mode.
	*/
	secondary_controls.unrestricted_guest = false;

	/**
	* If this control is 1, the logical processor virtualizes certain APIC accesses. See Section 29.4 and
	* Section 29.5.
	*/
	secondary_controls.apic_register_virtualization = false;

	/**
	* This controls enables the evaluation and delivery of pending virtual interrupts as well as the
	* emulation of writes to the APIC registers that control interrupt prioritization.
	*/
	secondary_controls.virtual_interrupt_delivery = false;

	/**
	* This control determines whether a series of executions of PAUSE can cause a VM exit (see
	* Section 24.6.13 and Section 25.1.3).
	*/
	secondary_controls.pause_loop_exiting = false;

	/**
	* This control determines whether executions of RDRAND cause VM exits.
	*/
#ifdef _MINIMAL
	secondary_controls.rdrand_exiting = false;
#else
	secondary_controls.rdrand_exiting = true;
#endif

	/**
	* If this control is 0, any execution of INVPCID causes a #UD.
	*/
	secondary_controls.enable_invpcid = true;

	/**
	* Setting this control to 1 enables use of the VMFUNC instruction in VMX non-root operation. See
	* Section 25.5.6.
	*/
	secondary_controls.enable_vmfunc = false;

	/**
	* If this control is 1, executions of VMREAD and VMWRITE in VMX non-root operation may access
	* a shadow VMCS (instead of causing VM exits). See Section 24.10 and Section 30.3.
	*/
	secondary_controls.vmcs_shadowing = false;

	/**
	* If this control is 1, executions of ENCLS consult the ENCLS-exiting bitmap to determine whether
	* the instruction causes a VM exit. See Section 24.6.16 and Section 25.1.3.
	*/
	secondary_controls.enable_encls_exiting = false;

	/**
	* This control determines whether executions of RDSEED cause VM exits.
	*/
#ifdef _MINIMAL
	secondary_controls.rdseed_exiting = false;
#else
	secondary_controls.rdseed_exiting = true;
#endif

	/**
	* If this control is 1, an access to a guest-physical address that sets an EPT dirty bit first adds an
	* entry to the page-modification log. See Section 28.2.6.
	*/
	secondary_controls.enable_pml = false;

	/**
	* If this control is 1, EPT violations may cause virtualization exceptions (#VE) instead of VM exits.
	* See Section 25.5.7.
	*/
	secondary_controls.use_virtualization_exception = false;

	/**
	* If this control is 1, Intel Processor Trace suppresses from PIPs an indication that the processor
	* was in VMX non-root operation and omits a VMCS packet from any PSB+ produced in VMX non-
	* root operation (see Chapter 35).
	*/
	secondary_controls.conceal_vmx_from_pt = true;

	/**
	* If this control is 0, any execution of XSAVES or XRSTORS causes a #UD.
	*/
	secondary_controls.enable_xsave_xrstor = true;

	/**
	* If this control is 1, EPT execute permissions are based on whether the linear address being
	* accessed is supervisor mode or user mode. See Chapter 28.
	*/
	secondary_controls.mode_based_execute_control_ept = false;

	/**
	* This control determines whether executions of RDTSC, executions of RDTSCP, and executions
	* of RDMSR that read from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the
	* TSC multiplier field (see Section 24.6.5 and Section 25.3).
	*/
	secondary_controls.sub_page_write_permission_for_ept = false;

	/**
	* This control determines whether executions of RDTSC, executions of RDTSCP, and executions
	* of RDMSR that read from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the
	* TSC multiplier field (see Section 24.6.5 and Section 25.3).
	*/
	secondary_controls.intel_pt_uses_guest_physical_address = false;

	/**
	* This control determines whether executions of RDTSC, executions of RDTSCP, and executions
	* of RDMSR that read from the IA32_TIME_STAMP_COUNTER MSR return a value modified by the
	* TSC multiplier field (see Section 24.6.5 and Section 25.3).
	*/
	secondary_controls.use_tsc_scaling = false;

	/**
	* If this control is 0, any execution of TPAUSE, UMONITOR, or UMWAIT causes a #UD.
	*/
	secondary_controls.enable_user_wait_and_pause = false;

	/**
	* If this control is 1, executions of ENCLV consult the ENCLV-exiting bitmap to determine whether
	* the instruction causes a VM exit. See Section 24.6.17 and Section 25.1.3.
	*/
	secondary_controls.enable_enclv_exiting = false;
}

/// <summary>
/// Derived from Intel Manuals Voulme 3 Section 24.8.1 Table 24-13. Definitions of VM-Entry Controls
/// </summary>
/// <param name="entry_control"></param>
void set_entry_control(__vmx_entry_control& entry_control) 
{
	/**
	* This control determines whether DR7 and the IA32_DEBUGCTL MSR are loaded on VM entry.
	* The first processors to support the virtual-machine extensions supported only the 1-setting of
	* this control.
	*/
	entry_control.load_dbg_controls = true;

	/**
	* On processors that support Intel 64 architecture, this control determines whether the logical
	* processor is in IA-32e mode after VM entry. Its value is loaded into IA32_EFER.LMA as part of
	* VM entry. 1
	* This control must be 0 on processors that do not support Intel 64 architecture.
	*/
	entry_control.ia32e_mode_guest = true;

	/**
	* This control determines whether the logical processor is in system-management mode (SMM)
	* after VM entry. This control must be 0 for any VM entry from outside SMM.
	*/
	entry_control.entry_to_smm = false;

	/**
	* If set to 1, the default treatment of SMIs and SMM is in effect after the VM entry (see Section
	* 34.15.7). This control must be 0 for any VM entry from outside SMM.
	*/
	entry_control.deactivate_dual_monitor_treament = false;

	/**
	* This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM entry.
	*/
	entry_control.load_ia32_perf_global_control = false;

	/**
	* This control determines whether the IA32_PAT MSR is loaded on VM entry.
	*/
	entry_control.load_ia32_pat = false;

	/**
	* This control determines whether the IA32_EFER MSR is loaded on VM entry.
	*/
	entry_control.load_ia32_efer = false;

	/**
	* This control determines whether the IA32_BNDCFGS MSR is loaded on VM entry.
	*/
	entry_control.load_ia32_bndcfgs = false;

	/**
	* If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP) on
	* a VM entry or a VMCS packet on a VM entry that returns from SMM (see Chapter 35).
	*/
	entry_control.conceal_vmx_from_pt = true;

	/**
	* This control determines whether the IA32_RTIT_CTL MSR is loaded on VM entry.
	*/
	entry_control.load_ia32_rtit_ctl = false;

	/**
	* This control determines whether CET-related MSRs and SPP are loaded on VM entry.
	*/
	entry_control.load_cet_state = false;

	/**
	* This control determines whether CET-related MSRs and SPP are loaded on VM entry.
	*/
	entry_control.load_pkrs = false;
}

/// <summary>
/// Derived from Intel Manuals Voulme 3 Section 24.7.1 Table 24-11. Definitions of VM-Exit Controls
/// </summary>
/// <param name="exit_control"></param>
void set_exit_control(__vmx_exit_control& exit_control) 
{
	/**
	* This control determines whether DR7 and the IA32_DEBUGCTL MSR are saved on VM exit.
	* The first processors to support the virtual-machine extensions supported only the 1-
	* setting of this control.
	*/
	exit_control.save_dbg_controls = true;

	/**
	* On processors that support Intel 64 architecture, this control determines whether a logical
	* processor is in 64-bit mode after the next VM exit. Its value is loaded into CS.L,
	* IA32_EFER.LME, and IA32_EFER.LMA on every VM exit. 1
	* This control must be 0 on processors that do not support Intel 64 architecture.
	*/
	exit_control.host_address_space_size = true;

	/**
	* This control determines whether the IA32_PERF_GLOBAL_CTRL MSR is loaded on VM exit.
	*/
	exit_control.load_ia32_perf_global_control = false;

	/**
	* This control affects VM exits due to external interrupts:
	* • If such a VM exit occurs and this control is 1, the logical processor acknowledges the
	*   interrupt controller, acquiring the interrupt’s vector. The vector is stored in the VM-exit
	*   interruption-information field, which is marked valid.
	* • If such a VM exit occurs and this control is 0, the interrupt is not acknowledged and the
	*   VM-exit interruption-information field is marked invalid.
	*/
	exit_control.ack_interrupt_on_exit = true;

	/**
	* This control determines whether the IA32_PAT MSR is saved on VM exit.
	*/
	exit_control.save_ia32_pat = false;

	/**
	* This control determines whether the IA32_PAT MSR is loaded on VM exit.
	*/
	exit_control.load_ia32_pat = false;

	/**
	* This control determines whether the IA32_EFER MSR is saved on VM exit.
	*/
	exit_control.save_ia32_efer = false;	

	/**
	* This control determines whether the IA32_EFER MSR is loaded on VM exit.
	*/
	exit_control.load_ia32_efer = false;

	/**
	* This control determines whether the value of the VMX-preemption timer is saved on
	* VM exit.
	*/
	exit_control.save_vmx_preemption_timer_value = false;

	/**
	* This control determines whether the IA32_BNDCFGS MSR is cleared on VM exit.
	*/
	exit_control.clear_ia32_bndcfgs = false;

	/**
	* If this control is 1, Intel Processor Trace does not produce a paging information packet (PIP)
	* on a VM exit or a VMCS packet on an SMM VM exit (see Chapter 35).
	*/
	exit_control.conceal_vmx_from_pt = true;

	/**
	* This control determines whether the IA32_RTIT_CTL MSR is cleared on VM exit.
	*/
	exit_control.load_ia32_rtit_ctl = false;

	/**
	* This control determines whether CET-related MSRs and SPP are loaded on VM exit.
	*/
	exit_control.load_cet_state = false;

	/**
	* This control determines whether the IA32_PKRS MSR is loaded on VM exit.
	*/
	exit_control.load_pkrs = false;
}

/// <summary>
/// Derived from Intel Manuals Voulme 3 Section 24.6.1 Table 24-5. Definitions of Pin-Based VM-Execution Controls
/// </summary>
/// <param name="pinbased_controls"></param>
void set_pinbased_control_msr(__vmx_pinbased_control_msr& pinbased_controls) 
{
	/**
	* If this control is 1, external interrupts cause VM exits. Otherwise, they are delivered normally
	* through the guest interrupt-descriptor table (IDT). If this control is 1, the value of RFLAGS.IF
	* does not affect interrupt blocking.
	*/
	pinbased_controls.external_interrupt_exiting = false;

	/**
	* If this control is 1, non-maskable interrupts (NMIs) cause VM exits. Otherwise, they are
	* delivered normally using descriptor 2 of the IDT. This control also determines interactions
	* between IRET and blocking by NMI (see Section 25.3).
	*/
	pinbased_controls.nmi_exiting = false;

	/**
	* If this control is 1, NMIs are never blocked and the “blocking by NMI” bit (bit 3) in the
	* interruptibility-state field indicates “virtual-NMI blocking” (see Table 24-3). This control also
	* interacts with the “NMI-window exiting” VM-execution control (see Section 24.6.2).
	*/
	pinbased_controls.virtual_nmis = false;

	/**
	* If this control is 1, the VMX-preemption timer counts down in VMX non-root operation; see
	* Section 25.5.1. A VM exit occurs when the timer counts down to zero; see Section 25.2.
	*/
	pinbased_controls.vmx_preemption_timer = false;

	/**
	* If this control is 1, the processor treats interrupts with the posted-interrupt notification vector
	* (see Section 24.6.8) specially, updating the virtual-APIC page with posted-interrupt requests
	* (see Section 29.6).
	*/
	pinbased_controls.process_posted_interrupts = false;
}

/// <summary>
/// Set which exception cause vmexit
/// </summary>
/// <param name="exception_bitmap"></param>
void set_exception_bitmap(__exception_bitmap& exception_bitmap)
{
	exception_bitmap.divide_error = false;

	exception_bitmap.debug = false;

	exception_bitmap.nmi_interrupt = false;

	exception_bitmap.breakpoint = false;

	exception_bitmap.overflow = false;

	exception_bitmap.bound = false;

	exception_bitmap.invalid_opcode = false;

	exception_bitmap.coprocessor_segment_overrun = false;

	exception_bitmap.invalid_tss = false;

	exception_bitmap.segment_not_present = false;

	exception_bitmap.stack_segment_fault = false;

	exception_bitmap.general_protection = false;

	exception_bitmap.page_fault = false;

	exception_bitmap.x87_floating_point_error = false;

	exception_bitmap.alignment_check = false;

	exception_bitmap.machine_check = false;

	exception_bitmap.simd_floating_point_error = false;

	exception_bitmap.virtualization_exception = false;
}


/// <summary>
/// Get segment base
/// </summary>
/// <param name="selector"></param>
/// <param name="gdt_base"></param>
/// <returns></returns>
unsigned __int64 get_segment_base(unsigned __int16 selector, unsigned __int8* gdt_base)
{
	__segment_descriptor* segment_descriptor;

	segment_descriptor = (__segment_descriptor*)(gdt_base + (selector & ~0x7));

	unsigned __int64 segment_base = segment_descriptor->base_low | segment_descriptor->base_middle << 16 | segment_descriptor->base_high << 24;

	if (segment_descriptor->descriptor_type == false)
		segment_base = (segment_base & MASK_32BITS) | (unsigned __int64)segment_descriptor->base_upper << 32;

	return segment_base;
}

/// <summary>
/// Fill the guest's selector data
/// </summary>
/// <param name="gdt_base"></param>
/// <param name="segment_register"></param>
/// <param name="selector"></param>
void fill_guest_selector_data(void* gdt_base, unsigned __int32 segment_register, unsigned __int16 selector)
{
	__segment_access_rights segment_access_rights;
	__segment_descriptor* segment_descriptor;

	if (selector & 0x4)
		return;

	segment_descriptor = (__segment_descriptor*)((unsigned __int8*)gdt_base + (selector & ~0x7));

	unsigned __int64 segment_base = segment_descriptor->base_low | segment_descriptor->base_middle << 16 | segment_descriptor->base_high << 24;

	unsigned __int32 segment_limit = segment_descriptor->limit_low | (segment_descriptor->segment_limit_high << 16);

	//
	// Load ar get access rights of descriptor specified by selector
	// Lower 8 bits are zeroed so we have to bit shift it to right by 8
	//
	segment_access_rights.all = __load_ar(selector) >> 8;
	segment_access_rights.unusable = 0;
	segment_access_rights.reserved0 = 0;
	segment_access_rights.reserved1 = 0;

	// This is a TSS or callgate etc, save the base high part
	if (segment_descriptor->descriptor_type == false)
		segment_base = (segment_base & MASK_32BITS) | (unsigned __int64)segment_descriptor->base_upper << 32;

	if (segment_descriptor->granularity == true)
		segment_limit = (segment_limit << 12) + 0xfff;

	if (selector == 0)
		segment_access_rights.all |= 0x10000;

	hv::vmwrite<unsigned __int64>(GUEST_ES_SELECTOR + segment_register * 2, selector);
	hv::vmwrite<unsigned __int64>(GUEST_ES_LIMIT + segment_register * 2, segment_limit);
	hv::vmwrite<unsigned __int64>(GUEST_ES_BASE + segment_register * 2, segment_base);
	hv::vmwrite<unsigned __int64>(GUEST_ES_ACCESS_RIGHTS + segment_register * 2, segment_access_rights.all);
}

unsigned __int32 ajdust_controls(unsigned __int32 ctl, unsigned __int32 msr)
{
	__msr msr_value = { 0 };
	msr_value.all = __readmsr(msr);
	ctl &= msr_value.high;
	ctl |= msr_value.low;
	return ctl;
}

/// <summary>
/// Set the vmcs structure
/// </summary>
/// <param name="vcpu"></param>
/// <param name="guest_rsp"></param>
void fill_vmcs(__vcpu* vcpu, void* guest_rsp)
{
	__pseudo_descriptor64 gdtr = { 0 };
	__pseudo_descriptor64 idtr = { 0 };
	__exception_bitmap exception_bitmap = { 0 };
	__vmx_basic_msr vmx_basic = { 0 };
	__vmx_entry_control entry_controls = { 0 };
	__vmx_exit_control exit_controls = { 0 };
	__vmx_pinbased_control_msr pinbased_controls = { 0 };
	__vmx_primary_processor_based_control primary_controls = { 0 };
	__vmx_secondary_processor_based_control secondary_controls = { 0 };

	const unsigned __int8 selector_mask = 7;

	vmx_basic.all = __readmsr(IA32_VMX_BASIC);

	set_entry_control(entry_controls);

	set_exit_control(exit_controls);

	set_primary_controls(primary_controls);

	set_secondary_controls(secondary_controls);

	set_exception_bitmap(exception_bitmap);

	set_pinbased_control_msr(pinbased_controls);

	//
	// We want to vmexit on every io and msr access
	memset(vcpu->vcpu_bitmaps.io_bitmap_a, 0xff, PAGE_SIZE);
	memset(vcpu->vcpu_bitmaps.io_bitmap_b, 0xff, PAGE_SIZE);

#ifndef _MINIMAL
	memset(vcpu->vcpu_bitmaps.msr_bitmap, 0xff, PAGE_SIZE);
#endif

	//
	// Msr bitmap controls which operation on which msr
	// in range of 0x00000000 to 0x00001FFF or 
	// in range of 0xC0000000 to 0xC0001FFF cause a vmexit

	//
	// Set single msr
	//hv::set_msr_bitmap(0xC0000000, vcpu, true, true, true);

	//
	// Only if your upper hypervisor is vmware
	// Because Vmware tools use ports 0x5655,0x5656,0x5657,0x5658,0x5659,0x565a,0x565b,0x1090,0x1094 as I/O backdoor
	hv::set_io_bitmap(0x5655, vcpu, false);
	hv::set_io_bitmap(0x5656, vcpu, false);
	hv::set_io_bitmap(0x5657, vcpu, false);
	hv::set_io_bitmap(0x5658, vcpu, false);
	hv::set_io_bitmap(0x5659, vcpu, false);
	hv::set_io_bitmap(0x565a, vcpu, false);
	hv::set_io_bitmap(0x565b, vcpu, false);
	hv::set_io_bitmap(0x1094, vcpu, false);
	hv::set_io_bitmap(0x1090, vcpu, false);

	__vmx_vmclear((unsigned __int64*)&vcpu->vmcs_physical);
	__vmx_vmptrld((unsigned __int64*)&vcpu->vmcs_physical);

	__sgdt(&gdtr);
	__sidt(&idtr);

	// Global descriptor table and local one
	hv::vmwrite<unsigned __int64>(GUEST_GDTR_LIMIT, gdtr.limit);
	hv::vmwrite<unsigned __int64>(GUEST_IDTR_LIMIT, idtr.limit);
	hv::vmwrite<unsigned __int64>(GUEST_GDTR_BASE, gdtr.base_address);
	hv::vmwrite<unsigned __int64>(GUEST_IDTR_BASE, idtr.base_address);
	hv::vmwrite<unsigned __int64>(HOST_GDTR_BASE, gdtr.base_address);
	hv::vmwrite<unsigned __int64>(HOST_IDTR_BASE, idtr.base_address);

	// Hypervisor features
	hv::vmwrite<unsigned __int64>(CONTROL_PIN_BASED_VM_EXECUTION_CONTROLS, ajdust_controls(pinbased_controls.all, vmx_basic.true_controls ? IA32_VMX_TRUE_PINBASED_CTLS : IA32_VMX_PINBASED_CTLS));
	hv::vmwrite<unsigned __int64>(CONTROL_PRIMARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS, ajdust_controls(primary_controls.all, vmx_basic.true_controls ? IA32_VMX_TRUE_PROCBASED_CTLS : IA32_VMX_PROCBASED_CTLS));
	hv::vmwrite<unsigned __int64>(CONTROL_SECONDARY_PROCESSOR_BASED_VM_EXECUTION_CONTROLS, ajdust_controls(secondary_controls.all, IA32_VMX_PROCBASED_CTLS2));
	hv::vmwrite<unsigned __int64>(CONTROL_VM_EXIT_CONTROLS, ajdust_controls(exit_controls.all, vmx_basic.true_controls ? IA32_VMX_TRUE_EXIT_CTLS : IA32_VMX_EXIT_CTLS));
	hv::vmwrite<unsigned __int64>(CONTROL_VM_ENTRY_CONTROLS, ajdust_controls(entry_controls.all, vmx_basic.true_controls ? IA32_VMX_TRUE_ENTRY_CTLS : IA32_VMX_ENTRY_CTLS));

	// Segments
	fill_guest_selector_data((void*)gdtr.base_address, ES, __read_es());
	fill_guest_selector_data((void*)gdtr.base_address, CS, __read_cs());
	fill_guest_selector_data((void*)gdtr.base_address, SS, __read_ss());
	fill_guest_selector_data((void*)gdtr.base_address, DS, __read_ds());
	fill_guest_selector_data((void*)gdtr.base_address, FS, __read_fs());
	fill_guest_selector_data((void*)gdtr.base_address, GS, __read_gs());
	fill_guest_selector_data((void*)gdtr.base_address, LDTR, __read_ldtr());
	fill_guest_selector_data((void*)gdtr.base_address, TR, __read_tr());
	hv::vmwrite<unsigned __int64>(GUEST_FS_BASE, __readmsr(IA32_FS_BASE));
	hv::vmwrite<unsigned __int64>(GUEST_GS_BASE, __readmsr(IA32_GS_BASE));
	hv::vmwrite<unsigned __int64>(HOST_CS_SELECTOR, __read_cs() & ~selector_mask);
	hv::vmwrite<unsigned __int64>(HOST_SS_SELECTOR, __read_ss() & ~selector_mask);
	hv::vmwrite<unsigned __int64>(HOST_DS_SELECTOR, __read_ds() & ~selector_mask);
	hv::vmwrite<unsigned __int64>(HOST_ES_SELECTOR, __read_es() & ~selector_mask);
	hv::vmwrite<unsigned __int64>(HOST_FS_SELECTOR, __read_fs() & ~selector_mask);
	hv::vmwrite<unsigned __int64>(HOST_GS_SELECTOR, __read_gs() & ~selector_mask);
	hv::vmwrite<unsigned __int64>(HOST_TR_SELECTOR, __read_tr() & ~selector_mask);
	hv::vmwrite<unsigned __int64>(HOST_FS_BASE, __readmsr(IA32_FS_BASE));
	hv::vmwrite<unsigned __int64>(HOST_GS_BASE, __readmsr(IA32_GS_BASE));
	hv::vmwrite<unsigned __int64>(HOST_TR_BASE, get_segment_base(__read_tr(),(unsigned char*)gdtr.base_address));

	// Cr registers
	hv::vmwrite<unsigned __int64>(GUEST_CR0, __readcr0());
	hv::vmwrite<unsigned __int64>(HOST_CR0, __readcr0());
	hv::vmwrite<unsigned __int64>(CONTROL_CR0_READ_SHADOW, __readcr0());	

	hv::vmwrite<unsigned __int64>(GUEST_CR3, __readcr3());
	hv::vmwrite<unsigned __int64>(HOST_CR3, hv::get_system_directory_table_base());
	hv::vmwrite<unsigned __int64>(CONTROL_CR3_TARGET_COUNT, 0);

	hv::vmwrite<unsigned __int64>(GUEST_CR4, __readcr4());
	hv::vmwrite<unsigned __int64>(HOST_CR4, __readcr4());
	hv::vmwrite<unsigned __int64>(CONTROL_CR4_READ_SHADOW, __readcr4() & ~0x2000);
	hv::vmwrite<unsigned __int64>(CONTROL_CR4_GUEST_HOST_MASK, 0x2000); // Virtual Machine Extensions Enable	

	// Debug register
	hv::vmwrite<unsigned __int64>(GUEST_DR7, __readdr(7));

	// RFLAGS
	hv::vmwrite<unsigned __int64>(GUEST_RFLAGS, __readeflags());

	// RSP and RIP
	hv::vmwrite<void*>(GUEST_RSP, guest_rsp);
	hv::vmwrite<void*>(GUEST_RIP, vmx_restore_state);
	hv::vmwrite<unsigned __int64>(HOST_RSP, (unsigned __int64)vcpu->vmm_stack + VMM_STACK_SIZE);
	hv::vmwrite<void*>(HOST_RIP, vmm_entrypoint);

	// MSRS Guest
	hv::vmwrite<unsigned __int64>(GUEST_DEBUG_CONTROL, __readmsr(IA32_DEBUGCTL));
	hv::vmwrite<unsigned __int64>(GUEST_SYSENTER_CS, __readmsr(IA32_SYSENTER_CS));
	hv::vmwrite<unsigned __int64>(GUEST_SYSENTER_ESP, __readmsr(IA32_SYSENTER_ESP));
	hv::vmwrite<unsigned __int64>(GUEST_SYSENTER_EIP, __readmsr(IA32_SYSENTER_EIP));
	hv::vmwrite<unsigned __int64>(GUEST_EFER, __readmsr(IA32_EFER));

	// MSRS Host
	hv::vmwrite<unsigned __int64>(HOST_SYSENTER_CS, __readmsr(IA32_SYSENTER_CS));
	hv::vmwrite<unsigned __int64>(HOST_SYSENTER_ESP, __readmsr(IA32_SYSENTER_ESP));
	hv::vmwrite<unsigned __int64>(HOST_SYSENTER_EIP, __readmsr(IA32_SYSENTER_EIP));
	hv::vmwrite<unsigned __int64>(HOST_EFER, __readmsr(IA32_EFER));

	// Features
	hv::vmwrite<unsigned __int64>(GUEST_VMCS_LINK_POINTER, ~0ULL);

	hv::vmwrite<unsigned __int64>(CONTROL_EXCEPTION_BITMAP, exception_bitmap.all);

	if (primary_controls.use_msr_bitmaps == true)
		hv::vmwrite<unsigned __int64>(CONTROL_MSR_BITMAPS_ADDRESS, vcpu->vcpu_bitmaps.msr_bitmap_physical);

	if (primary_controls.use_io_bitmaps == true)
	{
		hv::vmwrite<unsigned __int64>(CONTROL_BITMAP_IO_A_ADDRESS, vcpu->vcpu_bitmaps.io_bitmap_a_physical);
		hv::vmwrite<unsigned __int64>(CONTROL_BITMAP_IO_B_ADDRESS, vcpu->vcpu_bitmaps.io_bitmap_b_physical);
	}

	if(secondary_controls.enable_vpid == true)
		hv::vmwrite<unsigned __int64>(CONTROL_VIRTUAL_PROCESSOR_IDENTIFIER, 1);

	if(secondary_controls.enable_ept == true && secondary_controls.enable_vpid == true)
		hv::vmwrite<unsigned __int64>(CONTROL_EPT_POINTER, g_vmm_context->ept_state->ept_pointer->all);
}
```

`airhv/airhv-main/airhv/vmexit_handler.cpp`:

```cpp
#pragma warning( disable : 4201 4244 4065)

#include <ntddk.h>
#include <intrin.h>
#include "hypervisor_routines.h"
#include "common.h"
#include "vmexit_handler.h"
#include "ia32\cpuid.h"
#include "ia32\vmcs_encodings.h"
#include "ia32\msr.h"
#include "log.h"
#include "vmcall_handler.h"
#include "interrupt.h"
#include "asm\vm_intrin.h"
#include "ia32\cr.h"
#include "ia32\rflags.h"
#include "ia32\dr.h"
#include "invalidators.h"
#include "xsave.h"
#include "ia32\segment.h"
#include "ia32\vmcs.h"

void vmexit_ept_violation_handler(__vcpu* vcpu);
void vmexit_unimplemented(__vcpu* vcpu);
void vmexit_exception_handler(__vcpu* vcpu);
void vmexit_ept_violation_handler(__vcpu* vcpu);
void vmexit_cr_handler(__vcpu* vcpu);
void vmexit_vm_instruction(__vcpu* vcpu);
void vmexit_triple_fault_handler(__vcpu* vcpu);
void vmexit_failed(__vcpu* vcpu);
void vmexit_invd_handler(__vcpu* vcpu);
void vmexit_rdtscp_handler(__vcpu* vcpu);
void vmexit_xsetbv_handler(__vcpu* vcpu);
void vmexit_rdtsc_handler(__vcpu* vcpu);
void vmexit_rdrand_handler(__vcpu* vcpu);
void vmexit_rdseed_handler(__vcpu* vcpu);
void vmexit_io_handler(__vcpu* vcpu);
void vmexit_mov_dr_handler(__vcpu* vcpu);
void vmexit_cpuid_handler(__vcpu* vcpu);
void vmexit_msr_read_handler(__vcpu* vcpu);
void vmexit_msr_write_handler(__vcpu* vcpu);
void vmexit_invpcid_handler(__vcpu* vcpu);
void vmexit_invlpg_handler(__vcpu* vcpu);
void vmexit_ldtr_access_handler(__vcpu* vcpu);
void vmexit_gdtr_access_handler(__vcpu* vcpu);

void (*exit_handlers[EXIT_REASON_LAST])(__vcpu* guest_registers) =
{
	vmexit_exception_handler,						// 00 EXIT_REASON_EXCEPTION_NMI
	vmexit_unimplemented,							// 01 EXIT_REASON_EXTERNAL_INTERRUPT
	vmexit_triple_fault_handler,					// 02 EXIT_REASON_TRIPLE_FAULT
	vmexit_unimplemented,							// 03 EXIT_REASON_INIT_SIGNAL
	vmexit_unimplemented,							// 04 EXIT_REASON_SIPI
	vmexit_unimplemented,							// 05 EXIT_REASON_IO_SMI
	vmexit_unimplemented,							// 06 EXIT_REASON_OTHER_SMI
	vmexit_unimplemented,							// 07 EXIT_REASON_PENDING_INTERRUPT
	vmexit_unimplemented,							// 08 EXIT_REASON_NMI_WINDOW
	vmexit_unimplemented,							// 09 EXIT_REASON_TASK_SWITCH
	vmexit_cpuid_handler,							// 10 EXIT_REASON_CPUID
	vmexit_unimplemented,							// 11 EXIT_REASON_GETSEC
	vmexit_unimplemented,							// 12 EXIT_REASON_HLT
	vmexit_invd_handler,							// 13 EXIT_REASON_INVD
	vmexit_invlpg_handler,							// 14 EXIT_REASON_INVLPG
	vmexit_unimplemented,							// 15 EXIT_REASON_RDPMC
	vmexit_rdtsc_handler,							// 16 EXIT_REASON_RDTSC
	vmexit_unimplemented,							// 17 EXIT_REASON_RSM
	vmexit_vmcall_handler,							// 18 EXIT_REASON_VMCALL
	vmexit_vm_instruction,							// 19 EXIT_REASON_VMCLEAR
	vmexit_vm_instruction,							// 20 EXIT_REASON_VMLAUNCH
	vmexit_vm_instruction,							// 21 EXIT_REASON_VMPTRLD
	vmexit_vm_instruction,							// 22 EXIT_REASON_VMPTRST
	vmexit_vm_instruction,							// 23 EXIT_REASON_VMREAD
	vmexit_vm_instruction,							// 24 EXIT_REASON_VMRESUME
	vmexit_vm_instruction,							// 25 EXIT_REASON_VMWRITE
	vmexit_vm_instruction,							// 26 EXIT_REASON_VMXOFF
	vmexit_vm_instruction,							// 27 EXIT_REASON_VMXON
	vmexit_cr_handler,								// 28 EXIT_REASON_CR_ACCESSES
	vmexit_mov_dr_handler,							// 29 EXIT_REASON_MOV_DR
	vmexit_io_handler,								// 30 EXIT_REASON_IO_INSTRUCTION
	vmexit_msr_read_handler,						// 31 EXIT_REASON_MSR_READ
	vmexit_msr_write_handler,						// 32 EXIT_REASON_MSR_WRITE
	vmexit_failed,									// 33 EXIT_REASON_INVALID_GUEST_STATE
	vmexit_failed,									// 34 EXIT_REASON_MSR_LOADING
	vmexit_unimplemented,							// 35 EXIT_REASON_RESERVED1
	vmexit_unimplemented,							// 36 EXIT_REASON_MWAIT
	vmexit_unimplemented,						    // 37 EXIT_REASON_MONITOR_TRAP_FLAG
	vmexit_unimplemented,							// 38 EXIT_REASON_RESERVED2
	vmexit_unimplemented,							// 39 EXIT_REASON_MONITOR
	vmexit_unimplemented,							// 40 EXIT_REASON_PAUSE
	vmexit_failed,									// 41 EXIT_REASON_VM_ENTRY_FAILURE_MACHINE_CHECK_EVENT
	vmexit_unimplemented,							// 42 EXIT_REASON_RESERVED3
	vmexit_unimplemented,							// 43 EXIT_REASON_TPR_BELOW_THRESHOLD
	vmexit_unimplemented,							// 44 EXIT_REASON_APIC_ACCESS 
	vmexit_unimplemented,							// 45 EXIT_REASON_VIRTUALIZED_EIO
	vmexit_gdtr_access_handler,						// 46 EXIT_REASON_ACCESS_TO_GDTR_OR_IDTR
	vmexit_ldtr_access_handler,						// 47 EXIT_REASON_ACCESS_TO_LDTR_OR_TR
	vmexit_ept_violation_handler,					// 48 EXIT_REASON_EPT_VIOLATION
	vmexit_failed,									// 49 EXIT_REASON_EPT_MISCONFIGURATION
	vmexit_vm_instruction,							// 50 EXIT_REASON_INVEPT
	vmexit_rdtscp_handler,							// 51 EXIT_REASON_RDTSCP
	vmexit_unimplemented,							// 52 EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED
	vmexit_vm_instruction,							// 53 EXIT_REASON_INVVPID
	vmexit_invd_handler,							// 54 EXIT_REASON_WBINVD
	vmexit_xsetbv_handler,							// 55 EXIT_REASON_XSETBV
	vmexit_unimplemented,							// 56 EXIT_REASON_APIC_WRITE
	vmexit_rdrand_handler,							// 57 EXIT_REASON_RDRAND
	vmexit_invpcid_handler,							// 58 EXIT_REASON_INVPCID
	vmexit_vm_instruction,							// 59 EXIT_REASON_VMFUNC
	vmexit_unimplemented,							// 60 EXIT_REASON_ENCLS
	vmexit_rdseed_handler,							// 61 EXIT_REASON_RDSEED
	vmexit_unimplemented,							// 62 EXIT_REASON_PAGE_MODIFICATION_LOG_FULL
	vmexit_unimplemented,							// 63 EXIT_REASON_XSAVES
	vmexit_unimplemented,							// 64 EXIT_REASON_XRSTORS
	vmexit_unimplemented,							// 65 EXIT_REASON_RESERVED4
	vmexit_unimplemented,							// 66 EXIT_REASON_SPP_RELATED_EVENT
	vmexit_unimplemented,							// 67 EXIT_REASON_UMWAIT
	vmexit_unimplemented							// 68 EXIT_REASON_TPAUSE
};

/// <summary>
/// sgdt,sidt,lgdt,lidt handler
/// </summary>
/// <param name="guest_regs"></param>
void vmexit_gdtr_access_handler(__vcpu* vcpu)
{
	__vmexit_instruction_information3 instruction_information = { vcpu->vmexit_info.instruction_information };

	union __tmp_desc
	{
		__pseudo_descriptor64 desc64;
		__pseudo_descriptor32 desc32;
	};

	__tmp_desc* tmp_desc = (__tmp_desc*)hv::get_guest_address(vcpu);

	unsigned __int64 old_cr3 = hv::swap_context();

	switch (instruction_information.instruction_identity)
	{
		// SGDT
		case 0:
		{
			__segment_selector selector;
			selector.all = hv::vmread(GUEST_CS_SELECTOR);

			__segment_descriptor* segment_desc = (__segment_descriptor*)(hv::vmread(GUEST_GDTR_BASE) + selector.index * 8);

			if (segment_desc->long_mode == 1)
			{
				tmp_desc->desc64.base_address = hv::vmread(GUEST_GDTR_BASE);
				tmp_desc->desc64.limit = hv::vmread(GUEST_GDTR_LIMIT);
			}

			else 
			{
				tmp_desc->desc32.base_address = hv::vmread(GUEST_GDTR_BASE);
				tmp_desc->desc32.limit = hv::vmread(GUEST_GDTR_LIMIT);
			}

			break;
		}

		// SIDT
		case 1:
		{
			__segment_selector selector;
			selector.all = hv::vmread(GUEST_CS_SELECTOR);

			__segment_descriptor* segment_desc = (__segment_descriptor*)(hv::vmread(GUEST_GDTR_BASE) + selector.index * 8);

			if (segment_desc->long_mode == 1)
			{
				tmp_desc->desc64.base_address = hv::vmread(GUEST_IDTR_BASE);
				tmp_desc->desc64.limit = hv::vmread(GUEST_IDTR_LIMIT);
			}

			else
			{
				tmp_desc->desc32.base_address = hv::vmread(GUEST_IDTR_BASE);
				tmp_desc->desc32.limit = hv::vmread(GUEST_IDTR_LIMIT);
			}

			break;
		}

		// LGDT
		case 2:
		{
			hv::vmwrite(GUEST_GDTR_BASE, tmp_desc->desc64.base_address);
			hv::vmwrite(GUEST_GDTR_LIMIT, tmp_desc->desc64.limit);

			break;
		}

		// LIDT
		case 3:
		{
			hv::vmwrite(GUEST_IDTR_BASE, tmp_desc->desc64.base_address);
			hv::vmwrite(GUEST_IDTR_LIMIT, tmp_desc->desc64.limit);

			break;
		}
	}

	hv::restore_context(old_cr3);

	adjust_rip(vcpu);
}

/// <summary>
/// sldt,str,lldt,ltr handler
/// </summary>
/// <param name="guest_regs"></param>
void vmexit_ldtr_access_handler(__vcpu* vcpu)
{
	__vmexit_instruction_information4 instruction_information = { vcpu->vmexit_info.instruction_information };
	unsigned __int64* linear_address = 
		instruction_information.mem_reg ? 
		&vcpu->vmexit_info.guest_registers->rax - instruction_information.reg1 : 
		(unsigned __int64*)hv::get_guest_address(vcpu);

	unsigned __int64 old_cr3 = hv::swap_context();

	switch (instruction_information.instruction_identity)
	{
		// SLDT
		case 0:
		{
			*linear_address = hv::vmread(GUEST_LDTR_SELECTOR);

			break;
		}

		// STR
		case 1:
		{
			*linear_address = hv::vmread(GUEST_TR_SELECTOR);

			break;
		}

		// LLDT
		case 2:
		{
			hv::vmwrite(GUEST_LDTR_SELECTOR, *linear_address);

			break;
		}

		// LTR
		case 3:
		{
			hv::vmwrite(GUEST_TR_SELECTOR, *linear_address);

			__segment_selector selector;
			selector.all = *linear_address;
			__segment_descriptor* segment_desc = (__segment_descriptor*)(hv::vmread(GUEST_GDTR_BASE) + selector.index * 8);
			segment_desc->type |= 2;

			break;
		}
	}

	hv::restore_context(old_cr3);

	adjust_rip(vcpu);
}

/// <summary>
/// Msr read handler
/// </summary>
/// <param name="guest_regs"></param>
void vmexit_msr_read_handler(__vcpu* vcpu)
{
	__msr msr;
	unsigned __int64 msr_index = vcpu->vmexit_info.guest_registers->rcx;

	switch (msr_index)
	{
		case IA32_INTERRUPT_SSP_TABLE_ADDR:
			msr.all = hv::vmread(GUEST_INTERRUPT_SSP_TABLE_ADDR);
			break;

		case IA32_SYSENTER_CS:
			msr.all = hv::vmread(GUEST_SYSENTER_CS);
			break;

		case IA32_SYSENTER_EIP:
			msr.all = hv::vmread(GUEST_SYSENTER_EIP);
			break;

		case IA32_SYSENTER_ESP:
			msr.all = hv::vmread(GUEST_SYSENTER_ESP);
			break;

		case IA32_S_CET:
			msr.all = hv::vmread(GUEST_S_CET);
			break;

		case IA32_PERF_GLOBAL_CTRL:
			msr.all = hv::vmread(GUEST_PERF_GLOBAL_CONTROL);
			break;

		case IA32_PKRS:
			msr.all = hv::vmread(GUEST_PKRS);
			break;

		case IA32_RTIT_CTL:
			msr.all = hv::vmread(GUEST_RTIT_CTL);
			break;

		case IA32_BNDCFGS:
			msr.all = hv::vmread(GUEST_BNDCFGS);
			break;

		case IA32_PAT:
			msr.all = hv::vmread(GUEST_PAT);
			break;

		case IA32_EFER:
			msr.all = hv::vmread(GUEST_EFER);
			break;

		case IA32_GS_BASE:
			msr.all = hv::vmread(GUEST_GS_BASE);
			break;

		case IA32_FS_BASE:
			msr.all = hv::vmread(GUEST_FS_BASE);
			break;

		default:
			msr.all = __readmsr(msr_index);
			break;
	}

	vcpu->vmexit_info.guest_registers->rdx = msr.high;
	vcpu->vmexit_info.guest_registers->rax = msr.low;

	adjust_rip(vcpu);
}

/// <summary>
/// Msr write handler
/// </summary>
/// <param name="guest_regs"></param>
void vmexit_msr_write_handler(__vcpu* vcpu)
{
	unsigned __int64 msr_index = vcpu->vmexit_info.guest_registers->rcx;

	__msr msr;
	msr.high = vcpu->vmexit_info.guest_registers->rdx;
	msr.low = vcpu->vmexit_info.guest_registers->rax;

	switch (msr_index)
	{
		case IA32_INTERRUPT_SSP_TABLE_ADDR:
			hv::vmwrite(GUEST_INTERRUPT_SSP_TABLE_ADDR, msr.all);
			break;

		case IA32_SYSENTER_CS:
			hv::vmwrite(GUEST_SYSENTER_CS, msr.all);
			break;

		case IA32_SYSENTER_EIP:
			hv::vmwrite(GUEST_SYSENTER_EIP, msr.all);
			break;

		case IA32_SYSENTER_ESP:
			hv::vmwrite(GUEST_SYSENTER_ESP, msr.all);
			break;

		case IA32_S_CET:
			hv::vmwrite(GUEST_S_CET, msr.all);
			break;

		case IA32_PERF_GLOBAL_CTRL:
			hv::vmwrite(GUEST_PERF_GLOBAL_CONTROL, msr.all);
			break;

		case IA32_PKRS:
			hv::vmwrite(GUEST_PKRS, msr.all);
			break;

		case IA32_RTIT_CTL:
			hv::vmwrite(GUEST_RTIT_CTL, msr.all);
			break;

		case IA32_BNDCFGS:
			hv::vmwrite(GUEST_BNDCFGS, msr.all);
			break;

		case IA32_PAT:
			hv::vmwrite(GUEST_PAT, msr.all);
			break;

		case IA32_EFER:
			hv::vmwrite(GUEST_EFER, msr.all);
			break;

		case IA32_GS_BASE:
			hv::vmwrite(GUEST_GS_BASE, msr.all);
			break;

		case IA32_FS_BASE:
			hv::vmwrite(GUEST_FS_BASE, msr.all);
			break;

		default:
			__writemsr(msr_index, msr.all);
			break;
	}

	adjust_rip(vcpu);
}

/// <summary>
/// Ept violation handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_ept_violation_handler(__vcpu* vcpu)
{
	__ept_violation ept_violation;

	ept_violation.all = vcpu->vmexit_info.qualification;
	unsigned __int64 guest_physical_adddress = hv::vmread(GUEST_PHYSICAL_ADDRESS);

	PLIST_ENTRY current = &g_vmm_context->ept_state->hooked_page_list;
	while (&g_vmm_context->ept_state->hooked_page_list != current->Flink)
	{
		current = current->Flink;
		__ept_hooked_page_info* hooked_entry = CONTAINING_RECORD(current, __ept_hooked_page_info, hooked_page_list);
		if (hooked_entry->pfn_of_hooked_page == GET_PFN(guest_physical_adddress))
		{
			if ((ept_violation.read_access || ept_violation.write_access) && (!ept_violation.ept_readable || !ept_violation.ept_writeable)) 
				ept::swap_pml1(hooked_entry->entry_address, hooked_entry->original_entry);

			else if (ept_violation.execute_access && (ept_violation.ept_readable || ept_violation.ept_writeable))
				ept::swap_pml1(hooked_entry->entry_address, hooked_entry->changed_entry);

			break;
		}
	}
}

/// <summary>
/// Exception handler
/// </summary>
/// <param name="guest_reg"></param>
void vmexit_exception_handler(__vcpu* vcpu)
{
	__vmexit_interrupt_info interrupt_info;
	interrupt_info.all = hv::vmread(VM_EXIT_INTERRUPTION_INFORMATION);
	
	unsigned __int32 error_code = hv::vmread(VM_EXIT_INTERRUPTION_ERROR_CODE);

	// Exit Qualification contain the linear address which caused page fault
	if (interrupt_info.vector == EXCEPTION_VECTOR_PAGE_FAULT)
		__writecr2(vcpu->vmexit_info.qualification);

	hv::inject_interruption(interrupt_info.vector, interrupt_info.interruption_type, error_code, interrupt_info.error_code_valid);
}

/// <summary>
/// Cpuid handler
/// </summary>
/// <param name="guest_regs"></param>
void vmexit_cpuid_handler(__vcpu* vcpu)
{
	__cpuid_info cpuid_reg = { 0 };

	if (g_vmm_context->hv_presence == false &&
		vcpu->vmexit_info.guest_registers->rax >= 0x40000000 &&
		vcpu->vmexit_info.guest_registers->rax <= 0x4FFFFFFF)
		__cpuidex((int*)&cpuid_reg.eax, g_vmm_context->highest_basic_leaf, 0);

	else 
		__cpuidex((int*)&cpuid_reg.eax, vcpu->vmexit_info.guest_registers->rax, vcpu->vmexit_info.guest_registers->rcx);


	switch (vcpu->vmexit_info.guest_registers->rax)
	{
		case CPUID_PROCESSOR_FEATURES:
			cpuid_reg.cpuid_eax_01.feature_information_ecx.hypervisor_present = g_vmm_context->hv_presence; // Hypervisor present bit
			break;
		
		case CPUID_HV_VENDOR_AND_MAX_FUNCTIONS:
			if (g_vmm_context->hv_presence == true)
			{
				cpuid_reg.eax = CPUID_HV_INTERFACE;
				cpuid_reg.ebx = 'hria';  // airhv
				cpuid_reg.ecx = 'v\x00\x00\x00';
				cpuid_reg.edx = 0;
			}
			break;

		case CPUID_HV_INTERFACE:
			if (g_vmm_context->hv_presence == true)
			{
				//
				// This indicates that our hypervisor doesn't conform to microsoft hyperv interaface
				//
				cpuid_reg.eax = '0#vH';
				cpuid_reg.ebx = cpuid_reg.ecx = cpuid_reg.edx = 0;
			}
			break;

		case CPUID_EXTENDED_FEATURES:
			if (vcpu->vmexit_info.guest_registers->rcx == 0)
				CLR_CPUID_BIT(cpuid_reg.ecx, 5); // TPAUSE UMONITOR and UWAIT are not supported
			break;
	}

	vcpu->vmexit_info.guest_registers->rax = cpuid_reg.eax;
	vcpu->vmexit_info.guest_registers->rbx = cpuid_reg.ebx;
	vcpu->vmexit_info.guest_registers->rcx = cpuid_reg.ecx;
	vcpu->vmexit_info.guest_registers->rdx = cpuid_reg.edx;

	adjust_rip(vcpu);
}

/// <summary>
/// Invpcid handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_invpcid_handler(__vcpu* vcpu) 
{
	__vmexit_instruction_information2 instruction_information = { vcpu->vmexit_info.instruction_information };

	unsigned __int64* type = &vcpu->vmexit_info.guest_registers->rax - instruction_information.reg2;

	if (*type > INVPCID_ALL_CONTEXTS_EXCEPT_GLOBAL_TRANSLATIONS)
	{
		hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
		return;
	}

	unsigned __int64 guest_address = hv::get_guest_address(vcpu);

	unsigned __int64 old_cr3 = hv::swap_context();

	if (MmGetPhysicalAddress((void*)guest_address).QuadPart == 0) 
	{
		__writecr2(guest_address);
		hv::inject_interruption(EXCEPTION_VECTOR_PAGE_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
		hv::restore_context(old_cr3);
		return;
	}

	__invpcid_descriptor descriptor;
	memcpy(&descriptor, (void*)guest_address, sizeof(descriptor));

	hv::restore_context(old_cr3);

	if(descriptor.reserved != 0)
	{
		hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
		return;
	}

	__cr4 cr4 = { __readcr4() };

	if ((*type == INVPCID_INVIDUAL_ADDRESS || *type == INVPCID_SINGLE_CONTEXT) && descriptor.pcid != 0 && cr4.pcid_enable == false)
	{
		hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
		return;
	}

	if (*type == INVPCID_INVIDUAL_ADDRESS && !hv::is_address_canonical(descriptor.linear_address))
	{
		hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
		return;
	}

	if (*type == INVPCID_INVIDUAL_ADDRESS)
		invvpid_invidual_address(descriptor.linear_address, 1);

	else if (*type == INVPCID_SINGLE_CONTEXT)
		invvpid_single_context(1);

	else if (*type == INVPCID_ALL_CONTEXTS)
		invvpid_single_context(1);

	else if (*type == INVPCID_ALL_CONTEXTS_EXCEPT_GLOBAL_TRANSLATIONS)
		invvpid_single_context_except_global_translations(1);

	adjust_rip(vcpu);
}

void vmexit_invlpg_handler(__vcpu* vcpu)
{
	invvpid_invidual_address(vcpu->vmexit_info.qualification, 1);

	adjust_rip(vcpu);
}

/// <summary>
/// Mov dr handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_mov_dr_handler(__vcpu* vcpu) 
{
	//
	// Moves the contents of a debug register (DR0, DR1, DR2, DR3, DR4, DR5, DR6, or DR7) to a general-purpose register or vice versa.
	// The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute. 
	// (See Section 17.2, “Debug Registers”, of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, 
	// for a detailed description of the flags and fields in the debug registers.)
	//

	//
	// Accessing dr registers from non ring 0 is forbidden
	// and cause #GP exception
	//
	if (hv::get_guest_cpl() != 0) 
	{
		hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
		return;
	}

	__exit_qualification_dr operation;
	operation.all = vcpu->vmexit_info.qualification;
	unsigned __int64* gp_register = &vcpu->vmexit_info.guest_registers->rax - operation.gp_register;

	//
	// Accessing dr register 4 or 5 when debugging extension in cr4 is on cause #UD exception
	// When debug extension is off then it's algined to dr 6 and 7
	//
	if (operation.debug_register_number == 4 || operation.debug_register_number == 5) 
	{
		__cr4 cr4;
		cr4.all = hv::vmread(GUEST_CR4);

		if (cr4.debugging_extensions == true) 
		{
			hv::inject_interruption(EXCEPTION_VECTOR_UNDEFINED_OPCODE, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, false);
			return;
		}

		operation.debug_register_number += 2;
	}

	//
	// Trying to write to 32 upper bits of dr6 or dr7 cause a #GP exception 
	//
	if ((operation.debug_register_number == 6 || operation.debug_register_number == 7) && operation.access_direction == 0 && (*gp_register >> 32) != 0) 
	{
		hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
		return;
	}

	//
	// While dr7 bit general detect is set any access to any dr register cause #DB exception
	//
	__dr7 dr7;
	dr7.all = hv::vmread(GUEST_DR7);
	if (dr7.general_detect == 1) 
	{
		__dr6 dr6;
		dr6.all = __readdr(6);
		dr6.breakpoint_condition = 0;
		dr6.debug_register_access_detected = 1;

		__writedr(6, dr6.all);

		dr7.general_detect = 0;

		hv::vmwrite<unsigned __int64>(GUEST_DR7, dr7.all);

		hv::inject_interruption(EXCEPTION_VECTOR_SINGLE_STEP, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, false);
		return;
	}

	//
	// Mov to dr
	//
	if (operation.access_direction == 0) 
	{
		switch (operation.debug_register_number)
		{
			case 0:
				__writedr(0, *gp_register);
				break;

			case 1:
				__writedr(1, *gp_register);
				break;

			case 2:
				__writedr(2, *gp_register);
				break;

			case 3:
				__writedr(3, *gp_register);
				break;

			case 6:
				__writedr(6, *gp_register);
				break;

			case 7:
				hv::vmwrite<unsigned __int64>(GUEST_DR7, *gp_register);
				break;
		}
	}

	//
	// Mov from dr
	//
	else 
	{
		switch (operation.debug_register_number)
		{
			case 0:
				*gp_register = __readdr(0);
				break;

			case 1:
				*gp_register = __readdr(1);
				break;

			case 2:
				*gp_register = __readdr(2);
				break;

			case 3:
				*gp_register = __readdr(3);
				break;

			case 6:
				*gp_register = __readdr(6);
				break;

			case 7:
				*gp_register = hv::vmread(GUEST_DR7);
				break;
		}
	}

	adjust_rip(vcpu);
}

/// <summary>
/// IO access handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_io(__vcpu* vcpu)
{
	__exit_qualification_io io_information;
	__rflags rflags = vcpu->vmexit_info.guest_rflags;

	io_information.all = vcpu->vmexit_info.qualification;

	union
	{
		unsigned __int8* byte_ptr;
		unsigned __int16* word_ptr;
		unsigned long* dword_ptr;
		unsigned __int64* qword_ptr;

		unsigned __int64 qword;
	}port_value;

	if (io_information.string_instruction == 0)
		port_value.qword_ptr = &vcpu->vmexit_info.guest_registers->rax;

	//
	// If it's ins/outs instruction we have to check if passed buffer address exists and if not inject #PF
	//
	else 
	{
		port_value.qword = io_information.direction == 0 ? vcpu->vmexit_info.guest_registers->rsi : vcpu->vmexit_info.guest_registers->rdi;
		unsigned __int64 physcial_address = MmGetPhysicalAddress((void*)port_value.qword).QuadPart;

		if (physcial_address == 0)
		{
			__writecr2(port_value.qword);
			hv::inject_interruption(EXCEPTION_VECTOR_PAGE_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
			return;
		}
	}

	unsigned __int32 count = io_information.rep == 0 ? 1 : MASK_GET_LOWER_32BITS(vcpu->vmexit_info.guest_registers->rax);

	// OUT
	if (io_information.direction == 0)
	{
		// Not string
		if (io_information.string_instruction == 0)
		{
			switch (io_information.access_size)
			{
				// 1 Byte size
			case 0:
				__outbyte(io_information.port_number, *port_value.byte_ptr);
				break;

				// 2 Byte size
			case 1:
				__outword(io_information.port_number, *port_value.word_ptr);
				break;

				// 4 Byte size
			case 3:
				__outdword(io_information.port_number, *port_value.dword_ptr);
				break;
			}
		}

		// String
		else
		{
			switch (io_information.access_size)
			{
				// 1 Byte size
			case 0:
				__outbytestring(io_information.port_number, port_value.byte_ptr, count);
				break;

				// 2 Byte size
			case 1:
				__outwordstring(io_information.port_number, port_value.word_ptr, count);
				break;

				// 4 Byte size
			case 3:
				__outdwordstring(io_information.port_number, port_value.dword_ptr, count);
				break;
			}
		}
	}

	// IN
	else
	{
		// Not string
		if (io_information.string_instruction == 0)
		{
			switch (io_information.access_size)
			{
				// 1 Byte size
			case 0:
				*port_value.byte_ptr = __inbyte(io_information.port_number);
				break;

				// 2 Byte size
			case 1:
				*port_value.word_ptr = __inword(io_information.port_number);
				break;

				// 4 Byte size
			case 3:
				*port_value.dword_ptr = __indword(io_information.port_number);
				break;
			}
		}

		// String
		else
		{
			switch (io_information.access_size)
			{
				// 1 Byte size
			case 0:
				__inbytestring(io_information.port_number, port_value.byte_ptr, count);
				break;

				// 2 Byte size
			case 1:
				__inwordstring(io_information.port_number, port_value.word_ptr, count);
				break;

				// 4 Byte size
			case 3:
				__indwordstring(io_information.port_number, port_value.dword_ptr, count);
				break;
			}
		}
	}

	if (io_information.string_instruction == 1)
	{
		if (rflags.direction_flag == 1)
			*port_value.qword_ptr -= count * io_information.access_size;

		else
			*port_value.qword_ptr += count * io_information.access_size;

		if (io_information.rep == 1)
			vcpu->vmexit_info.guest_registers->rcx = 0;
	}

	adjust_rip(vcpu);
}

/// <summary>
/// IO access handler wraper
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_io_handler(__vcpu* vcpu) 
{
	unsigned __int64 old_cr3 = hv::swap_context();
	vmexit_io(vcpu);
	hv::restore_context(old_cr3);
}

/// <summary>
/// Rdrand handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_rdrand_handler(__vcpu* vcpu)
{
	__rflags rflags = vcpu->vmexit_info.guest_rflags;
	__vmexit_instruction_information5 instruction_information;

	instruction_information.all = vcpu->vmexit_info.instruction_information;

	unsigned __int64* register_pointer = &vcpu->vmexit_info.guest_registers->rax - instruction_information.operand_register;

	//
	// Loads a hardware generated random value and store it in the destination register.
	// The size of the random value is determined by the destination register size and operating mode.
	// The Carry Flag indicates whether a random value is available at the time the instruction is executed.
	// CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand 
	// will be returned as zeros for the specified width. All other flags are forced to 0 in either situation. 
	// Software must check the state of CF=1 for determining if a valid random value has been returned, 
	// otherwise it is expected to loop and retry execution of RDRAND 
	// (see Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, Section 7.3.17, “Random Number Generator Instructions”).
	// This instruction is available at all privilege levels.
	//
	switch (instruction_information.operand_size)
	{
		case 0:
		{
			rflags.carry_flag = _rdrand16_step((unsigned __int16*)register_pointer);
			break;
		}

		case 1:
		{
			rflags.carry_flag = _rdrand32_step((unsigned __int32*)register_pointer);
			break;
		}

		case 2:
		{
			rflags.carry_flag = _rdrand64_step(register_pointer);
			break;
		}
	}

	hv::vmwrite<unsigned __int64>(GUEST_RFLAGS, rflags.all);

	adjust_rip(vcpu);
}

/// <summary>
/// Rdseed handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_rdseed_handler(__vcpu* vcpu)
{
	__rflags rflags = vcpu->vmexit_info.guest_rflags;
	__vmexit_instruction_information5 instruction_information;
	
	instruction_information.all = vcpu->vmexit_info.instruction_information;

	unsigned __int64*  register_pointer = &vcpu->vmexit_info.guest_registers->rax - instruction_information.operand_register;

	//
	// Loads a hardware generated random value and store it in the destination register.
	// The random value is generated from an Enhanced NRBG (Non Deterministic Random Bit Generator)
	// that is compliant to NIST SP800-90B and NIST SP800-90C in the XOR construction mode.
	// The size of the random value is determined by the destination register size and operating mode.
	// The Carry Flag indicates whether a random value is available at the time the instruction is executed. 
	// CF=1 indicates that the data in the destination is valid. Otherwise CF=0 and the data in the destination operand 
	// will be returned as zeros for the specified width. All other flags are forced to 0 in either situation.
	// Software must check the state of CF=1 for determining if a valid random seed value has been returned, 
	// otherwise it is expected to loop and retry execution of RDSEED (see Section 1.2).
	// The RDSEED instruction is available at all privilege levels.The RDSEED instruction executes normally either
	// inside or outside a transaction region.
	//
	switch (instruction_information.operand_size)
	{
		case 0:
		{
			rflags.carry_flag = _rdseed16_step((unsigned __int16*)register_pointer);
			break;
		}

		case 1:
		{
			rflags.carry_flag = _rdseed32_step((unsigned __int32*)register_pointer);
			break;
		}

		case 2:
		{
			rflags.carry_flag = _rdseed64_step(register_pointer);
			break;
		}
	}

	hv::vmwrite<unsigned __int64>(GUEST_RFLAGS, rflags.all);

	adjust_rip(vcpu);
}

/// <summary>
/// Handler for failed vmexit
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_failed(__vcpu* vcpu)
{
	ASSERT(FALSE);
	hv::dump_vmcs();
	KeBugCheckEx(HYPERVISOR_ERROR, 1, vcpu->vmexit_info.reason, vcpu->vmexit_info.qualification, 0);
}

/// <summary>
/// Xsetbv handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_xsetbv_handler(__vcpu* vcpu)
{
	__xcr0 new_xcr0;
	__xcr0 current_xcr0;

	unsigned __int64 xcr_number = vcpu->vmexit_info.guest_registers->rcx;

	new_xcr0.all = vcpu->vmexit_info.guest_registers->rdx << 32 | MASK_GET_LOWER_32BITS(vcpu->vmexit_info.guest_registers->rax);

	current_xcr0.all = _xgetbv(0);

	//
	// If xcr_number is higher than 0 then inject #GP
	// If value in edx:eax sets bits that are reserved in the xcr specified by ecx then inject #GP
	// If an attempt is made to clear bit 0 of xcr0 then inject #GP
	// If an attempt is made to set new_xcr0[2:1] = 0 then inject #GP
	//
	if (xcr_number > 0 || new_xcr0.x87 == 0 || 
		new_xcr0.reserved1 != current_xcr0.reserved1 || 
		new_xcr0.reserved2 != current_xcr0.reserved2 || 
		new_xcr0.reserved3 != current_xcr0.reserved3 || 
		(new_xcr0.avx == 1 && new_xcr0.sse == 0))
	{
		hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
		return;
	}

	//
	// Writes the contents of registers EDX:EAX into the 64-bit extended control register (XCR) specified in the ECX register.
	// (On processors that support the Intel 64 architecture, the high-order 32 bits of RCX are ignored.) 
	// The contents of the EDX register are copied to high-order 32 bits of the selected XCR and the contents of the EAX register are copied
	// to low-order 32 bits of the XCR. (On processors that support the Intel 64 architecture,
	// the high-order 32 bits of each of RAX and RDX are ignored.) Undefined or reserved bits in an XCR should be set to values previously read.
	// This instruction must be executed at privilege level 0 or in real - address mode; otherwise, a general protection exception #GP(0)
	// is generated.Specifying a reserved or unimplemented XCR in ECX will also cause a general protection exception.
	// The processor will also generate a general protection exception if software attempts to write to reserved bits in an XCR.
	// Currently, only XCR0 is supported.Thus, all other values of ECX are reservedand will cause a #GP(0).
	//
	_xsetbv(xcr_number, new_xcr0.all);
	adjust_rip(vcpu);
}

/// <summary>
/// Invd handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_invd_handler(__vcpu* vcpu)
{
	//
	// Invalidates (flushes) the processor’s internal caches and issues a special-function bus cycle that directs 
	// external caches to also flush themselves. Data held in internal caches is not written back to main memory.
	// After executing this instruction, the processor does not wait for the external caches to complete their flushing operation before 
	// proceeding with instruction execution.It is the responsibility of hardware to respond to the cache flush signal.
	// The INVD instruction is a privileged instruction.When the processor is running in protected mode,
	// the CPL of a program or procedure must be 0 to execute this instruction.
	// The INVD instruction may be used when the cache is used as temporary memory and the cache contents
	// need to be invalidated rather than written back to memory.When the cache is used as temporary memory,
	// no external device should be actively writing data to main memory.
	// Use this instruction with care.Data cached internally and not written back to main memory will be lost.
	// Note that any data from an external device to main memory(for example, via a PCIWrite) can be temporarily stored in the caches;
	// these data can be lost when an INVD instruction is executed.Unless there is a specific requirement or 
	// benefit to flushing caches without writing back modified cache lines(for example, temporary memory, 
	// testing, or fault recovery where cache coherency with main memory is not a concern), software should instead use the WBINVD instruction.
	//
	// tldr: We use wbinvd cause it's safer
	//
	__wbinvd();
	adjust_rip(vcpu);
}

/// <summary>
/// Rdtscp handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_rdtscp_handler(__vcpu* vcpu)
{
	//
	// Reads the current value of the processor’s time-stamp counter (a 64-bit MSR) into the EDX:EAX registers
	// and also reads the value of the IA32_TSC_AUX MSR (address C0000103H) into the ECX register.
	// The EDX register is loaded with the high-order 32 bits of the IA32_TSC MSR; 
	// the EAX register is loaded with the low-order 32 bits of the IA32_TSC MSR; 
	// and the ECX register is loaded with the low-order 32-bits of IA32_TSC_AUX MSR.
	// On processors that support the Intel 64 architecture, the high-order 32 bits of each of RAX, RDX, and RCX are cleared.
	//

	unsigned __int32 processor_id;
	unsigned __int64 tsc = __rdtscp(&processor_id);
	vcpu->vmexit_info.guest_registers->rcx = processor_id;
	vcpu->vmexit_info.guest_registers->rdx = MASK_GET_HIGHER_32BITS(tsc) >> 32;
	vcpu->vmexit_info.guest_registers->rax = MASK_GET_LOWER_32BITS(tsc);

	adjust_rip(vcpu);
}

/// <summary>
/// Handler for unimplemented cases
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_unimplemented(__vcpu* vcpu)
{
	LogError("Not implemented vmexit reason %llu, qualificaton %llu, guest rip 0x%llX", vcpu->vmexit_info.reason, vcpu->vmexit_info.qualification, vcpu->vmexit_info.guest_rip);
}

/// <summary>
/// VT-x instructions handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_vm_instruction(__vcpu* vcpu)
{
	UNREFERENCED_PARAMETER(vcpu);
	hv::inject_interruption(EXCEPTION_VECTOR_UNDEFINED_OPCODE, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, false);
}

/// <summary>
/// Triple fault handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_triple_fault_handler(__vcpu* vcpu) 
{
	//
	// Dump whole vmcs state before hard reset
	//
	UNREFERENCED_PARAMETER(vcpu);
	hv::dump_vmcs();
	ASSERT(FALSE);
	hv::hard_reset();
}

/// <summary>
/// Rdtsc handler
/// </summary>
/// <param name="guest_registers"></param>
void vmexit_rdtsc_handler(__vcpu* vcpu) 
{
	//
	// Loads the current value of the processor's time-stamp counter into the EDX:EAX registers.
	// The time-stamp counter is contained in a 64-bit MSR.
	// The high-order 32 bits of the MSR are loaded into the EDX register, and the low-order 32 bits are loaded into the EAX register.
	// The processor monotonically increments the time-stamp counter MSR every clock cycle and resets it to 0 whenever the processor is reset.
	// See "Time Stamp Counter" in Chapter 15 of the IA-32 Intel Architecture Software Developer's Manual, 
	// Volume 3 for specific details of the time stamp counter behavior.
	//

	unsigned __int64 tsc = __rdtsc();

	vcpu->vmexit_info.guest_registers->rdx = MASK_GET_HIGHER_32BITS(tsc) >> 32;
	vcpu->vmexit_info.guest_registers->rax = MASK_GET_LOWER_32BITS(tsc);

	adjust_rip(vcpu);
}

/// <summary>
/// Get rsp for leaving vmx operation
/// </summary>
/// <returns></returns>
unsigned __int64 return_rsp_for_vmxoff()
{
	return g_vmm_context->vcpu_table[KeGetCurrentProcessorNumber()]->vmx_off_state.guest_rsp;
}

/// <summary>
/// Get rip for leaving vmx operation
/// </summary>
/// <returns></returns>
unsigned __int64 return_rip_for_vmxoff()
{
	return g_vmm_context->vcpu_table[KeGetCurrentProcessorNumber()]->vmx_off_state.guest_rip;
}

void vmexit_cr_handler(__vcpu* vcpu)
{
	__cr0 guest_cr0;
	__cr3 guest_cr3;
	__cr_access_qualification operation;
	operation.all = vcpu->vmexit_info.qualification;

	unsigned __int64* register_pointer = &vcpu->vmexit_info.guest_registers->rax - operation.register_type;

	union
	{
		__cr0 cr0;
		__cr3 cr3;
		__cr4 cr4;
		unsigned __int64 all;
	}cr_registers;

	cr_registers.all = *register_pointer;

	//
	// Moves the contents of a control register (CR0, CR2, CR3, CR4, or CR8) 
	// to a general-purpose register or the contents of a general purpose register to a control register.
	// The operand size for these instructions is always 32 bits in non-64-bit modes, regardless of the operand-size attribute.
	// (See “Control Registers” in Chapter 2 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual,
	// Volume 3A, for a detailed description of the flags and fields in the control registers.) 
	// This instruction can be executed only when the current privilege level is 0. 
	//
	// (We don't have to check cpl because cpu prioritizes fault based on privilege level over vm exit)
	//
	switch (operation.access_type)
	{
		case CR_ACCESS_MOV_TO_CR:
		{
			switch (operation.cr_number)
			{
				case 0:
				{
					// Any attempt to clear cr0 PG bit cause #GP
					if (cr_registers.cr0.paging_enable == 0)
					{
						hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
						return;
					}

					hv::vmwrite<unsigned __int64>(GUEST_CR0, *register_pointer);
					hv::vmwrite<unsigned __int64>(CONTROL_CR0_READ_SHADOW, *register_pointer);

					break;
				}

				case 3:
				{
					//
					// Any attempt to write a 1 to any reserved bit cause #GP
					//
					if (cr_registers.cr3.reserved_1 != 0 || cr_registers.cr3.reserved_2 != 0) 
					{
						hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
						return;
					}

					hv::vmwrite<unsigned __int64>(GUEST_CR3, (*register_pointer & ~(1ULL << 63)));

					invvpid_single_context_except_global_translations(1);
					break;
				}

				case 4:
				{
					guest_cr3.all = hv::vmread(GUEST_CR3);

					//
					// Any attempt to write a 1 to any reserved bit cause #GP or 
					// Trying to leave IA-32e mode by clearing cr pae bit cause #GP
					// Trying to change cr4 pcide from 0 to 1 while cr3[11:0] != 0 cause #GP
					//
					if (cr_registers.cr4.reserved_1 != 0 || cr_registers.cr4.reserved_2 != 0 || 
						cr_registers.cr4.reserved_3 != 0 || cr_registers.cr4.physical_address_extension == 0 ||
						(cr_registers.cr4.pcid_enable == 1 && guest_cr3.pcid != 0))
					{
						hv::inject_interruption(EXCEPTION_VECTOR_GENERAL_PROTECTION_FAULT, INTERRUPT_TYPE_HARDWARE_EXCEPTION, 0, true);
						return;
					}

					hv::vmwrite<unsigned __int64>(GUEST_CR4, *register_pointer);
					hv::vmwrite<unsigned __int64>(CONTROL_CR4_READ_SHADOW, *register_pointer);
					break;
				}

				default:
				{
					// We should never get here
					ASSERT(FALSE);
					break;
				}
			}

			break;
		}

		case CR_ACCESS_MOV_FROM_CR:
		{
			switch (operation.cr_number)
			{
				case 0:
				{
					*register_pointer = hv::vmread(GUEST_CR0);
					break;
				}

				case 3:
				{
					*register_pointer = hv::vmread(GUEST_CR3);
					break;
				}

				case 4:
				{
					*register_pointer = hv::vmread(GUEST_CR4);
					break;
				}

				default:
				{
					// We should never get here
					ASSERT(FALSE);
					break;
				}
			}

			break;
		}

		//
		// Clears the task-switched (TS) flag in the CR0 register. This instruction is intended for use in operating-system procedures. 
		// It is a privileged instruction that can only be executed at a CPL of 0. 
		// It is allowed to be executed in real-address mode to allow initialization for protected mode.
		// The processor sets the TS flag every time a task switch occurs.
		// The flag is used to synchronize the saving of FPU context in multitasking applications.
		// See the description of the TS flag in the section titled “Control Registers” 
		// in Chapter 2 of the Intel® 64 and IA - 32 Architectures Software Developer’s Manual, Volume 3A, for more information about this flag.
		//
		case CR_ACCESS_CLTS:
		{
			guest_cr0.all = hv::vmread(GUEST_CR0);

			guest_cr0.task_switched = 0;

			hv::vmwrite<unsigned __int64>(GUEST_CR0, guest_cr0.all);
			hv::vmwrite<unsigned __int64>(CONTROL_CR0_READ_SHADOW, guest_cr0.all);

			break;
		}

		//
		// Loads the source operand into the machine status word, bits 0 through 15 of register CR0.
		// The source operand can be a 16-bit general-purpose register or a memory location. 
		// Only the low-order 4 bits of the source operand (which contains the PE, MP, EM, and TS flags) are loaded into CR0. 
		// The PG, CD, NW, AM, WP, NE, and ET flags of CR0 are not affected. The operand-size attribute has no effect on this instruction.
		// If the PE flag of the source operand(bit 0) is set to 1, the instruction causes the processor to switch to protected mode.
		// While in protected mode, the LMSW instruction cannot be used to clear the PE flagand force a switch back to real - address mode.
		// The LMSW instruction is provided for use in operating - system software; it should not be used in application programs.
		// In protected or virtual - 8086 mode, it can only be executed at CPL 0.
		// This instruction is provided for compatibility with the Intel 286 processor
		// programs and procedures intended to run on IA - 32 and Intel 64 processors beginning with Intel386 processors should use
		// the MOV(control registers) instruction to load the whole CR0 register.The MOV CR0 instruction can be used to set and clear the PE flag
		// in CR0, allowing a procedure or program to switch between protectedand real - address modes.
		//
		case CR_ACCESS_LMSW:
		{
			// Register operand type
			if (operation.operand_type == 0) 
			{
				guest_cr0.all = hv::vmread(GUEST_CR0);

				guest_cr0.protection_enable = cr_registers.cr0.protection_enable;
				guest_cr0.monitor_coprocessor = cr_registers.cr0.monitor_coprocessor;
				guest_cr0.emulate_fpu = cr_registers.cr0.emulate_fpu;
				guest_cr0.task_switched = cr_registers.cr0.task_switched;

				hv::vmwrite<unsigned __int64>(GUEST_CR0, guest_cr0.all);
				hv::vmwrite<unsigned __int64>(CONTROL_CR0_READ_SHADOW, guest_cr0.all);
			}

			// Memory operand type
			else if (operation.operand_type == 1) 
			{
				guest_cr0.all = hv::vmread(GUEST_CR0);

				cr_registers.all = operation.source_data;

				guest_cr0.protection_enable = cr_registers.cr0.protection_enable;
				guest_cr0.monitor_coprocessor = cr_registers.cr0.monitor_coprocessor;
				guest_cr0.emulate_fpu = cr_registers.cr0.emulate_fpu;
				guest_cr0.task_switched = cr_registers.cr0.task_switched;

				hv::vmwrite<unsigned __int64>(GUEST_CR0, guest_cr0.all);
				hv::vmwrite<unsigned __int64>(CONTROL_CR0_READ_SHADOW, guest_cr0.all);
			}

			else 
			{
				// We should never get here
				ASSERT(FALSE);
			}

			break;
		}

		default: 
		{
			// We should never get here
			ASSERT(FALSE);
			break;
		}

	}

	adjust_rip(vcpu);
}

/// <summary>
/// Vm exit dispatcher
/// </summary>
/// <param name="guest_registers"></param>
/// <returns> status </returns>
bool vmexit_handler(__vmexit_guest_registers* guest_registers)
{
	__vcpu* vcpu = g_vmm_context->vcpu_table[KeGetCurrentProcessorNumber()];

	guest_registers->rsp = hv::vmread(GUEST_RSP);

	vcpu->vmexit_info.reason = hv::vmread(EXIT_REASON) & 0xffff;
	vcpu->vmexit_info.qualification = hv::vmread(EXIT_QUALIFICATION);
	vcpu->vmexit_info.guest_rflags.all = hv::vmread(GUEST_RFLAGS);
	vcpu->vmexit_info.guest_rip = hv::vmread(GUEST_RIP);
	vcpu->vmexit_info.instruction_length = hv::vmread(VM_EXIT_INSTRUCTION_LENGTH);
	vcpu->vmexit_info.instruction_information = hv::vmread(VM_EXIT_INSTRUCTION_INFORMATION);
	vcpu->vmexit_info.guest_registers = guest_registers;

	//
	//  Instructions That Cause VM Exits Unconditionally
	//  The following instructions cause VM exits when they are executed in VMX non - root operation : CPUID, GETSEC,
	//  INVD, and XSETBV.This is also true of instructions introduced with VMX, which include : INVEPT, INVVPID,
	//  VMCALL, VMCLEAR, VMLAUNCH, VMPTRLD, VMPTRST, VMRESUME, VMXOFF, and VMXON.
	//
	exit_handlers[vcpu->vmexit_info.reason](vcpu);

	if (vcpu->vmx_off_state.vmx_off_executed == 1)
	{
		vcpu->vcpu_status.vmm_launched = 0;
		return false;
	}

	return true;
}

/// <summary>
/// Add to guest rip size of instruction which he executed
/// </summary>
void adjust_rip(__vcpu* vcpu)
{
	hv::vmwrite(GUEST_RIP, vcpu->vmexit_info.guest_rip + vcpu->vmexit_info.instruction_length);
	if (vcpu->vmexit_info.guest_rflags.trap_flag)
	{
		__vmx_pending_debug_exceptions pending_debug = { hv::vmread(GUEST_PENDING_DEBUG_EXCEPTION) };
		__vmx_interruptibility_state interruptibility = { hv::vmread(GUEST_INTERRUPTIBILITY_STATE) };

		pending_debug.bs = true;
		hv::vmwrite(GUEST_PENDING_DEBUG_EXCEPTION, pending_debug.all);

		interruptibility.blocking_by_sti = false;
		interruptibility.blocking_by_mov_ss = false;
		hv::vmwrite(GUEST_INTERRUPTIBILITY_STATE, interruptibility.all);
	}
}
```

`airhv/airhv-main/airhv/vmexit_handler.h`:

```h
#pragma once

enum __vm_exit_reason
{
	EXIT_REASON_EXCEPTION_NMI,
	EXIT_REASON_EXTERNAL_INTERRUPT,
	EXIT_REASON_TRIPLE_FAULT,
	EXIT_REASON_INIT_SIGNAL,
	EXIT_REASON_SIPI,
	EXIT_REASON_SMI,
	EXIT_REASON_OTHER_SMI,
	EXIT_REASON_INTERRUPT_WINDOW,
	EXIT_REASON_NMI_WINDOW,
	EXIT_REASON_TASK_SWITCH,
	EXIT_REASON_CPUID,
	EXIT_REASON_GETSEC,
	EXIT_REASON_HLT,
	EXIT_REASON_INVD,
	EXIT_REASON_INVLPG,
	EXIT_REASON_RDPMC,
	EXIT_REASON_RDTSC,
	EXIT_REASON_RSM,
	EXIT_REASON_VMCALL,
	EXIT_REASON_VMCLEAR,
	EXIT_REASON_VMLAUNCH,
	EXIT_REASON_VMPTRLD,
	EXIT_REASON_VMPTRST,
	EXIT_REASON_VMREAD,
	EXIT_REASON_VMRESUME,
	EXIT_REASON_VMWRITE,
	EXIT_REASON_VMXOFF,
	EXIT_REASON_VMXON,
	EXIT_REASON_CR_ACCESSES,
	EXIT_REASON_MOV_DR,
	EXIT_REASON_IO_INSTRUCTION,
	EXIT_REASON_RDMSR,
	EXIT_REASON_WRMSR,
	EXIT_REASON_VM_ENTRY_FAILURE_INVALID_GUEST_STATE,
	EXIT_REASON_VM_ENTRY_FAILURE_MSR_LODAING,
	EXIT_REASON_RESERVED1,
	EXIT_REASON_MWAIT,
	EXIT_REASON_MONITOR_TRAP_FLAG,
	EXIT_REASON_RESERVED2,
	EXIT_REASON_MONITOR,
	EXIT_REASON_PAUSE,
	EXIT_REASON_VM_ENTRY_FAILURE_MACHINE_CHECK_EVENT,
	EXIT_REASON_RESERVED3,
	EXIT_REASON_TPR_BELOW_THRESHOLD,
	EXIT_REASON_APIC_ACCESS,
	EXIT_REASON_VIRTUALIZED_EOI,
	EXIT_REASON_ACCESS_TO_GDTR_OR_IDTR,
	EXIT_REASON_ACCESS_TO_LDTR_OR_TR,
	EXIT_REASON_EPT_VIOLATION,
	EXIT_REASON_EPT_MISCONFIGURATION,
	EXIT_REASON_INVEPT,
	EXIT_REASON_RDTSCP,
	EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED,
	EXIT_REASON_INVVPID,
	EXIT_REASON_WBINVD,
	EXIT_REASON_XSETBV,
	EXIT_REASON_APIC_WRITE,
	EXIT_REASON_RDRAND,
	EXIT_REASON_INVPCID,
	EXIT_REASON_VMFUNC,
	EXIT_REASON_ENCLS,
	EXIT_REASON_RDSEED,
	EXIT_REASON_PAGE_MODIFICATION_LOG_FULL,
	EXIT_REASON_XSAVES,
	EXIT_REASON_XRSTORS,
	EXIT_REASON_RESERVED4,
	EXIT_REASON_SPP_RELATED_EVENT,
	EXIT_REASON_UMWAIT,
	EXIT_REASON_TPAUSE,
	EXIT_REASON_LAST
};

// Table 27-8. Format of the VM-Exit Instruction-Information Field as Used for INS and OUTS
union __vmexit_instruction_information1
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 reserved1 : 7;
		unsigned __int64 address_size : 3;
		unsigned __int64 reserved2 : 5;
		unsigned __int64 segment_register : 3;
		unsigned __int64 reserved3 : 14;
	};
};

// Table 27-9. Format of the VM-Exit Instruction-Information Field as Used for INVEPT, INVPCID, and INVVPID
union __vmexit_instruction_information2
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 scaling : 2;
		unsigned __int64 reserved1 : 5;
		unsigned __int64 address_size : 3;
		unsigned __int64 reserved2 : 1;
		unsigned __int64 reserved3 : 4;
		unsigned __int64 segment_register : 3;
		unsigned __int64 index_reg : 4;
		unsigned __int64 index_reg_invalid : 1;
		unsigned __int64 base_reg : 4;
		unsigned __int64 base_reg_invalid : 1;
		unsigned __int64 reg2 : 4;
	};
};

// Table 27-10. Format of the VM-Exit Instruction-Information Field as Used for LIDT, LGDT, SIDT, or SGDT
union __vmexit_instruction_information3 
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 scaling : 2;
		unsigned __int64 reserved1 : 5;
		unsigned __int64 address_size : 3;
		unsigned __int64 reserved2 : 1;
		unsigned __int64 operand_size : 1;
		unsigned __int64 reserved3 : 3;
		unsigned __int64 segment_register : 3;
		unsigned __int64 index_reg : 4;
		unsigned __int64 index_reg_invalid : 1;
		unsigned __int64 base_reg : 4;
		unsigned __int64 base_reg_invalid : 1;
		unsigned __int64 instruction_identity : 2;
		unsigned __int64 reserved4 : 2;
	};
};

// Table 27-11. Format of the VM-Exit Instruction-Information Field as Used for LLDT, LTR, SLDT, and STR
union __vmexit_instruction_information4
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 scaling : 2;
		unsigned __int64 reserved1 : 1;
		unsigned __int64 reg1 : 4;
		unsigned __int64 address_size : 3;
		unsigned __int64 mem_reg : 1;
		unsigned __int64 reserved2 : 4;
		unsigned __int64 segment_register : 3;
		unsigned __int64 index_reg : 4;
		unsigned __int64 index_reg_invalid : 1;
		unsigned __int64 base_reg : 4;
		unsigned __int64 base_reg_invalid : 1;
		unsigned __int64 instruction_identity : 2;
		unsigned __int64 reserved4 : 2;
	};
};

// Table 27-12. Format of the VM-Exit Instruction-Information Field as Used for RDRAND, RDSEED, TPAUSE, and UMWAIT
union __vmexit_instruction_information5
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 reserved1 : 3;
		unsigned __int64 operand_register : 4;
		unsigned __int64 reserved2 : 4;
		unsigned __int64 operand_size : 2;
		unsigned __int64 reserved3 : 19;
	};
};

// Table 27 - 13. Format of the VM - Exit Instruction - Information Field as Used for VMCLEAR, VMPTRLD, VMPTRST, VMXON, XRSTORS, and XSAVES
union __vmexit_instruction_information6
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 scaling : 2;
		unsigned __int64 reserved1 : 5;
		unsigned __int64 address_size : 3;
		unsigned __int64 reserved2 : 1;
		unsigned __int64 reserved3 : 4;
		unsigned __int64 segment_register : 3;
		unsigned __int64 index_reg : 4;
		unsigned __int64 index_reg_invalid : 1;
		unsigned __int64 base_reg : 4;
		unsigned __int64 base_reg_invalid : 1;
		unsigned __int64 instruction_identity : 2;
		unsigned __int64 reserved4 : 2;
	};
};

// Table 27-14. Format of the VM-Exit Instruction-Information Field as Used for VMREAD and VMWRITE
union __vmexit_instruction_information7
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 scaling : 2;
		unsigned __int64 reserved1 : 1;
		unsigned __int64 reg1 : 4;
		unsigned __int64 address_size : 3;
		unsigned __int64 mem_reg : 1;
		unsigned __int64 reserved2 : 4;
		unsigned __int64 segment_register : 3;
		unsigned __int64 index_reg : 4;
		unsigned __int64 index_reg_invalid : 1;
		unsigned __int64 base_reg : 4;
		unsigned __int64 base_reg_invalid : 1;
		unsigned __int64 reg2 : 4;
	};
};

// Table 27-5. Exit Qualification for I/O Instructions
union __exit_qualification_io 
{
	unsigned __int64 all;
	struct
	{
		//
		// 0 = 1 - byte
		// 1 = 2 - byte
		// 3 = 4 - byte
		//
		unsigned __int64 access_size : 3;

		//
		// 0 = OUT
		// 1 = IN
		//
		unsigned __int64 direction : 1;

		//
		// 0 = not string
		// 1 = string
		//
		unsigned __int64 string_instruction : 1;

		//
		// 0 = not REP
		// 1 = REP
		//
		unsigned __int64 rep : 1;

		//
		// 0 = DX
		// 1 = immediate
		//
		unsigned __int64 operand_encoding : 1;

		//
		// Not currently defined
		//
		unsigned __int64 reserved1 : 9;

		//
		// as specified in DX or in an immediate operand
		//
		unsigned __int64 port_number : 16;

		//
		// Not currently defined. These bits exist only on processors that support Intel 64 architecture.
		//
		unsigned __int64 reserved2 : 32;
	};
};

union __exit_qualification_dr 
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 debug_register_number : 3;

		unsigned __int64 reserved1 : 1;

		//
		// 0 = MOV to DR
		// 1 = MOV from DR
		//
		unsigned __int64 access_direction : 1;

		unsigned __int64 reserved2 : 3;

		unsigned __int64 gp_register : 4;

		unsigned __int64 reserved3 : 52;
	};
};

unsigned __int64 return_rsp_for_vmxoff();

unsigned __int64 return_rip_for_vmxoff();

bool vmexit_handler(__vmexit_guest_registers * guest_registers);

void adjust_rip(__vcpu* vcpu);
```

`airhv/airhv-main/airhv/vmm.cpp`:

```cpp
#pragma warning( disable :  4201)

#include <ntddk.h>
#include <intrin.h>
#include "common.h"
#include "ia32\cpuid.h"
#include "asm\vm_context.h"
#include "ia32\cr.h"
#include "ia32\msr.h"
#include "ia32\vmcs.h"
#include "log.h"
#include "ntapi.h"
#include "ia32\vmcs_encodings.h"
#include "allocators.h"

void dpc_broadcast_initialize_guest(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
	UNREFERENCED_PARAMETER(DeferredContext);
	UNREFERENCED_PARAMETER(Dpc);
	vmx_save_state();

	// Wait for all DPCs to synchronize at this point
	KeSignalCallDpcSynchronize(SystemArgument2);

	// Mark the DPC as being complete
	KeSignalCallDpcDone(SystemArgument1);
}


/// <summary>
/// Deallocate all structures
/// </summary>
void free_vmm_context()
{
	if (g_vmm_context != nullptr)
	{
		// POOL MANAGER
		if (g_vmm_context->pool_manager != nullptr)
		{
			pool_manager::uninitialize();
			free_pool(g_vmm_context->pool_manager);
		}

		// EPT STATE
		if (g_vmm_context->ept_state != nullptr)
		{
			// EPT POINTER
			if (g_vmm_context->ept_state->ept_pointer != nullptr)
			{
				free_pool(g_vmm_context->ept_state->ept_pointer);
			}
			// EPT PAGE TABLE
			if (g_vmm_context->ept_state->ept_page_table != nullptr)
			{
				free_contignous_memory(g_vmm_context->ept_state->ept_page_table);

			}
			free_pool(g_vmm_context->ept_state);
		}

		// VCPU TABLE
		if (g_vmm_context->vcpu_table != nullptr)
		{
			for (unsigned int i = 0; i < g_vmm_context->processor_count; i++)
			{
				// VCPU
				if (g_vmm_context->vcpu_table[i] != nullptr)
				{
					// VCPU VMXON REGION
					if (g_vmm_context->vcpu_table[i]->vmxon != nullptr)
					{
						free_contignous_memory(g_vmm_context->vcpu_table[i]->vmxon);
					}

					// VCPU VMCS REGION
					if (g_vmm_context->vcpu_table[i]->vmcs != nullptr)
					{
						free_contignous_memory(g_vmm_context->vcpu_table[i]->vmcs);
					}

					// VCPU VMM STACK
					if (g_vmm_context->vcpu_table[i]->vmm_stack != nullptr)
					{
						free_pool(g_vmm_context->vcpu_table[i]->vmm_stack);
					}

					// MSR BITMAP
					if (g_vmm_context->vcpu_table[i]->vcpu_bitmaps.msr_bitmap != nullptr)
					{
						free_pool(g_vmm_context->vcpu_table[i]->vcpu_bitmaps.msr_bitmap);
					}

					// IO BITMAP A
					if (g_vmm_context->vcpu_table[i]->vcpu_bitmaps.io_bitmap_a != nullptr)
					{
						free_pool(g_vmm_context->vcpu_table[i]->vcpu_bitmaps.io_bitmap_a);
					}

					// IO BITMAP B
					if (g_vmm_context->vcpu_table[i]->vcpu_bitmaps.io_bitmap_b != nullptr)
					{
						free_pool(g_vmm_context->vcpu_table[i]->vcpu_bitmaps.io_bitmap_b);
					}

					free_pool(g_vmm_context->vcpu_table[i]);
				}
			}
			free_pool(g_vmm_context->vcpu_table);
		}

		free_pool(g_vmm_context);
	}

	g_vmm_context = 0;
}


/// <summary>
/// Allocates contiguous memory for vmcs
/// </summary>
/// <param name="vcpu"> Pointer to vcpu </param>
/// <returns> status </returns>
bool init_vmcs(__vcpu* vcpu)
{
	__vmx_basic_msr vmx_basic = { 0 };
	PHYSICAL_ADDRESS physical_max;

	vmx_basic.all = __readmsr(IA32_VMX_BASIC);

	physical_max.QuadPart = ~0ULL;
	vcpu->vmcs = allocate_contignous_memory<__vmcs*>(PAGE_SIZE);
	if (vcpu->vmcs == NULL)
	{
		LogError("Vmcs structure could not be allocated");
		return false;
	}

	vcpu->vmcs_physical = MmGetPhysicalAddress(vcpu->vmcs).QuadPart;
	if (vcpu->vmcs_physical == NULL)
	{
		LogError("Could not get physical address of vmcs");
		return false;
	}

	RtlSecureZeroMemory(vcpu->vmcs, PAGE_SIZE);
	vcpu->vmcs->header.revision_identifier = vmx_basic.vmcs_revision_identifier;

	// Indicates if it's shadow vmcs or not
	vcpu->vmcs->header.shadow_vmcs_indicator = 0;

	return true;
}

/// <summary>
/// Allocate whole vmm context, build mtrr map, initalize pool manager and initialize ept structure 
/// </summary>
/// <returns> status </returns>
bool allocate_vmm_context()
{
	__cpuid_info cpuid_reg = { 0 };

	//
	// Allocate Nonpaged memory for vm global context structure
	//
	g_vmm_context = allocate_pool<__vmm_context>();
	if (g_vmm_context == nullptr) {
		LogError("g_vmm_context could not be allocated");
		return false;
	}
	RtlSecureZeroMemory(g_vmm_context, sizeof(__vmm_context));

	//
	// Allocate virtual cpu context for every logical core
	//
	g_vmm_context->processor_count = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS);
	g_vmm_context->vcpu_table = allocate_pool<__vcpu**>(sizeof(__vcpu*) * (g_vmm_context->processor_count));
	if (g_vmm_context->vcpu_table == nullptr)
	{
		LogError("vcpu_table could not be allocated");
		return false;
	}
	RtlSecureZeroMemory(g_vmm_context->vcpu_table, sizeof(__vcpu*) * (g_vmm_context->processor_count));

	//
	// Allocate ept state structure
	//
	g_vmm_context->ept_state = allocate_pool<__ept_state>();
	if (g_vmm_context->ept_state == nullptr)
	{
		LogError("ept state could not be allocated");
		return false;
	}
	RtlSecureZeroMemory(g_vmm_context->ept_state, sizeof(__ept_state));

	InitializeListHead(&g_vmm_context->ept_state->hooked_page_list);

	//
	// Build mtrr map for physcial memory caching informations
	//
	ept::build_mtrr_map();

	if (pool_manager::initialize() == false)
	{
		return false;
	}

	//
	// Initialize ept structure
	//
	if (ept::initialize() == false)
	{
		return false;
	}

	g_vmm_context->hv_presence = true;

	__cpuid((int*)&cpuid_reg.eax, 0);
	g_vmm_context->highest_basic_leaf = cpuid_reg.eax;

	return true;
}

/// <summary>
/// Allocate whole vcpu context and bitmaps
/// </summary>
/// <returns> Pointer to vcpu </returns>
bool init_vcpu(__vcpu*& vcpu)
{
	vcpu = allocate_pool<__vcpu>();
	if (vcpu == nullptr)
	{
		LogError("vcpu structure could not be allocated");
		return false;
	}
	RtlSecureZeroMemory(vcpu, sizeof(__vcpu));

	vcpu->vmm_stack = allocate_pool<void*>(VMM_STACK_SIZE);
	if (vcpu->vmm_stack == nullptr)
	{
		LogError("vmm stack could not be allocated");
		return false;
	}
	RtlSecureZeroMemory(vcpu->vmm_stack, VMM_STACK_SIZE);

	vcpu->vcpu_bitmaps.msr_bitmap = allocate_pool<unsigned __int8*>(PAGE_SIZE);
	if (vcpu->vcpu_bitmaps.msr_bitmap == nullptr)
	{
		LogError("msr bitmap could not be allocated");
		return false;
	}
	RtlSecureZeroMemory(vcpu->vcpu_bitmaps.msr_bitmap, PAGE_SIZE);
	vcpu->vcpu_bitmaps.msr_bitmap_physical = MmGetPhysicalAddress(vcpu->vcpu_bitmaps.msr_bitmap).QuadPart;

	vcpu->vcpu_bitmaps.io_bitmap_a = allocate_pool<unsigned __int8*>(PAGE_SIZE);
	if (vcpu->vcpu_bitmaps.io_bitmap_a == nullptr)
	{
		LogError("io bitmap a could not be allocated");
		return false;
	}
	RtlSecureZeroMemory(vcpu->vcpu_bitmaps.io_bitmap_a, PAGE_SIZE);
	vcpu->vcpu_bitmaps.io_bitmap_a_physical = MmGetPhysicalAddress(vcpu->vcpu_bitmaps.io_bitmap_a).QuadPart;

	vcpu->vcpu_bitmaps.io_bitmap_b = allocate_pool<unsigned __int8*>(PAGE_SIZE);
	if (vcpu->vcpu_bitmaps.io_bitmap_b == nullptr)
	{
		LogError("io bitmap b could not be allocated");
		return false;
	}
	RtlSecureZeroMemory(vcpu->vcpu_bitmaps.io_bitmap_b, PAGE_SIZE);
	vcpu->vcpu_bitmaps.io_bitmap_b_physical = MmGetPhysicalAddress(vcpu->vcpu_bitmaps.io_bitmap_b).QuadPart;

	LogInfo("vcpu entry allocated successfully at %llX", vcpu);

	return true;
}

/// <summary>
/// Initialize vmxon structure
/// </summary>
/// <param name="vcpu"> Pointer to vcpu </param>
/// <returns> status </returns>
bool init_vmxon(__vcpu* vcpu)
{
	__vmx_basic_msr vmx_basic = { 0 };

	vmx_basic.all = __readmsr(IA32_VMX_BASIC);

	if (vmx_basic.vmxon_region_size > PAGE_SIZE)
		vcpu->vmxon = allocate_contignous_memory<__vmcs*>(PAGE_SIZE);

	else
		vcpu->vmxon = allocate_contignous_memory<__vmcs*>(vmx_basic.vmxon_region_size);

	if (vcpu->vmxon == nullptr)
	{
		LogError("vmxon could not be allocated");
		return false;
	}

	vcpu->vmxon_physical = MmGetPhysicalAddress(vcpu->vmxon).QuadPart;
	if (vcpu->vmxon_physical == 0)
	{
		LogError("Could not get vmxon physical address");
		return false;
	}

	RtlSecureZeroMemory(vcpu->vmxon, PAGE_SIZE);
	vcpu->vmxon->header.all = vmx_basic.vmcs_revision_identifier;
	vcpu->vmxon->header.shadow_vmcs_indicator = 0;

	return true;
}

/// <summary>
/// Adjust cr4 and cr0 for turning on vmx
/// </summary>
void adjust_control_registers()
{
	__cr4 cr4;
	__cr0 cr0;
	__cr_fixed cr_fixed;

	cr_fixed.all = __readmsr(IA32_VMX_CR0_FIXED0);
	cr0.all = __readcr0();
	cr0.all |= cr_fixed.split.low;
	cr_fixed.all = __readmsr(IA32_VMX_CR0_FIXED1);
	cr0.all &= cr_fixed.split.low;
	__writecr0(cr0.all);
	cr_fixed.all = __readmsr(IA32_VMX_CR4_FIXED0);
	cr4.all = __readcr4();
	cr4.all |= cr_fixed.split.low;
	cr_fixed.all = __readmsr(IA32_VMX_CR4_FIXED1);
	cr4.all &= cr_fixed.split.low;
	__writecr4(cr4.all);

	__ia32_feature_control_msr feature_msr = { 0 };
	feature_msr.all = __readmsr(IA32_FEATURE_CONTROL);

	if (feature_msr.lock == 0) 
	{
		feature_msr.vmxon_outside_smx = 1;
		feature_msr.lock = 1;

		__writemsr(IA32_FEATURE_CONTROL, feature_msr.all);
	}
}


/// <summary>
/// Initialize logical core and launch virtual machine managed by current vmcs
/// </summary>
/// <param name="guest_rsp"></param>
void init_logical_processor(void* guest_rsp)
{
	unsigned __int64 processor_number = KeGetCurrentProcessorNumber();

	__vcpu* vcpu = g_vmm_context->vcpu_table[processor_number];

	adjust_control_registers();

	if (__vmx_on(&vcpu->vmxon_physical)) 
	{
		LogError("Failed to put vcpu %d into VMX operation.\n", processor_number);
		return;
	}

	vcpu->vcpu_status.vmx_on = true;
	LogInfo("vcpu %d is now in VMX operation.\n", processor_number);

	fill_vmcs(vcpu, guest_rsp);
	vcpu->vcpu_status.vmm_launched = true;

	__vmx_vmlaunch();

	// We should never get here
	
	LogError("Vmlaunch failed");
	ASSERT(FALSE);
	vcpu->vcpu_status.vmm_launched = false;
	vcpu->vcpu_status.vmx_on = false;
	__vmx_off();
}

/// <summary>
/// Initialize and launch vmm
/// </summary>
/// <returns> status </returns>
bool vmm_init()
{
	if (allocate_vmm_context() == false)
		return false;

	//
	// Initalize vcpu for each logical core
	for (unsigned int iter = 0; iter < g_vmm_context->processor_count; iter++) 
	{
		if (init_vcpu(g_vmm_context->vcpu_table[iter]) == false)
			return false;

		if (init_vmxon(g_vmm_context->vcpu_table[iter]) == false)
			return false;

		if (init_vmcs(g_vmm_context->vcpu_table[iter]) == false)
			return false;
	}

	//
	// Call derefered procedure call (DPC) to fill vmcs and launch vmm for every logical core
	KeGenericCallDpc(dpc_broadcast_initialize_guest, 0);
	return true;
}
```

`airhv/airhv-main/airhv/vmm.h`:

```h
#pragma once
/// <summary>
/// Initialize and launch vmm
/// </summary>
/// <returns> status </returns>
bool vmm_init();

/// <summary>
/// Deallocate all structures
/// </summary>
void free_vmm_context();
```

`airhv/airhv-main/airhv/xsave.h`:

```h
#pragma once
union __xcomp_bv 
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 reserved1 : 63;
		unsigned __int64 fromat : 1;
	};
};

union __xstate_bv
{
	unsigned __int64 all;
	struct
	{
		unsigned __int64 x87state : 1;
		unsigned __int64 sse_state : 1;
		unsigned __int64 avx_state : 1;
		unsigned __int64 bndregs_state : 1;
		unsigned __int64 bndcsr_state : 1;
		unsigned __int64 opmask_state : 1;
		unsigned __int64 zmm_hi256_state : 1;
		unsigned __int64 hi16_zmm_state : 1;
		unsigned __int64 pt_state : 1;
		unsigned __int64 pkru_state : 1;
		unsigned __int64 reserved1 : 1;
		unsigned __int64 cet_u_state : 1;
		unsigned __int64 cet_s_state : 1;
		unsigned __int64 hdc_state : 1;
		unsigned __int64 reserved2 : 2;
		unsigned __int64 hwp_state : 1;
		unsigned __int64 reserved3 : 46;
		unsigned __int64 special : 1;
	};
};

struct __xsave_header
{
	__xstate_bv xstate_bv;
	__xcomp_bv xcomp_bv;
	unsigned __int64 reserved[6];
};
```

`airhv/airhv-main/airhvctrl/airhvctrl.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release_Minimal|x64">
      <Configuration>Release_Minimal</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{98E8F109-6A08-4461-A245-42B7CE32A703}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>airhvctrl</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_Minimal|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_Minimal|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_Minimal|x64'">
    <ClCompile>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_Minimal|x64'">
    <ClCompile>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hypervisor_gateway.cpp" />
    <ClCompile Include="log.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="vmintrin.asm" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hypervisor_gateway.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="nt.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`airhv/airhv-main/airhvctrl/airhvctrl.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hypervisor_gateway.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="vmintrin.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hypervisor_gateway.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`airhv/airhv-main/airhvctrl/hypervisor_gateway.cpp`:

```cpp
#include <ntddk.h>
#include "log.h"

#define IOCTL_POOL_MANAGER_ALLOCATE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

extern "C"
{
	void NTAPI KeGenericCallDpc(_In_ PKDEFERRED_ROUTINE Routine, PVOID Context);
	void NTAPI KeSignalCallDpcDone(_In_ PVOID SystemArgument1);
	BOOLEAN NTAPI KeSignalCallDpcSynchronize(_In_ PVOID SystemArgument2);
	bool __vm_call(unsigned __int64 vmcall_reason, unsigned __int64 rdx, unsigned __int64 r8, unsigned __int64 r9);
	bool __vm_call_ex(unsigned __int64 vmcall_reason, unsigned __int64 rdx, unsigned __int64 r8, unsigned __int64 r9, unsigned __int64 r10, unsigned __int64 r11, unsigned __int64 r12, unsigned __int64 r13, unsigned __int64 r14, unsigned __int64 r15);
}

enum vm_call_reasons
{
	VMCALL_TEST,
	VMCALL_VMXOFF,
	VMCALL_EPT_HOOK_FUNCTION,
	VMCALL_EPT_UNHOOK_FUNCTION,
	VMCALL_INVEPT_CONTEXT,
	VMCALL_DUMP_POOL_MANAGER,
	VMCALL_DUMP_VMCS_STATE,
	VMCALL_HIDE_HV_PRESENCE,
	VMCALL_UNHIDE_HV_PRESENCE
};

namespace hvgt
{
	void broadcast_vmoff(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(Dpc);
		UNREFERENCED_PARAMETER(DeferredContext);

		__vm_call(VMCALL_VMXOFF, 0, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	void broadcast_invept_all_contexts(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(Dpc);
		UNREFERENCED_PARAMETER(DeferredContext);
		
		__vm_call(VMCALL_INVEPT_CONTEXT, true, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	void broadcast_invept_single_context(KDPC* Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
	{
		UNREFERENCED_PARAMETER(Dpc);
		UNREFERENCED_PARAMETER(DeferredContext);

		__vm_call(VMCALL_INVEPT_CONTEXT, false, 0, 0);
		KeSignalCallDpcSynchronize(SystemArgument2);
		KeSignalCallDpcDone(SystemArgument1);
	}

	/// <summary>
	/// Turn off virtual machine
	/// </summary>
	void vmoff()
	{
		KeGenericCallDpc(broadcast_vmoff, NULL);
	}

	/// <summary>
	/// Invalidates mappings in the translation lookaside buffers (TLBs) 
	/// and paging-structure caches that were derived from extended page tables (EPT)
	/// </summary>
	/// <param name="invept_all"> If true invalidates all contexts otherway invalidate only single context (currently hv doesn't use more than 1 context)</param>
	void invept(bool invept_all)
	{
		if (invept_all == true) KeGenericCallDpc(broadcast_invept_all_contexts, NULL);
		else KeGenericCallDpc(broadcast_invept_single_context, NULL);
	}

	/// <summary>
	/// Set/Unset presence of hypervisor
	/// </summary>
	/// <param name="value"> If false, hypervisor is not visible via cpuid interface, If true, it become visible</param>
	void hypervisor_visible(bool value)
	{
		if (value == true)
			__vm_call(VMCALL_UNHIDE_HV_PRESENCE, 0, 0, 0);
		else
			__vm_call(VMCALL_HIDE_HV_PRESENCE, 0, 0, 0);
	}

	/// <summary>
	/// Unhook all pages and invalidate tlb
	/// </summary>
	/// <returns> status </returns>
	bool unhook_all_functions()
	{
		bool status = __vm_call(VMCALL_EPT_UNHOOK_FUNCTION, true, 0, 0);
		invept(false);
		return status;
	}

	/// <summary>
	/// Unhook single page and invalidate tlb
	/// </summary>
	/// <param name="page_physcial_address"></param>
	/// <returns> status </returns>
	bool unhook_function(void* function_address)
	{
		bool status = __vm_call(VMCALL_EPT_UNHOOK_FUNCTION, false, (unsigned __int64)function_address, 0);
		invept(false);
		return status;
	}

	/// <summary>
	/// Hook function via ept and invalidates mappings
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="trampoline_address">Address of codecave which is at least 14 bytes in size and in 2GB range of target function address
	/// Use only if function you want to hook uses some relatives jmps/moves in first 14 bytes</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void* trampoline_address, void** origin_function)
	{
		bool status = __vm_call_ex(VMCALL_EPT_HOOK_FUNCTION, (unsigned __int64)target_address, (unsigned __int64)hook_function, (unsigned __int64)trampoline_address, (unsigned __int64)origin_function, 0, 0, 0, 0, 0);
		invept(false);

		return status;
	}

	/// <summary>
	/// Hook function via ept and invalidates mappings
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void** origin_function)
	{
		bool status = __vm_call_ex(VMCALL_EPT_HOOK_FUNCTION, (unsigned __int64)target_address, (unsigned __int64)hook_function, 0, (unsigned __int64)origin_function, 0, 0, 0, 0, 0);
		invept(false);

		return status;
	}

	/// <summary>
	/// Dump info about allocated pools (Use Dbgview to see information)
	/// </summary>
	void dump_pool_manager() 
	{
		__vm_call(VMCALL_DUMP_POOL_MANAGER, 0, 0, 0);
	}

	/// <summary>
	/// Check if we can communicate with hypervisor
	/// </summary>
	/// <returns> status </returns>
	bool test_vmcall()
	{
		return __vm_call(VMCALL_TEST, 0, 0, 0);
	}

	/// <summary>
	/// Send irp to hypervisor driver with information to allocate memory
	/// </summary>
	/// <returns> status </returns>
	bool send_irp_perform_allocation()
	{
		PDEVICE_OBJECT airhv_device_object;
		NTSTATUS status;
		KEVENT event;
		PIRP irp;
		IO_STATUS_BLOCK io_status = { 0 };
		UNICODE_STRING airhv_name;
		PFILE_OBJECT file_object;

		RtlInitUnicodeString(&airhv_name, L"\\Device\\airhv");

		status = IoGetDeviceObjectPointer(&airhv_name, 0, &file_object, &airhv_device_object);

		ObReferenceObjectByPointer(airhv_device_object, FILE_ALL_ACCESS, 0, KernelMode);

		// We don't need this so we instantly dereference file object
		ObDereferenceObject(file_object);

		if (NT_SUCCESS(status) == false)
		{
			LogError("Couldn't get hypervisor device object pointer");
			return false;
		}

		KeInitializeEvent(&event, NotificationEvent, 0);
		irp = IoBuildDeviceIoControlRequest(IOCTL_POOL_MANAGER_ALLOCATE, airhv_device_object, 0, 0, 0, 0, 0, &event, &io_status);

		if (irp == NULL)
		{
			LogError("Couldn't create Irp");
			ObDereferenceObject(airhv_device_object);
			return false;
		}

		else
		{
			status = IofCallDriver(airhv_device_object, irp);

			if (status == STATUS_PENDING)
				KeWaitForSingleObject(&event, Executive, KernelMode, 0, 0);

			ObDereferenceObject(airhv_device_object);
			return true;
		}
	}
}
```

`airhv/airhv-main/airhvctrl/hypervisor_gateway.h`:

```h
#pragma once

namespace hvgt
{
	/// <summary>
	/// Turn off virtual machine
	/// </summary>
	void vmoff();

	/// <summary>
	/// Invalidates mappings in the translation lookaside buffers (TLBs) 
	/// and paging-structure caches that were derived from extended page tables (EPT)
	/// </summary>
	/// <param name="invept_all"> If true invalidates all contexts otherway invalidate only single context (currently hv doesn't use more than 1 context)</param>
	void invept(bool invept_all);

	/// <summary>
	/// Set/Unset presence of hypervisor
	/// </summary>
	/// <param name="value"> If false, hypervisor is not visible via cpuid interface, If true, it become visible</param>
	void hypervisor_visible(bool value);

	/// <summary>
	/// Unhook all pages and invalidate tlb
	/// </summary>
	/// <returns> status </returns>
	bool unhook_all_functions();

	/// <summary>
	/// Unhook single page and invalidate tlb
	/// </summary>
	/// <param name="page_physcial_address"></param>
	/// <returns> status </returns>
	bool unhook_function(void* function_address);

	/// <summary>
	/// Hook function via ept and invalidates mappings
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void** origin_function);

	/// <summary>
	/// <summary>
	/// Hook function via ept and invalidates mappings
	/// </summary>
	/// <param name="target_address">Address of function which we want to hook</param>
	/// <param name="hook_function">Address of function which is used to call original function</param>
	/// <param name="trampoline_address">Address of codecave which is at least 14 bytes in size and in 2GB range of target function address
	/// Use only if function you want to hook uses some relatives jmps/moves in first 14 bytes</param>
	/// <param name="origin_function">Address of function which is used to call original function</param>
	/// <returns> status </returns>
	bool hook_function(void* target_address, void* hook_function, void* trampoline_address, void** origin_function);

	/// <summary>
	/// Check if we can communicate with hypervisor
	/// </summary>
	/// <returns> status </returns>
	bool test_vmcall();

	/// <summary>
	/// Send irp with information to allocate memory
	/// </summary>
	/// <returns> status </returns>
	bool send_irp_perform_allocation();

	/// <summary>
	/// Dump info about allocated pools (Use Dbgview to see information)
	/// </summary>
	void dump_pool_manager();
}
```

`airhv/airhv-main/airhvctrl/log.cpp`:

```cpp
#define _NO_CRT_STDIO_INLINE
#include <ntifs.h>
#include <stdarg.h>
#include <ntstrsafe.h>
#include "log.h"

void LogPrint(__log_type type, const char* fmt, ...)
{
	char* LogType = NULL;
	LARGE_INTEGER SystemTime = {};
	LARGE_INTEGER LocalTime = {};
	TIME_FIELDS TimeFields = {};
	char TimeBuffer[20] = {};
	char MessageBuffer[412] = {};
	char* OutputFormat = NULL;
	char OutputBuffer[512] = {};
	va_list Args = {};

	switch (type)
	{
	case LOG_TYPE_DEBUG:
	{
		LogType = "[DEBUG]";
		break;
	}
	case LOG_TYPE_DUMP:
	{
		LogType = "[DUMP]";
		break;
	}
	case LOG_TYPE_ERROR:
	{
		LogType = "[ERROR]";
		;			break;
	}
	case LOG_TYPE_INFO:
	{
		LogType = "[INFORMATION]";
		break;
	}
	default:
	{
		break;
	}

	}

	KeQuerySystemTime(&SystemTime);
	ExSystemTimeToLocalTime(&SystemTime, &LocalTime);
	RtlTimeToTimeFields(&LocalTime, &TimeFields);

	RtlStringCchPrintfA(
		TimeBuffer,
		sizeof(TimeBuffer),
		"[%02hd:%02hd:%02hd.%03hd]",
		TimeFields.Hour,
		TimeFields.Minute,
		TimeFields.Second,
		TimeFields.Milliseconds);

	va_start(Args, fmt);
	RtlStringCchVPrintfA(MessageBuffer, sizeof(MessageBuffer), fmt, Args);
	va_end(Args);

	OutputFormat = "%s  %s  %s\r\n";

	RtlStringCchPrintfA(
		OutputBuffer,
		sizeof(OutputBuffer),
		OutputFormat,
		TimeBuffer,
		LogType,
		MessageBuffer);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "%s", OutputBuffer);
}
```

`airhv/airhv-main/airhvctrl/log.h`:

```h
#pragma once
#define LogError(format, ...)  \
    LogPrint(LOG_TYPE_ERROR," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogDebug(format, ...)  \
    LogPrint(LOG_TYPE_DEBUG," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogDump(format, ...)  \
    LogPrint(LOG_TYPE_DUMP," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)
#define LogInfo(format, ...)  \
    LogPrint(LOG_TYPE_INFO," [%s:%d] " format , __func__, __LINE__, __VA_ARGS__)

enum __log_type
{
	LOG_TYPE_DEBUG,
	LOG_TYPE_ERROR,
	LOG_TYPE_DUMP,
	LOG_TYPE_INFO
};

void LogPrint(__log_type type, const char* fmt, ...);
```

`airhv/airhv-main/airhvctrl/main.cpp`:

```cpp
#include <ntddk.h>
#include "hypervisor_gateway.h"
#include "utils.h"

extern void* kernel_code_caves[200];

void* nt_create_file_address;

NTSTATUS(*original_nt_create_file)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes,
	PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes,
	ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength
	);


NTSTATUS NTAPI hooked_nt_create_file(
	PHANDLE            FileHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PIO_STATUS_BLOCK   IoStatusBlock,
	PLARGE_INTEGER     AllocationSize,
	ULONG              FileAttributes,
	ULONG              ShareAccess,
	ULONG              CreateDisposition,
	ULONG              CreateOptions,
	PVOID              EaBuffer,
	ULONG              EaLength
)
{
	__try
	{
		ProbeForRead(FileHandle, sizeof(HANDLE), 1);
		ProbeForRead(ObjectAttributes, sizeof(OBJECT_ATTRIBUTES), 1);
		ProbeForRead(ObjectAttributes->ObjectName, sizeof(UNICODE_STRING), 1);
		ProbeForRead(ObjectAttributes->ObjectName->Buffer, ObjectAttributes->ObjectName->Length, 1);
		if (wcsstr(ObjectAttributes->ObjectName->Buffer, L"test.txt") != NULL)
		{
			return STATUS_INVALID_BUFFER_SIZE;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{

	}
	return original_nt_create_file(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength);
}

VOID driver_unload(PDRIVER_OBJECT driver_object)
{
	UNICODE_STRING dos_device_name;

	hvgt::unhook_function(nt_create_file_address);

	RtlInitUnicodeString(&dos_device_name, L"\\DosDevices\\airhvctrl");
	IoDeleteSymbolicLink(&dos_device_name);
	IoDeleteDevice(driver_object->DeviceObject);
}

NTSTATUS driver_create_close(_In_ PDEVICE_OBJECT device_object, _In_ PIRP irp)
{
	UNREFERENCED_PARAMETER(device_object);

	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

NTSTATUS driver_ioctl_dispatcher(_In_ PDEVICE_OBJECT device_object, _In_ PIRP irp)
{
	UNREFERENCED_PARAMETER(device_object);
	unsigned __int32 bytes_io = 0;

	NTSTATUS status = STATUS_SUCCESS;

	irp->IoStatus.Status = status;
	irp->IoStatus.Information = bytes_io;

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return status;
}

extern "C"
NTSTATUS DriverEntry(PDRIVER_OBJECT driver_object, PCUNICODE_STRING reg)
{
	UNREFERENCED_PARAMETER(reg);

	NTSTATUS status = STATUS_SUCCESS;
	PDEVICE_OBJECT device_oject = 0;
	UNICODE_STRING driver_name, dos_device_name;

	RtlInitUnicodeString(&driver_name, L"\\Device\\airhvctrl");
	RtlInitUnicodeString(&dos_device_name, L"\\DosDevices\\airhvctrl");

	status = IoCreateDevice(driver_object, 0, &driver_name, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &device_oject);

	if (status == STATUS_SUCCESS)
	{
		driver_object->MajorFunction[IRP_MJ_CLOSE] = driver_create_close;
		driver_object->MajorFunction[IRP_MJ_CREATE] = driver_create_close;
		driver_object->MajorFunction[IRP_MJ_DEVICE_CONTROL] = driver_ioctl_dispatcher;

		driver_object->DriverUnload = driver_unload;
		driver_object->Flags |= DO_BUFFERED_IO;
		IoCreateSymbolicLink(&dos_device_name, &driver_name);
	}

	UNICODE_STRING routine_name;
	RtlInitUnicodeString(&routine_name,L"NtCreateFile");

	// Find code caves in ntoskrnl.exe
	find_code_caves();

	// Get address of NtCreateFile syscall
	nt_create_file_address = MmGetSystemRoutineAddress(&routine_name);

	// 14 bytes hook using absolute jmp
	//hvgt::hook_function(nt_create_file_address, hooked_nt_create_file, (void**)&original_nt_create_file);

	// 5 bytes hook using relative jmp and code cave
	hvgt::hook_function(nt_create_file_address, hooked_nt_create_file, kernel_code_caves[0], (void**)&original_nt_create_file);

	// Send information to hypervisor to allocate new pools
	hvgt::send_irp_perform_allocation();

	return status;
}
```

`airhv/airhv-main/airhvctrl/nt.h`:

```h
#pragma once
#include <ntddk.h>

typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemExtendedProcessInformation = 6,
    SystemProcessorPerformanceInformation = 8,
    SystemModuleInformation = 11,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemKernelDebuggerInformation = 35,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45,
    SystemFullProcessInformation = 148
} SYSTEM_INFORMATION_CLASS;

extern "C" 
{
    NTKERNELAPI NTSTATUS NTAPI ZwQuerySystemInformation
    (
        IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
        OUT PVOID SystemInformation,
        IN ULONG SystemInformationLength,
        OUT PULONG ReturnLength OPTIONAL
    );
}

typedef struct _SYSTEM_MODULE_ENTRY {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE {
    PVOID 	Reserved1;
    PVOID 	Reserved2;
    PVOID 	ImageBaseAddress;
    ULONG 	ImageSize;
    ULONG 	Flags;
    unsigned short 	Id;
    unsigned short 	Rank;
    unsigned short 	Unknown;
    unsigned short 	NameOffset;
    unsigned char 	Name[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG                       ModulesCount;
    SYSTEM_MODULE_ENTRY         Modules[1];
    ULONG                       Count;
    SYSTEM_MODULE 	            Sys_Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;
```

`airhv/airhv-main/airhvctrl/utils.cpp`:

```cpp
#include <ntddk.h>
#include <ntifs.h>
#include "nt.h"

#define NUMBER_OF_CODE_CAVES 10

void* kernel_code_caves[NUMBER_OF_CODE_CAVES] = { 0 };

bool get_kernel_module(const char* name, unsigned __int64& image_size, void*& image_base)
{
	ULONG bytes;
	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &bytes);
	PSYSTEM_MODULE_INFORMATION mods = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, bytes, 'xxxx');

	RtlSecureZeroMemory(mods, bytes);

	status = ZwQuerySystemInformation(SystemModuleInformation, mods, bytes, &bytes);
	if (NT_SUCCESS(status) == FALSE)
	{
		ExFreePoolWithTag(mods, 'xxxx');
		return FALSE;
	}

	PSYSTEM_MODULE_ENTRY mod = mods->Modules;
	for (ULONG i = 0; i < mods->ModulesCount; i++)
	{
		if (strstr((const char*)mod[i].FullPathName, name) != 0)
		{
			if (mod[i].ImageSize != 0)
			{
				image_size = mod[i].ImageSize;
				image_base = mod[i].ImageBase;
				ExFreePoolWithTag(mods, 'xxxx');
				return true;
			}
		}
	}

	ExFreePoolWithTag(mods, 'xxxx');
	return false;
}

bool find_code_caves()
{
	unsigned __int64 kernel_text_section_size = 0;
	void* kernel_text_section_base = 0;

	if (get_kernel_module("ntoskrnl.exe", kernel_text_section_size, kernel_text_section_base) == false)
		return false;

	kernel_text_section_base = (void*)((unsigned __int64)kernel_text_section_base + 0x1000);

	unsigned __int64 kernel_code_cave_index = 0;
	unsigned __int64 kernel_code_cave_size = 0;

	for (unsigned __int64 memory_location = (unsigned __int64)kernel_text_section_base; memory_location < kernel_text_section_size, kernel_code_cave_index < NUMBER_OF_CODE_CAVES; memory_location++)
	{
		*(unsigned __int8*)memory_location == 0xCC ? kernel_code_cave_size++ : kernel_code_cave_size = 0;

		if (kernel_code_cave_size == 14)
		{
			if (PAGE_ALIGN(memory_location) != PAGE_ALIGN(memory_location - 13))
				continue;

			kernel_code_caves[kernel_code_cave_index] = (void*)(memory_location - 13);
			kernel_code_cave_index++;
		}
	}

	return TRUE;
}
```

`airhv/airhv-main/airhvctrl/utils.h`:

```h
#pragma once
#include <ntddk.h>
bool find_code_caves();
```

`airhv/airhv-main/airhvctrl/vmintrin.asm`:

```asm
.CODE                                                                                                                                                                            

__vm_call proc
    mov rax,0CDAEFAEDBBAEBEEFh
    vmcall
    ret
__vm_call endp

__vm_call_ex proc
        mov  rax,0CDAEFAEDBBAEBEEFh ; Our vmcall indentitifer

        sub rsp, 30h
        mov qword ptr [rsp],       r10
        mov qword ptr [rsp + 8h],  r11
        mov qword ptr [rsp + 10h], r12
        mov qword ptr [rsp + 18h], r13
        mov qword ptr [rsp + 20h], r14
        mov qword ptr [rsp + 28h], r15

        mov r10, qword ptr [rsp + 58h]
        mov r11, qword ptr [rsp + 60h]
        mov r12, qword ptr [rsp + 68h]
        mov r13, qword ptr [rsp + 70h]
        mov r14, qword ptr [rsp + 78h]
        mov r15, qword ptr [rsp + 80h]

        vmcall
        mov r10, qword ptr [rsp]
        mov r11, qword ptr [rsp + 8h]
        mov r12, qword ptr [rsp + 10h]
        mov r13, qword ptr [rsp + 18h]
        mov r14, qword ptr [rsp + 20h]
        mov r15, qword ptr [rsp + 28h]
        add rsp, 30h

        ret
__vm_call_ex endp

END
```