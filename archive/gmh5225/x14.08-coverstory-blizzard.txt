Project Path: arc_gmh5225_x14.08-coverstory-blizzard_vrmpe0r_

Source Tree:

```txt
arc_gmh5225_x14.08-coverstory-blizzard_vrmpe0r_
├── LICENSE
├── README.md
└── src
    ├── Hacks
    │   ├── RunScriptHack.cpp
    │   ├── RunScriptHack.h
    │   ├── WardenLoaderHack.cpp
    │   └── WardenLoaderHack.h
    ├── HacksController.cpp
    ├── HacksController.h
    ├── PB_lib
    │   ├── Delegates.h
    │   ├── HackBase.cpp
    │   ├── HackBase.h
    │   ├── Logger.cpp
    │   ├── Logger.h
    │   ├── Patcher.cpp
    │   ├── Patcher.h
    │   ├── Scanner.cpp
    │   ├── Scanner.h
    │   ├── Warden.cpp
    │   ├── Warden.h
    │   └── _internal.h
    ├── _Base_mod
    │   ├── Base_mod.cpp
    │   └── Base_mod.h
    ├── _Debug_mod
    │   ├── Debug_mod.cpp
    │   └── Debug_mod.h
    ├── _Inject_mod
    │   ├── Inject_mod.cpp
    │   ├── Inject_mod.h
    │   └── Inject_mod.obj
    ├── ntdll.h
    ├── wowhacks.cpp
    ├── wowhacks.h
    ├── wowhacks.sln
    ├── wowhacks.suo
    ├── wowhacks.user
    ├── wowhacks.v11.suo
    ├── wowhacks.vcxproj
    ├── wowhacks.vcxproj.filters
    └── wowhacks.vcxproj.user

```

`LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2014 XakepRU

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
x14.08-coverstory-blizzard
==========================

Материалы к статье "Натягиваем Blizzard Warden"

```

`src/Hacks/RunScriptHack.cpp`:

```cpp
#include "RunScriptHack.h"


bool RunScriptHack::MakePatches()
{
	if (PatchRunScript()!=0) return true;
	else return false;
}
bool RunScriptHack::RemovePatches()
{
	/*do i really need this?*/
	return true;
}

RunScriptHack::RunScriptHack(unsigned int ID): IHackBase(ID)
{
}

// ------------------------------------------------------

DWORD RunScriptHack::PatchRunScript()
{
	/*
		33C9          XOR ECX,ECX
		56            PUSH ESI
		390D A8BA5F01 CMP DWORD PTR DS:[15FBAA8],ECX
		74 44         JE SHORT 01309A84
		83FA 22       CMP EDX,22
	*/

	PBYTE	bCode = (PBYTE) "\xEB"; // JMP SHORT
	Scanner::TPattern Pattern( "\x33\xC9\x56\x39\x0D\xFF\xFF\xFF\xFF\x74\x44\x83\xFA\x22", "x5?4x5");

	DWORD dwProc = (DWORD) Scanner::ScanMem( &Pattern );
	if ( dwProc )
	{
		DWORD dwProcChangeOffset = dwProc+9;

#ifdef _DEBUG
		Logger::OutLog("Script_RunScript proc:0x%.8X, patching...\r\n", dwProc );
#endif
		if ( Patcher::Instance()->MakePatch( (PBYTE)dwProcChangeOffset, bCode, 1 ) ) 
		{
#ifdef _DEBUG
			Logger::OutLog("Script_RunScript patched at 0x%.8X (1 bytes)\r\n", dwProcChangeOffset);
#endif
			return dwProcChangeOffset;
		}
	}
	else
	{
#ifdef _DEBUG
		Logger::OutLog("Script_RunScript proc not found\r\n");
#endif
	}
	return NULL;

}

// ------------------------------------------------------

/*
Поиск по референсу на строку "Usage: JoinBattlefield(id, joinAsGroup)"
00F51992      E8 93803B00   CALL 01309A2A
первый же вызов - функция проверки прав

CPU Disasm
Address   Hex dump          Command                                  Comments
00F5198D  /.  55            PUSH EBP
00F5198E  |.  8BEC          MOV EBP,ESP
00F51990      6A 14         PUSH 14
00F51992      E8 93803B00   CALL 01309A2A
00F51997  |.  59            POP ECX
00F51998  |.  85C0          TEST EAX,EAX
00F5199A  |.  74 4E         JZ SHORT 00F519EA
00F5199C  |.  56            PUSH ESI
00F5199D  |.  8B75 08       MOV ESI,DWORD PTR SS:[EBP+8]
00F519A0  |.  6A 01         PUSH 1                                   ; /Arg2 = 1
00F519A2  |.  56            PUSH ESI                                 ; |Arg1
00F519A3  |.  E8 C848BCFF   CALL 00B16270                            ; \wow.00B16270
00F519A8  |.  59            POP ECX
00F519A9  |.  59            POP ECX
00F519AA  |.  85C0          TEST EAX,EAX
00F519AC  |.  74 2E         JZ SHORT 00F519DC
00F519AE  |.  57            PUSH EDI
00F519AF  |.  6A 01         PUSH 1                                   ; /Arg2 = 1
00F519B1  |.  56            PUSH ESI                                 ; |Arg1
00F519B2  |.  E8 AF49BCFF   CALL 00B16366                            ; \wow.00B16366
00F519B7  |.  6A 00         PUSH 0                                   ; /Arg3 = 0
00F519B9  |.  6A 02         PUSH 2                                   ; |Arg2 = 2
00F519BB  |.  56            PUSH ESI                                 ; |Arg1
00F519BC  |.  8BF8          MOV EDI,EAX                              ; |
00F519BE  |.  E8 3E98B4FF   CALL 00A9B201                            ; \wow.00A9B201
00F519C3  |.  0FB6C8        MOVZX ECX,AL
00F519C6  |.  E8 DBF2FFFF   CALL 00F50CA6                            ; [wow.00F50CA6
00F519CB  |.  0FB6C0        MOVZX EAX,AL
00F519CE  |.  50            PUSH EAX
00F519CF  |.  51            PUSH ECX
00F519D0  |.  57            PUSH EDI
00F519D1  |.  E8 BBF1FFFF   CALL 00F50B91
00F519D6  |.  83C4 20       ADD ESP,20
00F519D9  |.  5F            POP EDI
00F519DA  |.  EB 0D         JMP SHORT 00F519E9
00F519DC  |>  68 88393E01   PUSH OFFSET 013E3988                     ; /Format = "Usage: JoinBattlefield(id, joinAsGroup)"
00F519E1  |.  56            PUSH ESI                                 ; |Arg1
00F519E2  |.  E8 2B5ABCFF   CALL 00B17412                            ; \wow.00B17412

*/
```

`src/Hacks/RunScriptHack.h`:

```h
#ifndef __RUNSCRIPTHACK
#define __RUNSCRIPTHACK

#include "..\PB_lib\HackBase.h"

class RunScriptHack: public IHackBase
{
	DWORD PatchRunScript();
	bool MakePatches();
	bool RemovePatches();
	
public:
	RunScriptHack(unsigned int ID);
};

#endif
```

`src/Hacks/WardenLoaderHack.cpp`:

```cpp
#include "WardenLoaderHack.h"
#include "..\PB_lib\Warden.h"

bool WardenLoaderHack::MakePatches()
{
	if (PatchWardenLoader() != 0)return true;
	else return false;
}
bool WardenLoaderHack::RemovePatches()
{
	/*not implemented*/
	return true;
}

WardenLoaderHack::WardenLoaderHack(unsigned int ID): IHackBase(ID){ }

// ------------------------------------------------------

void WardenModulePatch( LPVOID dwMemBlock, DWORD dwSize)
{
#ifdef _DEBUG
			Logger::OutLog("WARDEN: code section at 0x%.8X (%x bytes)\r\n", dwMemBlock, dwSize);
#endif
	Warden::PatchWardenScan( dwMemBlock, dwSize);
}

__declspec(naked) void WardenLoader_hook( LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD pdwOldProtect ) // executes for every section (VirtualProtect)
{
	__asm 
	{
		push	ebp
		mov		ebp, esp
		pushad
	}
	if ( flNewProtect==PAGE_EXECUTE_READ ) // for code-section
		WardenModulePatch(lpAddress, dwSize);
	__asm
	{
		popad
		pop ebp
		jmp dword ptr[VirtualProtect]
	}
}

DWORD WardenLoaderHack::PatchWardenLoader()
{
	// LoadWardenModule thunk: (можно найти по референсу на "Warden.cpp"/"WardenLoader.cpp")
	// 51            |PUSH ECX                                ; /pOldProtect
	// FF76 08       |PUSH DWORD PTR DS:[ESI+8]               ; |NewProtect
	// 50            |PUSH EAX                                ; |Size
	// 53            |PUSH EBX                                ; |Address
	// FF15 BC329A01 |CALL DWORD PTR DS:[<&KERNEL32.VirtualPr ; \KERNEL32.VirtualProtect <<-- change( call dword ptr[vp_addr], call imm32 wa_hook )
	// F646 08 F0    |TEST BYTE PTR DS:[ESI+8],F0
	// 74 11         |JZ SHORT 016DBE9C
	// FF75 08       |PUSH DWORD PTR SS:[EBP+8]               ; /Size
	// 53            |PUSH EBX                                ; |Base
	// FF15 EC349A01 |CALL DWORD PTR DS:[<&KERNEL32.GetCurren ; |[KERNEL32.GetCurrentProcess
	// 50            |PUSH EAX                                ; |hProcess
	// FF15 B8329A01 |CALL DWORD PTR DS:[<&KERNEL32.FlushInst ; \KERNEL32.FlushInstructionCache
	// FF45 D4       |INC DWORD PTR SS:[EBP-2C]
	// 8B55 E4       |MOV EDX,DWORD PTR SS:[EBP-1C]
	// EB BA         \JMP SHORT 016DBE5E


	PBYTE	bCode = (PBYTE) "\xE8\x90\x90\x90\x90\x90\x90"; // call
	Scanner::TPattern Pattern( "\x51\xFF\x76\x08\x50\x53\xFF\x15\x00\x00\x00\x00\xF6\x46\x08\xF0\x74\x11\xFF\x75\x08\x53\xFF\x15\x00\x00\x00\x00\x50\xFF\x15",
		"x8?4x12?4x3");

	DWORD dwProc = (DWORD) Scanner::ScanMem( &Pattern );
	if ( dwProc )
	{
#ifdef _DEBUG
		Logger::OutLog("WARDEN: LoadWardenModule thunk:0x%.8X, patching...\r\n", dwProc );
#endif
		DWORD dwProcChangeOffset = dwProc+6;
		*((PDWORD)(bCode+1)) = (DWORD)&WardenLoader_hook - ((DWORD)dwProcChangeOffset+5);
		if ( Patcher::Instance()->MakePatch( (PBYTE)dwProcChangeOffset, bCode, 6 ) ) 
		{
#ifdef _DEBUG
			Logger::OutLog("WARDEN: LoadWardenModule patched at 0x%.8X (6 bytes)\r\n", dwProcChangeOffset);
#endif
			return dwProc;
		}
	}
	else
	{
#ifdef _DEBUG
		Logger::OutLog("WARDEN: LoadWardenModule thunk not found\r\n");
#endif
	}
	return NULL;

}

// ------------------------------------------------------

/*
CPU Disasm
Address   Hex dump          Command                                  Comments
016DBF4D  /$  55            PUSH EBP
016DBF4E  |.  8BEC          MOV EBP,ESP
016DBF50  |.  56            PUSH ESI
016DBF51  |.  33F6          XOR ESI,ESI
016DBF53  |.  56            PUSH ESI                                 ; /Arg4
016DBF54  |.  68 85000000   PUSH 85                                  ; |Arg3 = 85
016DBF59  |.  68 F43CA401   PUSH OFFSET 01A43CF4                     ; |Arg2 = ASCII "W32\WardenLoader.cpp"
016DBF5E  |.  6A 04         PUSH 4                                   ; |Arg1 = 4
016DBF60  |.  E8 6E01B8FF   CALL 0125C0D3                            ; \Wow.0125C0D3
016DBF65  |.  3BC6          CMP EAX,ESI
016DBF67  |.^ 74 09         JE SHORT 016DBF72
016DBF69  |.  8BC8          MOV ECX,EAX
016DBF6B  |.  E8 EDFCFFFF   CALL 016DBC5D                            ; [Wow.016DBC5D
016DBF70  |.  8BF0          MOV ESI,EAX
016DBF72  |>  FF75 0C       PUSH DWORD PTR SS:[EBP+0C]               ; /Arg2
016DBF75  |.  8B0E          MOV ECX,DWORD PTR DS:[ESI]               ; |
016DBF77  |.  FF75 08       PUSH DWORD PTR SS:[EBP+8]                ; |Arg1
016DBF7A  |.  E8 19FDFFFF   CALL 016DBC98                            ; \Wow.016DBC98 ; <<LOAD_MODULE>>
016DBF7F  |.  84C0          TEST AL,AL
016DBF81  |.^ 75 12         JNZ SHORT 016DBF95
016DBF83  |.  8BCE          MOV ECX,ESI
016DBF85  |.  E8 97FFFFFF   CALL 016DBF21                            ; [Wow.016DBF21
016DBF8A  |.  56            PUSH ESI                                 ; /Arg1
016DBF8B  |.  E8 7F509AFF   CALL 0108100F                            ; \Wow.0108100F
016DBF90  |.  59            POP ECX
016DBF91  |.  33C0          XOR EAX,EAX
016DBF93  |.^ EB 02         JMP SHORT 016DBF97
016DBF95  |>  8BC6          MOV EAX,ESI
016DBF97  |>  5E            POP ESI
016DBF98  |.  5D            POP EBP
016DBF99  \.  C3            RETN

*/
```

`src/Hacks/WardenLoaderHack.h`:

```h
#ifndef __WARDENLOADERHACK
#define __WARDENLOADERHACK

#include "..\PB_lib\HackBase.h"

class WardenLoaderHack: public IHackBase
{
	DWORD PatchWardenLoader();
	bool MakePatches();
	bool RemovePatches();
	
public:
	WardenLoaderHack(unsigned int ID);
};

#endif
```

`src/HacksController.cpp`:

```cpp
#include "HacksController.h"
#include "Hacks\WardenLoaderHack.h"
#include "Hacks\RunScriptHack.h"
HacksController::HacksController()
{
	HacksList.Add( new WardenLoaderHack(-1) );
	HacksList.Add( new RunScriptHack(0) );
	//HacksList.Add( new ForceInsecureHack(1) );
	//HacksList.Add( new GlobalCooldownHack(2) );
	//HacksList.Add( new LoadAddonHack(3) );
}

void HacksController::Run()
{
	for (int i=0; i<HacksList.Count(); i++ )
		HacksList[i]->Install();
}
```

`src/HacksController.h`:

```h
#ifndef __HACKSCTRL
#define __HACKSCTRL

#include "PB_lib\HackBase.h"
#include "PB_lib\_internal.h"

class HacksController
{
	class __list
	{
		pIHackBase * hacks; // array
		int dwHacks;
	public:
		__list()
		{
			hacks=NULL;
			dwHacks=0;
		}
		inline int Count() { return dwHacks; }
		void Add ( IHackBase *newHack )
		{
			pIHackBase *oldlist = hacks;
			hacks = new pIHackBase[dwHacks +1]; // MEMORY LEAK =)
			memcpy_s(hacks, sizeof(pIHackBase) * (dwHacks +1), oldlist, sizeof(pIHackBase) *dwHacks);
			hacks[dwHacks] = newHack;
			dwHacks++;
		}

		pIHackBase operator [] (int idx)
		{
			if (idx <dwHacks)
				return hacks[idx];
			else 
				return NULL;
		}

	} HacksList;

	void OnLogMsg( void *caller, LogData *ld);
public:
	HacksController(/* view? =) */);
	void Run();
};

#endif
```

`src/PB_lib/Delegates.h`:

```h
#ifndef __DELEGATES
#define __DELEGATES

// Interface for delegate with delegating function with 2 arguments
template<class Out, class Arg, class Arg2> 
class IDelegate
{
public:
	virtual	Out Invoke(Arg, Arg2)=0;
};

// 1 argument
template<class Out, class Arg> 
class IDelegate<Out, Arg, void>
{
public:
	virtual	Out Invoke(Arg)=0;
};

// no arguments (signal)
template<class Out> 
class IDelegate<Out, void, void>
{
public:
	virtual	Out Invoke()=0;
};

// DelegateBase

template<class Object, class Out, class Arg, class Arg2> 
class DelegateBase2Arg: public IDelegate<Out, Arg, Arg2>
{
protected:
	Object* obj;
	typedef Out (Object::*pfunc) (Arg, Arg2);
	pfunc func;

public:
	DelegateBase2Arg(Object* obj, pfunc f)
	{
		this->obj = obj;
		func = f;
	}

	Out Invoke(Arg a, Arg2 b)
	{
		/*
		like this:
			mov ecx, obj
			mov eax, [obj.vtable+offset]
			call eax
		*/
		if (obj)
		(obj->*func)(a, b);
	}
}; 

template<class Arg> 
class EventHandler
{
	IDelegate<void, void*, Arg> *del;
public:
	EventHandler()
	{
		del = NULL;
	}

	void operator =(IDelegate<void, void*, Arg>* cbdel)
	{
		Assign( cbdel );
	}

	void Assign (IDelegate<void, void*, Arg>* cbdel)
	{
		del = cbdel;
		return;
	}

	void operator () (void* caller, Arg arg)
	{
		Invoke(caller, arg);
	}

	void Invoke (void* caller, Arg arg)
	{
		if (del)
		del->Invoke(caller, arg);
	}

	bool Empty() // useless?
	{
		return del==NULL;
	}

	template<class Handler>
	static IDelegate<void, void*, Arg>* CreateHandler(Handler* obj, void (Handler::*pfunc) (void*, Arg) )
	{
		return new DelegateBase2Arg<Handler, void, void*, Arg>(obj, pfunc);
	}
};



/*
	Out Invoke(Arg arg)
	{
		return (obj->*func)(arg);
	}

	Out Invoke(void)
	{
		return (obj->*func)();
	}

template<class Object> 
class Delegate<Object,void,void>: public IDelegate<void, void>
{
protected:
	Object* obj;
	typedef void (Object::*pfunc) ();
	pfunc func;

public:
	Delegate(Object* obj, pfunc f)
	{
		this->obj = obj;
		func = f;
	}

	void Invoke()
	{
		(obj->*func)();
	}
};

template<class Object, class Arg> 
Delegate<Object,void,Arg>* CreateDelegate(Object* obj, void (Object::*pfunc) (Arg arg))
{
	return new Delegate<Object, void, Arg>(obj, pfunc);
}

template<class Object> 
Delegate<Object,void,void>* CreateDelegate(Object* obj, void (Object::*pfunc) ())
{
	return new Delegate<Object, void, void>(obj, pfunc);
}

template<class ArgClass> class CallBackFunc
{
	IDelegate<void, ArgClass> *del;

public:
	CallBackFunc()
	{
		del = 0;
	}

	void operator =(IDelegate<void, ArgClass>* cbdel)
	{
		del = cbdel;
		return;
	}

	void operator () (ArgClass arg)
	{
		if (del)
		del->Invoke(arg);
	}
};

template<> class CallBackFunc<void>
{
	IDelegate<void, void> *del;

public:
	CallBackFunc()
	{
		del = 0;
	}

	void operator =(IDelegate<void, void>* cbdel)
	{
		del = cbdel;
		return;
	}

	void operator () (void)
	{
		if (del)
		del->Invoke();
	}
};
*/

#endif
```

`src/PB_lib/HackBase.cpp`:

```cpp
#include "HackBase.h"

IHackBase::IHackBase(unsigned int ID)
{
	id = ID;
	state = notinstalled;
}

void IHackBase::pulseState()
{
	HackStateChangedHandler( this, id );
}

unsigned int IHackBase::GetID()
{
	return id;
}

void IHackBase::Install()
{
	if ( state!=installed) 
	{
		if (MakePatches())
			state = installed;
		else
			state = error;
		pulseState();
	}
}

void IHackBase::Uninstall()
{
	if (state==installed)
	{
		RemovePatches();
	}
	state = notinstalled;
	pulseState();
}

```

`src/PB_lib/HackBase.h`:

```h
#ifndef __HACKBASE
#define __HACKBASE

#include "_internal.h"

typedef enum {installed, notinstalled, error} enHackState;

typedef class IHackBase abstract
{
protected:
	unsigned int id;
	enHackState state;
	virtual bool MakePatches() =0;
	virtual bool RemovePatches() =0;

	void pulseState();

public:
	IHackBase(unsigned int ID);
	EventHandler<unsigned int> HackStateChangedHandler; // StateChanged(this, this.ID)

	unsigned int GetID();
	enHackState GetState() {return state;}
	void Install(); // patches
	void Uninstall();
} *pIHackBase;

#endif
```

`src/PB_lib/Logger.cpp`:

```cpp
#include "Logger.h"

// dark legacy =/
extern PCHAR xvprintf( PCHAR szFmtStr, va_list arg_list );
extern VOID	xfree( LPVOID lpAddr );

// ------------------------------------------------------

LogData::LogData( char* szMsg, bool isEx): msg(szMsg), isException(isEx) {}

// ------------------------------------------------------

EventHandler<pLogData> Logger::LogMessageHandler;

// ------------------------------------------------------

void Logger::OutLog( char* szFmtStr, ... )
{
	va_list arg_list;
	va_start( arg_list, szFmtStr );
		
	PCHAR szMsg = xvprintf( szFmtStr, arg_list );
	Out( szMsg, false );
	xfree(szMsg);
}
// ------------------------------------------------------

void Logger::OutEx( char* szFmtStr, ... )
{
	va_list arg_list;
	va_start( arg_list, szFmtStr );
		
	PCHAR szMsg = xvprintf( szFmtStr, arg_list );
	Out( szMsg, true );
	xfree(szMsg);
}
// ------------------------------------------------------

void Logger::Out( char* msg, bool ex )
{
	pLogData tempdata = new LogData( msg, ex );
	LogMessageHandler( NULL, tempdata );
	delete tempdata;
}
```

`src/PB_lib/Logger.h`:

```h
#ifndef __LOGGER
#define __LOGGER

#include <Windows.h>
#include "Delegates.h"

typedef class LogData
{
public:
	const char * msg;
	const bool isException;

	LogData( char*, bool );
} *pLogData;

class Logger
{
public:
	static EventHandler<pLogData> LogMessageHandler; // [Handler <= HacksManager.Log], for example
	static void OutLog( char* szFmtStr, ... );
	static void OutEx( char* szFmtStr, ... );
private:
	static void Out( char* msg, bool ex );
};

#endif

```

`src/PB_lib/Patcher.cpp`:

```cpp
#include "Patcher.h"

extern LPVOID 	xalloc( DWORD dwSize );
extern LPVOID 	xrealloc( LPVOID lpAddr, DWORD dwSize );
extern VOID	xfree( LPVOID lpAddr );
 
Patcher* Patcher::instance = NULL;

// ------------------------------------------------------

Patcher::_Patcher() 
{
	dwPatches = 0;
	Patches = NULL;
}

// ------------------------------------------------------

_Patcher* Patcher::Instance()
{
	if (instance==NULL) instance = new Patcher();
	return instance;
}

// ------------------------------------------------------

void Patcher::ResetInstance() // for new process
{
	instance=NULL;
}

// ------------------------------------------------------

DWORD Patcher::NewPatch ( DWORD dwAddr, DWORD dwSize )
{
	pPatch pPatchStruc = NULL;
	BOOL flAdded = false;

	CheckPatches();

	// already patched?
	int idx = FindPatch(dwAddr);
	if (idx)
		RemovePatchByIndex( idx ); // restore orig data before patching
	else
		Patches = (pPatch) xrealloc( Patches, (dwPatches+1) * sizeof(Patch));	

	pPatchStruc  = &Patches[dwPatches]; // last element
	pPatchStruc->addr = dwAddr;
	pPatchStruc->len = dwSize;
	memcpy( pPatchStruc->org , (PVOID) dwAddr, dwSize );
	dwPatches++;
	return dwPatches;
}

// ------------------------------------------------------

DWORD Patcher::GetAllPatches( pPatch & pPatches )
{
	if (  dwPatches )
	{
		pPatches = Patches; // direct access
	}
	return dwPatches;
}

// ------------------------------------------------------

int	Patcher::FindPatch( DWORD dwAddr )
{
	for (unsigned int idx=0; idx< dwPatches; idx++)
	{
		if ( Patches[idx].addr == dwAddr ) // found
		{
			return idx;
		}
	}
	return 0;
}

// ------------------------------------------------------

BOOL	Patcher::RemovePatch(DWORD dwAddr)
{
	bool found = false;
	int idx = FindPatch(dwAddr);
	 
	if (idx)
	{
		RemovePatchByIndex(idx);
		found = true;
	}
	return found;
}

// ------------------------------------------------------

void	Patcher::RemovePatchByIndex(DWORD idx)
{
	if (idx>=0 && idx <dwPatches) // in range of array
	{
		DWORD addr = Patches[idx].addr;
		DWORD len = Patches[idx].len;
		if (!IsBadWritePtr((PVOID)addr, len) )
		{
			memcpy( (PVOID)addr, Patches[idx].org, len);
		}

		// shift array left, but dont reallocate (small mem-leak) -->> this trick is used in 'AddPatch' 
		for ( DWORD i = idx+1; i < dwPatches; i++) 
			memcpy( (PVOID)&Patches[i-1], (PVOID)&Patches[i], sizeof(Patch));

		dwPatches--;
	}
}

// ------------------------------------------------------

VOID Patcher::CheckPatches() // removes unaccessible patches
{
	if ( dwPatches )
	{
		DWORD idx = 0;
		while ( idx < dwPatches )
		{
			if ( IsBadWritePtr((PVOID)Patches[idx].addr, Patches[idx].len) )
			{
				RemovePatchByIndex(idx);
			}
			else
				idx++;
		}
	}
}

// ------------------------------------------------------

VOID Patcher::RemoveAllPatches()
{
	if ( dwPatches )
	{
		for (DWORD i =dwPatches; i>0; i-- ) // backward
		{
			RemovePatchByIndex(i-1);
		}

		xfree(Patches);
		Patches = NULL;
	}
}

// ------------------------------------------------------

void Patcher::SafeSuspendAll(PSYSTEM_THREAD pThreads, DWORD dwThreads, DWORD dwBlockAddr, DWORD dwBlockSize)
{
	if ( pThreads == NULL ) return;
	DWORD dwCurrentTID = GetCurrentThreadId();
	
	for (unsigned int i = 0; i<dwThreads ; i++)
	{
		pThreads[i].ClientId.UniqueProcess = 0;	// use this field to handle the only threads are to resume
		if ( pThreads[i].ClientId.UniqueThread != dwCurrentTID )
		{
			if ( HANDLE hThrd = OpenThread(THREAD_SUSPEND_RESUME, 0, pThreads[i].ClientId.UniqueThread) )
			{
				while ( SuspendThread( hThrd ) != -1 )
				{
					pThreads[i].ClientId.UniqueProcess = (DWORD) hThrd;// dont care

					CONTEXT ctx;
					if ( GetThreadContext( hThrd, &ctx) )
					if ( ctx.Eip >= dwBlockAddr && ctx.Eip <= dwBlockSize )
					{
						ResumeThread( hThrd );
						Sleep(0); // switch
						continue; // try again
					}
					
					break;
				}
			}
		}
	}
}

// ------------------------------------------------------

void Patcher::WakeUP(PSYSTEM_THREAD pThreads, DWORD dwThreads)
{
	if ( pThreads )
	{
		for (unsigned int i = 0; i<dwThreads ; i++)
		{
			if ( pThreads[i].ClientId.UniqueProcess )
			{
				ResumeThread( (HANDLE) pThreads[i].ClientId.UniqueProcess );
				CloseHandle( (HANDLE) pThreads[i].ClientId.UniqueProcess );
			}
		}
	}
}

// ------------------------------------------------------

DWORD GetThreadsInfo (PSYSTEM_THREAD &pThreads, PSYSTEM_PROCESS_INFORMATION &pProcInfo)
{
	DWORD dwThreads = 0;
	pProcInfo = (PSYSTEM_PROCESS_INFORMATION) 
												QueryInformation( SystemProcessInformation );
	DWORD dwCurrentPID = GetCurrentProcessId();

	if ( pProcInfo )
	{
		for ( PSYSTEM_PROCESS_INFORMATION pCurrentProc = pProcInfo;;)
		{
			if (pCurrentProc->uUniqueProcessId == dwCurrentPID)
			{
				dwThreads = pCurrentProc->uThreadCount;
				pThreads = pCurrentProc->Threads;
			}

			if (pCurrentProc->uNext == 0)
				break;

			// find the address of the next process structure
			pCurrentProc = (PSYSTEM_PROCESS_INFORMATION)(((LPBYTE)pCurrentProc) + pCurrentProc->uNext);
		}
	}
	return dwThreads;
}

// ------------------------------------------------------

BOOL Patcher::MakePatch( PBYTE pAddr, PBYTE pData, DWORD dwDataSize )
{
	BOOL fRes = false;
	PSYSTEM_PROCESS_INFORMATION pProcInfo;
	PSYSTEM_THREAD pThreads;
	DWORD dwThreads;

	dwThreads = GetThreadsInfo(pThreads, pProcInfo);
	SafeSuspendAll( pThreads, dwThreads, (DWORD)pAddr, dwDataSize);

	DWORD dwOldp;
	if ( VirtualProtect( pAddr, dwDataSize, PAGE_EXECUTE_READWRITE, &dwOldp) && NewPatch( (DWORD)pAddr, dwDataSize ) )
	{
		memcpy( pAddr, pData, dwDataSize );
		fRes = true;
	}

	WakeUP( pThreads, dwThreads);
	xfree ( pProcInfo );
	return fRes;
}

// ------------------------------------------------------
```

`src/PB_lib/Patcher.h`:

```h
#ifndef __PATCHER
#define __PATCHER

#include "_internal.h"

typedef struct _Patch
{
	DWORD addr;
	DWORD len;
	BYTE  org[32];
} Patch, *pPatch ;

typedef class _Patcher
{
	DWORD dwPatches;
	pPatch Patches;

	DWORD	NewPatch ( DWORD dwAddr, DWORD dwSize );
	void	RemovePatchByIndex(DWORD idx);
	void	SafeSuspendAll(PSYSTEM_THREAD pThreads, DWORD dwThreads, DWORD dwBlockAddr, DWORD dwBlockSize);
	void	WakeUP(PSYSTEM_THREAD pThreads, DWORD dwThreads);

	static _Patcher*instance;
	_Patcher();
public:
	static  _Patcher* Instance();
	static  void ResetInstance();
	
	DWORD	GetAllPatches ( pPatch & pPatches );
	int		FindPatch( DWORD dwAddr );
	BOOL	RemovePatch(DWORD dwAddr);
	VOID	CheckPatches(); // base check for 'readable' address pointed by dwAddr
	VOID	RemoveAllPatches();

	BOOL	MakePatch( PBYTE pAddr, PBYTE pData, DWORD dwDataSize );

} Patcher, *pPatcher;

#endif
```

`src/PB_lib/Scanner.cpp`:

```cpp
#include "_internal.h"
#include "Scanner.h"

// ------------------------------------------------------

PVOID Scanner::FindPattern ( PVOID pMemBase, DWORD dwSize, pTPattern pPattern)
{
	DWORD dwRemain = dwSize;
	PBYTE pMem = (PBYTE)pMemBase, pMemCmp;
	BOOL fFound = false;

	while ( dwRemain >= pPattern->dwSequenceLen )
	{
		PBYTE pBytesToCompare = pPattern->pByteSequence;
		pMemCmp = pMem;
		
		for (DWORD i=0; pPattern->pPatternString[i] ; i++ )
		{
			bool skip = false;
			DWORD len = 0;
			switch (pPattern->pPatternString[i])
			{
				case '?':
					skip = true;
				case 'x':
					i++; // little optimization, may cause bug when pattern looks like "xx1"
					len = atoi( pPattern->pPatternString + i);
			}
			if (len)
			{
				if (!skip)
				fFound = !memcmp( pMemCmp, pBytesToCompare, len );

				pBytesToCompare += len;
				pMemCmp += len;
			}
			if (!fFound) break;
		}
		if (fFound) return pMem;

		pMem++;
		dwRemain--;
	}
	return 0;
}

// ------------------------------------------------------

PVOID Scanner::ScanMem( pTPattern pPattern )
{
     DWORD dwBase = 0x10000, dwProcessing;
     MEMORY_BASIC_INFORMATION Mem;
     PVOID pResult = 0;

	 do {
		if  ( dwProcessing = VirtualQuery( (PVOID) dwBase, &Mem, sizeof (MEMORY_BASIC_INFORMATION)) )
		{
			/*DbgOut("dwBase:%x, Alloc:%x, Base:%x, Size:%x, Aprotect:%x, Protect:%x, State:%x", 
				dwBase, (DWORD)Mem.AllocationBase, (DWORD) Mem.BaseAddress, Mem.RegionSize, 
				Mem.AllocationProtect, Mem.Protect, Mem.State);
*/
			// Only Executable&Readable memory ( 0x20 <= m <= 0x80 ) PAGE_GUARD
			if ( Mem.State == MEM_COMMIT && Mem.Protect<=0x80 && Mem.Protect>=0x20 ) 
				pResult = FindPattern( Mem.BaseAddress, Mem.RegionSize, pPattern );
			dwBase = Mem.RegionSize + (DWORD) Mem.BaseAddress ;
		}
	 } while ( dwProcessing && dwBase < 0x7C900000 && (!pResult || /* pattern found itself */ pResult==pPattern->pByteSequence) );

     return pResult;
}

// ------------------------------------------------------
```

`src/PB_lib/Scanner.h`:

```h
#ifndef __SCANNER
#define __SCANNER

namespace Scanner
{
	typedef class _Pattern 
	{
		public:
		PBYTE pByteSequence;
		DWORD dwSequenceLen;
		PCHAR pPatternString;

		_Pattern(PCHAR b, DWORD l, PCHAR p){
			pByteSequence = (PBYTE)b;
			dwSequenceLen = l;
			pPatternString = p;
		};
		_Pattern(PCHAR b, PCHAR p){ 
			pByteSequence = (PBYTE)b;
			dwSequenceLen = 0;
			pPatternString = p;

			// calc actual lenght
			for (DWORD i=0; pPatternString[i] ; i++ )
			{
				DWORD len = 0;
				switch (pPatternString[i])
				{
					case 'x':
					case '?':
						i++;
						len = atoi( pPatternString + i);
				}
				dwSequenceLen += len;
			}
		};
	} *pTPattern, TPattern;

	PVOID	ScanMem( pTPattern pszPattern );
	PVOID	FindPattern ( PVOID pMemBase, DWORD dwSize, pTPattern pPattern);
}

#endif

```

`src/PB_lib/Warden.cpp`:

```cpp
#include "Warden.h"
#include "Patcher.h"

// ------------------------------------------------------

 void __cdecl	Warden::ProcessScan( PBYTE pOutBuff, DWORD dwAddr, DWORD dwSize ) // zomg-hekk-code
{
#ifdef _DEBUG
	Logger::OutLog("WARDEN: Scan at: 0x%.8X (%d bytes)\r\n", dwAddr, dwSize );
#endif

	pPatcher p = Patcher::Instance();
	pPatch PatchList, pCurrentPatch = NULL;
	DWORD	dwPatches = p->GetAllPatches( PatchList );
	
	/* Forbid `warden-scanner` read patched data

	   .. - original bytes
	   ,, - patched	
	   `` - scanned

	   ....,,,,,,,,...................  (a)
	     ````````````````
	   ....,,,,,,,,...................  (b)
	      ```````
	   ....,,,,,,,,...................  (c)
	           ````
	   ....,,,,,,,,...................  (d)
	           ````````
	*/
	for ( unsigned int i=0; i< dwPatches; i++)
		// is here attempt to read a patched data?
		if ( (PatchList[i].addr - dwAddr < dwSize) /* (a) + (b) */ || 
			( dwAddr - PatchList[i].addr < PatchList[i].len ) /* (b) + (c) */ )
		{
			pCurrentPatch = &(PatchList[i]);
			break;
		}

	// copy
	if (!pCurrentPatch)
		memcpy(pOutBuff, (PVOID)dwAddr, dwSize);
	else
	{
		for ( unsigned int i=0; i< dwSize; i++)
		{
			unsigned int delta = dwAddr+i - pCurrentPatch->addr;
			byte* pCurrent;
			if( delta < pCurrentPatch->len ) // patched byte?
			{
				pCurrent = pCurrentPatch->org + delta;
			}
			else
				pCurrent = (PBYTE)(dwAddr+i);

			pOutBuff[i] = *pCurrent; 
		}
	
#ifdef _DEBUG
		Logger::OutLog("WARDEN: PREVENTED Scan at: 0x%.8X (%d bytes) with Patch at 0x%.8X\r\n", dwAddr, dwSize, pCurrentPatch->addr );
#endif
	}
}

// ------------------------------------------------------

bool Warden::PatchWardenScan( PVOID pMemBase, DWORD dwSize )
{	// WARDEN SCAN PROC
	// 56                     push    esi
	// 57                     push    edi
	// FC                     cld
	// 8B5424 14              mov     edx, dword ptr ss:[esp+14]
	// 8B7424 10              mov     esi, dword ptr ss:[esp+10]
	// 8B4424 0C              mov     eax, dword ptr ss:[esp+C]
	// 8BCA                   mov     ecx, edx
	// 8BF8                   mov     edi, eax
	// C1E9 02                shr     ecx, 2
	// 74 02                  je      short 
	// F3:A5                  rep     movs dword ptr es:[edi], dword ptr ds:[esi]
	// B1 03                  mov     cl, 3
	// 23CA                   and     ecx, edx
	// 74 02                  je      short 
	// F3:A4                  rep     movs byte ptr es:[edi], byte ptr ds:[esi]
	// 5F                     pop     edi
	// 5E                     pop     esi
	// C3                     ret
	bool	fResult = false;
	PBYTE	bCode = (PBYTE) "\x68\xAA\xAA\xAA\xAA\xC3"; // push 0xAAAAAAAA; retn
	Scanner::TPattern WardenPattern ("\x56\x57\xFC\x8B\x54\x24\x14\x8B\x74\x24\x10\x8B\x44\x24\x0C\x8B\xCA\x8B\xF8\xC1\xE9\x02\x74\x02\xF3\xA5" \
								  "\xB1\x03\x23\xCA\x74\x02\xF3\xA4\x5F\x5E\xC3", "x37");
	DWORD WardenProc;
	if (pMemBase)
		WardenProc = (DWORD) Scanner::FindPattern( pMemBase, dwSize, &WardenPattern );
	else
		WardenProc = (DWORD) Scanner::ScanMem( &WardenPattern );
	if ( WardenProc )
	{
#ifdef _DEBUG
		Logger::OutLog("Warden::Scan proc:0x%.8x, patching...\r\n", WardenProc);
#endif
		*((PDWORD)(bCode+1)) = (DWORD)&ProcessScan;
		if ( Patcher::Instance()->MakePatch( (PBYTE)WardenProc, bCode, 6 ) ) 
		{
#ifdef _DEBUG
		Logger::OutLog("Warden::Scan patched at 0x%.8x (6 bytes)\r\n", WardenProc);
#endif
			fResult = true;
		}
	}
	else
	{
#ifdef _DEBUG
		Logger::OutLog("Warden::Scan proc not found\r\n");
#endif
	}

	return fResult;
}

// ------------------------------------------------------
```

`src/PB_lib/Warden.h`:

```h
#ifndef __WARDEN
#define __WARDEN

#include "HackBase.h"

class Warden
{
public:
	static	void __cdecl	ProcessScan( PBYTE pOut, DWORD dwAddr, DWORD dwSize );
	static	bool	PatchWardenScan( PVOID pMemBase=NULL, DWORD dwSize=0 );
};

#endif
```

`src/PB_lib/_internal.h`:

```h
#define _CRT_SECURE_NO_WARNINGS
#define _WIN32_WINNT 0x0501
#pragma warning( disable : 4005 ) // fuck it
#include <Windows.h>
#include <Ntsecapi.h>
#include "..\ntdll.h"
#include "Delegates.h"

#include "Patcher.h"
#include "Scanner.h"
#include "Logger.h"

PVOID extern QueryInformation ( SYSTEMINFOCLASS dwClass );

```

`src/_Base_mod/Base_mod.cpp`:

```cpp
#include <windows.h>
#include <stdio.h>
#include "Base_mod.h"

#ifdef MEM_DEBUG
DWORD dwMemAlloc = 0;
#endif

// ---------------------------------------------------
// RDTSC
// ---------------------------------------------------



// ---------------------------------------------------
// Memory managment functions
// ---------------------------------------------------

LPVOID	xalloc( DWORD dwSize)
{
	//LPVOID lpRet = VirtualAlloc( 0, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE ); ,,,,,, HEAP_ZERO_MEMORY
	LPVOID lpRet = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize );
	//if ( lpRet ) memset( lpRet, 0, dwSize );
	#ifdef MEM_DEBUG
	dwMemAlloc += xsize( lpRet );
	#endif
	
	return lpRet;
}
// ---------------------------------------------------

LPVOID	xrealloc( LPVOID lpAddr, DWORD dwSize )
{
	LPVOID lpNewAddr;

	if ( lpAddr) 
	{
		#ifdef MEM_DEBUG
			dwMemAlloc -= xsize( lpAddr );
		#endif

		lpNewAddr = HeapReAlloc( GetProcessHeap(), 0, lpAddr, dwSize );
		if ( !lpNewAddr ) 
		{
			xfree( lpAddr );
		}
		else
		{
			//memset( lpNewAddr, 0, dwSize );
			#ifdef MEM_DEBUG
				dwMemAlloc += dwSize;
			#endif
		}
	}
	else
		lpNewAddr = xalloc ( dwSize );

	return lpNewAddr;
}
// ---------------------------------------------------

DWORD	xsize( LPVOID lpAddr )
{
	int iSize = 0;
	if ( lpAddr)
	{
		iSize = HeapSize( GetProcessHeap(), 0, lpAddr);
		//MEMORY_BASIC_INFORMATION MemInfo;
		//VirtualQuery(lpAddr, &MemInfo, sizeof(MEMORY_BASIC_INFORMATION));
		//return MemInfo.RegionSize;
		if (iSize == -1)iSize = 0;
	}
	return iSize;
}
// ---------------------------------------------------
VOID 	xfree( LPVOID lpAddr )
{
	#ifdef MEM_DEBUG
	dwMemAlloc -= xsize( lpAddr );
	#endif

	HeapFree( GetProcessHeap(), 0, lpAddr);
	//VirtualFree(lpAddr, 0, MEM_RELEASE);
}
// ---------------------------------------------------

DWORD	xmem( )
{
	#ifdef MEM_DEBUG
		return dwMemAlloc;
	#else
		return 0;
	#endif
		
}
// ---------------------------------------------------

// ---------------------------------------------------
// Dynamic buffered formatted output
// ---------------------------------------------------

PCHAR xvprintf( PCHAR szFmtStr, va_list arg_list )
{
	PCHAR buff = 0;
	DWORD size = 0;
	BOOL  flag = false;

	while ( !flag )
	{
		if ( size ) 
		{
			buff = (char*) xalloc( ++size );
			flag = true;
		}
		size = _vsnprintf(buff, size, szFmtStr, arg_list);
	}

	return buff;
}
// ---------------------------------------------------

PCHAR xprintf( PCHAR szFmtStr, ... )
{
	va_list arg_list;
	va_start( arg_list, szFmtStr );
		
	return xvprintf( szFmtStr, arg_list );
}
// ---------------------------------------------------
```

`src/_Base_mod/Base_mod.h`:

```h
#ifndef BASE_MOD
#define BASE_MOD

#define MEM_DEBUG
// memory managment
LPVOID 	xalloc( DWORD dwSize );
LPVOID 	xrealloc( LPVOID lpAddr, DWORD dwSize );
DWORD 	xsize( LPVOID lpAddr );
VOID	xfree( LPVOID lpAddr );

// i/o
PCHAR	xvprintf( PCHAR szFmtStr, va_list arg_list );
PCHAR	xprintf( PCHAR szFmtStr, ... );

#endif
```

`src/_Debug_mod/Debug_mod.cpp`:

```cpp
#include <windows.h>
#include <winnt.h>
#include <stdio.h>
#include "Debug_mod.h"
#include "../_Base_mod/Base_mod.h"

#if DBG_OUT == DBG_FILE 
#define DEBUG_FILE_LOG "e:\\dbg_log.txt"
	CRITICAL_SECTION dbg_logfile;
	BOOL dbg_section_initialized = false;
#endif

#if DBG_OUT == DBG_BUFF 
	PCHAR dbg_log_buff = NULL;
#endif

// ---------------------------------------------------
// Debug Logging function
// ---------------------------------------------------

void DbgOut( char * msg, ... )
{
#ifdef ALLOW_DEBUG_OUTPUT

	char *buff, *obuff;
	SYSTEMTIME SystemTime;
	va_list mylist;

	GetSystemTime( &SystemTime );

	va_start( mylist, msg );
 	buff = xvprintf(msg, mylist);

	obuff = xprintf( "%02d:%02d:%02d %03d, Thrd:%05x, %s\r\n", 
			SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds, 
			GetCurrentThreadId(), buff );

	#if DBG_OUT == DBG_STRINGS // debug output into debug strings

		OutputDebugStringA( obuff );

	#elif DBG_OUT == DBG_FILE // debug output into file log

		HANDLE hDbgFile;
		DWORD dwWritten;

		if (!dbg_section_initialized) 
		{
			InitializeCriticalSection( &dbg_logfile );
			dbg_section_initialized = true;
		}

		EnterCriticalSection ( &dbg_logfile );		
		hDbgFile = CreateFile( DEBUG_FILE_LOG, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
									OPEN_ALWAYS, 0, NULL );
		SetFilePointer( hDbgFile, 0, 0, FILE_END );
		WriteFile( hDbgFile, obuff, lstrlen(obuff), &dwWritten, 0 );
		CloseHandle( hDbgFile );
		LeaveCriticalSection( &dbg_logfile );

	#elif DBG_OUT == DBG_BUFF // debug output into global buffer
		
		DWORD dwMsgLen = lstrlen(obuff);

		if ( !dbg_log_buff )
			dbg_log_buff = (PCHAR) xalloc ( dwMsgLen + 1 );
		else
			dbg_log_buff = (PCHAR) xrealloc( dbg_log_buff, lstrlen(dbg_log_buff) + dwMsgLen + 1 );

		lstrcat( dbg_log_buff, obuff);
		
	#endif

	xfree( buff );
	xfree( obuff );

#endif
}

// ---------------------------------------------------
```

`src/_Debug_mod/Debug_mod.h`:

```h
#ifndef DEBUG_MOD
#define DEBUG_MOD

#define _CRT_SECURE_NO_WARNINGS

// enable debug information (main switch)
#define ALLOW_DEBUG_OUTPUT

// types of debug output
#define DBG_STRINGS 0
#define DBG_FILE	1
#define DBG_BUFF	2

// select type
#define DBG_OUT DBG_STRINGS

void DbgOut( char * msg, ... );

#endif
```

`src/_Inject_mod/Inject_mod.cpp`:

```cpp
#include "../PlayBuddy.h"

DWORD RvaToOffset(DWORD RVA, DWORD pFileMap);

/*	=================================
	== NtQuerySystemInformation wrap
	=================================	*/

PVOID QueryInformation ( SYSTEMINFOCLASS dwClass )
{
	PVOID pResult = NULL;
	DWORD dwLength = 0;
	NTSTATUS res;

	// Enumerate ALL processes in system and infect it
	do {
		dwLength += 0x8000;
		pResult = xrealloc( pResult, dwLength );

		res = NtQuerySystemInformation(dwClass, pResult, dwLength, NULL);
	} while (res == STATUS_INFO_LENGTH_MISMATCH);

	if ( res )
	{
		// error
		xfree( pResult );
		pResult = NULL;
	}

	return pResult;
}

// ------------------------------------------------------
// Injecting in process specifed by PID or ProcName
// If PID not NULL process will selected by PID and ProcName can be NULL, 
// else try to find process specifed by ProcName
// Both ProcName and PID cannot be NULL
// ------------------------------------------------------

HANDLE Inject(PWCHAR ProcName, DWORD PID, PTHREAD_START_ROUTINE RemoteProc, DWORD Base, HANDLE hThread)
{
	IMAGE_DOS_HEADER * dos;
	IMAGE_NT_HEADERS *pe;
	DWORD SizeOfImage, tmp;
	PVOID NewBase, NewImage;
	HANDLE Proc;
		
	if (PID == NULL) PID = FindProcess(ProcName);
	
	if (Base == NULL) Base = (DWORD) GetModuleHandle(NULL);

	dos = (IMAGE_DOS_HEADER *) Base;
	pe = (IMAGE_NT_HEADERS *) ((DWORD) dos->e_lfanew + (DWORD) dos);

	SizeOfImage = pe->OptionalHeader.SizeOfImage;

	Proc = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD, 0, PID);	
	NewBase = VirtualAllocEx(Proc, NULL, SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	if (Proc && NewBase)
	{	
		NewImage = VirtualAlloc(NULL, SizeOfImage, MEM_COMMIT, PAGE_READWRITE);

		// MemCpy
		__asm
		{
			pushad

			cld
			mov		esi, Base
			mov		edi, NewImage
			mov		ecx, SizeOfImage
			rep		movsb

			popad
		}

		// Fix-up offsets
		FixBase(NewImage, (DWORD)NewBase - Base); 
		WriteProcessMemory(Proc, NewBase, NewImage, SizeOfImage, &tmp);
		VirtualFree(NewImage, 0, MEM_RELEASE);

		RemoteProc = (PTHREAD_START_ROUTINE) ((DWORD) RemoteProc - Base + (DWORD) NewBase);
		CONTEXT ctx;
		ctx.ContextFlags = CONTEXT_FULL;
		if ( !hThread )
		{
			hThread = CreateRemoteThread(Proc, NULL, NULL, RemoteProc, 0, CREATE_SUSPENDED, &tmp);
			if ( hThread )
			{
				if ( GetThreadContext( hThread, &ctx ) )
				{
					ctx.Eax;					// any
					ctx.Ecx = 0;				// oep
					ctx.Edx = (DWORD) NewBase;	// iInstance
					ctx.Eip = (DWORD) RemoteProc;
					SetThreadContext( hThread, &ctx );
					ResumeThread( hThread );
				}
			}
		} 
		else
		{
			if ( GetThreadContext( hThread, &ctx ) )
			{
				ctx.Eax;					// oeax
				ctx.Ecx = ctx.Eip;			// oeip
				ctx.Edx = (DWORD) NewBase;	// iInstance
				ctx.Eip = (DWORD) RemoteProc;
				SetThreadContext( hThread, &ctx );
			}
		}
		

	}

	CloseHandle(Proc);

	return hThread;
}

// ------------------------------------------------------

void FixBase(PVOID Image, UINT dwDelta, BOOL isRawFile)
{
	PIMAGE_NT_HEADERS pe;
	PIMAGE_BASE_RELOCATION reloc;
	DWORD size;

	pe		= (PIMAGE_NT_HEADERS) ((DWORD)(((PIMAGE_DOS_HEADER) Image)->e_lfanew) + (DWORD) Image);
	reloc	= (PIMAGE_BASE_RELOCATION)((DWORD)pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + (int)Image);
	size	= (DWORD)pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

	if ( isRawFile ) reloc = (PIMAGE_BASE_RELOCATION) RvaToOffset( (int)reloc - (int)Image, (int)Image);

	DWORD dwOffset, SmallOffset;

	while ( size )
	{
		if ( reloc->VirtualAddress )
		{
			int number = (reloc->SizeOfBlock - 8) / 2;
			WORD * Rel = (WORD *)((int)reloc + 8);

			if ( isRawFile ) dwOffset = RvaToOffset( reloc->VirtualAddress, (int)Image);
			else
			dwOffset = reloc->VirtualAddress + (int)Image;
			
			for (int i = 0; i < number; i++)
			{
				if	(Rel[i])
				{
					SmallOffset = (Rel[i] & 0x0FFF) + dwOffset;
					
					__asm
					{
						pushad

						mov		ecx, dwDelta
						mov		eax, SmallOffset
						add		dword ptr[eax], ecx 

						popad
					};
				}
			}
		}

		size -= reloc->SizeOfBlock;
		reloc = (PIMAGE_BASE_RELOCATION) (reloc->SizeOfBlock + (DWORD)reloc);
	}
}

// ------------------------------------------------------

bool IsImportByOrdinal(DWORD ImportDescriptor)
{
	return (ImportDescriptor & 0x80000000) != 0;
}

// ------------------------------------------------------

__declspec(naked) HMODULE GetKernel32(void)
{
	__asm 
	{
		push    esi
		xor     eax,eax
		mov     eax,fs:[0x30]
		mov     eax,[eax+0x0c]
		mov     esi,[eax+0x1c]
		lodsd
		mov     eax,[eax+0x8]
		pop     esi
		ret
	}
}
// ------------------------------------------------------
DWORD __stdcall CalcHash(char *s)
{
	__asm 
	{
		mov		eax,s
		push	edx
		xor		edx,edx
calc_hash:
		rol		edx,3
		xor		dl,[eax]
		inc		eax
		cmp		[eax],0
        jnz		calc_hash
		mov		eax,edx
		pop		edx
	}
}
// ------------------------------------------------------
LPVOID __stdcall GetProcAddrEx(HMODULE hModule, DWORD dwProcHash)
{
	__asm
	{
		xor     eax,eax
		mov     ebx,dwProcHash
		mov     esi,hModule
		mov     edi,esi
		add     esi,[esi+3Ch]
		mov     ecx,[esi+78h]
		add     ecx,edi
		mov     edx,[ecx+1ch]
		push    edx
		mov     edx,[ecx+24h]
		push    edx
		mov     esi,[ecx+20h]
		add     esi,edi
		cdq
		dec     edx
next_func:     
		lodsd
		inc     edx
		add     eax,hModule
		push    eax
		call    CalcHash
		cmp     eax,ebx
		jnz		next_func
		mov     eax,hModule
		xchg    eax,edx
		pop     esi
		add     esi,edx
		shl     eax,1
		add     eax,esi
		xor     ecx,ecx
		movzx   ecx,word ptr [eax]
		pop     edi
		shl     ecx,2
		add     ecx,edx
		add     ecx,edi
		mov     eax,[ecx]
		add     eax,edx
	}
}
// ------------------------------------------------------

void ProcessImport(DWORD Image, BOOL LoadNewModules)
{
	HMODULE k32 = GetKernel32();
	typedef HMODULE (WINAPI *tgetmodule)( LPCSTR lpModuleName );
	typedef DWORD (WINAPI *tgetprocaddr)( HMODULE hModule, LPCSTR lpProcName );
	typedef HMODULE (WINAPI *tloadlib)( LPCSTR lpModuleName, PVOID resrvd, DWORD flags );

	tgetmodule	 xGetModuleHandle = (tgetmodule)GetProcAddrEx( k32, 0xC9BFFA7D);
	tloadlib	 xLoadLibraryEx = (tloadlib)GetProcAddrEx( k32, 0x4BF60E8);
	tgetprocaddr xGetProcAddress = (tgetprocaddr)GetProcAddrEx( k32, 0xF2509B84);


	LPCSTR szLibName, szFuncName;
	HMODULE LibHandle;
	PIMAGE_THUNK_DATA OriginalTable, ImportTable;
	PIMAGE_IMPORT_BY_NAME ImportName;

	PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS)(Image + ((PIMAGE_DOS_HEADER)Image)->e_lfanew);
	PIMAGE_IMPORT_DESCRIPTOR import = (PIMAGE_IMPORT_DESCRIPTOR) (pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress + Image);

	if ((DWORD)import == Image) return; // non import table present

	while (import->Name)
	{
		szLibName = (LPCSTR) ((DWORD) import->Name + Image);
		LibHandle = xGetModuleHandle(szLibName);

		if (LibHandle == NULL)
			if (LoadNewModules) LibHandle = xLoadLibraryEx(szLibName, 0 , 0);

		OriginalTable = (PIMAGE_THUNK_DATA) ((DWORD)import->OriginalFirstThunk + Image);
		ImportTable = (PIMAGE_THUNK_DATA) ((DWORD)import->FirstThunk + Image);

		while (ImportTable->u1.AddressOfData)
		{
			if (IsImportByOrdinal(OriginalTable->u1.Ordinal) )
			{
				ImportTable->u1.Function = xGetProcAddress(LibHandle, (PCHAR) (OriginalTable->u1.Ordinal & 0xFFFF));
			}	else {

				ImportName = (PIMAGE_IMPORT_BY_NAME)((DWORD) OriginalTable->u1.AddressOfData + Image);
				szFuncName = (PCHAR) ImportName->Name;
					
				ImportTable->u1.Function = xGetProcAddress(LibHandle, szFuncName);
			}

			OriginalTable++;
			ImportTable++;
		}

		import++;
	}

	return;
}
// ------------------------------------------------------
DWORD RvaToOffset(DWORD RVA, DWORD pFileMap)
{
	PIMAGE_NT_HEADERS pe = (IMAGE_NT_HEADERS *) ( ((IMAGE_DOS_HEADER *)pFileMap)->e_lfanew + (UINT)pFileMap);
	PIMAGE_SECTION_HEADER section = (IMAGE_SECTION_HEADER *) ((DWORD)pe + sizeof (IMAGE_NT_HEADERS));

	int NumOfSections = pe->FileHeader.NumberOfSections;

	for (int i = 0; i < NumOfSections; i++)
	{
		if ((RVA >= section->VirtualAddress) && (RVA < section->VirtualAddress + section->SizeOfRawData))    
		//	return (DWORD)pFileMap + section->PointerToRawData + RVA - section->VirtualAddress;
			return section->PointerToRawData + RVA - section->VirtualAddress + pFileMap;
		section++;
	}
	return 0;
}

/*	================================
	== Find Proc
	================================	*/

DWORD FindProcess ( LPCWSTR szProcessName, TFindProcCallBack pFunc )
{
	DWORD dwResult = NULL;
	PSYSTEM_PROCESS_INFORMATION pProcInfo = (PSYSTEM_PROCESS_INFORMATION) 
												QueryInformation( SystemProcessInformation );

	if ( pProcInfo )
	{
		for (PSYSTEM_PROCESS_INFORMATION pProcInfoItem = pProcInfo;;)
		{
			if (pProcInfoItem->uUniqueProcessId > 4) // exclude "Idle" and "System" processes
			if (!lstrcmpiW(pProcInfoItem->usName.Buffer, szProcessName))
			{
				dwResult = pProcInfoItem->uUniqueProcessId;
				if ( pFunc ) pFunc( dwResult );
				else break;
			}

			if (pProcInfoItem->uNext == 0)
				break;

			// find the address of the next process structure
			pProcInfoItem = (PSYSTEM_PROCESS_INFORMATION)(((LPBYTE)pProcInfoItem) + pProcInfoItem->uNext);
		}
		
		xfree ( pProcInfo );
	}

	return dwResult;
}

/*	================================
	== Privelegies
	================================	*/

BOOL SetPrivilege( ULONG Privilege, BOOLEAN Enable)
{
	BOOLEAN Enabled;
	return ! RtlAdjustPrivilege( Privilege, Enable, 0, &Enabled );
}
// ------------------------------------------------------
BOOL GetDebug()
{
	return SetPrivilege( SE_DEBUG_PRIVILEGE, TRUE);
}

// ------------------------------------------------------
BOOL GetDriver()
{
	return SetPrivilege( SE_LOAD_DRIVER_PRIVILEGE, TRUE);
}

// ------------------------------------------------------
```

`src/_Inject_mod/Inject_mod.h`:

```h
#ifndef INJECT_MOD
#define INJECT_MOD

typedef void (*TFindProcCallBack)( DWORD dwProcessID );

PVOID QueryInformation ( SYSTEMINFOCLASS dwClass );
HANDLE	Inject(PWCHAR ProcName, DWORD PID, PTHREAD_START_ROUTINE RemoteProc, DWORD Base, HANDLE hThread = 0);
void	ProcessImport(DWORD Image, BOOL LoadNewModules);
void FixBase(PVOID Image, UINT dwDelta, BOOL isRawFile = false);
bool	UnHookSystemLib(PCHAR szModule);
DWORD	FindProcess ( LPCWSTR szProcessName, TFindProcCallBack pFunc = NULL );
BOOL	GetDebug();
BOOL	GetDriver();

#endif
```

`src/ntdll.h`:

```h
#ifndef _NTDDK_
#define _NTDDK_

#define NT_INCLUDED
#define _NTDEF_
#define _CTYPE_DISABLE_MACROS

#pragma warning(disable : 4200)

#undef STATUS_WAIT_0
#undef STATUS_ABANDONED_WAIT_0
#undef STATUS_USER_APC
#undef STATUS_TIMEOUT
#undef STATUS_PENDING
#undef DBG_CONTINUE
#undef STATUS_SEGMENT_NOTIFICATION
#undef DBG_TERMINATE_THREAD
#undef DBG_TERMINATE_PROCESS
#undef DBG_CONTROL_C
#undef DBG_CONTROL_BREAK
#undef STATUS_GUARD_PAGE_VIOLATION
#undef STATUS_DATATYPE_MISALIGNMENT
#undef STATUS_BREAKPOINT
#undef STATUS_SINGLE_STEP
#undef DBG_EXCEPTION_NOT_HANDLED
#undef STATUS_ACCESS_VIOLATION
#undef STATUS_IN_PAGE_ERROR
#undef STATUS_INVALID_HANDLE
#undef STATUS_NO_MEMORY
#undef STATUS_ILLEGAL_INSTRUCTION
#undef STATUS_NONCONTINUABLE_EXCEPTION
#undef STATUS_INVALID_DISPOSITION
#undef STATUS_ARRAY_BOUNDS_EXCEEDED
#undef STATUS_FLOAT_DENORMAL_OPERAND
#undef STATUS_FLOAT_DIVIDE_BY_ZERO
#undef STATUS_FLOAT_INEXACT_RESULT
#undef STATUS_FLOAT_INVALID_OPERATION
#undef STATUS_FLOAT_OVERFLOW
#undef STATUS_FLOAT_STACK_CHECK
#undef STATUS_FLOAT_UNDERFLOW
#undef STATUS_INTEGER_DIVIDE_BY_ZERO
#undef STATUS_INTEGER_OVERFLOW
#undef STATUS_PRIVILEGED_INSTRUCTION
#undef STATUS_STACK_OVERFLOW
#undef STATUS_CONTROL_C_EXIT
#undef STATUS_FLOAT_MULTIPLE_FAULTS
#undef STATUS_FLOAT_MULTIPLE_TRAPS
#undef STATUS_ILLEGAL_VLM_REFERENCE
#undef STATUS_REG_NAT_CONSUMPTION
#undef DBG_EXCEPTION_HANDLED

#include <ntstatus.h>

#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NTAPI __stdcall
#else
#define _cdecl
#define NTAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define MAXIMUM_FILENAME_LENGTH			256
#define PORT_MAXIMUM_MESSAGE_LENGTH		256
#define INITIAL_PRIVILEGE_COUNT			3

#define FSCTL_GET_VOLUME_INFORMATION	0x90064

// constants for RtlDetermineDosPathNameType_U
#define DOS_PATHTYPE_UNC				0x00000001	// \\COMPUTER1
#define DOS_PATHTYPE_ROOTDRIVE			0x00000002	// C:\ 
#define DOS_PATHTYPE_STREAM				0x00000003	// X:X or C:
#define DOS_PATHTYPE_NT					0x00000004	// \\??\\C:
#define DOS_PATHTYPE_NAME				0x00000005	// C
#define DOS_PATHTYPE_DEVICE				0x00000006	// \\.\C:
#define DOS_PATHTYPE_LOCALUNCROOT		0x00000007	// \\.

// Define the various device characteristics flags
#define FILE_REMOVABLE_MEDIA            0x00000001
#define FILE_READ_ONLY_DEVICE           0x00000002
#define FILE_FLOPPY_DISKETTE            0x00000004
#define FILE_WRITE_ONCE_MEDIA           0x00000008
#define FILE_REMOTE_DEVICE              0x00000010
#define FILE_DEVICE_IS_MOUNTED          0x00000020
#define FILE_VIRTUAL_VOLUME             0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME  0x00000080
#define FILE_DEVICE_SECURE_OPEN			0x00000100

#define FILE_SUPERSEDE							0x00000000
#define FILE_OPEN								0x00000001
#define FILE_CREATE								0x00000002
#define FILE_OPEN_IF							0x00000003
#define FILE_OVERWRITE							0x00000004
#define FILE_OVERWRITE_IF						0x00000005
#define FILE_MAXIMUM_DISPOSITION				0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

// THREAD STATES
#define THREAD_STATE_INITIALIZED		0
#define THREAD_STATE_READY				1
#define THREAD_STATE_RUNNING			2
#define THREAD_STATE_STANDBY			3
#define THREAD_STATE_TERMINATED			4
#define THREAD_STATE_WAIT				5
#define THREAD_STATE_TRANSITION			6
#define THREAD_STATE_UNKNOWN			7

// OBJECT TYPE CODES
#define OB_TYPE_TYPE					1
#define OB_TYPE_DIRECTORY				2
#define OB_TYPE_SYMBOLIC_LINK			3
#define OB_TYPE_TOKEN					4
#define OB_TYPE_PROCESS					5
#define OB_TYPE_THREAD					6
#define OB_TYPE_EVENT					7
#define OB_TYPE_EVENT_PAIR				8
#define OB_TYPE_MUTANT					9
#define OB_TYPE_SEMAPHORE				10
#define OB_TYPE_TIMER					11
#define OB_TYPE_PROFILE					12
#define OB_TYPE_WINDOW_STATION			13
#define OB_TYPE_DESKTOP					14
#define OB_TYPE_SECTION					15
#define OB_TYPE_KEY						16
#define OB_TYPE_PORT					17
#define OB_TYPE_ADAPTER					18
#define OB_TYPE_CONTROLLER				19
#define OB_TYPE_DEVICE					20
#define OB_TYPE_DRIVER					21
#define OB_TYPE_IO_COMPLETION			22
#define OB_TYPE_FILE					23

#define OBJ_INHERIT						0x00000002
#define OBJ_PERMANENT					0x00000010
#define OBJ_EXCLUSIVE					0x00000020
#define OBJ_CASE_INSENSITIVE			0x00000040
#define OBJ_OPENIF						0x00000080
#define OBJ_OPENLINK					0x00000100
#define OBJ_VALID_ATTRIBUTES			0x000001F2


// Object Manager Directory Specific Access Rights.
#define DIRECTORY_QUERY					0x0001
#define DIRECTORY_TRAVERSE				0x0002
#define DIRECTORY_CREATE_OBJECT			0x0004
#define DIRECTORY_CREATE_SUBDIRECTORY	0x0008
#define DIRECTORY_ALL_ACCESS			(STANDARD_RIGHTS_REQUIRED | 0xF)

// Object Manager Symbolic Link Specific Access Rights.
#define SYMBOLIC_LINK_QUERY				0x0001
#define SYMBOLIC_LINK_ALL_ACCESS		(STANDARD_RIGHTS_REQUIRED | 0x1)

#define NT_SUCCESS(Status)				((LONG)(Status) &gt;= 0)
#define NT_ERROR(Status)				((ULONG)(Status) &gt;&gt; 30 == 3)

#define DEVICE_TYPE						DWORD

// values for RtlAdjustPrivilege
#define SE_MIN_WELL_KNOWN_PRIVILEGE       (2L)
#define SE_CREATE_TOKEN_PRIVILEGE         (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE   (3L)
#define SE_LOCK_MEMORY_PRIVILEGE          (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE       (5L)
#define SE_UNSOLICITED_INPUT_PRIVILEGE    (6L) // obsolete and unused
#define SE_MACHINE_ACCOUNT_PRIVILEGE      (6L)
#define SE_TCB_PRIVILEGE                  (7L)
#define SE_SECURITY_PRIVILEGE             (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE       (9L)
#define SE_LOAD_DRIVER_PRIVILEGE          (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE       (11L)
#define SE_SYSTEMTIME_PRIVILEGE           (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE  (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE    (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE      (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE     (16L)
#define SE_BACKUP_PRIVILEGE               (17L)
#define SE_RESTORE_PRIVILEGE              (18L)
#define SE_SHUTDOWN_PRIVILEGE             (19L)
#define SE_DEBUG_PRIVILEGE                (20L)
#define SE_AUDIT_PRIVILEGE                (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE   (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE        (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE      (24L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE       (SE_REMOTE_SHUTDOWN_PRIVILEGE)

#define InitializeObjectAttributes( p, n, a, r, s ) {   \
    (p)->uLength = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->hRootDirectory = r;                             \
    (p)->uAttributes = a;                                \
    (p)->pObjectName = n;                                \
    (p)->pSecurityDescriptor = s;                        \
    (p)->pSecurityQualityOfService = NULL;               \
}


typedef LONG		NTSTATUS;
/*lint -e624 */  // Don't complain about different typedefs.
				 // winnt
typedef NTSTATUS	*PNTSTATUS;
/*lint +e624 */  // Resume checking for different typedefs.

typedef NTSTATUS	(NTAPI *NTSYSCALL)();
typedef NTSYSCALL	*PNTSYSCALL;

typedef ULONG		KAFFINITY;
typedef KAFFINITY	*PKAFFINITY;
typedef LONG		KPRIORITY;

typedef BYTE		KPROCESSOR_MODE;

typedef VOID		*POBJECT;

typedef VOID		(*PKNORMAL_ROUTINE) (
						IN PVOID NormalContext,
						IN PVOID SystemArgument1,
						IN PVOID SystemArgument2
					);




typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;


typedef struct _HARDWARE_PTE
{
    ULONG Valid             : 1;
    ULONG Write             : 1;
    ULONG Owner             : 1;
    ULONG WriteThrough      : 1;
    ULONG CacheDisable      : 1;
    ULONG Accessed          : 1;
    ULONG Dirty             : 1;
    ULONG LargePage         : 1;
    ULONG Global            : 1;
    ULONG CopyOnWrite       : 1;
    ULONG Prototype         : 1;
    ULONG reserved          : 1;
    ULONG PageFrameNumber   : 20;
} HARDWARE_PTE, *PHARDWARE_PTE;

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG			uLength;
	HANDLE			hRootDirectory;
	PUNICODE_STRING	pObjectName;
	ULONG			uAttributes;
	PVOID			pSecurityDescriptor;
	PVOID			pSecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID
{
	DWORD	UniqueProcess;
	DWORD	UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _PEB_FREE_BLOCK
{
   struct _PEB_FREE_BLOCK	*Next;
   ULONG					Size;
} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;

typedef struct _CURDIR
{
   UNICODE_STRING	DosPath;
   HANDLE			Handle;
} CURDIR, *PCURDIR;

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	WORD	Flags;
	WORD	Length;
	DWORD	TimeStamp;
	STRING	DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

#define	PROCESS_PARAMETERS_NORMALIZED	1	// pointers in are absolute (not self-relative)

typedef struct _PROCESS_PARAMETERS
{
    ULONG					MaximumLength;
    ULONG					Length;
    ULONG					Flags;				// PROCESS_PARAMETERS_NORMALIZED
    ULONG					DebugFlags;
    HANDLE					ConsoleHandle;
    ULONG					ConsoleFlags;
    HANDLE					StandardInput;
    HANDLE					StandardOutput;
    HANDLE					StandardError;
    CURDIR					CurrentDirectory;
    UNICODE_STRING			DllPath;
    UNICODE_STRING			ImagePathName;
    UNICODE_STRING			CommandLine;
    PWSTR					Environment;
    ULONG					StartingX;
    ULONG					StartingY;
    ULONG					CountX;
    ULONG					CountY;
    ULONG					CountCharsX;
    ULONG					CountCharsY;
    ULONG					FillAttribute;
    ULONG					WindowFlags;
    ULONG					ShowWindowFlags;
    UNICODE_STRING			WindowTitle;
    UNICODE_STRING			Desktop;
    UNICODE_STRING			ShellInfo;
    UNICODE_STRING			RuntimeInfo;
	RTL_DRIVE_LETTER_CURDIR	CurrentDirectores[32];
} PROCESS_PARAMETERS, *PPROCESS_PARAMETERS;

typedef struct _RTL_BITMAP
{
	DWORD	SizeOfBitMap;
	PDWORD	Buffer;
} RTL_BITMAP, *PRTL_BITMAP, **PPRTL_BITMAP;

#define LDR_STATIC_LINK				0x0000002
#define LDR_IMAGE_DLL				0x0000004
#define LDR_LOAD_IN_PROGRESS		0x0001000
#define LDR_UNLOAD_IN_PROGRESS		0x0002000
#define LDR_ENTRY_PROCESSED			0x0004000
#define LDR_ENTRY_INSERTED			0x0008000
#define LDR_CURRENT_LOAD			0x0010000
#define LDR_FAILED_BUILTIN_LOAD		0x0020000
#define LDR_DONT_CALL_FOR_THREADS	0x0040000
#define LDR_PROCESS_ATTACH_CALLED	0x0080000
#define LDR_DEBUG_SYMBOLS_LOADED	0x0100000
#define LDR_IMAGE_NOT_AT_BASE		0x0200000
#define LDR_WX86_IGNORE_MACHINETYPE	0x0400000

typedef struct _LDR_DATA_TABLE_ENTRY
{
     LIST_ENTRY InLoadOrderLinks;
     LIST_ENTRY InMemoryOrderLinks;
     LIST_ENTRY InInitializationOrderLinks;
     PVOID DllBase;
     PVOID EntryPoint;
     ULONG SizeOfImage;
     UNICODE_STRING FullDllName; // +36
     UNICODE_STRING BaseDllName; // +44
     ULONG Flags;
     WORD LoadCount;
     WORD TlsIndex;
     union
     {
          LIST_ENTRY HashLinks;
          struct
          {
               PVOID SectionPointer;
               ULONG CheckSum;
          };
     };
     union
     {
          ULONG TimeDateStamp;
          PVOID LoadedImports;
     };
     _ACTIVATION_CONTEXT * EntryPointActivationContext;
     PVOID PatchInformation;
     LIST_ENTRY ForwarderLinks;
     LIST_ENTRY ServiceTagLinks;
     LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA
{
     ULONG Length;
     UCHAR Initialized;
     PVOID SsHandle;
     LIST_ENTRY InLoadOrderModuleList;
     LIST_ENTRY InMemoryOrderModuleList;
     LIST_ENTRY InInitializationOrderModuleList;
     PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef VOID NTSYSAPI (*PPEBLOCKROUTINE)(PVOID);

typedef struct _SYSTEM_STRINGS
{
	UNICODE_STRING	SystemRoot;       // C:\WINNT
	UNICODE_STRING	System32Root;     // C:\WINNT\System32
	UNICODE_STRING	BaseNamedObjects; // \BaseNamedObjects
}SYSTEM_STRINGS,*PSYSTEM_STRINGS;

typedef struct _TEXT_INFO
{
	PVOID			Reserved;
	PSYSTEM_STRINGS	SystemStrings;
}TEXT_INFO, *PTEXT_INFO;

typedef struct _PEB
{
	UCHAR				InheritedAddressSpace;				// 0
	UCHAR				ReadImageFileExecOptions;			// 1
	UCHAR				BeingDebugged;						// 2
	BYTE				b003;								// 3
	PVOID				Mutant;								// 4
	PVOID				ImageBaseAddress;					// 8
	PPEB_LDR_DATA		Ldr;								// C
	PPROCESS_PARAMETERS	ProcessParameters;					// 10
	PVOID				SubSystemData;						// 14  
	PVOID				ProcessHeap;						// 18
	KSPIN_LOCK			FastPebLock;						// 1C
	PPEBLOCKROUTINE		FastPebLockRoutine;					// 20
	PPEBLOCKROUTINE		FastPebUnlockRoutine;				// 24
	ULONG				EnvironmentUpdateCount;				// 28
	PVOID				*KernelCallbackTable;				// 2C
	PVOID				EventLogSection;					// 30
	PVOID				EventLog;							// 34
	PPEB_FREE_BLOCK		FreeList;							// 38
	ULONG				TlsExpansionCounter;				// 3C
	PRTL_BITMAP			TlsBitmap;							// 40
	ULONG				TlsBitmapData[0x2];					// 44
	PVOID				ReadOnlySharedMemoryBase;			// 4C
	PVOID				ReadOnlySharedMemoryHeap;			// 50
	PTEXT_INFO			ReadOnlyStaticServerData;			// 54
	PVOID				InitAnsiCodePageData;				// 58
	PVOID				InitOemCodePageData;				// 5C
	PVOID				InitUnicodeCaseTableData;			// 60
	ULONG				KeNumberProcessors;					// 64
	ULONG				NtGlobalFlag;						// 68
	DWORD				d6C;								// 6C
	LARGE_INTEGER		MmCriticalSectionTimeout;			// 70
	ULONG				MmHeapSegmentReserve;				// 78
	ULONG				MmHeapSegmentCommit;				// 7C
	ULONG				MmHeapDeCommitTotalFreeThreshold;	// 80
	ULONG				MmHeapDeCommitFreeBlockThreshold;	// 84
	ULONG				NumberOfHeaps;						// 88
	ULONG				AvailableHeaps;						// 8C
	PHANDLE				ProcessHeapsListBuffer;				// 90
	PVOID				GdiSharedHandleTable;				// 94
	PVOID				ProcessStarterHelper;				// 98
	PVOID				GdiDCAttributeList;					// 9C
	KSPIN_LOCK			LoaderLock;							// A0
	ULONG				NtMajorVersion;						// A4
	ULONG				NtMinorVersion;						// A8
	USHORT				NtBuildNumber;						// AC
	USHORT				NtCSDVersion;						// AE
	ULONG				PlatformId;							// B0
	ULONG				Subsystem;							// B4
	ULONG				MajorSubsystemVersion;				// B8
	ULONG				MinorSubsystemVersion;				// BC
	KAFFINITY			AffinityMask;						// C0
	ULONG				GdiHandleBuffer[0x22];				// C4
	ULONG				PostProcessInitRoutine;				// 14C
	ULONG				TlsExpansionBitmap;					// 150
	UCHAR				TlsExpansionBitmapBits[0x80];		// 154
	ULONG				SessionId;							// 1D4
	ULARGE_INTEGER		AppCompatFlags;						// 1D8
	PWORD				CSDVersion;							// 1E0
/*	PVOID				AppCompatInfo;						// 1E4
	UNICODE_STRING		usCSDVersion;
	PVOID				ActivationContextData;
    PVOID				ProcessAssemblyStorageMap;
    PVOID				SystemDefaultActivationContextData;
    PVOID				SystemAssemblyStorageMap;
    ULONG				MinimumStackCommit; */
} PEB, *PPEB;

typedef struct _TEB
{
	NT_TIB			Tib;                         
	PVOID			EnvironmentPointer;           
	CLIENT_ID		Cid;                      
	PVOID			ActiveRpcInfo;                
	PVOID			ThreadLocalStoragePointer;    
	PPEB			Peb;                           
	ULONG			LastErrorValue;               
	ULONG			CountOfOwnedCriticalSections; 
	PVOID			CsrClientThread;              
	PVOID			Win32ThreadInfo;              
	ULONG			Win32ClientInfo[0x1F];        
	PVOID			WOW32Reserved;                
	ULONG			CurrentLocale;                
	ULONG			FpSoftwareStatusRegister;     
	PVOID			SystemReserved1[0x36];        
	PVOID			Spare1;                       
	LONG			ExceptionCode;                 
	ULONG			SpareBytes1[0x28];            
	PVOID			SystemReserved2[0xA];         
	ULONG			gdiRgn;                       
	ULONG			gdiPen;                       
	ULONG			gdiBrush;                     
	CLIENT_ID		RealClientId;             
	PVOID			GdiCachedProcessHandle;       
	ULONG			GdiClientPID;                 
	ULONG			GdiClientTID;                 
	PVOID			GdiThreadLocaleInfo;          
	PVOID			UserReserved[5];              
	PVOID			glDispatchTable[0x118];       
	ULONG			glReserved1[0x1A];            
	PVOID			glReserved2;                  
	PVOID			glSectionInfo;                
	PVOID			glSection;                    
	PVOID			glTable;                      
	PVOID			glCurrentRC;                  
	PVOID			glContext;                    
	NTSTATUS		LastStatusValue;           
	UNICODE_STRING	StaticUnicodeString; 
	WCHAR			StaticUnicodeBuffer[0x105];   
	PVOID			DeallocationStack;            
	PVOID			TlsSlots[0x40];               
	LIST_ENTRY		TlsLinks;                
	PVOID			Vdm;                          
	PVOID			ReservedForNtRpc;             
	PVOID			DbgSsReserved[0x2];           
	ULONG			HardErrorDisabled;            
	PVOID			Instrumentation[0x10];        
	PVOID			WinSockData;                  
	ULONG			GdiBatchCount;                
	ULONG			Spare2;                       
	ULONG			Spare3;                       
	ULONG			Spare4;                       
	PVOID			ReservedForOle;               
	ULONG			WaitingOnLoaderLock;          
	PVOID			StackCommit;                  
	PVOID			StackCommitMax;               
	PVOID			StackReserve;                 
} TEB, *PTEB;

typedef enum _POOL_TYPE
{
	NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed,
	DontUseThisType,
	NonPagedPoolCacheAligned,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS,
	MaxPoolType
} POOL_TYPE, *PPOOL_TYPE;

typedef enum _KWAIT_REASON
{
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	Spare2,
	Spare3,
	Spare4,
	Spare5,
	Spare6,
	WrKernel,
	MaximumWaitReason
} KWAIT_REASON, *PKWAIT_REASON;

typedef struct _DISPATCHER_HEADER
{
	BYTE		uType;			//DO_TYPE_*
	BYTE		uAbsolute;
	BYTE		uSize;			// number of DWORDs
	BYTE		uInserted;
	LONG		lSignalState;
	LIST_ENTRY	WaitListHead;
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KPROCESS
{
	DISPATCHER_HEADER	Header;           // DO_TYPE_PROCESS (0x1A)
	LIST_ENTRY			le10;
	DWORD				d18;
	DWORD				d1C;
	DWORD				d20;
	DWORD				d24;
	DWORD				d28;
	DWORD				d2C;
	DWORD				d30;
	DWORD				d34;
	DWORD				dKernelTime;      // ticks
	DWORD				dUserTime;        // ticks
	LIST_ENTRY			le40;
	LIST_ENTRY			OutSwapList;
	LIST_ENTRY			ThreadListHead;   // KTHREAD.ThreadList
	DWORD				d58;
	KAFFINITY			AffinityMask;
	WORD				w60;
	BYTE				bBasePriority;
	BYTE				b63;
	WORD				w64;
	BYTE				b66;
	BOOLEAN				fPriorityBoost;
} KPROCESS, *PKPROCESS;

typedef struct _PORT_MESSAGE
{
	USHORT		DataSize;
	USHORT		MessageSize;
	USHORT		MessageType;
	USHORT		VirtualRangesOffset;
	CLIENT_ID	ClientId;
	ULONG		MessageId;
	ULONG		SectionSize;
//	UCHAR		Data[];
} PORT_MESSAGE, *PPORT_MESSAGE;

typedef struct _SERVICE_DESCRIPTOR_TABLE
{
	PNTSYSCALL	ServiceTable;    // array of entrypoints
	PULONG		puCounterTable;    // array of counters
	ULONG		uTableSize;       // number of table entries
	PBYTE		pbArgumentTable;   // array of byte counts
} SERVICE_DESCRIPTOR_TABLE, *PSERVICE_DESCRIPTOR_TABLE;

typedef struct _KSEMAPHORE
{
	DISPATCHER_HEADER	Header;
	LONG				lLimit;
} KSEMAPHORE, *PKSEMAPHORE;

typedef struct _KTHREAD
{
	DISPATCHER_HEADER			Header;       // DO_TYPE_THREAD (0x6C)
	LIST_ENTRY					le010;
	DWORD						d018;
	DWORD						d01C;
	PTEB						pTeb;
	DWORD						d024;
	DWORD						d028;
	BYTE						b02C;
	BYTE						bThreadState; // THREAD_STATE_*
	WORD						w02E;
	WORD						w030;
	BYTE						b032;
	BYTE						bPriority;
	LIST_ENTRY					le034;
	LIST_ENTRY					le03C;
	PKPROCESS					pProcess;
	DWORD						d048;
	DWORD						dContextSwitches;
	DWORD						d050;
	WORD						w054;
	BYTE						b056;
	BYTE						bWaitReason;
	DWORD						d058;
	PLIST_ENTRY					ple05C;
	PLIST_ENTRY					ple060;
	DWORD						d064;
	BYTE						bBasePriority;
	BYTE						b069;
	WORD						w06A;
	DWORD						d06C;
	DWORD						d070;
	DWORD						d074;
	DWORD						d078;
	DWORD						d07C;
	DWORD						d080;
	DWORD						d084;
	DWORD						d088;
	DWORD						d08C;
	DWORD						d090;
	DWORD						d094;
	DWORD						d098;
	DWORD						d09C;
	DWORD						d0A0;
	DWORD						d0A4;
	DWORD						d0A8;
	DWORD						d0AC;
	DWORD						d0B0;
	DWORD						d0B4;
	DWORD						d0B8;
	DWORD						d0BC;
	DWORD						d0C0;
	DWORD						d0C4;
	DWORD						d0C8;
	DWORD						d0CC;
	DWORD						d0D0;
	DWORD						d0D4;
	DWORD						d0D8;
	PSERVICE_DESCRIPTOR_TABLE	pServiceDescriptorTable;
	DWORD						d0E0;
	DWORD						d0E4;
	DWORD						d0E8;
	DWORD						d0EC;
	LIST_ENTRY					le0F0;
	DWORD						d0F8;
	DWORD						d0FC;
	DWORD						d100;
	DWORD						d104;
	DWORD						d108;
	DWORD						d10C;
	DWORD						d110;
	DWORD						d114;
	DWORD						d118;
	BYTE						b11C;
	BYTE						b11D;
	WORD						w11E;
	DWORD						d120;
	DWORD						d124;
	DWORD						d128;
	DWORD						d12C;
	DWORD						d130;
	WORD						w134;
	BYTE						b136;
	KPROCESSOR_MODE				ProcessorMode;
	DWORD						dKernelTime;  // ticks
	DWORD						dUserTime;    // ticks
	DWORD						d140;
	DWORD						d144;
	DWORD						d148;
	DWORD						d14C;
	DWORD						d150;
	DWORD						d154;
	DWORD						d158;
	DWORD						d15C;
	DWORD						d160;
	DWORD						d164;
	DWORD						d168;
	DWORD						d16C;
	DWORD						d170;
	PROC						SuspendNop;
	DWORD						d178;
	DWORD						d17C;
	DWORD						d180;
	DWORD						d184;
	DWORD						d188;
	DWORD						d18C;
	KSEMAPHORE					SuspendSemaphore;
	LIST_ENTRY					ThreadList; // KPROCESS.ThreadListHead
	DWORD						d1AC;
} KTHREAD, *PKTHREAD;

typedef struct _ETHREAD
{
	KTHREAD			Tcb;
	LARGE_INTEGER	liCreateTime;
	LARGE_INTEGER	liExitTime;
	NTSTATUS		ExitStatus;
	LIST_ENTRY		PostBlockList;
	LIST_ENTRY		TerminationPortList;
	ULONG			uActiveTimerListLock;
	LIST_ENTRY		ActiveTimerListHead;
	CLIENT_ID		Cid;
	KSEMAPHORE		LpcReplySemaphore;
	ULONG			uLpcReplyMessage;
	LARGE_INTEGER	liLpcReplyMessageId;
	ULONG			uImpersonationInfo;
	LIST_ENTRY		IrpList;
	LIST_ENTRY		TopLevelIrp;
	ULONG			uReadClusterSize;
	BOOLEAN			fForwardClusterOnly;
	BOOLEAN			fDisablePageFaultClustering;
	BOOLEAN			fDeadThread;
	BOOLEAN			fHasTerminated;
	ULONG			uEventPair;
	ULONG			uGrantedAccess;
	ULONG			uThreadsProcess;
	PVOID			pStartAddress;
	PVOID			Win32StartAddress;
	BOOLEAN			fLpcExitThreadCalled;
	BOOLEAN			fHardErrorsAreDisabled;
	WORD			wUknown1;
	DWORD			dwUknown2;
} ETHREAD, *PETHREAD;

typedef PETHREAD	ERESOURCE_THREAD,
					*PERESOURCE_THREAD;

typedef struct _KEVENT
{
	DISPATCHER_HEADER	Header;
} KEVENT, *PKEVENT;

typedef struct _ERESOURCE_OLD
{
	LIST_ENTRY			SystemResourcesList;
	PERESOURCE_THREAD	OwnerThreads;
	PBYTE				pbOwnerCounts;
	WORD				wTableSize;
	WORD				wActiveCount;
	WORD				wFlag;
	WORD				wTableRover;
	BYTE				bInitialOwnerCounts[4];
	ERESOURCE_THREAD	InitialOwnerThreads[4];
	DWORD				dwUknown1;
	ULONG				uContentionCount;
	WORD				wNumberOfExclusiveWaiters;
	WORD				wNumberOfSharedWaiters;
	KSEMAPHORE			SharedWaiters;
	KEVENT				ExclusiveWaiters;
	KSPIN_LOCK			SpinLock;
	ULONG				uCreatorBackTraceIndex;
	WORD				wDepth;
	WORD				wUknown2;
	PVOID				pOwnerBackTrace[4];
} ERESOURCE_OLD, *PERESOURCE_OLD;

typedef struct _OWNER_ENTRY
{
	ERESOURCE_THREAD	OwnerThread;
	SHORT				sOwnerCount;
	WORD				wTableSize;
} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE_LITE
{
	LIST_ENTRY		SystemResourcesList;
	POWNER_ENTRY	OwnerTable;
	SHORT			sActiveCount;
	WORD			wFlag;
	PKSEMAPHORE		SharedWaiters;
	PKEVENT			ExclusiveWaiters;
	OWNER_ENTRY		OwnerThreads[2];
	ULONG			uContentionCount;
	WORD			wNumberOfSharedWaiters;
	WORD			wNumberOfExclusiveWaiters;
	union
	{

		PVOID		pAddress;
		ULONG		uCreatorBackTraceIndex;
	};
	KSPIN_LOCK		SpinLock;
} ERESOURCE_LITE, *PERESOURCE_LITE;

typedef ERESOURCE_LITE	ERESOURCE,
						*PERESOURCE;

typedef struct _IO_STATUS_BLOCK
{
	NTSTATUS	Status;
	ULONG		uInformation;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

/* Defined in Winnt.h
typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;
*/

typedef struct _IOCOUNTERS
{
	ULONG			uReadOperationCount;
	ULONG			uWriteOperationCount;
	ULONG			uOtherOperationCount;
	LARGE_INTEGER	liReadTransferCount;
	LARGE_INTEGER	liWriteTransferCount;
	LARGE_INTEGER	liOtherTransferCount;
} IOCOUNTERS, *PIOCOUNTERS;

typedef struct _VM_COUNTERS
{
	ULONG	uPeakVirtualSize;
	ULONG	uVirtualSize;
	ULONG	uPageFaultCount;
	ULONG	uPeakWorkingSetSize;
	ULONG	uWorkingSetSize;
	ULONG	uQuotaPeakPagedPoolUsage;
	ULONG	uQuotaPagedPoolUsage;
	ULONG	uQuotaPeakNonPagedPoolUsage;
	ULONG	uQuotaNonPagedPoolUsage;
	ULONG	uPagefileUsage;
	ULONG	uPeakPagefileUsage;
} VM_COUNTERS, *PVM_COUNTERS;

typedef struct _KERNEL_USER_TIMES
{
	LARGE_INTEGER liCreateTime;
	LARGE_INTEGER liExitTime;
	LARGE_INTEGER liKernelTime;
	LARGE_INTEGER liUserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

typedef struct _BASE_PRIORITY_INFORMATION
{
	KPRIORITY	BasePriority;
} BASE_PRIORITY_INFORMATION, *PBASE_PRIORITY_INFORMATION;

typedef struct _AFFINITY_MASK
{
	KAFFINITY	AffinityMask;
} AFFINITY_MASK, *PAFFINITY_MASK;

typedef struct _TIME_FIELDS
{
	WORD	wYear;
	WORD	wMonth;
	WORD	wDay;
	WORD	wHour;
	WORD	wMinute;
	WORD	wSecond;
	WORD	wMilliseconds;
	WORD	wWeekday;
} TIME_FIELDS, *PTIME_FIELDS;

typedef void (*PIO_APC_ROUTINE)	(PVOID				ApcContext,
                                 PIO_STATUS_BLOCK	IoStatusBlock,
                                 ULONG				Reserved);

#if(_WIN32_WINNT < 0x0400)

typedef struct _NTFS_VOLUME_DATA_BUFFER
{
	LARGE_INTEGER	liSerialNumber;
	LARGE_INTEGER	liNumberOfSectors;
	LARGE_INTEGER	liTotalClusters;
	LARGE_INTEGER	liFreeClusters;
	LARGE_INTEGER	liReserved;
	ULONG			uBytesPerSector;
	ULONG			uBytesPerCluster;
	ULONG			uBytesPerMFTRecord;
	ULONG			uClustersPerMFTRecord;
	LARGE_INTEGER	liMFTLength;
	LARGE_INTEGER	liMFTStart;
	LARGE_INTEGER	liMFTMirrorStart;
	LARGE_INTEGER	liMFTZoneStart;
	LARGE_INTEGER	liMFTZoneEnd;
} NTFS_VOLUME_DATA_BUFFER, *PNTFS_VOLUME_DATA_BUFFER;

#endif

typedef struct _OBJDIR_INFORMATION
{
	UNICODE_STRING	ObjectName;
	UNICODE_STRING	ObjectTypeName; // e.g. Directory, Device ...
	UCHAR			Data[1];        // variable length
} OBJDIR_INFORMATION, *POBJDIR_INFORMATION;

// Define the file system information class values
typedef enum _FSINFOCLASS {
    FileFsVolumeInformation       = 1,
    FileFsLabelInformation,      // 2
    FileFsSizeInformation,       // 3
    FileFsDeviceInformation,     // 4
    FileFsAttributeInformation,  // 5
    FileFsControlInformation,    // 6
    FileFsFullSizeInformation,   // 7
    FileFsObjectIdInformation,   // 8
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BOOLEAN SupportsObjects;
    WCHAR VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_FS_LABEL_INFORMATION {
    ULONG VolumeLabelLength;
    WCHAR VolumeLabel[1];
} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;

typedef struct _FILE_FS_SIZE_INFORMATION {
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER AvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;

typedef struct _FILE_FS_DEVICE_INFORMATION {
    DEVICE_TYPE DeviceType;
    ULONG Characteristics;
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;

typedef struct _FILE_FS_ATTRIBUTE_INFORMATION {
    ULONG FileSystemAttributes;
    LONG MaximumComponentNameLength;
    ULONG FileSystemNameLength;
    WCHAR FileSystemName[1];
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;

typedef struct _FILE_FS_CONTROL_INFORMATION {
    LARGE_INTEGER FreeSpaceStartFiltering;
    LARGE_INTEGER FreeSpaceThreshold;
    LARGE_INTEGER FreeSpaceStopFiltering;
    LARGE_INTEGER DefaultQuotaThreshold;
    LARGE_INTEGER DefaultQuotaLimit;
    ULONG FileSystemControlFlags;
} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;

typedef struct _FILE_FS_FULL_SIZE_INFORMATION {
    LARGE_INTEGER TotalQuotaAllocationUnits;
    LARGE_INTEGER AvailableQuotaAllocationUnits;
    LARGE_INTEGER AvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION;

typedef struct _FILE_FS_OBJECT_ID_INFORMATION {
    GUID VolumeObjectId;
    ULONG VolumeObjectIdExtendedInfo[12];
} FILE_FS_OBJECT_ID_INFORMATION, *PFILE_FS_OBJECT_ID_INFORMATION;

typedef enum _SYSTEMINFOCLASS
{
	SystemBasicInformation,             // 0x002C
	SystemProcessorInformation,         // 0x000C
	SystemPerformanceInformation,       // 0x0138
	SystemTimeInformation,              // 0x0020
	SystemPathInformation,              // not implemented
	SystemProcessInformation,           // 0x00C8+ per process
	SystemCallInformation,              // 0x0018 + (n * 0x0004)
	SystemConfigurationInformation,     // 0x0018
	SystemProcessorCounters,            // 0x0030 per cpu
	SystemGlobalFlag,                   // 0x0004 (fails if size != 4)
	SystemCallTimeInformation,          // not implemented
	SystemModuleInformation,            // 0x0004 + (n * 0x011C)
	SystemLockInformation,              // 0x0004 + (n * 0x0024)
	SystemStackTraceInformation,        // not implemented
	SystemPagedPoolInformation,         // checked build only
	SystemNonPagedPoolInformation,      // checked build only
	SystemHandleInformation,            // 0x0004  + (n * 0x0010)
	SystemObjectTypeInformation,        // 0x0038+ + (n * 0x0030+)
	SystemPageFileInformation,          // 0x0018+ per page file
	SystemVdmInstemulInformation,       // 0x0088
	SystemVdmBopInformation,            // invalid info class
	SystemCacheInformation,             // 0x0024
	SystemPoolTagInformation,           // 0x0004 + (n * 0x001C)
	SystemInterruptInformation,         // 0x0000, or 0x0018 per cpu
	SystemDpcInformation,               // 0x0014
	SystemFullMemoryInformation,        // checked build only
	SystemLoadDriver,                   // 0x0018, set mode only
	SystemUnloadDriver,                 // 0x0004, set mode only
	SystemTimeAdjustmentInformation,    // 0x000C, 0x0008 writeable
	SystemSummaryMemoryInformation,     // checked build only
	SystemNextEventIdInformation,       // checked build only
	SystemEventIdsInformation,          // checked build only
	SystemCrashDumpInformation,         // 0x0004
	SystemExceptionInformation,         // 0x0010
	SystemCrashDumpStateInformation,    // 0x0004
	SystemDebuggerInformation,          // 0x0002
	SystemContextSwitchInformation,     // 0x0030
	SystemRegistryQuotaInformation,     // 0x000C
	SystemAddDriver,                    // 0x0008, set mode only
	SystemPrioritySeparationInformation,// 0x0004, set mode only
	SystemPlugPlayBusInformation,       // not implemented
	SystemDockInformation,              // not implemented
	SystemPowerInfo,             // 0x0060 (XP only!)
	SystemProcessorSpeedInformation,    // 0x000C (XP only!)
	SystemTimeZoneInformation,          // 0x00AC
	SystemLookasideInformation,         // n * 0x0020
	SystemSetTimeSlipEvent,
    SystemCreateSession,				// set mode only
    SystemDeleteSession,				// set mode only
    SystemInvalidInfoClass1,			// invalid info class
    SystemRangeStartInformation,		// 0x0004 (fails if size != 4)
    SystemVerifierInformation,
    SystemAddVerifier,
    SystemSessionProcessesInformation,	// checked build only
	MaxSystemInfoClass
} SYSTEMINFOCLASS, *PSYSTEMINFOCLASS;

typedef struct _SYSTEM_BASIC_INFORMATION
{
    DWORD		dwUnknown1;               // 0
    ULONG		uKeMaximumIncrement;      // x86: 0x0002625A or 0x00018730
    ULONG		uPageSize;                // bytes
    ULONG		uMmNumberOfPhysicalPages;
    ULONG		uMmLowestPhysicalPage;
    ULONG		uMmHighestPhysicalPage;
    ULONG		uAllocationGranularity;   // bytes
    PVOID		pLowestUserAddress;
    PVOID		pMmHighestUserAddress;
    KAFFINITY	uKeActiveProcessors;
    BYTE		bKeNumberProcessors;
    BYTE		bUnknown2;
    WORD		wUnknown3;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_INFORMATION
{
	WORD	wKeProcessorArchitecture; // PROCESSOR_ARCHITECTURE_* (PROCESSOR_ARCHITECTURE_INTEL)
	WORD	wKeProcessorLevel;        // PROCESSOR_* (PROCESSOR_INTEL_PENTIUM)
	WORD	wKeProcessorRevision;     // Pentium: H=model, L=stepping
	WORD	wUnknown1;                // 0
	ULONG	uKeFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

typedef struct _MM_INFO_COUNTERS
{
	ULONG	uPageFaults;
	ULONG	uWriteCopyFaults;
	ULONG	uTransistionFaults;
	ULONG	uCacheTransitionCount;
	ULONG	uDemandZeroFaults;
	ULONG	uPagesRead;
	ULONG	uPageReadIos;
	ULONG	uCacheReadCount;
	ULONG	uCacheIoCount;
	ULONG	uPagefilePagesWritten;
	ULONG	uPagefilePageWriteIos;
	ULONG	uMappedFilePagesWritten;
	ULONG	uMappedFilePageWriteIos;
} MM_INFO_COUNTERS, *PMM_INFO_COUNTERS;

typedef struct _SYSTEM_PERFORMANCE_INFORMATION
{
	LARGE_INTEGER		liIdleTime;             // 100 nsec units
	LARGE_INTEGER		liIoReadTransferCount;
	LARGE_INTEGER		liIoWriteTransferCount;
	LARGE_INTEGER		liIoOtherTransferCount;
	ULONG				uIoReadOperationCount;
	ULONG				uIoWriteOperationCount;
	ULONG				uIoOtherOperationCount;
	ULONG				uMmAvailablePages;
	ULONG				uMmTotalCommittedPages;
	ULONG				uMmTotalCommitLimit;   // pages
	ULONG				uMmPeakCommitLimit;    // pages
	MM_INFO_COUNTERS	MmInfoCounters;
	ULONG				uPoolPaged;            // pages
	ULONG				uPoolNonPaged;         // pages
	ULONG				uPagedPoolAllocs;
	ULONG				uPagedPoolFrees;
	ULONG				uNonPagedPoolAllocs;
	ULONG				uNonPagedPoolFrees;
	ULONG				uMmTotalFreeSystemPages;
	ULONG				uMmSystemCodePage;
	ULONG				uMmTotalSystemDriverPages;
	ULONG				uMmTotalSystemCodePages;
	ULONG				uSmallNonPagedLookasideListAllocateHits;
	ULONG				uSmallPagedLookasideListAllocateHits;
	DWORD				dwUnknown1;
	ULONG				uMmSystemCachePage;
	ULONG				uMmPagedPoolPage;
	ULONG				uMmSystemDriverPage;
	ULONG				uCcFastReadNoWait;
	ULONG				uCcFastReadWait;
	ULONG				uCcFastReadResourceMiss;
	ULONG				uCcFastReadNotPossible;
	ULONG				uCcFastMdlReadNoWait;
	ULONG				uCcFastMdlReadWait;
	ULONG				uCcFastMdlReadResourceMiss;
	ULONG				uCcFastMdlReadNotPossible;
	ULONG				uCcMapDataNoWait;
	ULONG				uCcMapDataWait;
	ULONG				uCcMapDataNoWaitMiss;
	ULONG				uCcMapDataWaitMiss;
	ULONG				uCcPinMappedDataCount;
	ULONG				uCcPinReadNoWait;
	ULONG				uCcPinReadWait;
	ULONG				uCcPinReadNoWaitMiss;
	ULONG				uCcPinReadWaitMiss;
	ULONG				uCcCopyReadNoWait;
	ULONG				uCcCopyReadWait;
	ULONG				uCcCopyReadNoWaitMiss;
	ULONG				uCcCopyReadWaitMiss;
	ULONG				uCcMdlReadNoWait;
	ULONG				uCcMdlReadWait;
	ULONG				uCcMdlReadNoWaitMiss;
	ULONG				uCcMdlReadWaitMiss;
	ULONG				uCcReadAheadIos;
	ULONG				uCcLazyWriteIos;
	ULONG				uCcLazyWritePages;
	ULONG				uCcDataFlushes;
	ULONG				uCcDataPages;
	ULONG				uTotalContextSwitches; // total across cpus
	ULONG				uFirstLevelTbFills;
	ULONG				uSecondLevelTbFills;
	ULONG				uSystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

typedef struct _SYSTEM_TIME_INFORMATION
{
	LARGE_INTEGER	liKeBootTime;			// relative to 01-01-1601
	LARGE_INTEGER	liKeSystemTime;			// relative to 01-01-1601
	LARGE_INTEGER	liExpTimeZoneBias;		// utc time = local time + bias
	ULONG			uExpCurrentTimeZoneId;	// TIME_ZONE_ID_* (TIME_ZONE_ID_UNKNOWN, etc.)
	DWORD			dwUnknown1;
} SYSTEM_TIME_INFORMATION, *PSYSTEM_TIME_INFORMATION;

typedef enum
{
    StateInitialized,
    StateReady,
    StateRunning,
    StateStandby,
    StateTerminated,
    StateWait,
    StateTransition,
    StateUnknown
} THREAD_STATE;

typedef struct _SYSTEM_THREAD 
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitchCount;
    THREAD_STATE State;
    KWAIT_REASON WaitReason;
 
} SYSTEM_THREAD, 
*PSYSTEM_THREAD;
 
typedef struct _SYSTEM_PROCESSES_INFORMATION
{
    ULONG uNext;
    ULONG uThreadCount;
    ULONG Reserved1[6];
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING usName; 
    KPRIORITY BasePriority;
    DWORD uUniqueProcessId;
    ULONG InheritedFromProcessId;
    ULONG HandleCount;
    ULONG Reserved2[2];
    VM_COUNTERS VmCounters;
    IO_COUNTERS IoCounters;
    SYSTEM_THREAD Threads[1];
 
} SYSTEM_PROCESSES_INFORMATION, 
*PSYSTEM_PROCESS_INFORMATION;

typedef struct _IO_COUNTERSEX
{
    LARGE_INTEGER	ReadOperationCount;
    LARGE_INTEGER	WriteOperationCount;
    LARGE_INTEGER	OtherOperationCount;
    LARGE_INTEGER	ReadTransferCount;
    LARGE_INTEGER	WriteTransferCount;
    LARGE_INTEGER	OtherTransferCount;
} IO_COUNTERSEX, *PIO_COUNTERSEX;

typedef struct _SYSTEM_PROCESS_INFORMATION_2000
{
	ULONG			uNext;           // relative offset
	ULONG			uThreadCount;
	LARGE_INTEGER	liUnknown1;
	LARGE_INTEGER	liUnknown2;
	LARGE_INTEGER	liUnknown3;
	LARGE_INTEGER	liCreateTime;     // relative to 01-01-1601
	LARGE_INTEGER	liUserTime;       // 100 nsec units
	LARGE_INTEGER	liKernelTime;     // 100 nsec units
	UNICODE_STRING	usName;
	KPRIORITY		BasePriority;
	ULONG			uUniqueProcessId;
	ULONG			uInheritedFromUniqueProcessId;
	ULONG			uHandleCount;
	ULONG			uSessionId;      // W2K Only!
	DWORD			dwUnknown5;
	VM_COUNTERS		VmCounters;
	ULONG			uCommitCharge;   // bytes
	IO_COUNTERSEX	IoCounters;
	SYSTEM_THREAD	aST[];
} SYSTEM_PROCESS_INFORMATION_2000, *PSYSTEM_PROCESS_INFORMATION_2000;

typedef struct _SYSTEM_CALL_INFORMATION
{
	ULONG	Length;
	ULONG	NumberOfTables;
//	ULONG	NumberOfEntries[NumberOfTables]
//	ULONG	CallCounts[NumberOfTables][NumberOfEntries];
} SYSTEM_CALL_INFORMATION, *PSYSTEM_CALL_INFORMATION;

typedef struct _SYSTEM_CONFIGURATION_INFORMATION
{
	ULONG	uDiskCount;
	ULONG	uFloppyCount;
	ULONG	uCDRomCount;
	ULONG	uTapeCount;
	ULONG	uSerialCount;         // com port with mouse not included
	ULONG	uParallelCount;
} SYSTEM_CONFIGURATION_INFORMATION, *PSYSTEM_CONFIGURATION_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_COUNTERS
{
	LARGE_INTEGER	liProcessorTime;       // 100 nsec units
	LARGE_INTEGER	liKernelTime;          // 100 nsec units
	LARGE_INTEGER	liUserTime;            // 100 nsec units
	LARGE_INTEGER	liDpcTime;             // 100 nsec units
	LARGE_INTEGER	liInterruptTime;       // 100 nsec units
	ULONG			uInterruptCount;
	DWORD			dwUnknown1;
} SYSTEM_PROCESSOR_COUNTERS, *PSYSTEM_PROCESSOR_COUNTERS;

typedef struct _SYSTEM_GLOBAL_FLAG
{
	ULONG	NtGlobalFlag;        // see Q147314, Q102985, Q105677
} SYSTEM_GLOBAL_FLAG, *PSYSTEM_GLOBAL_FLAG;

typedef struct _SYSTEM_CALL_TIME_INFORMATION
{
	ULONG			Length;
	ULONG			TotalCalls;
	LARGE_INTEGER	TimeOfCalls[1];
} SYSTEM_CALL_TIME_INFORMATION, *PSYSTEM_CALL_TIME_INFORMATION;

typedef struct _SYSTEM_MODULE
{
    ULONG	Reserved[2];
    ULONG	Base;
    ULONG	Size;
    ULONG	Flags;
    USHORT	Index;
    USHORT	Unknown;
    USHORT	LoadCount;
    USHORT	ModuleNameOffset;
    CHAR	ImageName[256];
} SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG			uCount;
	SYSTEM_MODULE	aSM[];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_LOCK
{
	union
	{
		PERESOURCE_OLD	pEResourceOld;  // old ERESOURCE format
		PERESOURCE_LITE	pEResourceLite; // new "lite" format
		PERESOURCE		pEResource;     // current format
	};
	WORD	wUnknown1;                  // 1
	WORD	wUnknown2;                  // 0
	ULONG	ExclusiveOwnerThreadId;
	ULONG	uActiveCount;
	ULONG	uContentionCount;
	DWORD	dwUnknown3;
	DWORD	dwUnknown4;
	ULONG	uNumberOfSharedWaiters;
	ULONG	uNumberOfExclusiveWaiters;
} SYSTEM_LOCK, *PSYSTEM_LOCK;

typedef struct _SYSTEM_LOCK_INFORMATION
{
	ULONG		uCount;
	SYSTEM_LOCK	aSL[];
} SYSTEM_LOCK_INFORMATION, *PSYSTEM_LOCK_INFORMATION;

typedef struct _SYSTEM_HANDLE
{
	ULONG		uIdProcess;
	UCHAR		ObjectType;    // OB_TYPE_* (OB_TYPE_TYPE, etc.)
	UCHAR		Flags;         // HANDLE_FLAG_* (HANDLE_FLAG_INHERIT, etc.)
	USHORT		Handle;
	POBJECT		pObject;
	ACCESS_MASK	GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG			uCount;
	SYSTEM_HANDLE	aSH[];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION
{
	ULONG			NextEntryOffset;	// absolute offset
	ULONG			ObjectCount;
	ULONG			HandleCount;
	ULONG			TypeIndex;			// OB_TYPE_* (OB_TYPE_TYPE, etc.)
	ULONG			InvalidAttributes;	// OBJ_* (OBJ_INHERIT, etc.)
	GENERIC_MAPPING	GenericMapping;
	ACCESS_MASK		ValidAccessMask;
	POOL_TYPE		PoolType;
	BOOLEAN			SecurityRequired;
	BOOLEAN			WaitableObject;
	UNICODE_STRING	TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

// follows after SYSTEM_OBJECTTYPE_INFORMATION.TypeName
typedef struct _SYSTEM_OBJECT_INFORMATION
{
	ULONG					NextEntryOffset;		// absolute offset
	POBJECT					Object;
	ULONG					CreatorProcessId;
	USHORT					CreatorBackTraceIndex;
	USHORT					Flags;					// see "Native API Reference" page 24
	LONG					PointerCount;
	LONG					HandleCount;
	ULONG					PagedPoolCharge;
	ULONG					NonPagedPoolCharge;
	ULONG					ExclusiveProcessId;
	PSECURITY_DESCRIPTOR	SecurityDescriptor;
	UNICODE_STRING			ObjectName;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

typedef struct _SYSTEM_PAGE_FILE_INFORMATION
{
	ULONG			NextEntryOffset;	// relative offset
	ULONG			CurrentSize;		// pages
	ULONG			TotalUsed;			// pages
	ULONG			PeakUsed;			// pages
	UNICODE_STRING	FileName;
} SYSTEM_PAGE_FILE_INFORMATION, *PSYSTEM_PAGE_FILE_INFORMATION;

typedef struct _SYSTEM_VDM_INSTEMUL_INFO
{
	BOOL	fExVdmSegmentNotPresent;
	ULONG	uOpcode0FV86;
	ULONG	uOpcodeESPrefixV86;
	ULONG	uOpcodeCSPrefixV86;
	ULONG	uOpcodeSSPrefixV86;
	ULONG	uOpcodeDSPrefixV86;
	ULONG	uOpcodeFSPrefixV86;
	ULONG	uOpcodeGSPrefixV86;
	ULONG	uOpcodeOPER32PrefixV86;
	ULONG	uOpcodeADDR32PrefixV86;
	ULONG	uOpcodeINSBV86;
	ULONG	uOpcodeINSWV86;
	ULONG	uOpcodeOUTSBV86;
	ULONG	uOpcodeOUTSWV86;
	ULONG	uOpcodePUSHFV86;
	ULONG	uOpcodePOPFV86;
	ULONG	uOpcodeINTnnV86;
	ULONG	uOpcodeINTOV86;
	ULONG	uOpcodeIRETV86;
	ULONG	uOpcodeINBimmV86;
	ULONG	uOpcodeINWimmV86;
	ULONG	uOpcodeOUTBimmV86;
	ULONG	uOpcodeOUTWimmV86;
	ULONG	uOpcodeINBV86;
	ULONG	uOpcodeINWV86;
	ULONG	uOpcodeOUTBV86;
	ULONG	uOpcodeOUTWV86;
	ULONG	uOpcodeLOCKPrefixV86;
	ULONG	uOpcodeREPNEPrefixV86;
	ULONG	uOpcodeREPPrefixV86;
	ULONG	uOpcodeHLTV86;
	ULONG	uOpcodeCLIV86;
	ULONG	uOpcodeSTIV86;
	ULONG	uVdmBopCount;
} SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;

typedef struct _SYSTEM_CACHE_INFORMATION
{
    ULONG uFileCache;           // bytes
	ULONG uFileCachePeak;       // bytes
    ULONG PageFaultCount;
    ULONG MinimumWorkingSet;
    ULONG MaximumWorkingSet;
    ULONG TransitionSharedPages;
    ULONG TransitionSharedPagesPeak;
    ULONG Reserved[2];
} SYSTEM_CACHE_INFORMATION, *PSYSTEM_CACHE_INFORMATION;

typedef struct _SYSTEM_POOL_ENTRY
{
	BOOLEAN	Allocated;
	BOOLEAN	Spare0;
	USHORT	AllocatorBackTraceIndex;
	ULONG	Size;
	union
	{
		UCHAR	Tag[4];
		ULONG	TagUlong;
		PVOID	ProcessChargedQuota;
	};
} SYSTEM_POOL_ENTRY, *PSYSTEM_POOL_ENTRY;

typedef struct _SYSTEM_POOL_INFORMATION
{
	ULONG				TotalSize;
	PVOID				FirstEntry;
	USHORT				EntryOverhead;
	BOOLEAN				PoolTagPresent;
	BOOLEAN				Spare0;
	ULONG				NumberOfEntries;
	SYSTEM_POOL_ENTRY	Entries[1];
} SYSTEM_POOL_INFORMATION, *PSYSTEM_POOL_INFORMATION;

typedef struct _SYSTEM_POOL_TAG
{
	union
	{
		UCHAR	Tag[4];
		ULONG	TagUlong;
    };
	ULONG	PagedPoolAllocs;
	ULONG	PagedPoolFrees;
	ULONG	PagedPoolUsage;
	ULONG	NonPagedPoolAllocs;
	ULONG	NonPagedPoolFrees;
	ULONG	NonPagedPoolUsage;
} SYSTEM_POOL_TAG, *PSYSTEM_POOL_TAG;

typedef struct _SYSTEM_POOL_TAG_INFORMATION
{
	ULONG			uCount;
	SYSTEM_POOL_TAG	aSPT[];
} SYSTEM_POOL_TAG_INFORMATION, *PSYSTEM_POOL_TAG_INFORMATION;

typedef struct _SYSTEM_INTERRUPT_INFORMATION
{
	ULONG	ContextSwitches;
	ULONG	DpcCount;
	ULONG	DpcRate;
	ULONG	TimeIncrement;
	ULONG	DpcBypassCount;
	ULONG	ApcBypassCount;
} SYSTEM_INTERRUPT_INFORMATION, *PSYSTEM_INTERRUPT_INFORMATION;

typedef struct _SYSTEM_DPC_INFORMATION
{
	DWORD	dwUnknown1;
	ULONG	MaximumDpcQueueDepth;
	ULONG	MinimumDpcRate;
	ULONG	AdjustDpcThreshold;
	ULONG	IdealDpcRate;
} SYSTEM_DPC_INFORMATION, *PSYSTEM_DPC_INFORMATION;

typedef struct _SYSTEM_MEMORY_INFO
{
	PUCHAR	StringOffset;
	USHORT	ValidCount;
	USHORT	TransitionCount;
	USHORT	ModifiedCount;
	USHORT	PageTableCount;
} SYSTEM_MEMORY_INFO, *PSYSTEM_MEMORY_INFO;

typedef struct _SYSTEM_MEMORY_INFORMATION
{
	ULONG				InfoSize;
	ULONG				StringStart;
	SYSTEM_MEMORY_INFO	Memory[1];
} SYSTEM_MEMORY_INFORMATION, *PSYSTEM_MEMORY_INFORMATION;

typedef struct _SYSTEM_LOAD_DRIVER
{
	UNICODE_STRING			DriverName;			// input
	PVOID					BaseAddress;		// output
	PVOID					SectionPointer;		// output
	PVOID					EntryPoint;			// output
	PIMAGE_EXPORT_DIRECTORY	ExportDirectory;	// output
} SYSTEM_LOAD_DRIVER, *PSYSTEM_LOAD_DRIVER;

typedef struct _SYSTEM_UNLOAD_DRIVER
{
	PVOID	SectionPointer;
} SYSTEM_UNLOAD_DRIVER, *PSYSTEM_UNLOAD_DRIVER;

typedef struct _SYSTEM_QUERY_TIME_ADJUSTMENT
{
	ULONG	TimeAdjustment;
	ULONG	MaximumIncrement;
	BOOLEAN	TimeSynchronization;
} SYSTEM_QUERY_TIME_ADJUSTMENT, *PSYSTEM_QUERY_TIME_ADJUSTMENT;

typedef struct _SYSTEM_SET_TIME_ADJUSTMENT
{
	ULONG	TimeAdjustment;
	BOOLEAN	TimeSynchronization;
} SYSTEM_SET_TIME_ADJUSTMENT, *PSYSTEM_SET_TIME_ADJUSTMENT;

typedef struct _SYSTEM_CRASH_DUMP_INFORMATION
{
	HANDLE	CrashDumpSectionHandle;
} SYSTEM_CRASH_DUMP_INFORMATION, *PSYSTEM_CRASH_DUMP_INFORMATION;

typedef struct _SYSTEM_CRASH_DUMP_INFORMATION_2000
{
	HANDLE	CrashDumpSectionHandle;
	HANDLE	Unknown;				// Windows 2000 only
} SYSTEM_CRASH_DUMP_INFORMATION_2000, *PSYSTEM_CRASH_DUMP_INFORMATION_2000;

typedef struct _SYSTEM_EXCEPTION_INFORMATION
{
	ULONG	AlignmentFixupCount;
	ULONG	ExceptionDispatchCount;
	ULONG	FloatingEmulationCount;
	ULONG	ByteWordEmulationCount;
} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

typedef struct _SYSTEM_CRASH_DUMP_STATE_INFORMATION
{
	ULONG	ValidCrashDump;
} SYSTEM_CRASH_DUMP_STATE_INFORMATION, *PSYSTEM_CRASH_DUMP_STATE_INFORMATION;

typedef struct _SYSTEM_CRASH_DUMP_STATE_INFORMATION_2000
{
	ULONG	ValidCrashDump;
	ULONG	Unknown;		// Windows 2000 only
} SYSTEM_CRASH_DUMP_STATE_INFORMATION_2000, *PSYSTEM_CRASH_DUMP_STATE_INFORMATION_2000;

typedef struct _SYSTEM_DEBUGGER_INFORMATION
{
	BOOLEAN	KernelDebuggerEnabled;
	BOOLEAN	KernelDebuggerNotPresent;
} SYSTEM_DEBUGGER_INFORMATION, *PSYSTEM_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_CONTEXT_SWITCH_INFORMATION
{
	ULONG	ContextSwitches;
	ULONG	FindAny;
	ULONG	FindLast;
	ULONG	FindIdeal;
	ULONG	IdleAny;
	ULONG	IdleCurrent;
	ULONG	IdleLast;
	ULONG	IdleIdeal;
	ULONG	PreemptAny;
	ULONG	PreemptCurrent;
	ULONG	PreemptLast;
	ULONG	SwitchToIdle;
} SYSTEM_CONTEXT_SWITCH_INFORMATION, *PSYSTEM_CONTEXT_SWITCH_INFORMATION;

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION
{
	ULONG	RegistryQuotaAllowed;	// bytes
	ULONG	RegistryQuotaUsed;		// bytes
	ULONG	PagedPoolSize;			// bytes
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_ADD_DRIVER
{
	UNICODE_STRING	ModuleName;
} SYSTEM_ADD_DRIVER, *PSYSTEM_ADD_DRIVER;

typedef struct _SYSTEM_PRIORITY_SEPARATION_INFORMATION
{
	ULONG	PrioritySeparation;		// 0..2
} SYSTEM_PRIORITY_SEPARATION_INFORMATION, *PSYSTEM_PRIORITY_SEPARATION_INFORMATION;

#define MAX_BUS_NAME	24

typedef enum _PLUGPLAY_BUS_CLASS
{
	SystemBus,
	PlugPlayVirtualBus,
	MaxPlugPlayBusClass
} PLUGPLAY_BUS_CLASS, *PPLUGPLAY_BUS_CLASS;

typedef enum _PLUGPLAY_VIRTUAL_BUS_TYPE
{
	Root,
	MaxPlugPlayVirtualBusType
} PLUGPLAY_VIRTUAL_BUS_TYPE, *PPLUGPLAY_VIRTUAL_BUS_TYPE;

typedef enum _INTERFACE_TYPE
{
	InterfaceTypeUndefined = -1,
	Internal,
	Isa,
	Eisa,
	MicroChannel,
	TurboChannel,
	PCIBus,
	VMEBus,
	NuBus,
	PCMCIABus,
	CBus,
	MPIBus,
	MPSABus,
	ProcessorInternal,
	InternalPowerBus,
	PNPISABus,
	PNPBus,
	MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

typedef struct _PLUGPLAY_BUS_TYPE
{
	PLUGPLAY_BUS_CLASS	BusClass;
	union
	{
		INTERFACE_TYPE				SystemBusType;
		PLUGPLAY_VIRTUAL_BUS_TYPE	PlugPlayVirtualBusType;
    };
} PLUGPLAY_BUS_TYPE, *PPLUGPLAY_BUS_TYPE;

typedef struct _PLUGPLAY_BUS_INSTANCE
{
	PLUGPLAY_BUS_TYPE	BusType;
	ULONG				BusNumber;
	WCHAR				BusName[MAX_BUS_NAME];
} PLUGPLAY_BUS_INSTANCE, *PPLUGPLAY_BUS_INSTANCE;

typedef struct _SYSTEM_PLUGPLAY_BUS_INFORMATION
{
	ULONG					BusCount;
	PLUGPLAY_BUS_INSTANCE	BusInstance[1];
} SYSTEM_PLUGPLAY_BUS_INFORMATION, *PSYSTEM_PLUGPLAY_BUS_INFORMATION;

typedef enum _SYSTEM_DOCK_STATE
{
	SystemDockStateUnknown,
	SystemUndocked,
	SystemDocked
} SYSTEM_DOCK_STATE, *PSYSTEM_DOCK_STATE;

typedef struct _SYSTEM_DOCK_INFORMATION
{
	SYSTEM_DOCK_STATE	DockState;
	INTERFACE_TYPE		DeviceBusType;
	ULONG				DeviceBusNumber;
	ULONG				SlotNumber;
} SYSTEM_DOCK_INFORMATION, *PSYSTEM_DOCK_INFORMATION;

typedef struct _SYSTEM_POWER_INFORMATION	// not for SystemPowerInfo !
{
	BOOLEAN			SystemSuspendSupported;
	BOOLEAN			SystemHibernateSupported;
	BOOLEAN			ResumeTimerSupportsSuspend;
	BOOLEAN			ResumeTimerSupportsHibernate;
	BOOLEAN			LidSupported;
	BOOLEAN			TurboSettingSupported;
	BOOLEAN			TurboMode;
	BOOLEAN			SystemAcOrDc;
	BOOLEAN			PowerDownDisabled;
	LARGE_INTEGER	SpindownDrives;
} SYSTEM_POWER_INFORMATION, *PSYSTEM_POWER_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_SPEED_INFORMATION	// not for SystemProcessorSpeedInformation !
{
	ULONG	MaximumProcessorSpeed;
	ULONG	CurrentAvailableSpeed;
	ULONG	ConfiguredSpeedLimit;
	BOOLEAN	PowerLimit;
	BOOLEAN	ThermalLimit;
	BOOLEAN	TurboLimit;
} SYSTEM_PROCESSOR_SPEED_INFORMATION, *PSYSTEM_PROCESSOR_SPEED_INFORMATION;

typedef struct _SYSTEM_TIME_ZONE_INFORMATION
{
	LONG		Bias;
	WCHAR		StandardName[32];
	TIME_FIELDS	StandardDate;
	LONG		StandardBias;
	WCHAR		DaylightName[32];
	TIME_FIELDS	DaylightDate;
	LONG		DaylightBias;
} SYSTEM_TIME_ZONE_INFORMATION, *PSYSTEM_TIME_ZONE_INFORMATION;

typedef struct _SYSTEM_LOOKASIDE
{
	USHORT		Depth;
	USHORT		MaximumDepth;
	ULONG		TotalAllocates;
	ULONG		AllocateMisses;
	ULONG		TotalFrees;
	ULONG		FreeMisses;
	POOL_TYPE	Type;
	ULONG		Tag;
	ULONG		Size;
} SYSTEM_LOOKASIDE, *PSYSTEM_LOOKASIDE;

typedef struct _SYSTEM_LOOKASIDE_INFORMATION
{
	SYSTEM_LOOKASIDE	asl[];
} SYSTEM_LOOKASIDE_INFORMATION, *PSYSTEM_LOOKASIDE_INFORMATION;

typedef struct _SYSTEM_SET_TIME_SLIP_EVENT
{
	HANDLE	TimeSlipEvent;
} SYSTEM_SET_TIME_SLIP_EVENT, *PSYSTEM_SET_TIME_SLIP_EVENT;

typedef struct _SYSTEM_CREATE_SESSION
{
	ULONG	Session;
} SYSTEM_CREATE_SESSION, *PSYSTEM_CREATE_SESSION;

typedef struct _SYSTEM_DELETE_SESSION
{
	ULONG	Session;
} SYSTEM_DELETE_SESSION, *PSYSTEM_DELETE_SESSION;

typedef struct _SYSTEM_RANGE_START_INFORMATION
{
	PVOID	SystemRangeStart;
} SYSTEM_RANGE_START_INFORMATION, *PSYSTEM_RANGE_START_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
	IN SYSTEMINFOCLASS	SystemInformationClass,
	OUT PVOID			pSystemInformation,
	IN ULONG			uSystemInformationLength,
    OUT PULONG			puReturnLength OPTIONAL
	);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
	IN SYSTEMINFOCLASS	SystemInformationClass,
	IN PVOID			pSystemInformation,
	IN ULONG			uSystemInformationLength
	);

// Time functions
NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemTime(
	OUT PLARGE_INTEGER	SystemTime
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemTime(
	IN PLARGE_INTEGER	NewTime,
	OUT PLARGE_INTEGER	OldTime OPTIONAL
);

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
	IN PLARGE_INTEGER	pliTime,
	OUT PTIME_FIELDS	pTimeFields
);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime(
	IN	PTIME_FIELDS	pTimeFields,
	OUT PLARGE_INTEGER	pliTime
);

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime(
    IN ULONG			SecondsSince1970,
    OUT PLARGE_INTEGER	Time
);

NTSYSAPI
VOID
NTAPI
RtlTimeToSecondsSince1970(
	IN PLARGE_INTEGER	Time,
	OUT PULONG			SecondsSince1970
);

// Event functions
NTSYSAPI
NTSTATUS
NTAPI
NtOpenEvent(
	PHANDLE				phEvent,
	ACCESS_MASK			AccessMask,
	POBJECT_ATTRIBUTES	pObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
NtClearEvent(
	IN HANDLE	hEvent
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEvent(
	IN HANDLE	hEvent,
	OUT PLONG	plSignaled OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN LONG InitialCount,
    IN LONG MaximumCount
);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT PLONG PreviousCount OPTIONAL
);

typedef enum _SEMAPHORE_INFORMATION_CLASS
{
	SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT PULONG ResultLength OPTIONAL
);

typedef struct _SEMAPHORE_BASIC_INFORMATION
{
	LONG CurrentCount;
	LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

// Directory and Symbolic Link functions
NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
	OUT PHANDLE				phDirectory,
	IN ACCESS_MASK			AccessMask,
	IN POBJECT_ATTRIBUTES	pObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
	OUT PHANDLE				DirectoryHandle,
	IN ACCESS_MASK			DesiredAccess,
	IN POBJECT_ATTRIBUTES	ObjectAttributes
);

typedef struct _DIRECTORY_CONTENTS
{
    struct
	{
        UNICODE_STRING Name;
        UNICODE_STRING Type;
    } Entry[ANYSIZE_ARRAY];
} DIRECTORY_CONTENTS, *PDIRECTORY_CONTENTS;

NTSYSAPI
NTSTATUS
NTAPI 
NtQueryDirectoryObject(
	IN HANDLE				DirectoryHandle,
	OUT PDIRECTORY_CONTENTS	Buffer,
	IN ULONG				Length,
	IN BOOLEAN				ReturnSingleEntry,
	IN BOOLEAN				RestartScan,
	IN OUT PULONG			Index,
	OUT PULONG				ResultLength OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSymbolicLinkObject(
	OUT PHANDLE				SymbolicLinkHandle,
	IN ACCESS_MASK			DesiredAccess,
	IN POBJECT_ATTRIBUTES	ObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
	IN HANDLE			SymbolicLinkHandle,
	OUT PUNICODE_STRING	NameString,
	OUT PULONG			ResultLength OPTIONAL
);

// File functions
NTSYSAPI
NTSTATUS
NTAPI
NtCreateFile(
	PHANDLE				phFile,
	ACCESS_MASK			AccessMask,
	POBJECT_ATTRIBUTES	pObjectAttributes,
	PIO_STATUS_BLOCK	pIoStatusBlock,
	PLARGE_INTEGER		pliAllocationSize,
	ULONG				uFileAttributes,
	ULONG				uShareAccess,
	ULONG				uCreateDisposition,
	ULONG				uCreateOptions,
	PVOID				pEaBuffer,
	ULONG				uEaLength
);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenFile(
	PHANDLE				phFile,
	ACCESS_MASK			AccessMask,

	POBJECT_ATTRIBUTES	pObjectAttributes,
	PIO_STATUS_BLOCK	pIoStatusBlock,
	ULONG				uShareAccess,
	ULONG				uOpenOptions
);

NTSYSAPI 
NTSTATUS
NTAPI
NtWriteFile(
  IN HANDLE               FileHandle,
  IN HANDLE               Event OPTIONAL,
  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,
  IN PVOID                ApcContext OPTIONAL,
  OUT PIO_STATUS_BLOCK    IoStatusBlock,
  IN PVOID                Buffer,
  IN ULONG                Length,
  IN PLARGE_INTEGER       ByteOffset OPTIONAL,
  IN PULONG               Key OPTIONAL );

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteFile(
	IN POBJECT_ATTRIBUTES	pObjectAttributes
);

typedef enum _FILE_INFORMATION_CLASS
{
    FileDirectoryInformation       = 1,
    FileFullDirectoryInformation, // 2
    FileBothDirectoryInformation, // 3
    FileBasicInformation,         // 4
    FileStandardInformation,      // 5
    FileInternalInformation,      // 6
    FileEaInformation,            // 7
    FileAccessInformation,        // 8
    FileNameInformation,          // 9
    FileRenameInformation,        // 10
    FileLinkInformation,          // 11
    FileNamesInformation,         // 12
    FileDispositionInformation,   // 13
    FilePositionInformation,      // 14
    FileFullEaInformation,        // 15
    FileModeInformation,          // 16
    FileAlignmentInformation,     // 17
    FileAllInformation,           // 18
    FileAllocationInformation,    // 19
    FileEndOfFileInformation,     // 20
    FileAlternateNameInformation, // 21
    FileStreamInformation,        // 22
    FilePipeInformation,          // 23
    FilePipeLocalInformation,     // 24
    FilePipeRemoteInformation,    // 25
    FileMailslotQueryInformation, // 26
    FileMailslotSetInformation,   // 27
    FileCompressionInformation,   // 28
    FileObjectIdInformation,      // 29
    FileCompletionInformation,    // 30
    FileMoveClusterInformation,   // 31
    FileInformationReserved32,    // 32
    FileInformationReserved33,    // 33
    FileNetworkOpenInformation,   // 34
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG FileInformationLength,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
	IN BOOLEAN RestartScan
);

typedef struct _FILE_DIRECTORY_INFORMATION
{
    ULONG			NextEntryOffset;
    ULONG			FileIndex;
    LARGE_INTEGER	CreationTime;
    LARGE_INTEGER	LastAccessTime;
    LARGE_INTEGER	LastWriteTime;
    LARGE_INTEGER	ChangeTime;
    LARGE_INTEGER	EndOfFile;
    LARGE_INTEGER	AllocationSize;
    ULONG			FileAttributes;
    ULONG			FileNameLength;
    WCHAR			FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION
{
    ULONG			NextEntryOffset;
    ULONG			FileIndex;
    LARGE_INTEGER	CreationTime;
    LARGE_INTEGER	LastAccessTime;
    LARGE_INTEGER	LastWriteTime;
    LARGE_INTEGER	ChangeTime;
    LARGE_INTEGER	EndOfFile;
    LARGE_INTEGER	AllocationSize;
    ULONG			FileAttributes;
    ULONG			FileNameLength;
    ULONG			EaSize;
    WCHAR			FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION
{
    ULONG			NextEntryOffset;
    ULONG			FileIndex;
    LARGE_INTEGER	CreationTime;
    LARGE_INTEGER	LastAccessTime;
    LARGE_INTEGER	LastWriteTime;
    LARGE_INTEGER	ChangeTime;
    LARGE_INTEGER	EndOfFile;
    LARGE_INTEGER	AllocationSize;
    ULONG			FileAttributes;
    ULONG			FileNameLength;
    ULONG			EaSize;
    CCHAR			ShortNameLength;
    WCHAR			ShortName[12];
    WCHAR			FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_BASIC_INFORMATION
{                    
    LARGE_INTEGER	CreationTime;                             
    LARGE_INTEGER	LastAccessTime;                           
    LARGE_INTEGER	LastWriteTime;                            
    LARGE_INTEGER	ChangeTime;                               
    ULONG			FileAttributes;                                   
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;         

typedef struct _FILE_STANDARD_INFORMATION
{                 
    LARGE_INTEGER	AllocationSize;                           
    LARGE_INTEGER	EndOfFile;                                
    ULONG			NumberOfLinks;                                    
    BOOLEAN			DeletePending;                                  
    BOOLEAN			Directory;                                      
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;   
                                                            
typedef struct _FILE_INTERNAL_INFORMATION
{
    LARGE_INTEGER	IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION
{
    ULONG	EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION
{
    ACCESS_MASK	AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_NAME_INFORMATION
{
    ULONG	FileNameLength;
    WCHAR	FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION
{
    BOOLEAN	ReplaceIfExists;
    HANDLE	RootDirectory;
    ULONG	FileNameLength;
    WCHAR	FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_LINK_INFORMATION
{
    BOOLEAN	ReplaceIfExists;
    HANDLE	RootDirectory;
    ULONG	FileNameLength;
    WCHAR	FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION
{
    ULONG	NextEntryOffset;
    ULONG	FileIndex;
    ULONG	FileNameLength;
    WCHAR	FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION
{
    LARGE_INTEGER	AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION
{
    LARGE_INTEGER   CompressedFileSize;
    USHORT          CompressionFormat;
    UCHAR           CompressionUnitShift;
    UCHAR           ChunkShift;
    UCHAR           ClusterShift;
    UCHAR           Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION
{
    HANDLE  Port;
    ULONG   Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    IN HANDLE					FileHandle,
    OUT PIO_STATUS_BLOCK		IoStatusBlock,
    OUT PVOID					FileInformation,
    IN ULONG					Length,
    IN FILE_INFORMATION_CLASS	FileInformationClass
);

NTSYSAPI
NTSTATUS

NTAPI
NtDeviceIoControlFile(
    IN HANDLE				FileHandle,
    IN HANDLE				Event OPTIONAL,
    IN PIO_APC_ROUTINE		ApcRoutine OPTIONAL,
    IN PVOID				ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK	IoStatusBlock,
    IN ULONG				IoControlCode,
    IN PVOID				InputBuffer OPTIONAL,
    IN ULONG				InputBufferLength,
    OUT PVOID				OutputBuffer OPTIONAL,
    IN ULONG				OutputBufferLength
);

NTSYSAPI
NTSTATUS
NTAPI
NtFsControlFile(
    IN HANDLE				FileHandle,
    IN HANDLE				Event OPTIONAL,
    IN PIO_APC_ROUTINE		ApcRoutine OPTIONAL,
    IN PVOID				ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK	IoStatusBlock,
    IN ULONG				FsControlCode,
    IN PVOID				InputBuffer OPTIONAL,
    IN ULONG				InputBufferLength,
    OUT PVOID				OutputBuffer OPTIONAL,
    IN ULONG				OutputBufferLength
);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    IN HANDLE				FileHandle,
    OUT PIO_STATUS_BLOCK	IoStatusBlock,
    OUT PVOID				FsInformation,
    IN ULONG				Length,
    IN FS_INFORMATION_CLASS	FsInformationClass
);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    IN HANDLE				FileHandle,
    OUT PIO_STATUS_BLOCK	IoStatusBlock
);

// Process functions
#define NtCurrentProcess()				((HANDLE) -1)

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcess(
	OUT PHANDLE				phProcess,
	IN ACCESS_MASK			AccessMask,
	IN POBJECT_ATTRIBUTES	pObjectAttributes,
	IN PCLIENT_ID			pClientId
);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcess(
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN HANDLE InheritFromProcessHandle,
    IN BOOLEAN InheritHandles,
    IN HANDLE SectionHandle OPTIONAL,
    IN HANDLE DebugPort OPTIONAL,
    IN HANDLE ExceptionPort OPTIONAL
);

typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation,
	ProcessQuotaLimits,			// QUOTA_LIMITS
	ProcessIoCounters,			// IOCOUNTERS
	ProcessVmCounters,			// VM_COUNTERS
	ProcessTimes,				// KERNEL_USER_TIMES
	ProcessBasePriority,		// BASE_PRIORITY_INFORMATION
	ProcessRaisePriority,
	ProcessDebugPort,
	ProcessExceptionPort,
	ProcessAccessToken,
	ProcessLdtInformation,
	ProcessLdtSize,
	ProcessDefaultHardErrorMode,
	ProcessIoPortHandlers,          // Note: this is kernel mode only
	ProcessPooledUsageAndLimits,
	ProcessWorkingSetWatch,
	ProcessUserModeIOPL,
	ProcessEnableAlignmentFaultFixup,
	ProcessPriorityClass,
	ProcessWx86Information,
	ProcessHandleCount,
	ProcessAffinityMask,		// AFFINITY_MASK
	ProcessPriorityBoost,
	ProcessDeviceMap,
    ProcessSessionInformation,
    ProcessForegroundInformation,
    ProcessWow64Information,
    MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef struct _PROCESS_BASIC_INFORMATION
{
	NTSTATUS	ExitStatus;
	PPEB		PebBaseAddress;
	KAFFINITY	AffinityMask;
	KPRIORITY	BasePriority;
	ULONG		uUniqueProcessId;
	ULONG		uInheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_RAISE_PRIORITY
{
	KPRIORITY	RaisePriority;
} PROCESS_RAISE_PRIORITY, *PPROCESS_RAISE_PRIORITY;

typedef struct _PROCESS_DEBUG_PORT_INFORMATION
{
	HANDLE	DebugPort;
} PROCESS_DEBUG_PORT_INFORMATION, *PPROCESS_DEBUG_PORT_INFORMATION;

typedef struct _PROCESS_EXCEPTION_PORT
{
	HANDLE	ExceptionPort;
} PROCESS_EXCEPTION_PORT, *PPROCESS_EXCEPTION_PORT;

typedef struct _PROCESS_ACCESS_TOKEN
{
	HANDLE	Token;
	HANDLE	Thread;
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

#ifndef _LDT_ENTRY_DEFINED
#define _LDT_ENTRY_DEFINED

typedef struct _LDT_ENTRY
{
    USHORT	LimitLow;
    USHORT	BaseLow;
    union
	{
        struct
		{
            UCHAR	BaseMid;
            UCHAR	Flags1;     // Declare as bytes to avoid alignment
            UCHAR	Flags2;     // Problems.
            UCHAR	BaseHi;
        } Bytes;

        struct
		{
            ULONG	BaseMid : 8;
            ULONG	Type : 5;
            ULONG	Dpl : 2;
            ULONG	Pres : 1;
            ULONG	LimitHi : 4;
            ULONG	Sys : 1;
            ULONG	Reserved_0 : 1;
            ULONG	Default_Big : 1;
            ULONG	Granularity : 1;
            ULONG	BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;

#endif

#define LDT_TABLE_SIZE  (8 * 1024 * sizeof(LDT_ENTRY))

typedef struct _LDT_INFORMATION
{
    ULONG		Start;
    ULONG		Length;
    LDT_ENTRY	LdtEntries[1];
} PROCESS_LDT_INFORMATION, *PPROCESS_LDT_INFORMATION;

typedef struct _LDT_SIZE
{
	ULONG	Length;
} PROCESS_LDT_SIZE, *PPROCESS_LDT_SIZE;

typedef struct _PROCESS_DEFAULT_HARDERROR_MODE_INFORMATION
{
	ULONG	HardErrorMode;	// SEM_* (SEM_FAILCRITICALERRORS, etc.)
} PROCESS_DEFAULT_HARDERROR_MODE_INFORMATION, *PPROCESS_DEFAULT_HARDERROR_MODE_INFORMATION;

typedef struct _PROCESS_POOLED_USAGE_AND_LIMITS_INFORMATION
{
	ULONG	PeakPagedPoolUsage;
	ULONG	PagedPoolUsage;
	ULONG	PagedPoolLimit;
	ULONG	PeakNonPagedPoolUsage;
	ULONG	NonPagedPoolUsage;
	ULONG	NonPagedPoolLimit;
	ULONG	PeakPagefileUsage;
	ULONG	PagefileUsage;
	ULONG	PagefileLimit;
} PROCESS_POOLED_USAGE_AND_LIMITS_INFORMATION, *PPROCESS_POOLED_USAGE_AND_LIMITS_INFORMATION;

typedef struct _PROCESS_WS_WATCH_INFORMATION
{
	PVOID	FaultingPc;
	PVOID	FaultingVa;
} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;

typedef struct _PROCESS_IOPL
{
	ULONG	Iopl;
} PROCESS_IOPL, *PPROCESS_IOPL;

typedef struct _PROCESS_ALLIGNMENT_FAULT_FIXUP
{
	BOOLEAN	EnableAllignmentFaultFixup;
} PROCESS_ALLIGNMENT_FAULT_FIXUP, *PPROCESS_ALLIGNMENT_FAULT_FIXUP;

#define KRNL_NORMAL_PRIORITY_CLASS       0x02
#define KRNL_IDLE_PRIORITY_CLASS         0x01
#define KRNL_HIGH_PRIORITY_CLASS         0x03
#define KRNL_REALTIME_PRIORITY_CLASS     0x04

typedef struct _PROCESS_PRIORITY_CLASS_INFORMATION
{
	UCHAR	Unknown;
	UCHAR	PriorityClass;
} PROCESS_PRIORITY_CLASS_INFORMATION, *PPROCESS_PRIORITY_CLASS_INFORMATION;

typedef struct _PROCESS_X86_INFORMATION
{
	ULONG	x86Info;
} PROCESS_X86_INFORMATION, *PPROCESS_X86_INFORMATION;

typedef struct _PROCESS_HANDLE_COUNT_INFORMATION
{
	ULONG	HandleCount;
} PROCESS_HANDLE_COUNT_INFORMATION, *PPROCESS_HANDLE_COUNT_INFORMATION;

typedef struct _PROCESS_PRIORITY_BOOST_INFORMATION
{
	ULONG	PriorityBoostEnabled;
} PROCESS_PRIORITY_BOOST_INFORMATION, *PPROCESS_PRIORITY_BOOST_INFORMATION;

typedef struct _PROCESS_DEVICE_MAP_INFORMATION
{
    union
	{
        struct
		{
            HANDLE	DirectoryHandle;
        } Set;

        struct
		{
            ULONG	DriveMap;
            UCHAR	DriveType[32];
        } Query;
    };

} PROCESS_DEVICE_MAP_INFORMATION, *PPROCESS_DEVICE_MAP_INFORMATION;

typedef struct _PROCESS_SESSION_INFORMATION
{
    ULONG	SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    IN HANDLE			hProcess,
    IN PROCESSINFOCLASS	ProcessInformationClass,
    OUT PVOID			pProcessInformation,
    IN ULONG			uProcessInformationLength,
    OUT PULONG			puReturnLength OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
    IN HANDLE			hProcess,
    IN PROCESSINFOCLASS	ProcessInformationClass,
    OUT PVOID			pProcessInformation,
    IN ULONG			uProcessInformationLength
);

NTSTATUS
NTAPI
RtlCreateProcessParameters(
    OUT PPROCESS_PARAMETERS *ProcessParameters,
    IN PUNICODE_STRING ImageFile,
    IN PUNICODE_STRING DllPath OPTIONAL,
    IN PUNICODE_STRING CurrentDirectory OPTIONAL,
    IN PUNICODE_STRING CommandLine OPTIONAL,
    IN ULONG CreationFlags,
    IN PUNICODE_STRING WindowTitle OPTIONAL,
    IN PUNICODE_STRING Desktop OPTIONAL,
    IN PUNICODE_STRING Reserved OPTIONAL,
    IN PUNICODE_STRING Reserved2 OPTIONAL
);

NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    IN PPROCESS_PARAMETERS ProcessParameters
);

// Thread functions
#define NtCurrentThread()				((HANDLE) -2)

typedef struct _USER_STACK
{
	PVOID	FixedStackBase;
	PVOID	FixedStackLimit;
	PVOID	ExpandableStackBase;
	PVOID	ExpandableStackLimit;
	PVOID	ExpandableStackBottom;
} USER_STACK, *PUSER_STACK;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThread(
    OUT PHANDLE				ThreadHandle,
    IN ACCESS_MASK			DesiredAccess,
    IN POBJECT_ATTRIBUTES	ObjectAttributes,
    IN HANDLE				ProcessHandle,
    OUT PCLIENT_ID			ClientId,
    IN PCONTEXT				ThreadContext,
    IN PUSER_STACK			UserStack,
    IN BOOLEAN				CreateSuspended
);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThread(
	OUT PHANDLE				phThread,
	IN ACCESS_MASK			AccessMask,
	IN POBJECT_ATTRIBUTES	pObjectAttributes,
	IN PCLIENT_ID			pClientId
);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateThread(
    IN HANDLE	ThreadHandle OPTIONAL,
    IN NTSTATUS	ExitStatus
);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendThread(
    IN HANDLE	ThreadHandle,
    OUT PULONG	PreviousSuspendCount OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeThread(
    IN HANDLE	ThreadHandle,
    OUT PULONG	PreviousSuspendCount OPTIONAL
);

typedef enum _THREADINFOCLASS
{
	ThreadBasicInformation,
	ThreadTimes,				// KERNEL_USER_TIMES
	ThreadPriority,
	ThreadBasePriority,			// BASE_PRIORITY_INFORMATION
	ThreadAffinityMask,			// AFFINITY_MASK
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending,			// W2K
	ThreadHideFromDebugger,		// W2K
	MaxThreadInfoClass
} THREADINFOCLASS;

typedef struct _THREAD_BASIC_INFORMATION
{
    NTSTATUS	ExitStatus;
    PTEB		TebBaseAddress;
    CLIENT_ID	ClientId;
    KAFFINITY	AffinityMask;
    KPRIORITY	Priority;
    KPRIORITY	BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

typedef struct _THREAD_PRIORITY
{
	KPRIORITY	Priority;
} THREAD_PRIORITY, *PTHREAD_PRIORITY;

typedef struct _THREAD_DESCRIPTOR_TABLE_ENTRY_INFORMATION
{
    ULONG		Selector;
    LDT_ENTRY	Descriptor;
} THREAD_DESCRIPTOR_TABLE_ENTRY_INFORMATION, *PTHREAD_DESCRIPTOR_TABLE_ENTRY_INFORMATION;

typedef struct _THREAD_EVENTPAIR
{
	HANDLE	EventPair;
} THREAD_EVENTPAIR, *PTHREAD_EVENTPAIR;

typedef struct _THREAD_WIN32_START_ADDRESS_INFORMATION
{
	PVOID	Win32StartAddress;
} THREAD_WIN32_START_ADDRESS_INFORMATION, *PTHREAD_WIN32_START_ADDRESS_INFORMATION;

typedef struct _THREAD_ZERO_TLSCELL
{
	ULONG	TlsIndex;
} THREAD_ZERO_TLSCELL, *PTHREAD_ZERO_TLSCELL;

typedef struct _THREAD_PERFORMANCE_COUNTER_INFORMATION
{
	ULONG	Count1;
	ULONG	Count2;
} THREAD_PERFORMANCE_COUNTER_INFORMATION, *PTHREAD_PERFORMANCE_COUNTER_INFORMATION;

typedef struct _THREAD_AMI_LAST_THREAD
{
	ULONG	AmILastThread;
} THREAD_AMI_LAST_THREAD, *PTHREAD_AMI_LAST_THREAD;

typedef struct _THREAD_IDEAL_PROCESSOR
{
	ULONG	IdealProcessor;
} THREAD_IDEAL_PROCESSOR, *PTHREAD_IDEAL_PROCESSOR;

typedef struct _THREAD_TLS_ARRAY
{
	PULONG	TlsArray;
} THREAD_TLS_ARRAY, *PTHREAD_TLS_ARRAY;

typedef struct _THREAD_IS_IO_PENDING_INFORMATION
{
	ULONG	IsIOPending;
} THREAD_IS_IO_PENDING_INFORMATION, *PTHREAD_IS_IO_PENDING_INFORMATION;

typedef struct _THREAD_HIDE_FROM_DEBUGGER
{
	ULONG	HideFromDebugger;
} THREAD_HIDE_FROM_DEBUGGER, *PTHREAD_HIDE_FROM_DEBUGGER;

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    IN HANDLE			hThread,
    IN THREADINFOCLASS	ThreadInformationClass,
    OUT PVOID			pThreadInformation,
    IN ULONG			uThreadInformationLength,
    OUT PULONG			puReturnLength OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationThread(
	IN HANDLE			hThread,
	IN THREADINFOCLASS	ThreadInformationClass,
	OUT PVOID			pThreadInformation,
	IN ULONG			uthreadInformationLength
);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
	IN HANDLE	hThread,
	IN ACCESS_MASK	DesiredAccess,
	IN BOOLEAN		bOpenAsSelf,
	OUT PHANDLE		phToken
);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateThread(
    IN HANDLE						ThreadHandle,
    IN HANDLE						TargetThreadHandle,
    IN PSECURITY_QUALITY_OF_SERVICE	SecurityQos
);

NTSYSAPI
NTSTATUS
NTAPI
NtGetContextThread(
    IN HANDLE		ThreadHandle,
    OUT PCONTEXT	Context
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetContextThread(
    IN HANDLE	ThreadHandle,
    IN PCONTEXT	Context
);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    IN HANDLE			ThreadHandle,
    IN PKNORMAL_ROUTINE	ApcRoutine,
    IN PVOID ApcContext	OPTIONAL,
    IN PVOID Argument1	OPTIONAL,
    IN PVOID Argument2	OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
	IN HANDLE	hThread
);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PLARGE_INTEGER SectionSize OPTIONAL,
    IN ULONG Protect,
    IN ULONG Attributes,
    IN HANDLE FileHandle
);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSection(
	OUT PHANDLE				SectionHandle,
	IN ACCESS_MASK			DesiredAccess,
	IN POBJECT_ATTRIBUTES	ObjectAttributes
);

typedef enum _SECTION_INFORMATION_CLASS
{
	SectionBasicInformation,
	SectionImageInformation
} SECTION_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySection(
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN ULONG SectionInformationLength,
    OUT PULONG ResultLength OPTIONAL
);

typedef struct _SECTION_BASIC_INFORMATION
{
	PVOID			BaseAddress;
	ULONG			Attributes;
	LARGE_INTEGER	Size;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION
{
	PVOID	EntryPoint;
	ULONG	Unknown1;
	ULONG	StackReserve;
	ULONG	StackCommit;
	ULONG	Subsystem;
	USHORT	MinorSubsystemVersion;
	USHORT	MajorSubsystemVersion;
	ULONG	Unknown2;
	ULONG	Characteristics;
	USHORT	ImageNumber;
	BOOLEAN	Executable;
	UCHAR	Unknown3;
	ULONG	Unknown4[3];
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtExtendSection(
	IN HANDLE SectionHandle,
	IN PLARGE_INTEGER SectionSize
);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
	IN HANDLE	hProcess,
	IN PVOID	pBaseAddress
);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
	IN HANDLE			hObject,
	IN BOOL				fAlertable,
	IN PLARGE_INTEGER	pliTimeout   // NULL = infinite
);

// Object functions
typedef enum _OBJECT_INFORMATION_CLASS
{
	ObjectBasicInformation,             // 0    Y       N
	ObjectNameInformation,              // 1    Y       N
	ObjectTypeInformation,              // 2    Y       N
	ObjectAllTypesInformation,          // 3    Y       N
	ObjectHandleInformation             // 4    Y       Y
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_BASIC_INFORMATION
{
	ULONG			Attributes;
	ACCESS_MASK		GrantedAccess;
	ULONG			HandleCount;
	ULONG			PointerCount;
	ULONG			PagedPoolUsage;
	ULONG			NonPagedPoolUsage;
	ULONG			Reserved[3];
	ULONG			NameInformationLength;
	ULONG			TypeInformationLength;
	ULONG			SecurityDescriptorLength;
	LARGE_INTEGER	CreateTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION
{               
	UNICODE_STRING	Name;                                
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;   

typedef struct _OBJECT_TYPE_INFORMATION {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_ALL_TYPES_INFORMATION
{
	ULONG					NumberOfTypes;
	OBJECT_TYPE_INFORMATION	TypeInformation[1];
} OBJECT_ALL_TYPES_INFORMATION, *POBJECT_ALL_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_ATTRIBUTE_INFORMATION
{
	BOOLEAN	Inherit;
	BOOLEAN	ProtectFromClose;
} OBJECT_HANDLE_ATTRIBUTE_INFORMATION, *POBJECT_HANDLE_ATTRIBUTE_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtQueryObject(
	IN HANDLE ObjectHandle,
	IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
	OUT PVOID ObjectInformation,
	IN ULONG ObjectInformationLength,
	OUT PULONG ReturnLength OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationObject(
	IN HANDLE ObjectHandle,
	IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
	IN PVOID ObjectInformation,
	IN ULONG ObjectInformationLength
);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateObject(
	IN HANDLE SourceProcessHandle,
	IN HANDLE SourceHandle,
	IN HANDLE TargetProcessHandle OPTIONAL,
	OUT PHANDLE TargetHandle OPTIONAL,
	IN ACCESS_MASK DesiredAccess,
	IN ULONG HandleAttributes,
	IN ULONG Options
);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
	IN HANDLE FileHandle,
	IN SECURITY_INFORMATION SecurityInformation,
	OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
	IN ULONG Length,
	OUT PULONG ResultLength
);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
	IN HANDLE FileHandle,
	IN SECURITY_INFORMATION SecurityInformation,
	IN PSECURITY_DESCRIPTOR SecurityDescriptor
);

// Memory management functions
NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
	IN HANDLE ProcessHandle,
	IN OUT PVOID *BaseAddress,
	IN ULONG ZeroBits,
	IN OUT PULONG AllocationSize,
	IN ULONG AllocationType,
	IN ULONG Protect
);

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetList,
	MemorySectionName,
	MemoryBasicVlmInformation
} MEMORY_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
	OUT PVOID MemoryInformation,
	IN ULONG MemoryInformationLength,
	OUT PULONG ReturnLength OPTIONAL
);

/* Defined in Winnt.h
typedef struct _MEMORY_BASIC_INFORMATION
{
	PVOID	BaseAddress;
	PVOID	AllocationBase;
	ULONG	AllocationProtect;
	ULONG	RegionSize;
	ULONG	State;
	ULONG	Protect;
	ULONG	Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
*/

typedef struct _MEMORY_WORKING_SET_LIST
{
	ULONG	NumberOfPages;
	ULONG	WorkingSetList[1];
} MEMORY_WORKING_SET_LIST, *PMEMORY_WORKING_SET_LIST;

typedef struct _MEMORY_SECTION_NAME
{
	UNICODE_STRING	SectionFileName;
} MEMORY_SECTION_NAME, *PMEMORY_SECTION_NAME;

NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	OUT PVOID Buffer,
	IN ULONG BufferLength,
	OUT PULONG ReturnLength OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
	IN HANDLE ProcessHandle,
	IN PVOID BaseAddress,
	IN PVOID Buffer,
	IN ULONG BufferLength,
	OUT PULONG ReturnLength OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG ProtectSize,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG FlushSize,
    OUT PIO_STATUS_BLOCK IoStatusBlock
);

// Ldr Functions
NTSYSAPI
NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll(
	IN HANDLE hModule
);

NTSYSAPI 
NTSTATUS
NTAPI
LdrGetDllHandle(

  IN PWORD                pwPath OPTIONAL,
  IN PVOID                Unused OPTIONAL,
  IN PUNICODE_STRING      ModuleFileName,
  OUT PHANDLE             pHModule );


NTSYSAPI 
NTSTATUS
NTAPI
LdrLoadDll(

  IN PWCHAR               PathToFile OPTIONAL,
  IN ULONG                Flags OPTIONAL,
  IN PUNICODE_STRING      ModuleFileName,
  OUT PHANDLE             ModuleHandle );

NTSYSAPI 
NTSTATUS
NTAPI
LdrGetProcedureAddress(
  IN HMODULE              ModuleHandle,
  IN PANSI_STRING         FunctionName OPTIONAL,
  IN WORD                 Oridinal OPTIONAL,
  OUT PVOID               *FunctionAddress );

// Rtl String Functions
NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlCreateUnicodeString(
    OUT PUNICODE_STRING AllocatedString,
    IN PCWSTR SourceString
    );

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    IN PUNICODE_STRING UnicodeString
    );

NTSYSAPI
ULONG
NTAPI
RtlAnsiStringToUnicodeSize(
    IN PANSI_STRING AnsiString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    OUT PUNICODE_STRING Destination,
    IN PUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
    OUT PUNICODE_STRING Destination,
    IN PWSTR Source
    );

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString(
    IN ULONG Value,
    IN ULONG Base,
    OUT PUNICODE_STRING String
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger(
    IN PUNICODE_STRING String,
    IN ULONG Base,
    OUT PULONG Value
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlOemStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN POEM_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

NTSYSAPI
ULONG
NTAPI
RtlxAnsiStringToUnicodeSize(
    IN PANSI_STRING AnsiString
    );

NTSYSAPI
ULONG
NTAPI
RtlxOemStringToUnicodeSize(
    IN POEM_STRING OemString
    );

// Rtl Misc Operations
NTSYSAPI
NTSTATUS
NTAPI
NtReplyPort(
	IN HANDLE	hPort,
	OUT PVOID	pReply
);

NTSYSAPI
NTSTATUS
NTAPI
NtClose(
	IN HANDLE	hObject
);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
	NTSTATUS	status
);

NTSYSAPI
UINT
NTAPI
RtlGetLongestNtPathLength();

NTSYSAPI
UINT
NTAPI
RtlDetermineDosPathNameType_U(
	IN PWSTR	Path
);

NTSYSAPI
UINT
NTAPI
RtlIsDosDeviceName_U(
	IN PWSTR	Path
);

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    IN PCWSTR			DosName,
    OUT PUNICODE_STRING	NtName,
    OUT PCWSTR			*DosFilePath OPTIONAL,
    OUT PUNICODE_STRING	NtFilePath OPTIONAL
);

// Rtl Large Integer Operations

#define RtlLargeIntegerLessThanZero($a)	(($a).HighPart &lt; 0)
#define Li2Double(x)					((double)((x).HighPart) * 4.294967296E9 + (double)((x).LowPart))

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlEnlargedIntegerMultiply(
	IN LONG lMultiplicand,
	IN LONG lMultiplier
	);

NTSYSAPI
ULONG
NTAPI
RtlEnlargedUnsignedDivide(
	IN LARGE_INTEGER	liDividend,
	IN ULONG			uDivisor,
	OUT PULONG			puRemainder OPTIONAL
	);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlEnlargedUnsignedMultiply(
	IN ULONG	uMultiplicand,
	IN ULONG	uMultiplier
	);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedIntegerMultiply(
	IN LARGE_INTEGER	liMultiplicand,
	IN LONG				lMultiplier
	);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlExtendedLargeIntegerDivide(
	IN LARGE_INTEGER	liDividend,
	IN ULONG			uDivisor,
	OUT PULONG			puRemainder OPTIONAL
	);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerAdd(
	IN LARGE_INTEGER	liAddend1,
	IN LARGE_INTEGER	liAddend2
	);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerDivide(
	IN LARGE_INTEGER	liDividend,
	IN LARGE_INTEGER	liDivisor,
	OUT PLARGE_INTEGER	pliRemainder OPTIONAL
	);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerNegate(
	IN LARGE_INTEGER	liSubtrahend
	);

NTSYSAPI
LARGE_INTEGER
NTAPI
RtlLargeIntegerSubtract(
	IN LARGE_INTEGER	liMinuend,
	IN LARGE_INTEGER	liSubtrahend
	);

// Debug Functions
typedef struct _DEBUG_BUFFER
{
    HANDLE	SectionHandle;
    PVOID	SectionBase;
    PVOID	RemoteSectionBase;
    ULONG	SectionBaseDelta;
    HANDLE	EventPairHandle;
    ULONG	Unknown[2];
    HANDLE	RemoteThreadHandle;
    ULONG	InfoClassMask;
    ULONG	SizeOfInfo;
    ULONG	AllocatedSize;
    ULONG	SectionSize;
    PVOID	ModuleInformation;
    PVOID	BackTraceInformation;
    PVOID	HeapInformation;
    PVOID	LockInformation;
    PVOID	Reserved[8];
} DEBUG_BUFFER, *PDEBUG_BUFFER;

#define PDI_MODULES		0x01
#define PDI_BACKTRACE	0x02
#define PDI_HEAPS		0x04
#define PDI_HEAP_TAGS	0x08
#define PDI_HEAP_BLOCKS	0x10
#define PDI_LOCKS		0x20

typedef struct _DEBUG_MODULE_INFORMATION // c.f. SYSTEM_MODULE_INFORMATION
{
    ULONG	Reserved[2];
    ULONG	Base;
    ULONG	Size;
    ULONG	Flags;
    USHORT	Index;
    USHORT	Unknown;
    USHORT	LoadCount;
    USHORT	ModuleNameOffset;
    CHAR	ImageName[256];
} DEBUG_MODULE_INFORMATION, *PDEBUG_MODULE_INFORMATION;

typedef struct _DEBUG_HEAP_INFORMATION
{
    ULONG	Base;
    ULONG	Flags;
    USHORT	Granularity;
    USHORT	Unknown;
    ULONG	Allocated;
    ULONG	Committed;
    ULONG	TagCount;
    ULONG	BlockCount;
    ULONG	Reserved[7];
    PVOID	Tags;
    PVOID	Blocks;
} DEBUG_HEAP_INFORMATION, *PDEBUG_HEAP_INFORMATION;

typedef struct _DEBUG_LOCK_INFORMATION // c.f. SYSTEM_LOCK_INFORMATION
{
    PVOID	Address;
    USHORT	Type;
    USHORT	CreatorBackTraceIndex;
    ULONG	OwnerThreadId;
    ULONG	ActiveCount;
    ULONG	ContentionCount;
    ULONG	EntryCount;
    ULONG	RecursionCount;
    ULONG	NumberOfSharedWaiters;
    ULONG	NumberOfExclusiveWaiters;
} DEBUG_LOCK_INFORMATION, *PDEBUG_LOCK_INFORMATION;


NTSYSAPI
PDEBUG_BUFFER
NTAPI
RtlCreateQueryDebugBuffer(
    IN ULONG Size,
    IN BOOLEAN EventPair
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
    IN ULONG ProcessId,
    IN ULONG DebugInfoClassMask,
    IN OUT PDEBUG_BUFFER DebugBuffer
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyQueryDebugBuffer(
    IN PDEBUG_BUFFER DebugBuffer
    );

NTSYSAPI
NTSTATUS
NTAPI
NtLoadDriver(
    // "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\&lt;DriverName&gt;"
	IN PUNICODE_STRING RegistryPath
);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadDriver(
    // "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\&lt;DriverName&gt;"
	IN PUNICODE_STRING RegistryPath
);

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
	IN ULONG Privilege,
	IN BOOLEAN NewValue,
	IN BOOLEAN ForThread,
	OUT PBOOLEAN OldValue
);

#ifdef __cplusplus
}

#pragma warning(default : 4200)

#endif
#endif

```

`src/wowhacks.cpp`:

```cpp
#include "wowhacks.h"

/*
	wowhacks by Teq 10.2011 - 06.2014

	Передаю привет всем читателям ][, заглянувшим в мои исходники!
       Этот проект стал результатом кропотливого исследования и вложенных в него трудов, он многократно протестирован и полностью работоспособен
       Очень надеюсь, что вы подчерпнете отсюда что-то полезное для себя
*/

HANDLE hConIn, hConOut;

class ConsoleLogger
{
public:
	void OnLogMsg( void *caller, LogData *ld) // caller is undefined
	{
		DWORD written;
		WriteConsole( hConOut, ld->msg, strlen(ld->msg), &written, NULL ); 
	}
};

// ------------------------------------------------------

void ConsoleDbgCreate( )
{
	AllocConsole();
	SetConsoleTitle("Teq's wowhacks: debug console");
	hConIn = GetStdHandle( STD_INPUT_HANDLE );
	hConOut = GetStdHandle( STD_OUTPUT_HANDLE );
	SetConsoleMode(hConIn, 0);
}

// ------------------------------------------------------

void ConsoleProc()
{
	CHAR	byte;
	DWORD	read;
	while ( ReadConsole( hConIn, &byte, 1, &read, NULL) )
	{
		if ( byte == 'C' || byte == 'c' )
		{
			COORD coordScreen = { 0, 0 };
			FillConsoleOutputCharacter(hConOut,' ', 0xFFFFFFFF, coordScreen, &read);
			SetConsoleCursorPosition(hConOut, coordScreen);
		}
		else if ( byte == 'W' || byte == 'w' )
		{
			Scanner::TPattern WardenPattern ("\x56\x57\xFC\x8B\x54\x24\x14\x8B\x74\x24\x10\x8B\x44\x24\x0C\x8B\xCA\x8B\xF8\xC1\xE9\x02\x74\x02\xF3\xA5" \
								  "\xB1\x03\x23\xCA\x74\x02\xF3\xA4\x5F\x5E\xC3", "x37");
			DWORD WardenProc = (DWORD) Scanner::ScanMem( &WardenPattern );
			if ( WardenProc )
			{
				Logger::OutLog("Warden::Scan proc:0x%.8x\r\n", WardenProc);
			}
			else 
				Logger::OutLog("Warden::Scan proc not found\r\n");
		}
	}
}

// ------------------------------------------------------

void VA_hook_internal( DWORD dwCallAddr, DWORD dwMemBlock, DWORD dwSize)
{
	if ( dwMemBlock && dwSize > 0x2000 )
	{
		//if ( *(PDWORD)dwMemBlock == '2LLB' )
		Logger::OutLog("Allocated block:%.8X - %.8X, called from:%.8X\r\n", dwMemBlock, dwMemBlock+dwSize, dwCallAddr );
	}
}

void VP_hook_internal( DWORD dwCallAddr, DWORD dwMemBlock, DWORD dwSize, DWORD flNewProtect)
{
	if ( dwMemBlock && flNewProtect==PAGE_EXECUTE_READ )
	{
		MEMORY_BASIC_INFORMATION Mem;
		if  ( VirtualQuery( (PVOID) dwMemBlock, &Mem, sizeof (MEMORY_BASIC_INFORMATION)) )
		{
			if ( *(PDWORD)Mem.AllocationBase == '2LLB' )
			Logger::OutLog("Warden image found at:%.8X, code section:%.8X, called from:%.8X\r\n", Mem.AllocationBase, dwMemBlock, dwCallAddr);
			
		}
		
	}
}

__declspec(naked) void VA_hook( LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect )
{
	__asm 
	{
		pop		eax	// org func
		push	ebp
		mov		ebp, esp // to access parameters via names

		// call orig-func
		push	[flProtect]
		push	[flAllocationType]
		push	[dwSize]
		push	[lpAddress]
		call	VA_prologue

		pushad
		push	dwSize
		push	eax // mem block
		push	[ebp+4] // ret addr
		call	VA_hook_internal
		add esp, 0xC
		popad	

		leave
		ret 0x10
VA_prologue:
		push    ebp
		mov     ebp, esp
		jmp		eax // to VirtualAlloc
	}
}

__declspec(naked) void VP_hook( LPVOID lpAddress, SIZE_T dwSize, DWORD flProtect, DWORD pOldProtect )
{
	__asm 
	{
		pop		eax	// org func
		push	ebp
		mov		ebp, esp // to access parameters via names

		// call orig-func
		push	[pOldProtect]
		push	[flProtect]
		push	[dwSize]
		push	[lpAddress]
		call	VP_prologue

		pushad
		push	[flProtect]
		push	[dwSize]
		push	[lpAddress]
		push	[ebp+4] // ret addr
		call	VP_hook_internal
		add esp, 0x10
		popad	

		leave
		ret 0x10
VP_prologue:
		push    ebp
		mov     ebp, esp
		jmp		eax // to VirtualAlloc
	}
}

bool PatchVA()
{
	bool bRetval = false;
	PBYTE bCode = (PBYTE) "\xE8\x90\x90\x90\x90\x90"; // call rel32
	DWORD pProc = (DWORD) GetProcAddress( GetModuleHandleA( "KernelBase.DLL"), "VirtualAlloc" );
	
	*((PDWORD)(bCode+1)) = (DWORD)&VA_hook - ((DWORD)pProc+5);
	
	if ( Patcher::Instance()->MakePatch( (PBYTE)pProc, bCode, 5 ) ) 
	{
		Logger::OutLog( "VirtualAlloc patched at: %x\r\n", pProc );
		bRetval = true;
	}
	else Logger::OutLog( "VirtualAlloc patch failed\r\n" );
	return bRetval;
}

bool PatchVP()
{
	bool bRetval = false;
	PBYTE bCode = (PBYTE) "\xE8\x90\x90\x90\x90\x90"; // call rel32
	DWORD pProc = (DWORD) GetProcAddress( GetModuleHandleA( "KernelBase.DLL"), "VirtualProtect" );
	
	*((PDWORD)(bCode+1)) = (DWORD)&VP_hook - ((DWORD)pProc+5);
	
	if ( Patcher::Instance()->MakePatch( (PBYTE)pProc, bCode, 5 ) ) 
	{
		Logger::OutLog( "VirtualProtect patched at: %x\r\n", pProc );
		bRetval = true;
	}
	else Logger::OutLog( "VirtualProtect patch failed\r\n" );
	return bRetval;
}



// ------------------------------------------------------

void BuddyThread( LPVOID param )
{
	//PatchVP();
	ConsoleDbgCreate();

	// logger
	ConsoleLogger *log = new ConsoleLogger();
	Logger::LogMessageHandler = EventHandler<pLogData>(); // static-field initialize
	Logger::LogMessageHandler.Assign( EventHandler<pLogData>::CreateHandler<ConsoleLogger>(log, &ConsoleLogger::OnLogMsg) );

	HacksController * hc = new HacksController();
	hc->Run();
	
	ConsoleProc();
}

 // ------------------------------------------------------

void RemoteProc( )
{
	// prologue
	DWORD oeax, oeip, dwHistance;
	__asm mov oeax, eax
	__asm mov oeip, ecx	      // original eip in ecx
	__asm mov dwHistance, edx // new base

	//__asm int 3;
	ProcessImport(dwHistance, true);
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE) BuddyThread, NULL, 0, NULL );

	// epilogue
	__asm mov eax, oeax
	__asm jmp oeip
 }

// ------------------------------------------------------

void StartWow()
{
	STARTUPINFO			si;
	PROCESS_INFORMATION	pi;
	ZeroMemory(&pi, sizeof(pi));
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	CreateProcessA( NULL, (PCHAR) "D:\\Games\\World of Warcraft\\wow.exe -noautolaunch64bit", NULL, NULL, false, CREATE_SUSPENDED, NULL, NULL, &si, &pi );
	Inject( NULL, pi.dwProcessId, (PTHREAD_START_ROUTINE)&RemoteProc, 0, pi.hThread); // using context-hijacking method
	ResumeThread( pi.hThread );
}

// ------------------------------------------------------

int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	StartWow();
	return 0;
}

```

`src/wowhacks.h`:

```h
#define _WIN32_WINNT 0x0501
#define _CRT_SECURE_NO_WARNINGS
#pragma warning( disable : 4005 ) // fuck it
#include <Windows.h>
#include <stdio.h>
#include <Ntsecapi.h>
#include "ntdll.h"

#include "_Debug_mod/Debug_mod.h"
#include "_Base_mod/Base_mod.h"
#include "_Inject_mod/Inject_mod.h"

#include "PB_lib\Logger.h"
#include "PB_lib\Warden.h"
#include "HacksController.h"
```

`src/wowhacks.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wowhacks", "wowhacks.vcxproj", "{5F76D650-4A30-497A-AD9E-2FFBBB25644C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5F76D650-4A30-497A-AD9E-2FFBBB25644C}.Debug|Win32.ActiveCfg = Debug|Win32
		{5F76D650-4A30-497A-AD9E-2FFBBB25644C}.Debug|Win32.Build.0 = Debug|Win32
		{5F76D650-4A30-497A-AD9E-2FFBBB25644C}.Release|Win32.ActiveCfg = Release|Win32
		{5F76D650-4A30-497A-AD9E-2FFBBB25644C}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`src/wowhacks.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`src/wowhacks.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5F76D650-4A30-497A-AD9E-2FFBBB25644C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>PlayBuddy</RootNamespace>
    <ProjectName>wowhacks</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>NotSet</CharacterSet>
    <PlatformToolset>v110</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v110</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>E:\Projects\;$(IncludePath)</IncludePath>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAsManaged>false</CompileAsManaged>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>WinMain</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <OptimizeReferences>false</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAsManaged>false</CompileAsManaged>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="HacksController.cpp" />
    <ClCompile Include="Hacks\RunScriptHack.cpp" />
    <ClCompile Include="Hacks\WardenLoaderHack.cpp" />
    <ClCompile Include="PB_lib\HackBase.cpp" />
    <ClCompile Include="PB_lib\Logger.cpp" />
    <ClCompile Include="PB_lib\Patcher.cpp" />
    <ClCompile Include="PB_lib\Scanner.cpp" />
    <ClCompile Include="PB_lib\Warden.cpp" />
    <ClCompile Include="wowhacks.cpp" />
    <ClCompile Include="_Base_mod\Base_mod.cpp" />
    <ClCompile Include="_Debug_mod\Debug_mod.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HacksController.h" />
    <ClInclude Include="Hacks\RunScriptHack.h" />
    <ClInclude Include="Hacks\WardenLoaderHack.h" />
    <ClInclude Include="PB_lib\Delegates.h" />
    <ClInclude Include="PB_lib\HackBase.h" />
    <ClInclude Include="PB_lib\Logger.h" />
    <ClInclude Include="PB_lib\Patcher.h" />
    <ClInclude Include="PB_lib\PB_internal.h" />
    <ClInclude Include="PB_lib\Scanner.h" />
    <ClInclude Include="PB_lib\Warden.h" />
    <ClInclude Include="wowhacks.h" />
    <ClInclude Include="_Debug_mod\Debug_mod.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="..\..\ntdll.lib" />
  </ItemGroup>
  <ItemGroup>
    <Object Include="_Inject_mod\Inject_mod.obj" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/wowhacks.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="HacksController.cpp" />
    <ClCompile Include="wowhacks.cpp" />
    <ClCompile Include="_Base_mod\Base_mod.cpp">
      <Filter>_shared modules</Filter>
    </ClCompile>
    <ClCompile Include="_Debug_mod\Debug_mod.cpp">
      <Filter>_shared modules</Filter>
    </ClCompile>
    <ClCompile Include="Hacks\WardenLoaderHack.cpp">
      <Filter>Hacks</Filter>
    </ClCompile>
    <ClCompile Include="Hacks\RunScriptHack.cpp">
      <Filter>Hacks</Filter>
    </ClCompile>
    <ClCompile Include="PB_lib\HackBase.cpp">
      <Filter>pb_lib</Filter>
    </ClCompile>
    <ClCompile Include="PB_lib\Logger.cpp">
      <Filter>pb_lib</Filter>
    </ClCompile>
    <ClCompile Include="PB_lib\Patcher.cpp">
      <Filter>pb_lib</Filter>
    </ClCompile>
    <ClCompile Include="PB_lib\Scanner.cpp">
      <Filter>pb_lib</Filter>
    </ClCompile>
    <ClCompile Include="PB_lib\Warden.cpp">
      <Filter>pb_lib</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HacksController.h" />
    <ClInclude Include="wowhacks.h" />
    <ClInclude Include="_Debug_mod\Debug_mod.h">
      <Filter>_shared modules</Filter>
    </ClInclude>
    <ClInclude Include="Hacks\WardenLoaderHack.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="Hacks\RunScriptHack.h">
      <Filter>Hacks</Filter>
    </ClInclude>
    <ClInclude Include="PB_lib\Delegates.h">
      <Filter>pb_lib</Filter>
    </ClInclude>
    <ClInclude Include="PB_lib\HackBase.h">
      <Filter>pb_lib</Filter>
    </ClInclude>
    <ClInclude Include="PB_lib\Logger.h">
      <Filter>pb_lib</Filter>
    </ClInclude>
    <ClInclude Include="PB_lib\Patcher.h">
      <Filter>pb_lib</Filter>
    </ClInclude>
    <ClInclude Include="PB_lib\PB_internal.h">
      <Filter>pb_lib</Filter>
    </ClInclude>
    <ClInclude Include="PB_lib\Scanner.h">
      <Filter>pb_lib</Filter>
    </ClInclude>
    <ClInclude Include="PB_lib\Warden.h">
      <Filter>pb_lib</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Library Include="..\..\ntdll.lib" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="_shared modules">
      <UniqueIdentifier>{b4f104cb-202a-48c1-83ff-a7de99ef4d12}</UniqueIdentifier>
    </Filter>
    <Filter Include="Hacks">
      <UniqueIdentifier>{7dd6509a-299e-45f9-9031-9501d62bb11d}</UniqueIdentifier>
    </Filter>
    <Filter Include="pb_lib">
      <UniqueIdentifier>{9c12ed80-1b33-40a6-b5e4-31e2807247af}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Object Include="_Inject_mod\Inject_mod.obj">
      <Filter>_shared modules</Filter>
    </Object>
  </ItemGroup>
</Project>
```

`src/wowhacks.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```