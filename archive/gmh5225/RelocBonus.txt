Project Path: arc_gmh5225_RelocBonus_yuq8o9vg

Source Tree:

```txt
arc_gmh5225_RelocBonus_yuq8o9vg
├── README.MD
├── RelocBonus.sln
├── deps
│   └── PeLib
│       ├── BoundImportDirectory.cpp
│       ├── BoundImportDirectory.h
│       ├── ComHeaderDirectory.cpp
│       ├── ComHeaderDirectory.h
│       ├── DebugDirectory.cpp
│       ├── DebugDirectory.h
│       ├── ExportDirectory.cpp
│       ├── ExportDirectory.h
│       ├── IatDirectory.cpp
│       ├── IatDirectory.h
│       ├── ImportDirectory.h
│       ├── MzHeader.cpp
│       ├── MzHeader.h
│       ├── PeFile.cpp
│       ├── PeFile.h
│       ├── PeHeader.cpp
│       ├── PeHeader.h
│       ├── PeLib.h
│       ├── PeLib.sln
│       ├── PeLib.vcxproj
│       ├── PeLibAux.cpp
│       ├── PeLibAux.h
│       ├── PeLibInc.h
│       ├── RelocationsDirectory.cpp
│       ├── RelocationsDirectory.h
│       ├── ResourceDirectory.cpp
│       ├── ResourceDirectory.h
│       ├── TlsDirectory.h
│       ├── buffer
│       │   ├── InputBuffer.cpp
│       │   ├── InputBuffer.h
│       │   ├── OutputBuffer.cpp
│       │   └── OutputBuffer.h
│       └── license.htm
├── license.txt
├── samples
│   ├── README.MD
│   ├── normal-nofixup.exe
│   ├── normal-runtimefixup.exe
│   ├── reloc-deltafixup.exe
│   ├── reloc-nofixup.exe
│   └── reloc-runtimefixup.exe
└── src
    └── reloc
        ├── ASLRPreselectionStub.h
        ├── LdrDefs.h
        ├── PeLibInclude.h
        ├── PeRecompiler.cpp
        ├── PeRecompiler.h
        ├── RewriteBlock.cpp
        ├── RewriteBlock.h
        ├── ShellcodeMacros.h
        ├── VectorUtils.h
        ├── main.cpp
        ├── reloc.vcxproj
        └── reloc.vcxproj.filters

```

`README.MD`:

```MD
# RelocBonus

RelocBonus is an obfuscation tool for Windows which instruments the Windows Loader into acting as an unpacking engine.

I gave a [talk](https://github.com/nickcano/RelocBonusSlides) about this tool at DEFCON 26; here is the abstract:

> The arbiters of defense wield many static analysis tools; disassemblers, PE viewers, and anti-viruses are among them. When you peer into their minds, these tools reveal their perilous implementations of PE file parsing. They assume PE files come as-is, but the Windows Loader actually applies many mutations (some at the command of the PE itself) before execution ever begins. This talk is about bending that loader to one's whim with the Relocations Table as a command spell. It will demonstrate how the loader can be instrumented into a mutation engine capable of transforming an utterly mangled PE file into a valid executable. This method starts with multiple ASLR Preselection attacks that force binary mapping at a predictable address. It then mangles the PE file, garbling any byte not required prior to relocation. Finally, it embeds a new Relocations Table which, when paired with a preselected base address, causes the loader to reconstruct the PE and execute it with ease.
>
> This isn't a packer or a POC, it is a PE rebuilder which generates completely valid, stable, and vastly tool-breaking executables. This talk will show you how this attack twists the protocols of a machine against the controls meant to protect it. It flexes on tools with various look-what-I-can-break demonstrations and, if you write similar tools, it'll make you rethink how you do it.

## Features

There are quite a few nifty capabilities built right into the tool:

- Targeting specific sections with `--section`
- Doing multiple passes of obfuscation using `--multipass`
- Obfuscating only specific strings using `--stringMatch="string to obfuscate"`
- Obfuscating imports (on by default; turned off with `--noImports`)

## Code

The code is written in C++ and the project files are for Visual Studio 2017. There is a dependency on `PeLib`; a version slightly modified to work with the C++17 standard lives in `deps/`.

Because of the usage of some C++17 features, this project and it's dependencies won't cleanly backport to earlier Visual Studio versions.

## Usage

Usage is fully described by running `reloc.exe` with no arguments. Here are some example invocations:

**Standard**
`reloc.exe malware.exe obfuscated_malware.exe`

**Standard Multipass**
`reloc.exe --multipass malware.exe obfuscated_malware.exe`

**Standard Win10**
`reloc.exe --win10 malware.exe obfuscated_malware.exe`

**Obfuscate Strings**
`reloc.exe --stringMatch="hello world" malware.exe obfuscated_malware.exe`

## Samples

Some pre-built samples exist in the `samples/` directory.
```

`RelocBonus.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26730.12
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "reloc", "src\reloc\reloc.vcxproj", "{B1628253-F5E4-427C-8EB9-C0D67742F6D9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B1628253-F5E4-427C-8EB9-C0D67742F6D9}.Debug|Win32.ActiveCfg = Debug|Win32
		{B1628253-F5E4-427C-8EB9-C0D67742F6D9}.Debug|Win32.Build.0 = Debug|Win32
		{B1628253-F5E4-427C-8EB9-C0D67742F6D9}.Release|Win32.ActiveCfg = Release|Win32
		{B1628253-F5E4-427C-8EB9-C0D67742F6D9}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`deps/PeLib/BoundImportDirectory.cpp`:

```cpp
/*
* BoundImportDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "PeLibInc.h"
#include "BoundImportDirectory.h"
#include <numeric>
#include <set>
#include <map>

namespace PeLib
{
	/**
	* Adds another bound import to the BoundImport directory.
	* @param strModuleName Name of the PE file which will be imported.
	* @param dwTds Value of the TimeDateStamp of the bound import field.
	* @param wOmn Value of the OffsetModuleName of the bound import field.
	* @param wWfr Value of the NumberOfModuleForwarderRefs of the bound import field.
	**/
	int BoundImportDirectory::addBoundImport(const std::string& strModuleName, dword dwTds, word wOmn, word wWfr)
	{
		for (unsigned int i=0;i<m_vIbd.size();i++)
		{
			if (isEqualNc(strModuleName, m_vIbd[i].strModuleName))
			{
				return ERROR_DUPLICATE_ENTRY;
			}
		}
		
		PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR ibidCurrent;
		ibidCurrent.TimeDateStamp = dwTds;
		ibidCurrent.OffsetModuleName = wOmn;
		ibidCurrent.NumberOfModuleForwarderRefs = wWfr;
		PELIB_IMAGE_BOUND_DIRECTORY ibdCurrent;
		ibdCurrent.ibdDescriptor = ibidCurrent;
		ibdCurrent.strModuleName = strModuleName;
		m_vIbd.push_back(ibdCurrent);
		
		return NO_ERROR;
	}

	/**
	* Searches for the first instance of a module with the given modulename.
	* @param strModuleName The name of a module.
	* @return The id of the module.
	**/
	int BoundImportDirectory::getModuleIndex(const std::string& strModuleName) const
	{
		std::vector<PELIB_IMAGE_BOUND_DIRECTORY>::const_iterator Iter = std::find_if(m_vIbd.begin(), m_vIbd.end(), std::bind2nd(std::mem_fun_ref(&PELIB_IMAGE_BOUND_DIRECTORY::equal), strModuleName));
		
		if (Iter == m_vIbd.end())
		{
			return ERROR_ENTRY_NOT_FOUND;
		}
		
		return static_cast<int>(std::distance(m_vIbd.begin(), Iter));
	}

	/**
	* @return Number of files in the current BoundImport directory.
	**/
	unsigned int BoundImportDirectory::calcNumberOfModules() const
	{
		return static_cast<unsigned int>(m_vIbd.size());
	}

	int BoundImportDirectory::read(InputBuffer& inpBuffer, unsigned char* data, unsigned int dwSize)
	{
		std::vector<PELIB_IMAGE_BOUND_DIRECTORY> currentDirectory;
		
		do
		{
			PELIB_IMAGE_BOUND_DIRECTORY ibdCurrent;
			
			inpBuffer >> ibdCurrent.ibdDescriptor.TimeDateStamp;
			inpBuffer >> ibdCurrent.ibdDescriptor.OffsetModuleName;
			inpBuffer >> ibdCurrent.ibdDescriptor.NumberOfModuleForwarderRefs;

			if (ibdCurrent.ibdDescriptor.TimeDateStamp == 0 && ibdCurrent.ibdDescriptor.OffsetModuleName == 0 && ibdCurrent.ibdDescriptor.NumberOfModuleForwarderRefs == 0) break;
			
			for (int i=0;i<ibdCurrent.ibdDescriptor.NumberOfModuleForwarderRefs;i++)
			{
				PELIB_IMAGE_BOUND_DIRECTORY currentForwarder;
				
				inpBuffer >> currentForwarder.ibdDescriptor.TimeDateStamp;
				inpBuffer >> currentForwarder.ibdDescriptor.OffsetModuleName;
				inpBuffer >> currentForwarder.ibdDescriptor.NumberOfModuleForwarderRefs;
				
				ibdCurrent.moduleForwarders.push_back(currentForwarder);
			}
			
			currentDirectory.push_back(ibdCurrent);
			ibdCurrent.moduleForwarders.clear();
		} while (true);
		
		for (unsigned int i=0;i<currentDirectory.size();i++)
		{
			dword wOmn = currentDirectory[i].ibdDescriptor.OffsetModuleName;
			if (wOmn > dwSize)
			{
				return ERROR_INVALID_FILE;
			}
			
			currentDirectory[i].strModuleName = "";
			for (int k=0;data[wOmn + k] != 0 && k + wOmn < dwSize;k++)
			{
				currentDirectory[i].strModuleName += data[wOmn + k];
			}
			
			for (unsigned int j=0;j<currentDirectory[i].moduleForwarders.size();j++)
			{
				dword wOmn = currentDirectory[i].moduleForwarders[j].ibdDescriptor.OffsetModuleName;
				
				if (wOmn > dwSize)
				{
					return ERROR_INVALID_FILE;
				}
				
//				m_vIbd[i].moduleForwarders[j].strModuleName.assign((char*)(&vBimpDir[wOmn]));
				currentDirectory[i].moduleForwarders[j].strModuleName = "";
				for (int k=0;data[wOmn + k] != 0 && k + wOmn < dwSize;k++)
				{
					currentDirectory[i].moduleForwarders[j].strModuleName += data[wOmn + k];
				}
			}
		}
		
		std::swap(m_vIbd, currentDirectory);
		
		return NO_ERROR;
	}

	/**
	* Reads the BoundImport directory from a PE file.
	* @param strModuleName The name of the PE file from which the BoundImport directory is read.
	* @param dwOffset The file offset where the BoundImport directory can be found (see #PeFile::PeHeader::getIDBoundImportRVA).
	* @param dwSize The size of the BoundImport directory (see #PeFile::PeHeader::getIDBoundImportSize).
	**/
	int BoundImportDirectory::read(const std::string& strModuleName, dword dwOffset, unsigned int uiSize)
	{
		std::ifstream ifFile(strModuleName.c_str(), std::ios::binary);

		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		if (fileSize(ifFile) < dwOffset + uiSize)
		{
			return ERROR_INVALID_FILE;
		}
		
		ifFile.seekg(dwOffset, std::ios::beg);
		
		std::vector<unsigned char> vBimpDir(uiSize);
		ifFile.read(reinterpret_cast<char*>(&vBimpDir[0]), uiSize);

		InputBuffer inpBuffer(vBimpDir);
		
		return read(inpBuffer, &vBimpDir[0], uiSize);
 	}
 	
 	int BoundImportDirectory::read(unsigned char* pcBuffer, unsigned int uiSize)
 	{
		std::vector<unsigned char> vBimpDir(pcBuffer, pcBuffer + uiSize);
		InputBuffer inpBuffer(vBimpDir);
		
		return read(inpBuffer, &vBimpDir[0], uiSize);
 	}
 	
 	unsigned int BoundImportDirectory::totalModules() const
 	{
 		unsigned int modules = static_cast<unsigned int>(m_vIbd.size());
 		
 		for (unsigned int i=0;i<m_vIbd.size();i++)
 		{
 			modules += static_cast<unsigned int>(m_vIbd[i].moduleForwarders.size());
 		}
 		
 		return modules;
 	}

	/**
	* Rebuilds the BoundImport directory. The rebuilded BoundImport directory can then be
	* written back to a PE file.
	* @param vBuffer Buffer where the rebuilt BoundImport directory will be stored.
	* @param fMakeValid If this flag is true a valid directory will be produced.
	**/
	void BoundImportDirectory::rebuild(std::vector<byte>& vBuffer, bool fMakeValid) const
	{
		std::map<std::string, word> filename_offsets;
		
		OutputBuffer obBuffer(vBuffer);
		
		word ulNameOffset = static_cast<word>((totalModules() + 1) * PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size());
		
		for (unsigned int i=0;i<m_vIbd.size();i++)
		{
			obBuffer << m_vIbd[i].ibdDescriptor.TimeDateStamp;

			// Recalculate the offsets if a valid directory is wanted.
			if (fMakeValid)
			{
				if (filename_offsets.find(m_vIbd[i].strModuleName) == filename_offsets.end())
				{
					filename_offsets[m_vIbd[i].strModuleName] = ulNameOffset;
					obBuffer << ulNameOffset;
					ulNameOffset += static_cast<word>(m_vIbd[i].strModuleName.size() + 1);
				}
				else
				{
					obBuffer << filename_offsets[m_vIbd[i].strModuleName];
				}
			}
			else // Otherwise just copy the old values into the buffer.
			{
				obBuffer << m_vIbd[i].ibdDescriptor.OffsetModuleName;
			}

			obBuffer << m_vIbd[i].ibdDescriptor.NumberOfModuleForwarderRefs;
			
			for (int j=0;j<calcNumberOfModuleForwarderRefs(i);j++)
			{
				obBuffer << m_vIbd[i].moduleForwarders[j].ibdDescriptor.TimeDateStamp;
				
				if (fMakeValid)
				{
					if (filename_offsets.find(m_vIbd[i].strModuleName) == filename_offsets.end())
					{
						filename_offsets[m_vIbd[i].moduleForwarders[j].strModuleName] = ulNameOffset;
						obBuffer << ulNameOffset;
						ulNameOffset += static_cast<word>(m_vIbd[i].moduleForwarders[j].strModuleName.size() + 1);
					}
					else
					{
						obBuffer << filename_offsets[m_vIbd[i].moduleForwarders[j].strModuleName];
					}
				}
				else // Otherwise just copy the old values into the buffer.
				{
					obBuffer << m_vIbd[i].moduleForwarders[j].ibdDescriptor.OffsetModuleName;
				}

				obBuffer << m_vIbd[i].moduleForwarders[j].ibdDescriptor.NumberOfModuleForwarderRefs;
			}
		}
		
		obBuffer << static_cast<dword>(0);
		obBuffer << static_cast<word>(0);
		obBuffer << static_cast<word>(0);

		for (unsigned int i=0;i<m_vIbd.size();i++)
		{
			if (filename_offsets.find(m_vIbd[i].strModuleName) != filename_offsets.end())
			{
				obBuffer.add(getModuleName(i).c_str(), static_cast<unsigned long>(getModuleName(i).size() + 1));
				filename_offsets.erase(m_vIbd[i].strModuleName);
			}
			
			for (int j=0;j<calcNumberOfModuleForwarderRefs(i);j++)
			{
				if (filename_offsets.find(getModuleName(i, j)) != filename_offsets.end())
				{
					obBuffer.add(getModuleName(i, j).c_str(), static_cast<unsigned long>(getModuleName(i, j).size() + 1));
					filename_offsets.erase(getModuleName(i, j));
				}
			}
		}
	}

	/**
	* Removes all bound import files.
	**/
	void BoundImportDirectory::clear()
	{
		m_vIbd.clear();
	}

	/**
	* Removes a field specified by the parameter filename from the BoundImport directory.
	* @param strModuleName Name of the file whose field will be removed from the BoundImport directory.
	**/
	void BoundImportDirectory::removeBoundImport(const std::string& strModuleName)
	{
		m_vIbd.erase(std::remove_if(m_vIbd.begin(), m_vIbd.end(), std::bind2nd(std::mem_fun_ref(&PELIB_IMAGE_BOUND_DIRECTORY::equal), strModuleName)), m_vIbd.end());
	}
	
	/**
	* Returns the size of the rebuilt BoundImportDirectory.
	* @return Size of the rebuilt BoundImportDirectory.
	**/
	unsigned int BoundImportDirectory::size() const
	{
		unsigned int size = PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size();
		
		std::set<std::string> filenames;
		
		for (unsigned int i = 0; i < m_vIbd.size(); i++)
		{
			filenames.insert(m_vIbd[i].strModuleName);
			
			size += PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size();
			
			for (unsigned int j = 0; j < m_vIbd[i].moduleForwarders.size(); j++)
			{
				filenames.insert(m_vIbd[i].moduleForwarders[j].strModuleName);
				
				size += PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size();
			}
		}
		
		for (std::set<std::string>::iterator iter = filenames.begin(); iter != filenames.end(); ++iter)
		{
			size += static_cast<unsigned int>(iter->size()) + 1;
		}
		
		return size;
	}

	/**
	* @param strFilename Name of the file.
	* @param dwOffset File offset the bound importdirectory will be written to.
	* @param fMakeValid If this flag is true a valid directory will be produced.
	**/
	int BoundImportDirectory::write(const std::string& strFilename, dword dwOffset,  bool fMakeValid) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(dwOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer, fMakeValid);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<std::streamsize>(vBuffer.size()));

		ofFile.close();
		
		return NO_ERROR;
	}

	/**
	* Retrieves the value of the TimeDateStamp value of a bound import field.
	* @param dwBidnr Number of the bound import field.
	* @return Value of the TimeDateStamp of the bound import field.
	**/
	dword BoundImportDirectory::getTimeDateStamp(dword dwBidnr) const
	{
		return m_vIbd[dwBidnr].ibdDescriptor.TimeDateStamp;
	}
	
	/**
	* Retrieves the value of the OffsetModuleName value of a bound import field. 
	* @param dwBidnr Number of the bound import field.
	* @return Value of the OffsetModuleName of the bound import field.
	**/
	word BoundImportDirectory::getOffsetModuleName(dword dwBidnr) const
	{
		return m_vIbd[dwBidnr].ibdDescriptor.OffsetModuleName;
	}
	
	/**
	* Retrieves the value of the NumberOfModuleForwarderRefs value of a bound import field.
	* @param dwBidnr Number of the bound import field.
	* @return Value of the NumberOfModuleForwarderRefs of the bound import field.
	**/
	word BoundImportDirectory::getNumberOfModuleForwarderRefs(dword dwBidnr) const
	{
		return m_vIbd[dwBidnr].ibdDescriptor.NumberOfModuleForwarderRefs;
	}
	
	/**
	* Retrieves the value of the ModuleName value of a bound import field.
	* @param dwBidnr Number of the bound import field.
	* @return Value of the ModuleName of the bound import field.
	**/
	std::string BoundImportDirectory::getModuleName(dword dwBidnr) const
	{
		return m_vIbd[dwBidnr].strModuleName;
	}

	/**
	* Changes the TimeDateStamp value of an existing bound import field.
	* @param dwBidnr Number of the bound import field which will be changed.
	* @param dwTds New value of the TimeDateStamp of the bound import field.
	**/
	void BoundImportDirectory::setTimeDateStamp(dword dwBidnr, dword dwTds)
	{
		m_vIbd[dwBidnr].ibdDescriptor.TimeDateStamp = dwTds;
	}

	/**
	* Changes the OffsetModuleName value of an existing bound import field.
	* @param dwBidnr Number of the bound import field which will be changed.
	* @param wOmn New value of the OffsetModuleName of the bound import field.
	**/
	void BoundImportDirectory::setOffsetModuleName(dword dwBidnr, word wOmn)
	{
		m_vIbd[dwBidnr].ibdDescriptor.OffsetModuleName = wOmn;
	}
	
	/**
	* Changes the NumberOfModuleForwarderRefs value of an existing bound import field.
	* @param dwBidnr Number of the bound import field which will be changed.
	* @param wMfr New value of the NumberOfModuleForwarderRefs of the bound import field.
	**/
	void BoundImportDirectory::setNumberOfModuleForwarderRefs(dword dwBidnr, word wMfr)
	{
		m_vIbd[dwBidnr].ibdDescriptor.NumberOfModuleForwarderRefs = wMfr;
	}
	
	/**
	* Changes the ModuleName value of an existing bound import field.
	* @param dwBidnr Number of the bound import field which will be changed.
	* @param strModuleName New value of the ModuleName of the bound import field.
	**/
	void BoundImportDirectory::setModuleName(dword dwBidnr, const std::string& strModuleName)
	{
		m_vIbd[dwBidnr].strModuleName = strModuleName;
	}
	
	dword BoundImportDirectory::getTimeDateStamp(dword dwBidnr, dword forwardedModule) const
	{
		return m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.TimeDateStamp;
	}
	
	word BoundImportDirectory::getOffsetModuleName(dword dwBidnr, dword forwardedModule) const
	{
		return m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.OffsetModuleName;
	}
	
	word BoundImportDirectory::getNumberOfModuleForwarderRefs(dword dwBidnr, dword forwardedModule) const
	{
		return m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.NumberOfModuleForwarderRefs;
	}
	
	std::string BoundImportDirectory::getModuleName(dword dwBidnr, dword forwardedModule) const
	{
		return m_vIbd[dwBidnr].moduleForwarders[forwardedModule].strModuleName;
	}
	
	void BoundImportDirectory::setTimeDateStamp(dword dwBidnr, dword forwardedModule, dword dwTds)
	{
		m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.TimeDateStamp = dwTds;
	}
	
	void BoundImportDirectory::setOffsetModuleName(dword dwBidnr, dword forwardedModule, word wOmn)
	{
		m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.OffsetModuleName = wOmn;
	}
	
	void BoundImportDirectory::setNumberOfModuleForwarderRefs(dword dwBidnr, dword forwardedModule, word wMfr)
	{
		m_vIbd[dwBidnr].moduleForwarders[forwardedModule].ibdDescriptor.NumberOfModuleForwarderRefs = wMfr;
	}

	void BoundImportDirectory::setModuleName(dword dwBidnr, dword forwardedModule, const std::string& strModuleName)
	{
		m_vIbd[dwBidnr].moduleForwarders[forwardedModule].strModuleName = strModuleName;
	}
	
	word BoundImportDirectory::calcNumberOfModuleForwarderRefs(dword dwBidnr) const
	{
		return static_cast<word>(m_vIbd[dwBidnr].moduleForwarders.size());
	}
	
	void BoundImportDirectory::addForwardedModule(dword dwBidnr, const std::string& name, dword timeStamp, word offsetModuleName, word forwardedModules)
	{
		// XXX: Maybe test if there are already 0xFFFF forwarded modules.
		// XXX: Check for duplicate entries. Is it also necessary to check
		//      non-forwarded entries and forwarded entries in other non-forwarded
		//      entries?
		// XXX: Can forwarders forward recursively?
		
		PELIB_IMAGE_BOUND_DIRECTORY ibdCurrent;
		ibdCurrent.strModuleName = name;
		ibdCurrent.ibdDescriptor.TimeDateStamp = timeStamp;
		ibdCurrent.ibdDescriptor.OffsetModuleName = offsetModuleName;
		ibdCurrent.ibdDescriptor.NumberOfModuleForwarderRefs = forwardedModules;
		
		m_vIbd[dwBidnr].moduleForwarders.push_back(ibdCurrent);
	}
	
	void BoundImportDirectory::removeForwardedModule(dword dwBidnr, word forwardedModule)
	{
		m_vIbd[dwBidnr].moduleForwarders.erase(m_vIbd[dwBidnr].moduleForwarders.begin() + forwardedModule);
	}
}

```

`deps/PeLib/BoundImportDirectory.h`:

```h
/*
* BoundImportDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef BOUNDIMPORTDIRECTORY_H
#define BOUNDIMPORTDIRECTORY_H

#include "PeLibAux.h"

namespace PeLib
{
	/// Class that handles the BoundImport directory.
	/**
	* This class can read and modify the BoundImport directory table of a PE file.
	**/
	class BoundImportDirectory
	{
		private:
		  std::vector<PELIB_IMAGE_BOUND_DIRECTORY> m_vIbd; ///< Stores the individual BoundImport fields.
		  
		  int read(InputBuffer& inpBuffer, unsigned char* data, unsigned int dwSize);
		  unsigned int totalModules() const;
		public:
		  /// Adds another bound import.
		  int addBoundImport(const std::string& strModuleName, dword dwTds, word dwOmn, word wWfr); // EXPORT
		  /// Identifies a module through it's name.
		  int getModuleIndex(const std::string& strModuleName) const; // EXPORT
		  /// Returns the number of files in the BoundImport directory.
		  unsigned int calcNumberOfModules() const; // EXPORT
		  /// Reads the BoundImport directory table from a PE file.
		  int read(const std::string& strFileName, dword dwOffset, unsigned int uiSize); // EXPORT
		  int read(unsigned char* pcBuffer, unsigned int uiSize); // EXPORT
		  /// Rebuilds the BoundImport directory.
		  void rebuild(std::vector<byte>& vBuffer, bool fMakeValid = true) const; // EXPORT
		  /// Empties the BoundImport directory.
		  void clear(); // EXPORT
		  /// Removes a bound import.
		  void removeBoundImport(const std::string& strModuleName); // EXPORT
		  /// Returns the size of the BoundImport directory.
		  unsigned int size() const; // EXPORT
		  /// Writes the current bound import directory to a file.
		  int write(const std::string& strFilename, dword dwOffset, bool fMakeValid = true) const; // EXPORT

		  /// Retrieves the TimeDateStamp value of a bound import.
		  dword getTimeDateStamp(dword dwBidnr) const; // EXPORT
		  /// Retrieves the OffsetModuleName value of a bound import.
		  word getOffsetModuleName(dword dwBidnr) const; // EXPORT
		  /// Retrieves the NumberOfModuleForwarderRefs value of a bound import.
		  word getNumberOfModuleForwarderRefs(dword dwBidnr) const; // EXPORT
		  /// Retrieves the ModuleName value of a bound import.
		  std::string getModuleName(dword dwBidnr) const; // EXPORT

		  /// Updates the TimeDateStamp value of a bound import.
		  void setTimeDateStamp(dword dwBidnr, dword dwTds); // EXPORT
		  /// Updates the OffsetModuleName value of a bound import.
		  void setOffsetModuleName(dword dwBidnr, word wOmn); // EXPORT
		  /// Updates the NumberOfModuleForwarderRefs value of a bound import.
		  void setNumberOfModuleForwarderRefs(dword dwBidnr, word wMfr); // EXPORT
		  /// Updates the ModuleName value of a bound import.
		  void setModuleName(dword dwBidnr, const std::string& strModuleName); // EXPORT
		  
		  dword getTimeDateStamp(dword dwBidnr, dword forwardedModule) const; // EXPORT _module
		  word getOffsetModuleName(dword dwBidnr, dword forwardedModule) const; // EXPORT _module
		  word getNumberOfModuleForwarderRefs(dword dwBidnr, dword forwardedModule) const; // EXPORT _module
		  std::string getModuleName(dword dwBidnr, dword forwardedModule) const; // EXPORT _module

		  void setTimeDateStamp(dword dwBidnr, dword forwardedModule, dword dwTds); // EXPORT _module
		  void setOffsetModuleName(dword dwBidnr, dword forwardedModule, word wOmn); // EXPORT _module
		  void setNumberOfModuleForwarderRefs(dword dwBidnr, dword forwardedModule, word wMfr); // EXPORT _module
		  void setModuleName(dword dwBidnr, dword forwardedModule, const std::string& strModuleName); // EXPORT _module
		  
		  word calcNumberOfModuleForwarderRefs(dword dwBidnr) const; // EXPORT
		  void addForwardedModule(dword dwBidnr, const std::string& name, dword timeStamp = 0, word offsetModuleName = 0, word forwardedModules = 0); // EXPORT
		  void removeForwardedModule(dword dwBidnr, word forwardedModule); // EXPORT
	};
}


#endif

```

`deps/PeLib/ComHeaderDirectory.cpp`:

```cpp
/*
* ComHeaderDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "PeLibInc.h"
#include "ComHeaderDirectory.h"

namespace PeLib
{
	void ComHeaderDirectory::read(InputBuffer& inputbuffer)
	{
		PELIB_IMAGE_COR20_HEADER ichCurr;
		
		inputbuffer >> ichCurr.cb;
		inputbuffer >> ichCurr.MajorRuntimeVersion;
		inputbuffer >> ichCurr.MinorRuntimeVersion;
		inputbuffer >> ichCurr.MetaData.VirtualAddress;
		inputbuffer >> ichCurr.MetaData.Size;
		inputbuffer >> ichCurr.Flags;
		inputbuffer >> ichCurr.EntryPointToken;
		inputbuffer >> ichCurr.Resources.VirtualAddress;
		inputbuffer >> ichCurr.Resources.Size;
		inputbuffer >> ichCurr.StrongNameSignature.VirtualAddress;
		inputbuffer >> ichCurr.StrongNameSignature.Size;
		inputbuffer >> ichCurr.CodeManagerTable.VirtualAddress;
		inputbuffer >> ichCurr.CodeManagerTable.Size;
		inputbuffer >> ichCurr.VTableFixups.VirtualAddress;
		inputbuffer >> ichCurr.VTableFixups.Size;
		inputbuffer >> ichCurr.ExportAddressTableJumps.VirtualAddress;
		inputbuffer >> ichCurr.ExportAddressTableJumps.Size;
		inputbuffer >> ichCurr.ManagedNativeHeader.VirtualAddress;
		inputbuffer >> ichCurr.ManagedNativeHeader.Size;
		
		std::swap(ichCurr, m_ichComHeader);
	}
	
	int ComHeaderDirectory::read(unsigned char* buffer, unsigned int buffersize)
	{
		if (buffersize < PELIB_IMAGE_COR20_HEADER::size())
		{
			return ERROR_INVALID_FILE;
		}
		
		std::vector<byte> vComDescDirectory(buffer, buffer + buffersize);
		
		InputBuffer ibBuffer(vComDescDirectory);
		read(ibBuffer);
		return NO_ERROR;
	}
	
	/**
	* Reads a file's COM+ descriptor.
	* @param strFilename Name of the file.
	* @param uiOffset File offset of the COM+ descriptor.
	* @param uiSize Size of the COM+ descriptor.
	**/
	int ComHeaderDirectory::read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);
		unsigned int ulFileSize = fileSize(ifFile);

		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		if (ulFileSize < uiOffset + uiSize)
		{
			return ERROR_INVALID_FILE;
		}

		ifFile.seekg(uiOffset, std::ios::beg);

		std::vector<byte> vComDescDirectory(uiSize);
		ifFile.read(reinterpret_cast<char*>(&vComDescDirectory[0]), uiSize);
		
		InputBuffer ibBuffer(vComDescDirectory);
		read(ibBuffer);
		return NO_ERROR;
	}
	
	/**
	* Rebuilds the current COM+ descriptor.
	* @param vBuffer Buffer where the COM+ descriptor will be written to.
	**/
	void ComHeaderDirectory::rebuild(std::vector<byte>& vBuffer) const
	{
		OutputBuffer obBuffer(vBuffer);
		
		obBuffer << m_ichComHeader.cb;
		obBuffer << m_ichComHeader.MajorRuntimeVersion;
		obBuffer << m_ichComHeader.MinorRuntimeVersion;
		obBuffer << m_ichComHeader.MetaData.VirtualAddress;
		obBuffer << m_ichComHeader.MetaData.Size;
		obBuffer << m_ichComHeader.Flags;
		obBuffer << m_ichComHeader.EntryPointToken;
		obBuffer << m_ichComHeader.Resources.VirtualAddress;
		obBuffer << m_ichComHeader.Resources.Size;
		obBuffer << m_ichComHeader.StrongNameSignature.VirtualAddress;
		obBuffer << m_ichComHeader.StrongNameSignature.Size;
		obBuffer << m_ichComHeader.CodeManagerTable.VirtualAddress;
		obBuffer << m_ichComHeader.CodeManagerTable.Size;
		obBuffer << m_ichComHeader.VTableFixups.VirtualAddress;
		obBuffer << m_ichComHeader.VTableFixups.Size;
		obBuffer << m_ichComHeader.ExportAddressTableJumps.VirtualAddress;
		obBuffer << m_ichComHeader.ExportAddressTableJumps.Size;
		obBuffer << m_ichComHeader.ManagedNativeHeader.VirtualAddress;
		obBuffer << m_ichComHeader.ManagedNativeHeader.Size;
	}

	/**
	* @return Size in bytes.
	**/
	unsigned int ComHeaderDirectory::size() const
	{
		return PELIB_IMAGE_COR20_HEADER::size();
	}

	/**
	* @param strFilename Name of the file.
	* @param dwOffset File offset the COM+ descriptor will be written to.
	**/
	int ComHeaderDirectory::write(const std::string& strFilename, unsigned int dwOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(dwOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();
		
		return NO_ERROR;
	}

	/**
	* @return SizeOfHeader value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getSizeOfHeader() const
	{
		return m_ichComHeader.cb;
	}

	/**
	* @return MajorRuntimeVersion value of the current COM+ descriptor.
	**/
	word ComHeaderDirectory::getMajorRuntimeVersion() const
	{
		return m_ichComHeader.MajorRuntimeVersion;
	}

	/**
	* @return MinorRuntimeVersion value of the current COM+ descriptor.
	**/
	word ComHeaderDirectory::getMinorRuntimeVersion() const
	{
		return m_ichComHeader.MinorRuntimeVersion;
	}

	/**
	* @return MetaData (Virtual Address) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getMetaDataVa() const
	{
		return m_ichComHeader.MetaData.VirtualAddress;
	}

	/**
	* @return MetaData (Size) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getMetaDataSize() const
	{
		return m_ichComHeader.MetaData.Size;
	}

	/**
	* @return Flags value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getFlags() const
	{
		return m_ichComHeader.Flags;
	}

	/**
	* @return EntryPointToken value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getEntryPointToken() const
	{
		return m_ichComHeader.EntryPointToken;
	}

	/**
	* @return Resources (Virtual Address) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getResourcesVa() const
	{
		return m_ichComHeader.Resources.VirtualAddress;
	}

	/**
	* @return Resources (Size) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getResourcesSize()
	{
		return m_ichComHeader.Resources.Size;
	}

	/**
	* @return StrongNameSignature (Virtual Address) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getStrongNameSignatureVa() const
	{
		return m_ichComHeader.StrongNameSignature.VirtualAddress;
	}

	/**
	* @return StrongNameSignature (Size) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getStrongNameSignagureSize() const
	{
		return m_ichComHeader.StrongNameSignature.Size;
	}

	/**
	* @return CodeManagerTable (Virtual Address) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getCodeManagerTableVa() const
	{
		return m_ichComHeader.CodeManagerTable.VirtualAddress;
	}

	/**
	* @return CodeManagerTable (Size) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getCodeManagerTableSize() const
	{
		return m_ichComHeader.CodeManagerTable.Size;
	}

	/**
	* @return VTableFixups (Virtual Address) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getVTableFixupsVa() const
	{
		return m_ichComHeader.VTableFixups.VirtualAddress;
	}

	/**
	* @return VTableFixups (Size) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getVTableFixupsSize() const
	{
		return m_ichComHeader.VTableFixups.Size;
	}

	/**
	* @return ExportAddressTableJumps (Virtual Address) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getExportAddressTableJumpsVa() const
	{
		return m_ichComHeader.ExportAddressTableJumps.VirtualAddress;
	}

	/**
	* @return ExportAddressTableJumps (Size) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getExportAddressTableJumpsSize() const
	{
		return m_ichComHeader.ExportAddressTableJumps.Size;
	}

	/**
	* @return ManagedNativeHeader (Virtual Address) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getManagedNativeHeaderVa() const
	{
		return m_ichComHeader.ManagedNativeHeader.VirtualAddress;
	}

	/**
	* @return ManagedNativeHeader (Size) value of the current COM+ descriptor.
	**/
	dword ComHeaderDirectory::getManagedNativeHeaderSize() const
	{
		return m_ichComHeader.ManagedNativeHeader.Size;
	}

	/**
	* @param dwValue New value for the current SizeOfHeader (cb) value.
	**/
	void ComHeaderDirectory::setSizeOfHeader(dword dwValue)
	{
		m_ichComHeader.cb = dwValue;
	}

	/**
	* @param wValue New value for the current MajorRuntimeVersion value.
	**/
	void ComHeaderDirectory::setMajorRuntimeVersion(word wValue)
	{
		m_ichComHeader.MajorRuntimeVersion = wValue;
	}

	/**
	* @param wValue New value for the current MinorRuntimeVersion value.
	**/
	void ComHeaderDirectory::setMinorRuntimeVersion(word wValue)
	{
		m_ichComHeader.MinorRuntimeVersion = wValue;
	}

	/**
	* @param dwValue New value for the current MetaData (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setMetaDataVa(dword dwValue)
	{
		m_ichComHeader.MetaData.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current MetaData (Size) value.
	**/
	void ComHeaderDirectory::setMetaDataSize(dword dwValue)
	{
		m_ichComHeader.MetaData.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current Flags value.
	**/
	void ComHeaderDirectory::setFlags(dword dwValue)
	{
		m_ichComHeader.Flags = dwValue;
	}

	/**
	* @param dwValue New value for the current EntryPointToken value.
	**/
	void ComHeaderDirectory::setEntryPointToken(dword dwValue)
	{
		m_ichComHeader.EntryPointToken = dwValue;
	}

	/**
	* @param dwValue New value for the current Resources (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setResourcesVa(dword dwValue)
	{
		m_ichComHeader.Resources.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current Resources (Size) value.
	**/
	void ComHeaderDirectory::setResourcesSize(dword dwValue)
	{
		m_ichComHeader.Resources.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current StrongNameSignature (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setStrongNameSignatureVa(dword dwValue)
	{
		m_ichComHeader.StrongNameSignature.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current StrongNameSignature (Size) value.
	**/
	void ComHeaderDirectory::setStrongNameSignagureSize(dword dwValue)
	{
		m_ichComHeader.StrongNameSignature.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current CodeManagerTable (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setCodeManagerTableVa(dword dwValue)
	{
		m_ichComHeader.CodeManagerTable.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current CodeManagerTable (Size) value.
	**/
	void ComHeaderDirectory::setCodeManagerTableSize(dword dwValue)
	{
		m_ichComHeader.CodeManagerTable.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current VTableFixups (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setVTableFixupsVa(dword dwValue)
	{
		m_ichComHeader.VTableFixups.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current VTableFixups (Size) value.
	**/
	void ComHeaderDirectory::setVTableFixupsSize(dword dwValue)
	{
		m_ichComHeader.VTableFixups.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current ExportAddressTableJumps (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setExportAddressTableJumpsVa(dword dwValue)
	{
		m_ichComHeader.ExportAddressTableJumps.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current ExportAddressTableJumps (Size) value.
	**/
	void ComHeaderDirectory::setExportAddressTableJumpsSize(dword dwValue)
	{
		m_ichComHeader.ExportAddressTableJumps.Size = dwValue;
	}

	/**
	* @param dwValue New value for the current ManagedNativeHeader (VirtualAddress) value.
	**/
	void ComHeaderDirectory::setManagedNativeHeaderVa(dword dwValue)
	{
		m_ichComHeader.ManagedNativeHeader.VirtualAddress = dwValue;
	}

	/**
	* @param dwValue New value for the current ManagedNativeHeader (Size) value.
	**/
	void ComHeaderDirectory::setManagedNativeHeaderSize(dword dwValue)
	{
		m_ichComHeader.ManagedNativeHeader.Size = dwValue;
	}

}

```

`deps/PeLib/ComHeaderDirectory.h`:

```h
/*
* ComHeaderDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef COMHEADERDIRECTORY_H
#define COMHEADERDIRECTORY_H

namespace PeLib
{
	/// Class that handles the COM+ descriptor directory.
	/**
	* This class handles the COM+ Descriptor directory which was added to PE files
	* which work with the .NET runtime modules.
	**/
	class ComHeaderDirectory
	{
		private:
		  PELIB_IMAGE_COR20_HEADER m_ichComHeader; ///< The COM+ descriptor.
		  
		  void read(InputBuffer& inputbuffer);

		public:
		  /// Read a file's COM+ runtime descriptor directory.
		  int read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize); // EXPORT
		  int read(unsigned char* buffer, unsigned int buffersize); // EXPORT
		  /// Rebuild the COM+ descriptor.
		  void rebuild(std::vector<byte>& vBuffer) const; // EXPORT
		  /// Returns the size of the current COM+ descriptor.
		  unsigned int size() const; // EXPORT
		  /// Writes the current COM+ descriptor directory to a file.
		  int write(const std::string& strFilename, unsigned int dwOffset) const; // EXPORT

		  /// Get the COM+ descriptor's SizeOfHeader (cb) value.
		  dword getSizeOfHeader() const; // EXPORT
		  /// Get the COM+ descriptor's MajorRuntimeVersion value.
		  word getMajorRuntimeVersion() const; // EXPORT
		  /// Get the COM+ descriptor's MinorRuntimeVersion value.
		  word getMinorRuntimeVersion() const; // EXPORT
		  /// Get the COM+ descriptor's MetaData (Virtual Address) value.
		  dword getMetaDataVa() const; // EXPORT
		  /// Get the COM+ descriptor's MetaData (Size) value.
		  dword getMetaDataSize() const; // EXPORT
		  /// Get the COM+ descriptor's Flags value.
		  dword getFlags() const; // EXPORT
		  /// Get the COM+ descriptor's EntryPointToken value.
		  dword getEntryPointToken() const; // EXPORT
		  /// Get the COM+ descriptor's Resources (Virtual Address) value.
		  dword getResourcesVa() const; // EXPORT
		  /// Get the COM+ descriptor's Resources (Size) value.
		  dword getResourcesSize(); // EXPORT
		  /// Get the COM+ descriptor's StrongNameSignature (Virtual Address) value.
		  dword getStrongNameSignatureVa() const; // EXPORT
		  /// Get the COM+ descriptor's StrongNameSignature (Size) value.
		  dword getStrongNameSignagureSize() const; // EXPORT
		  /// Get the COM+ descriptor's CodeManagerTable (Virtual Address) value.
		  dword getCodeManagerTableVa() const; // EXPORT
		  /// Get the COM+ descriptor's CodeManagerTable (Size) value.
		  dword getCodeManagerTableSize() const; // EXPORT
		  /// Get the COM+ descriptor's VTableFixup (Virtual Address) value.
		  dword getVTableFixupsVa() const; // EXPORT
		  /// Get the COM+ descriptor's VTableFixup (Size) value.
		  dword getVTableFixupsSize() const; // EXPORT
		  /// Get the COM+ descriptor's ExportAddressTable (Virtual Address) value.
		  dword getExportAddressTableJumpsVa() const; // EXPORT
		  /// Get the COM+ descriptor's ExportAddressTable (Size) value.
		  dword getExportAddressTableJumpsSize() const; // EXPORT
		  /// Get the COM+ descriptor's ManagedNativeHeader (Virtual Address) value.
		  dword getManagedNativeHeaderVa() const; // EXPORT
		  /// Get the COM+ descriptor's ManagedNativeHeader (Size) value.
		  dword getManagedNativeHeaderSize() const; // EXPORT

		  /// Change the COM+ descriptor's SizeOfHeader (cb) value.
		  void setSizeOfHeader(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's MajorRuntimeVersion value.
		  void setMajorRuntimeVersion(word wValue); // EXPORT
		  /// Change the COM+ descriptor's MinorRuntimeVersion value.
		  void setMinorRuntimeVersion(word wValue); // EXPORT
		  /// Change the COM+ descriptor's MetaData (VirtualAddress) value.
		  void setMetaDataVa(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's MetaData (Size) value.
		  void setMetaDataSize(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's Flags value.
		  void setFlags(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's EntryPointToken value.
		  void setEntryPointToken(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's Resources (VirtualAddress) value.
		  void setResourcesVa(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's Resources (Size) value.
		  void setResourcesSize(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's StrongNameSignatureVa (VirtualAddress) value.
		  void setStrongNameSignatureVa(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's StrongNameSignatureVa (Size) value.
		  void setStrongNameSignagureSize(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's CodeManagerTable (VirtualAddress) value.
		  void setCodeManagerTableVa(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's CodeManagerTable (Size) value.
		  void setCodeManagerTableSize(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's VTableFixups (VirtualAddress) value.
		  void setVTableFixupsVa(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's VTableFixups (Size) value.
		  void setVTableFixupsSize(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's ExportAddressTableJumps (VirtualAddress) value.
		  void setExportAddressTableJumpsVa(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's ExportAddressTableJumps (Size) value.
		  void setExportAddressTableJumpsSize(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's ManagedNativeHeader (VirtualAddress) value.
		  void setManagedNativeHeaderVa(dword dwValue); // EXPORT
		  /// Change the COM+ descriptor's ManagedNativeHeader (Size) value.
		  void setManagedNativeHeaderSize(dword dwValue); // EXPORT
	};
}
#endif

```

`deps/PeLib/DebugDirectory.cpp`:

```cpp
/*
* DebugDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "PeLibInc.h"
#include "DebugDirectory.h"

namespace PeLib
{
	void DebugDirectory::clear()
	{
		m_vDebugInfo.clear();
	}
	
	std::vector<PELIB_IMG_DEBUG_DIRECTORY> DebugDirectory::read(InputBuffer& ibBuffer, unsigned int uiSize)
	{
		std::vector<PELIB_IMG_DEBUG_DIRECTORY> currDebugInfo;
		
		PELIB_IMG_DEBUG_DIRECTORY iddCurr;
		
		for (unsigned int i=0;i<uiSize/PELIB_IMAGE_DEBUG_DIRECTORY::size();i++)
		{
			
			ibBuffer >> iddCurr.idd.Characteristics;
			ibBuffer >> iddCurr.idd.TimeDateStamp;
			ibBuffer >> iddCurr.idd.MajorVersion;
			ibBuffer >> iddCurr.idd.MinorVersion;
			ibBuffer >> iddCurr.idd.Type;
			ibBuffer >> iddCurr.idd.SizeOfData;
			ibBuffer >> iddCurr.idd.AddressOfRawData;
			ibBuffer >> iddCurr.idd.PointerToRawData;
		
			currDebugInfo.push_back(iddCurr);
		}
		
		return currDebugInfo;
	}
	
	int DebugDirectory::read(unsigned char* buffer, unsigned int buffersize)
	{
		// XXX: Note, debug data is not read at all. This might or might not change
		//      in the future.
		
		std::vector<byte> vDebugDirectory(buffer, buffer + buffersize);
		
		InputBuffer ibBuffer(vDebugDirectory);
		
		std::vector<PELIB_IMG_DEBUG_DIRECTORY> currDebugInfo = read(ibBuffer, buffersize);
		
		std::swap(currDebugInfo, m_vDebugInfo);
		
		return NO_ERROR;
	}
	
	/**
	* @param strFilename Name of the file which will be read.
	* @param uiOffset File offset of the Debug directory.
	* @param uiSize Size of the Debug directory.
	**/
	int DebugDirectory::read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);
		unsigned int ulFileSize = fileSize(ifFile);

		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		if (ulFileSize < uiOffset + uiSize)
		{
			return ERROR_INVALID_FILE;
		}

		ifFile.seekg(uiOffset, std::ios::beg);

		std::vector<byte> vDebugDirectory(uiSize);
		ifFile.read(reinterpret_cast<char*>(&vDebugDirectory[0]), uiSize);
		
		InputBuffer ibBuffer(vDebugDirectory);
		
		std::vector<PELIB_IMG_DEBUG_DIRECTORY> currDebugInfo = read(ibBuffer, uiSize);
		
		for (unsigned int i=0;i<currDebugInfo.size();i++)
		{
			ifFile.seekg(currDebugInfo[i].idd.PointerToRawData, std::ios::beg);
			currDebugInfo[i].data.resize(currDebugInfo[i].idd.SizeOfData);
			ifFile.read(reinterpret_cast<char*>(&currDebugInfo[i].data[0]), currDebugInfo[i].idd.SizeOfData);
			if (!ifFile) return ERROR_INVALID_FILE;
		}
		
		std::swap(currDebugInfo, m_vDebugInfo);
		
		return NO_ERROR;
	}
	
	/**
	* Rebuilds the current debug directory.
	* @param vBuffer Buffer where the rebuilt directory is stored.
	**/
	void DebugDirectory::rebuild(std::vector<byte>& vBuffer) const
	{
		OutputBuffer obBuffer(vBuffer);
		
		for (unsigned int i=0;i<m_vDebugInfo.size();i++)
		{
			obBuffer << m_vDebugInfo[i].idd.Characteristics;
			obBuffer << m_vDebugInfo[i].idd.TimeDateStamp;
			obBuffer << m_vDebugInfo[i].idd.MajorVersion;
			obBuffer << m_vDebugInfo[i].idd.MinorVersion;
			obBuffer << m_vDebugInfo[i].idd.Type;
			obBuffer << m_vDebugInfo[i].idd.SizeOfData;
			obBuffer << m_vDebugInfo[i].idd.AddressOfRawData;
			obBuffer << m_vDebugInfo[i].idd.PointerToRawData;
		}
	}

	/**
	* @return Size of the debug directory.
	**/
	unsigned int DebugDirectory::size() const
	{
		return static_cast<unsigned int>(m_vDebugInfo.size()) * PELIB_IMAGE_DEBUG_DIRECTORY::size();
	}

	/**
	* @param strFilename Name of the file which will be written.
	* @param uiOffset File offset where the debug directory will be stored.
	**/
	int DebugDirectory::write(const std::string& strFilename, unsigned int uiOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();
		
		return NO_ERROR;
	}

	/**
	* @return Number of debug structures in the current Debug directory.
	**/
	unsigned int DebugDirectory::calcNumberOfEntries() const
	{
		return static_cast<unsigned int>(m_vDebugInfo.size());
	}

	/**
	* Adds a new debug structure to the debug directory. The initial values of all members of the structure
	* are undefined.
	**/
	void DebugDirectory::addEntry()
	{
		PELIB_IMG_DEBUG_DIRECTORY p;
		m_vDebugInfo.push_back(p);
	}

	/**
	* Removes a debug structure from the current debug directory. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	**/
	void DebugDirectory::removeEntry(unsigned int uiIndex)
	{
		m_vDebugInfo.erase(m_vDebugInfo.begin() + uiIndex);
	}
		  
	/**
	* Returns the Characteristics value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return Characteristics value of the debug structure.
	**/
	dword DebugDirectory::getCharacteristics(unsigned int uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.Characteristics;
	}
	
	/**
	* Returns the TimeDateStamp value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return TimeDateStamp value of the debug structure.
	**/
	dword DebugDirectory::getTimeDateStamp(unsigned int uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.TimeDateStamp;
	}
	
	/**
	* Returns the MajorVersion value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return MajorVersion value of the debug structure.
	**/
	word DebugDirectory::getMajorVersion(unsigned int uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.MajorVersion;
	}
	
	/**
	* Returns the MinorVersion value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return MinorVersion value of the debug structure.
	**/
	word DebugDirectory::getMinorVersion(unsigned int uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.MinorVersion;
	}
	
	/**
	* Returns the Type value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return Type value of the debug structure.
	**/
	dword DebugDirectory::getType(unsigned int uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.Type;
	}
	
	/**
	* Returns the SizeOfData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return SizeOfData value of the debug structure.
	**/
	dword DebugDirectory::getSizeOfData(unsigned int uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.SizeOfData;
	}
	
	/**
	* Returns the AddressOfRawData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return AddressOfRawData value of the debug structure.
	**/
	dword DebugDirectory::getAddressOfRawData(unsigned int uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.AddressOfRawData;
	}
	
	/**
	* Returns the PointerToRawData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @return PointerToRawData value of the debug structure.
	**/
	dword DebugDirectory::getPointerToRawData(unsigned int uiIndex) const
	{
		return m_vDebugInfo[uiIndex].idd.PointerToRawData;
	}
	
	std::vector<byte> DebugDirectory::getData(unsigned int index) const
	{
		return m_vDebugInfo[index].data;
	}

	/**
	* Changes the Characteristics value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the Characteristics value of the debug structure.
	**/
	void DebugDirectory::setCharacteristics(unsigned int uiIndex, dword dwValue)
	{
		m_vDebugInfo[uiIndex].idd.Characteristics = dwValue;
	}
	
	/**
	* Changes the TimeDateStamp value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the TimeDateStamp value of the debug structure.
	**/
	void DebugDirectory::setTimeDateStamp(unsigned int uiIndex, dword dwValue)
	{
		m_vDebugInfo[uiIndex].idd.TimeDateStamp = dwValue;
	}
	
	/**
	* Changes the MajorVersion value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param wValue New value of the MajorVersion value of the debug structure.
	**/
	void DebugDirectory::setMajorVersion(unsigned int uiIndex, word wValue)
	{
		m_vDebugInfo[uiIndex].idd.MajorVersion = wValue;
	}
	
	/**
	* Changes the MinorVersion value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param wValue New value of the MinorVersion value of the debug structure.
	**/
	void DebugDirectory::setMinorVersion(unsigned int uiIndex, word wValue)
	{
		m_vDebugInfo[uiIndex].idd.MinorVersion = wValue;
	}
	
	/**
	* Changes the Type value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the Type value of the debug structure.
	**/
	void DebugDirectory::setType(unsigned int uiIndex, dword dwValue)
	{
		m_vDebugInfo[uiIndex].idd.Type = dwValue;
	}
	
	/**
	* Changes the SizeOfData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the SizeOfData value of the debug structure.
	**/
	void DebugDirectory::setSizeOfData(unsigned int uiIndex, dword dwValue)
	{
		m_vDebugInfo[uiIndex].idd.SizeOfData = dwValue;
	}
	
	/**
	* Changes the AddressOfRawData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the AddressOfRawData value of the debug structure.
	**/
	void DebugDirectory::setAddressOfRawData(unsigned int uiIndex, dword dwValue)
	{
		m_vDebugInfo[uiIndex].idd.AddressOfRawData = dwValue;
	}
	
	/**
	* Changes the PointerToRawData value of a debug structure. If an invalid structure is specified
	* by the parameter uiIndex the result will be undefined behaviour.
	* @param uiIndex Identifies the debug structure.
	* @param dwValue New value of the PointerToRawData value of the debug structure.
	**/
	void DebugDirectory::setPointerToRawData(unsigned int uiIndex, dword dwValue)
	{
		m_vDebugInfo[uiIndex].idd.PointerToRawData = dwValue;
	}
	
	void DebugDirectory::setData(unsigned int index, const std::vector<byte>& data)
	{
		m_vDebugInfo[index].data = data;
	}
}

```

`deps/PeLib/DebugDirectory.h`:

```h
/*
* DebugDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef DEBUGDIRECTORY_H
#define DEBUGDIRECTORY_H

namespace PeLib
{
	/// Class that handles the Debug directory.
	class DebugDirectory
	{
		private:
		  /// Stores the various DebugDirectory structures.
		  std::vector<PELIB_IMG_DEBUG_DIRECTORY> m_vDebugInfo;
		  
		  std::vector<PELIB_IMG_DEBUG_DIRECTORY> read(InputBuffer& ibBuffer, unsigned int uiSize);

		public:
		  void clear(); // EXPORT
		  /// Reads the Debug directory from a file.
		  int read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize); // EXPORT
		  int read(unsigned char* buffer, unsigned int buffersize);
		  /// Rebuilds the current Debug directory.
		  void rebuild(std::vector<byte>& obBuffer) const; // EXPORT
		  /// Returns the size the current Debug directory needs after rebuilding.
		  unsigned int size() const;
		  /// Writes the current Debug directory back to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset) const; // EXPORT

		  /// Returns the number of DebugDirectory image structures in the current DebugDirectory.
		  unsigned int calcNumberOfEntries() const; // EXPORT
		  
		  /// Adds a new debug structure.
		  void addEntry(); // EXPORT
		  /// Removes a debug structure.
		  void removeEntry(unsigned int uiIndex); // EXPORT
		  
		  /// Returns the Characteristics value of a debug structure.
		  dword getCharacteristics(unsigned int uiIndex) const; // EXPORT
		  /// Returns the TimeDateStamp value of a debug structure.
		  dword getTimeDateStamp(unsigned int uiIndex) const; // EXPORT
		  /// Returns the MajorVersion value of a debug structure.
		  word getMajorVersion(unsigned int uiIndex) const; // EXPORT
		  /// Returns the MinorVersion value of a debug structure.
		  word getMinorVersion(unsigned int uiIndex) const; // EXPORT
		  /// Returns the Type value of a debug structure.
		  dword getType(unsigned int uiIndex) const; // EXPORT
		  /// Returns the SizeOfData value of a debug structure.
		  dword getSizeOfData(unsigned int uiIndex) const; // EXPORT
		  /// Returns the AddressOfRawData value of a debug structure.
		  dword getAddressOfRawData(unsigned int uiIndex) const; // EXPORT
		  /// Returns the PointerToRawData value of a debug structure.
		  dword getPointerToRawData(unsigned int uiIndex) const; // EXPORT
		  std::vector<byte> getData(unsigned int index) const; // EXPORT
		  
		  /// Sets the Characteristics value of a debug structure.
		  void setCharacteristics(unsigned int uiIndex, dword dwValue); // EXPORT
		  /// Sets the TimeDateStamp value of a debug structure.
		  void setTimeDateStamp(unsigned int uiIndex, dword dwValue); // EXPORT
		  /// Sets the MajorVersion value of a debug structure.
		  void setMajorVersion(unsigned int uiIndex, word wValue); // EXPORT
		  /// Sets the MinorVersion value of a debug structure.
		  void setMinorVersion(unsigned int uiIndex, word wValue); // EXPORT
		  /// Sets the Type value of a debug structure.
		  void setType(unsigned int uiIndex, dword dwValue); // EXPORT
		  /// Sets the SizeOfData value of a debug structure.
		  void setSizeOfData(unsigned int uiIndex, dword dwValue); // EXPORT
		  /// Sets the AddressOfRawData value of a debug structure.
		  void setAddressOfRawData(unsigned int uiIndex, dword dwValue); // EXPORT
		  /// Sets the PointerToRawData value of a debug structure.
		  void setPointerToRawData(unsigned int uiIndex, dword dwValue); // EXPORT
		  void setData(unsigned int index, const std::vector<byte>& data); // EXPORT
	};
}
#endif

```

`deps/PeLib/ExportDirectory.cpp`:

```cpp
/*
* ExportDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

//#ifdef false

#include "PeLibInc.h"
#include "ExportDirectory.h"

namespace PeLib
{
	/**
	* @param strFuncname Name of the function.
	* @param dwFuncAddr RVA of the function.
	**/
	void ExportDirectory::addFunction(const std::string& strFuncname, dword dwFuncAddr)
	{
		PELIB_EXP_FUNC_INFORMATION efiCurr;
		efiCurr.funcname = strFuncname;
		efiCurr.addroffunc = dwFuncAddr;
		m_ied.functions.push_back(efiCurr);
	}
	
	void ExportDirectory::removeFunction(unsigned int index)
	{
		m_ied.functions.erase(m_ied.functions.begin() + index);
	}
	
	void ExportDirectory::clear()
	{
		m_ied.functions.clear();
	}
		
	unsigned int ExportDirectory::calcNumberOfFunctions() const
	{
		return static_cast<unsigned int>(m_ied.functions.size());
	}

	/**
	* Identifies an exported function through it's name.
	* @param strFunctionName Name of the function
	* @return Number which identifies the functions.
	**/
	int ExportDirectory::getFunctionIndex(const std::string& strFunctionName) const
	{
		std::vector<PELIB_EXP_FUNC_INFORMATION>::const_iterator Iter = std::find_if(m_ied.functions.begin(), m_ied.functions.end(), std::bind2nd(std::mem_fun_ref(&PELIB_EXP_FUNC_INFORMATION::equal), strFunctionName));
		
		if (Iter == m_ied.functions.end())
		{
//			throw Exceptions::InvalidName(ExportDirectoryId, __LINE__);
			return -1;
		}
		
		return static_cast<int>(std::distance(m_ied.functions.begin(), Iter));
	}

	/**
	* @param strFilename Name of the file.
	* @param uiOffset File offset of the export directory.
	* @param uiSize Size of the export directory.
	* @param pehHeader A valid PE header which is necessary because some RVA calculations need to be done.
    * \todo: Proper use of InputBuffer
	**/
	int ExportDirectory::read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize, const PeHeader& pehHeader)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);
		
		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		unsigned int filesize = fileSize(ifFile);
		
		if (filesize < uiOffset + uiSize)
		{
			return ERROR_INVALID_FILE;
		}

		ifFile.seekg(uiOffset, std::ios::beg);

		PELIB_IMAGE_EXP_DIRECTORY iedCurr;

		std::vector<unsigned char> vExportdirectory(uiSize);
		ifFile.read(reinterpret_cast<char*>(&vExportdirectory[0]), uiSize);

		InputBuffer inpBuffer(vExportdirectory);

		inpBuffer >> iedCurr.ied.Characteristics;
		inpBuffer >> iedCurr.ied.TimeDateStamp;
		inpBuffer >> iedCurr.ied.MajorVersion;
		inpBuffer >> iedCurr.ied.MinorVersion;
		inpBuffer >> iedCurr.ied.Name;
		inpBuffer >> iedCurr.ied.Base;
		inpBuffer >> iedCurr.ied.NumberOfFunctions;
		inpBuffer >> iedCurr.ied.NumberOfNames;
		inpBuffer >> iedCurr.ied.AddressOfFunctions;
		inpBuffer >> iedCurr.ied.AddressOfNames;
		inpBuffer >> iedCurr.ied.AddressOfNameOrdinals;

		if (const PeHeader32* p32 = dynamic_cast<const PeHeader32*>(&pehHeader))
		{
			unsigned int offset = p32->rvaToOffset(iedCurr.ied.Name);
			
			if (offset >= filesize)
				return ERROR_INVALID_FILE;
			
			ifFile.seekg(offset, std::ios::beg);
		}
		else if (const PeHeader64* p64 = dynamic_cast<const PeHeader64*>(&pehHeader))
		{
			// XXX: Files might be > 4 GB
			unsigned int offset = static_cast<unsigned int>(p64->rvaToOffset(iedCurr.ied.Name));
			
			if (offset >= filesize)
				return ERROR_INVALID_FILE;
			
			ifFile.seekg(offset, std::ios::beg);
		}
		
		char c = 0;
		std::string strFname = "";
		do
		{
			ifFile.read(reinterpret_cast<char*>(&c), sizeof(c));
			if (!ifFile) return ERROR_INVALID_FILE;
			if (c) strFname += c;
		}
		while (c != 0);
		iedCurr.name = strFname;

		if (const PeHeader32* p32 = dynamic_cast<const PeHeader32*>(&pehHeader))
		{
			unsigned int offset = p32->rvaToOffset(iedCurr.ied.AddressOfFunctions);
			
			if (offset >= filesize)
				return ERROR_INVALID_FILE;
			
			ifFile.seekg(offset, std::ios::beg);
		}
		else if (const PeHeader64* p64 = dynamic_cast<const PeHeader64*>(&pehHeader))
		{
			// XXX: File might be > 4 GB
			unsigned int offset = static_cast<unsigned int>(p64->rvaToOffset(iedCurr.ied.AddressOfFunctions));
			
			if (offset >= filesize)
				return ERROR_INVALID_FILE;
				
			ifFile.seekg(offset, std::ios::beg);
		}

		PELIB_EXP_FUNC_INFORMATION efiCurr;
		efiCurr.ordinal = 0; efiCurr.addroffunc = 0; efiCurr.addrofname = 0;

		for (unsigned int i=0;i<iedCurr.ied.NumberOfFunctions;i++)
		{
			if (const PeHeader32* p32 = dynamic_cast<const PeHeader32*>(&pehHeader))
			{
				unsigned int offset = p32->rvaToOffset(iedCurr.ied.AddressOfFunctions) + i*sizeof(efiCurr.addroffunc);
				
				if (offset >= filesize)
					return ERROR_INVALID_FILE;
					
				ifFile.seekg(offset, std::ios::beg);
			}
			else if (const PeHeader64* p64 = dynamic_cast<const PeHeader64*>(&pehHeader))
			{
				// XXX: File might be > 4GB
				unsigned int offset = static_cast<unsigned int>(p64->rvaToOffset(iedCurr.ied.AddressOfFunctions)) + i*sizeof(efiCurr.addroffunc);
				
				if (offset >= filesize)
					return ERROR_INVALID_FILE;
					
				ifFile.seekg(offset, std::ios::beg);
			}
			
			ifFile.read(reinterpret_cast<char*>(&efiCurr.addroffunc), sizeof(efiCurr.addroffunc));
			
			if (!ifFile)
				return ERROR_INVALID_FILE;
				
			efiCurr.ordinal = i;
			iedCurr.functions.push_back(efiCurr);
		}

		for (unsigned int i=0;i<iedCurr.ied.NumberOfNames;i++)
		{
			if (const PeHeader32* p32 = dynamic_cast<const PeHeader32*>(&pehHeader))
			{
				unsigned int offset = p32->rvaToOffset(iedCurr.ied.AddressOfNameOrdinals) + i*sizeof(efiCurr.ordinal);
				
				if (offset >= filesize)
					return ERROR_INVALID_FILE;
				
				ifFile.seekg(offset, std::ios::beg);
			}
			else if (const PeHeader64* p64 = dynamic_cast<const PeHeader64*>(&pehHeader))
			{
				// XXX: File might be > 4 GB
				unsigned int offset = static_cast<unsigned int>(p64->rvaToOffset(iedCurr.ied.AddressOfNameOrdinals)) + i*sizeof(efiCurr.ordinal);
				
				if (offset >= filesize)
					return ERROR_INVALID_FILE;
				
				ifFile.seekg(offset, std::ios::beg);
			}

			word ordinal;
			ifFile.read(reinterpret_cast<char*>(&ordinal), sizeof(ordinal));
			
			if (!ifFile)
				return ERROR_INVALID_FILE;
			
			iedCurr.functions[ordinal].ordinal = ordinal;

			if (const PeHeader32* p32 = dynamic_cast<const PeHeader32*>(&pehHeader))
			{
				unsigned int offset = p32->rvaToOffset(iedCurr.ied.AddressOfNames) + i*sizeof(efiCurr.addrofname);
				
				if (offset >= filesize)
					return ERROR_INVALID_FILE;
				
				ifFile.seekg(offset, std::ios::beg);
			}
			else if (const PeHeader64* p64 = dynamic_cast<const PeHeader64*>(&pehHeader))
			{
				// XXX: File might be > 4 GB.
				unsigned int offset = static_cast<unsigned int>(p64->rvaToOffset(iedCurr.ied.AddressOfNames)) + i*sizeof(efiCurr.addrofname);
				
				if (offset >= filesize)
					return ERROR_INVALID_FILE;
				
				ifFile.seekg(offset, std::ios::beg);
			}
			
			ifFile.read(reinterpret_cast<char*>(&iedCurr.functions[ordinal].addrofname), sizeof(iedCurr.functions[ordinal].addrofname));
			
			if (!ifFile)
				return ERROR_INVALID_FILE;

			if (const PeHeader32* p32 = dynamic_cast<const PeHeader32*>(&pehHeader))
			{
				unsigned int offset = p32->rvaToOffset(iedCurr.functions[ordinal].addrofname);

				if (offset >= filesize)
					return ERROR_INVALID_FILE;

				ifFile.seekg(offset, std::ios::beg);
			}
			else if (const PeHeader64* p64 = dynamic_cast<const PeHeader64*>(&pehHeader))
			{
				// XXX: File might be > 4 GB.
				unsigned int offset = static_cast<unsigned int>(p64->rvaToOffset(iedCurr.functions[ordinal].addrofname));

				if (offset >= filesize)
					return ERROR_INVALID_FILE;

				ifFile.seekg(static_cast<unsigned int>(p64->rvaToOffset(iedCurr.functions[ordinal].addrofname)), std::ios::beg);
			}

			char c = 0;
			std::string strFname = "";
			do
			{
				ifFile.read(reinterpret_cast<char*>(&c), sizeof(c));
				
				if (!ifFile)
					return ERROR_INVALID_FILE;
					
				if (c) strFname += c;
			}
			while (c != 0);

			iedCurr.functions[ordinal].funcname = strFname;
		}

		std::swap(m_ied, iedCurr);
		
		return NO_ERROR;
	}

	/**
	* @param vBuffer Buffer where the rebuilt export directory is written to.
	* @param dwRva RVA of the export directory.
	* \todo fValid flag
	**/
	void ExportDirectory::rebuild(std::vector<byte>& vBuffer, dword dwRva) const
	{
		unsigned int uiSizeDirectory = sizeof(PELIB_IMAGE_EXPORT_DIRECTORY);

		unsigned int uiSizeNames = 0;
		unsigned int uiSizeAddrFuncs = 0;
		unsigned int uiSizeAddrNames = 0;
		unsigned int uiSizeOrdinals = 0;

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			uiSizeNames += (m_ied.functions[i].funcname.empty()) ? 0 : static_cast<unsigned int>(m_ied.functions[i].funcname.size()) + 1;
			uiSizeAddrFuncs += sizeof(m_ied.functions[i].addroffunc);
			uiSizeAddrNames += (m_ied.functions[i].funcname.empty()) ? 0 : sizeof(m_ied.functions[i].addrofname);
			uiSizeOrdinals += (m_ied.functions[i].funcname.empty()) ? 0 : sizeof(m_ied.functions[i].ordinal);
		}
		
		unsigned int uiFilenameSize = static_cast<unsigned int>(m_ied.name.size()) + 1;
		
		OutputBuffer obBuffer(vBuffer);

		obBuffer << m_ied.ied.Characteristics;
		obBuffer << m_ied.ied.TimeDateStamp;
		obBuffer << m_ied.ied.MajorVersion;
		obBuffer << m_ied.ied.MinorVersion;
		obBuffer << dwRva + uiSizeDirectory;
		obBuffer << m_ied.ied.Base;
		obBuffer << static_cast<unsigned int>(m_ied.functions.size());

		// TODO: Not correct but sufficient for now. (Update: I forgot what this comment refers to, but I'll leave it in)
		obBuffer << static_cast<unsigned int>(m_ied.functions.size());
		obBuffer << dwRva + uiSizeDirectory + uiFilenameSize;
		obBuffer << dwRva + uiSizeDirectory + uiFilenameSize + uiSizeAddrFuncs; 
		obBuffer << dwRva + uiSizeDirectory + uiFilenameSize + uiSizeAddrFuncs + uiSizeAddrNames;

		obBuffer.add(m_ied.name.c_str(), static_cast<unsigned int>(m_ied.name.size())+1);

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			obBuffer << m_ied.functions[i].addroffunc;
		}

		unsigned int ulFuncCounter = dwRva + uiSizeDirectory + uiFilenameSize + uiSizeAddrFuncs + uiSizeAddrNames + uiSizeOrdinals;
		
		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			if (!m_ied.functions[i].funcname.empty())
			{
				obBuffer << ulFuncCounter;
				ulFuncCounter += static_cast<unsigned int>(m_ied.functions[i].funcname.size()) + 1;
			}
		}

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			if (!m_ied.functions[i].funcname.empty())
			{
				obBuffer <<  m_ied.functions[i].ordinal;
			}
		}

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			if (m_ied.functions[i].funcname.empty() && m_ied.functions[i].addroffunc)
			{
				obBuffer <<  m_ied.functions[i].ordinal;
			}
		}

		for (unsigned int i=0;i<m_ied.functions.size();i++)
		{
			if (!m_ied.functions[i].funcname.empty())
			{
				obBuffer.add(m_ied.functions[i].funcname.c_str(), static_cast<unsigned int>(m_ied.functions[i].funcname.size()) + 1);
			}
		}
	}

	/**
	* @return Size of the current export directory.
	**/
	unsigned int ExportDirectory::size() const
	{
		return m_ied.size();
	}

	/**
	* @param strFilename Name of the file.
	* @param uiOffset File offset the export directory will be written to.
	* @param uiRva RVA of the export directory.
	* \todo Check if ofFile.write succeeded.
	**/
	int ExportDirectory::write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}
		
		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer, uiRva);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();
		
		return NO_ERROR;
	}

	/**
	* Changes the filename according to the export directory.
	* @param strFilename New filename.
	**/
	void ExportDirectory::setNameString(const std::string& strFilename)
	{
		m_ied.name = strFilename;
	}

	std::string ExportDirectory::getNameString() const
	{
		return m_ied.name;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @return The name of that function.
	**/
	std::string ExportDirectory::getFunctionName(dword dwIndex) const
	{
		return m_ied.functions[dwIndex].funcname;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @return The ordinal of that function.
	**/
	word ExportDirectory::getFunctionOrdinal(dword dwIndex) const
	{
		return m_ied.functions[dwIndex].ordinal;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @return The RVA of the name string of that function.
	**/
	dword ExportDirectory::getAddressOfName(dword dwIndex) const
	{
		return m_ied.functions[dwIndex].addrofname;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @return The RVA of that function.
	**/
	dword ExportDirectory::getAddressOfFunction(dword dwIndex) const
	{
		return m_ied.functions[dwIndex].addroffunc;
	}
	
	/**
	* @param dwIndex Number which identifies an exported function.
	* @param strName The name of that function.
	**/
	void ExportDirectory::setFunctionName(dword dwIndex, const std::string& strName)
	{
		m_ied.functions[dwIndex].funcname = strName;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @param wValue The ordinal of that function.
	**/
	void ExportDirectory::setFunctionOrdinal(dword dwIndex, word wValue)
	{
		m_ied.functions[dwIndex].ordinal = wValue;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @param dwValue The RVA of the name string of that function.
	**/
	void ExportDirectory::setAddressOfName(dword dwIndex, dword dwValue)
	{
		m_ied.functions[dwIndex].addrofname = dwValue;
	}

	/**
	* @param dwIndex Number which identifies an exported function.
	* @param dwValue The RVA of that function.
	**/
	void ExportDirectory::setAddressOfFunction(dword dwIndex, dword dwValue)
	{
		m_ied.functions[dwIndex].addroffunc = dwValue;
	}

	/**
	* @return The ordinal base of the export directory.
	**/
	dword ExportDirectory::getBase() const
	{
		return m_ied.ied.Base;
	}

	/**
	* @return The characteristics of the export directory.
	**/
	dword ExportDirectory::getCharacteristics() const
	{
		return m_ied.ied.Characteristics;
	}

	/**
	* @return The time/date stamp of the export directory.
	**/
	dword ExportDirectory::getTimeDateStamp() const
	{
		return m_ied.ied.TimeDateStamp;
	}

	/**
	* @return The MajorVersion of the export directory.
	**/
	word ExportDirectory::getMajorVersion() const
	{
		return m_ied.ied.MajorVersion;
	}

	/**
	* @return The MinorVersion of the export directory.
	**/
	word ExportDirectory::getMinorVersion() const
	{
		return m_ied.ied.MinorVersion;
	}

	/**
	* @return The RVA of the name of the file.
	**/
	dword ExportDirectory::getName() const
	{
		return m_ied.ied.Name;
	}

	/**
	* @return The NumberOfFunctions of the export directory.
	**/
	dword ExportDirectory::getNumberOfFunctions() const
	{
		return m_ied.ied.NumberOfFunctions;
	}

	/**
	* @return The NumberOfNames of the export directory.
	**/
	dword ExportDirectory::getNumberOfNames() const
	{
		return m_ied.ied.NumberOfNames;
	}

	/**
	* @return The AddressOfFunctions of the export directory.
	**/
	dword ExportDirectory::getAddressOfFunctions() const
	{
		return m_ied.ied.AddressOfFunctions;
	}

	/**
	* @return The AddressOfNames of the export directory.
	**/
	dword ExportDirectory::getAddressOfNames() const
	{
		return m_ied.ied.AddressOfNames;
	}

/*	dword ExportDirectory::getNumberOfNameOrdinals() const
	{
		return static_cast<dword>(m_ied.functions.size());
	}

	dword ExportDirectory::getNumberOfAddressOfFunctionNames() const
	{
		return static_cast<dword>(m_ied.functions.size());
	}

	dword ExportDirectory::getNumberOfAddressOfFunctions() const
	{
		return static_cast<dword>(m_ied.functions.size());
	}
*/
	/**
	* @return The AddressOfNameOrdinals of the export directory.
	**/
	dword ExportDirectory::getAddressOfNameOrdinals() const
	{
		return m_ied.ied.AddressOfNameOrdinals;
	}

	/**
	* @param dwValue The ordinal base of the export directory.
	**/
	void ExportDirectory::setBase(dword dwValue)
	{
		m_ied.ied.Base = dwValue;
	}

	/**
	* @param dwValue The Characteristics of the export directory.
	**/
	void ExportDirectory::setCharacteristics(dword dwValue)
	{
		m_ied.ied.Characteristics = dwValue;
	}

	/**
	* @param dwValue The TimeDateStamp of the export directory.
	**/
	void ExportDirectory::setTimeDateStamp(dword dwValue)
	{
		m_ied.ied.TimeDateStamp = dwValue;
	}

	/**
	* @param wValue The MajorVersion of the export directory.
	**/
	void ExportDirectory::setMajorVersion(word wValue)
	{
		m_ied.ied.MajorVersion = wValue;
	}

	/**
	* @param wValue The MinorVersion of the export directory.
	**/
	void ExportDirectory::setMinorVersion(word wValue)
	{
		m_ied.ied.MinorVersion = wValue;
	}

	/**
	* @param dwValue The Name of the export directory.
	**/
	void ExportDirectory::setName(dword dwValue)
	{
		m_ied.ied.Name = dwValue;
	}

	/**
	* @param dwValue The NumberOfFunctions of the export directory.
	**/
	void ExportDirectory::setNumberOfFunctions(dword dwValue)
	{
		m_ied.ied.NumberOfFunctions = dwValue;
	}

	/**
	* @param dwValue The NumberOfNames of the export directory.
	**/
	void ExportDirectory::setNumberOfNames(dword dwValue)
	{
		m_ied.ied.NumberOfNames = dwValue;
	}

	/**
	* @param dwValue The AddressOfFunctions of the export directory.
	**/
	void ExportDirectory::setAddressOfFunctions(dword dwValue)
	{
		m_ied.ied.AddressOfFunctions = dwValue;
	}

	/**
	* @param dwValue The AddressOfNames of the export directory.
	**/
	void ExportDirectory::setAddressOfNames(dword dwValue)
	{
		m_ied.ied.AddressOfNames = dwValue;
	}
	
	void ExportDirectory::setAddressOfNameOrdinals(dword value)
	{
		m_ied.ied.AddressOfNameOrdinals = value;
	}
}

```

`deps/PeLib/ExportDirectory.h`:

```h
/*
* ExportDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef EXPORTDIRECTORY_H
#define EXPORTDIRECTORY_H
#include "PeHeader.h"

namespace PeLib
{
	/// Class that handles the export directory.
	/**
	* This class handles the export directory.
	* \todo getNameString
	**/
//	template<int bits>
	class ExportDirectory
	{
		private:
		  /// Used to store all necessary information about a file's exported functions.
		  PELIB_IMAGE_EXP_DIRECTORY m_ied;

		public:
		  /// Add another function to be exported.
		  void addFunction(const std::string& strFuncname, dword dwFuncAddr); // EXPORT
		  unsigned int calcNumberOfFunctions() const; // EXPORT
		  void clear(); // EXPORT
		  /// Identifies a function through it's name.
		  int getFunctionIndex(const std::string& strFunctionName) const; // EXPORT
		  /// Read a file's export directory.
		  int read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize, const PeHeader& pehHeader); // EXPORT
		  /// Rebuild the current export directory.
		  void rebuild(std::vector<byte>& vBuffer, dword dwRva) const; // EXPORT
		  void removeFunction(unsigned int index); // EXPORT
		  /// Returns the size of the current export directory.
		  unsigned int size() const; // EXPORT
		  /// Writes the current export directory to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva) const; // EXPORT

		  /// Changes the name of the file (according to the export directory).
		  void setNameString(const std::string& strFilename); // EXPORT
		  std::string getNameString() const; // EXPORT

		  /// Get the name of an exported function.
		  std::string getFunctionName(unsigned int index) const; // EXPORT
		  /// Get the ordinal of an exported function.
		  word getFunctionOrdinal(unsigned int index) const; // EXPORT
		  /// Get the address of the name of an exported function.
		  dword getAddressOfName(unsigned int index) const; // EXPORT
		  /// Get the address of an exported function.
		  dword getAddressOfFunction(unsigned int index) const; // EXPORT
		  
		  /// Change the name of an exported function.
		  void setFunctionName(unsigned int index, const std::string& strName); // EXPORT
		  /// Change the ordinal of an exported function.
		  void setFunctionOrdinal(unsigned int index, word wValue); // EXPORT
		  /// Change the address of the name of an exported function.
		  void setAddressOfName(unsigned int index, dword dwValue); // EXPORT
		  /// Change the address of an exported function.
		  void setAddressOfFunction(unsigned int index, dword dwValue); // EXPORT
		  
		  /*
		  word getFunctionOrdinal(std::string strFuncname) const;
		  dword getAddressOfName(std::string strFuncname) const;
		  dword getAddressOfFunction(std::string strFuncname) const;

		  void setFunctionOrdinal(std::string strFuncname, word wValue);
		  void setAddressOfName(std::string strFuncname, dword dwValue);
		  void setAddressOfFunction(std::string strFuncname, dword dwValue);
		  */

		  /// Return the Base value of the export directory.
		  dword getBase() const; // EXPORT
		  /// Return the Characteristics value of the export directory.
		  dword getCharacteristics() const; // EXPORT
		  /// Return the TimeDateStamp value of the export directory.
		  dword getTimeDateStamp() const; // EXPORT
		  /// Return the MajorVersion value of the export directory.
		  word getMajorVersion() const; // EXPORT
		  /// Return the MinorVersion value of the export directory.
		  word getMinorVersion() const; // EXPORT
		  /// Return the Name value of the export directory.
		  dword getName() const; // EXPORT
		  /// Return the NumberOfFunctions value of the export directory.
		  dword getNumberOfFunctions() const; // EXPORT
		  /// Return the NumberOfNames value of the export directory.
		  dword getNumberOfNames() const; // EXPORT
		  /// Return the AddressOfFunctions value of the export directory.
		  dword getAddressOfFunctions() const; // EXPORT
		  /// Return the AddressOfNames value of the export directory.
		  dword getAddressOfNames() const; // EXPORT
		  /// Returns the AddressOfNameOrdinals value.
		  dword getAddressOfNameOrdinals() const; // EXPORT

/*		  /// Returns the number of NameOrdinals.
		  dword getNumberOfNameOrdinals() const; // EXPORT
		  /// Returns the number of AddressOfFunctionNames values.
		  dword getNumberOfAddressOfFunctionNames() const; // EXPORT
		  /// Returns the number of AddressOfFunction values.
		  dword getNumberOfAddressOfFunctions() const; // EXPORT
*/
		  /// Set the Base value of the export directory.
		  void setBase(dword dwValue); // EXPORT
		  /// Set the Characteristics value of the export directory.
		  void setCharacteristics(dword dwValue); // EXPORT
		  /// Set the TimeDateStamp value of the export directory.
		  void setTimeDateStamp(dword dwValue); // EXPORT
		  /// Set the MajorVersion value of the export directory.
		  void setMajorVersion(word wValue); // EXPORT
		  /// Set the MinorVersion value of the export directory.
		  void setMinorVersion(word wValue); // EXPORT
		  /// Set the Name value of the export directory.
		  void setName(dword dwValue); // EXPORT
		  /// Set the NumberOfFunctions value of the export directory.
		  void setNumberOfFunctions(dword dwValue); // EXPORT
		  /// Set the NumberOfNames value of the export directory.
		  void setNumberOfNames(dword dwValue); // EXPORT
		  /// Set the AddressOfFunctions value of the export directory.
		  void setAddressOfFunctions(dword dwValue); // EXPORT
		  /// Set the AddressOfNames value of the export directory.
		  void setAddressOfNames(dword dwValue); // EXPORT
		  void setAddressOfNameOrdinals(dword value); // EXPORT
	};
}
#endif

```

`deps/PeLib/IatDirectory.cpp`:

```cpp
/*
* IatDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "IatDirectory.h"

namespace PeLib
{
	int IatDirectory::read(InputBuffer& inputBuffer, unsigned int size)
	{
		dword dwAddr;

		std::vector<dword> vIat;

		for (unsigned int i=0;i<size/sizeof(dword);i++)
		{
			inputBuffer >> dwAddr;
			vIat.push_back(dwAddr);
		}
		
		std::swap(vIat, m_vIat);
		
		return NO_ERROR;
	}
	
	/**
	* Reads the Import Address table from a file.
	* @param strFilename Name of the file.
	* @param dwOffset File offset of the IAT (see #PeFile::PeHeader::getIDIatRVA).
	* @param dwSize Size of the IAT (see #PeFile::PeHeader::getIDIatSize).
	**/
	int IatDirectory::read(const std::string& strFilename, unsigned int dwOffset, unsigned int dwSize)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);
		
		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		if (fileSize(ifFile) < dwOffset + dwSize)
		{
			return ERROR_INVALID_FILE;
		}
		
		ifFile.seekg(dwOffset, std::ios::beg);
		
		std::vector<byte> vBuffer(dwSize);
		ifFile.read(reinterpret_cast<char*>(&vBuffer[0]), dwSize);

		InputBuffer inpBuffer(vBuffer);
		return read(inpBuffer, dwSize);
	}
	
	int IatDirectory::read(unsigned char* buffer, unsigned int buffersize)
	{
		std::vector<byte> vBuffer(buffer, buffer + buffersize);
		InputBuffer inpBuffer(vBuffer);
		return read(inpBuffer, buffersize);
	}
	
	/**
	* Returns the number of fields in the IAT. This is equivalent to the number of
	* imported functions.
	* @return Number of fields in the IAT.
	**/
	unsigned int IatDirectory::calcNumberOfAddresses() const
	{
		return static_cast<unsigned int>(m_vIat.size());
	}

	/**
	* Returns the dwValue of a field in the IAT.
	* @param dwAddrnr Number identifying the field.
	* @return dwValue of the field.
	**/
	dword IatDirectory::getAddress(unsigned int index) const
	{
		return m_vIat[index];
	}
	
	/**
	* Updates the dwValue of a field in the IAT.
	* @param dwAddrnr Number identifying the field.
	* @param dwValue New dwValue of the field.
	**/
	void IatDirectory::setAddress(dword dwAddrnr, dword dwValue)
	{
		m_vIat[dwAddrnr] = dwValue;
	}

	/**
	* Adds another field to the IAT.
	* @param dwValue dwValue of the new field.
	**/
	void IatDirectory::addAddress(dword dwValue)
	{
		m_vIat.push_back(dwValue);
	}
	
	/**
	* Removes an address from the IAT.
	* @param dwAddrnr Number identifying the field.
	**/
	void IatDirectory::removeAddress(unsigned int index)
	{
		std::vector<dword>::iterator pos = m_vIat.begin() + index;
		m_vIat.erase(pos);
	}
	
	/**
	* Delete all entries from the IAT.
	**/
	void IatDirectory::clear()
	{
		m_vIat.clear();
	}
	
	/**
	* Rebuilds the complete Import Address Table.
	* @param vBuffer Buffer where the rebuilt IAT will be stored.
	**/
	void IatDirectory::rebuild(std::vector<byte>& vBuffer) const
	{
		vBuffer.reserve(size());
		OutputBuffer obBuffer(vBuffer);
	
		for (unsigned int i=0;i<m_vIat.size();i++)
		{
			obBuffer << m_vIat[i];
		}
	}

	unsigned int IatDirectory::size() const
	{
		return static_cast<unsigned int>(m_vIat.size())* sizeof(dword);
	}

	/// Writes the current IAT to a file.
	int IatDirectory::write(const std::string& strFilename, unsigned int uiOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();
		
		return NO_ERROR;
	}
}

```

`deps/PeLib/IatDirectory.h`:

```h
/*
* IatDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef IATDIRECTORY_H
#define IATDIRECTORY_H

#include "PeLibInc.h"

namespace PeLib
{
	/// Class that handles the Import Address Table (IAT)
	/**
	* This class can read and modify the Import Address Table of a PE file.
	**/
	class IatDirectory
	{
		private:
		  std::vector<dword> m_vIat; ///< Stores the individual IAT fields.
		  
		  int read(InputBuffer& inputBuffer, unsigned int size);
		  
		public:
		  /// Reads the Import Address Table from a PE file.
		  int read(const std::string& strFilename, unsigned int dwOffset, unsigned int dwSize); // EXPORT
		  int read(unsigned char* buffer, unsigned int buffersize); // EXPORT
		  /// Returns the number of fields in the IAT.
		  unsigned int calcNumberOfAddresses() const; // EXPORT
		  /// Adds another address to the IAT.
		  void addAddress(dword dwValue); // EXPORT
		  /// Removes an address from the IAT.
		  void removeAddress(unsigned int index); // EXPORT
		  /// Empties the IAT.
		  void clear(); // EXPORT
		  // Rebuilds the IAT.
		  void rebuild(std::vector<byte>& vBuffer) const; // EXPORT
		  /// Returns the size of the current IAT.
		  unsigned int size() const; // EXPORT
		  /// Writes the current IAT to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset) const; // EXPORT

		  /// Retrieve the value of a field in the IAT.
		  dword getAddress(unsigned int index) const; // EXPORT
		  /// Change the value of a field in the IAT.
		  void setAddress(dword dwAddrnr, dword dwValue); // EXPORT
	};
}

#endif


```

`deps/PeLib/ImportDirectory.h`:

```h
/*
* ImportDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef IMPORTDIRECTORY_H
#define IMPORTDIRECTORY_H

#include "PeLibAux.h"
#include "PeHeader.h"

namespace PeLib
{
	/// Parameter for functions that can operate on the OLDDIR or new import directory.
	enum currdir {OLDDIR = 1, NEWDIR};
		
	class PeLibException;

	/// Class that handles import directories.
	/**
	* This class can read import directories from existing PE files or start completely from scratch.
	* Modifying import directories and writing them to files is also possible.
	* It's worthy to note that many functions require an extra parameter of type currdir
	* because the structure of import directories make it necessary that the OLDDIR import directory
	* must be preserved. That's why some functions (like adding and removing) imported functions
	* only exist for the new import directory, not for the one which is already written to the file.
	* \todo Adding functions by ordinal doesn't work yet (rebuild needs to be changed).
	* \todo Somehow store the rvas of the chunks in the file.
	**/
	template<int bits>
	class ImportDirectory
	{
		typedef typename std::vector<PELIB_IMAGE_IMPORT_DIRECTORY<bits> >::iterator ImpDirFileIterator;
		typedef typename std::vector<PELIB_IMAGE_IMPORT_DIRECTORY<bits> >::const_iterator ConstImpDirFileIterator;
	
		private:
		  /// Stores information about already imported DLLs.
		  std::vector<PELIB_IMAGE_IMPORT_DIRECTORY<bits> > m_vOldiid;
		  /// Stores information about imported DLLs which will be added.
		  std::vector<PELIB_IMAGE_IMPORT_DIRECTORY<bits> > m_vNewiid;

		// I can't convince Borland C++ to compile the function outside of the class declaration.
		// That's why the function definition is here.
		/// Tests if a certain function is imported.
		template<typename T> bool hasFunction(std::string strFilename, T value, bool(PELIB_THUNK_DATA<bits>::* comp)(T) const) const
	    {
			ConstImpDirFileIterator FileIter = m_vOldiid.begin();
			ConstImpDirFileIterator EndIter = m_vOldiid.end();
			
			for (int i=0;i<=1;i++) // Loop once for m_vOldiid and once for m_vNewiid
			{
				do
				{
					FileIter = std::find_if(FileIter, EndIter, std::bind2nd(std::mem_fun_ref(&PELIB_IMAGE_IMPORT_DIRECTORY<bits>::operator==), strFilename));
					
					if (FileIter != EndIter)
					{
						typename std::vector<PELIB_THUNK_DATA<bits> >::const_iterator Iter = std::find_if(FileIter->originalfirstthunk.begin(), FileIter->originalfirstthunk.end(), std::bind2nd(std::mem_fun_ref(comp), value));
						if (Iter != FileIter->originalfirstthunk.end())
						{
							return true;
						}
						++FileIter;
					}
				}
				while (FileIter != EndIter);
				
				FileIter = m_vNewiid.begin();
				EndIter = m_vNewiid.end();
	 		}
		 	
	 		return false;
		}
        

		public:

		  /// Add a function to the import directory.
		  int addFunction(const std::string& strFilename, word wHint); // EXPORT _byHint
		  /// Add a function to the import directory.
		  int addFunction(const std::string& strFilename, const std::string& strFuncname); // EXPORT _byName

		  /// Get the ID of a file through it's name.
		  unsigned int getFileIndex(const std::string& strFilename, currdir cdDir) const; // EXPORT
		  /// Get the ID of a function through it's name.
		  unsigned int getFunctionIndex(const std::string& strFilename, const std::string& strFuncname, currdir cdDir) const; // EXPORT

		  /// Get the name of an imported file.
		  std::string getFileName(dword dwFilenr, currdir cdDir) const; // EXPORT
		  
		  void setFileName(dword filenr, currdir dir, const std::string& name); // EXPORT
		  
		  /// Get the hint of an imported function.
		  word getFunctionHint(dword dwFilenr, dword dwFuncnr, currdir cdDir) const; // EXPORT
		  void setFunctionHint(dword dwFilenr, dword dwFuncnr, currdir cdDir, word value); // EXPORT
		  /// Get the name of an imported function.
		  std::string getFunctionName(dword dwFilenr, dword dwFuncnr, currdir cdDir) const; // EXPORT
		  void setFunctionName(dword dwFilenr, dword dwFuncnr, currdir cdDir, const std::string& functionName); // EXPORT
		  /// Get the number of files which are imported.
		  dword getNumberOfFiles(currdir cdDir) const; // EXPORT
		  /// Get the number of fucntions which are imported by a specific file.
		  dword getNumberOfFunctions(dword dwFilenr, currdir cdDir) const; // EXPORT
		  /// Read a file's import directory.
		  int read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize, const PeHeaderT<bits>& pehHeader); // EXPORT
		  /// Rebuild the import directory.
		  void rebuild(std::vector<byte>& vBuffer, dword dwRva, bool fixEntries = true) const; // EXPORT
		  /// Remove a file from the import directory.
		  int removeFile(const std::string& strFilename); // EXPORT
		  /// Remove a function from the import directory.
		  int removeFunction(const std::string& strFilename, const std::string& strFuncname); // EXPORT _byName
		  /// Remove a function from the import directory.
		  int removeFunction(const std::string& strFilename, word wHint); // EXPORT _byHint
		  /// Returns the size of the current import directory.
		  unsigned int size() const; // EXPORT
		  /// Writes the import directory to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva); // EXPORT

		  /// Returns the FirstThunk value of a function.
		  dword getFirstThunk(dword dwFilenr, dword dwFuncnr, currdir cdDir) const; // EXPORT _byNumber
		  void setFirstThunk(dword dwFilenr, dword dwFuncnr, currdir cdDir, dword value); // EXPORT _byNumber
		  /// Returns the OriginalFirstThunk value of a function.
		  dword getOriginalFirstThunk(dword dwFilenr, dword dwFuncnr, currdir cdDir) const; // EXPORT _byNumber
		  void setOriginalFirstThunk(dword dwFilenr, dword dwFuncnr, currdir cdDir, dword value); // EXPORT

//		  dword getFirstThunk(const std::string& strFilename, const std::string& strFuncname, currdir cdDir) const throw (PeLibException);
//		  dword getOriginalFirstThunk(const std::string& strFilename, const std::string& strFuncname, currdir cdDir) const throw (PeLibException);

		  /// Returns the FirstThunk value of a file.
		  dword getFirstThunk(const std::string& strFilename, currdir cdDir) const; // EXPORT _byName
		  /// Returns the OriginalFirstThunk value of a file.
		  dword getOriginalFirstThunk(const std::string& strFilename, currdir cdDir) const; // EXPORT _byName
		  /// Returns the ForwarderChain value of a file.
		  dword getForwarderChain(const std::string& strFilename, currdir cdDir) const; // EXPORT _byName
		  dword getRvaOfName(const std::string& strFilename, currdir cdDir) const; // EXPORT _byName
		  /// Returns the TimeDateStamp value of a file.
		  dword getTimeDateStamp(const std::string& strFilename, currdir cdDir) const; // EXPORT _byName

		  /// Returns the FirstThunk value of a file.
		  dword getFirstThunk(dword dwFilenr, currdir cdDir) const; // EXPORT
		  void setFirstThunk(dword dwFilenr, currdir cdDir, dword value); // EXPORT _byNumber_function
		  /// Returns the OriginalFirstThunk value of a file.
		  dword getOriginalFirstThunk(dword dwFilenr, currdir cdDir) const; // EXPORT
		  void setOriginalFirstThunk(dword dwFilenr, currdir cdDir, dword value); // EXPORT _byNumber_function
		  /// Returns the ForwarderChain value of a file.
		  dword getForwarderChain(dword dwFilenr, currdir cdDir) const; // EXPORT _byNumber
		  void setForwarderChain(dword dwFilenr, currdir cdDir, dword value); // EXPORT _byNumber_function
		  dword getRvaOfName(dword dwFilenr, currdir cdDir) const; // EXPORT _byNumber
		  void setRvaOfName(dword dwFilenr, currdir cdDir, dword value); // EXPORT
		  /// Returns the TimeDateStamp value of a file.
		  dword getTimeDateStamp(dword dwFilenr, currdir cdDir) const; // EXPORT
		  void setTimeDateStamp(dword dwFilenr, currdir cdDir, dword value); // EXPORT _byNumber

//		  word getFunctionHint(const std::string& strFilename, const std::string& strFuncname, currdir cdDir) const throw (PeLibException);
	};

	/**
	* Add another import (by Ordinal) to the current file. Note that the import table is not automatically updated.
	* The new imported functions will be added when you recalculate the import table as it's necessary
	* to specify the address the import table will have in the file.
	* @param strFilename The name of a DLL.
	* @param wHint The ordinal of the function in the DLL.
	**/
	template<int bits>
	int ImportDirectory<bits>::addFunction(const std::string& strFilename, word wHint)
	{
		if (hasFunction(strFilename, wHint, &PELIB_THUNK_DATA<bits>::equalHint))
		{
			return ERROR_DUPLICATE_ENTRY;
		}
		
	 	// Find the imported file.
		ImpDirFileIterator FileIter = std::find_if(m_vNewiid.begin(), m_vNewiid.end(), std::bind2nd(std::mem_fun_ref(&PELIB_IMAGE_IMPORT_DIRECTORY<bits>::operator==), strFilename));

		PELIB_IMAGE_IMPORT_DIRECTORY<bits> iid;
		PELIB_THUNK_DATA<bits> td;
		td.hint = wHint;
		td.itd.Ordinal = wHint | PELIB_IMAGE_ORDINAL_FLAGS<bits>::IMAGE_ORDINAL_FLAG;
		iid.name = strFilename;
		if (FileIter == m_vNewiid.end())
		{
			iid.originalfirstthunk.push_back(td);
			iid.firstthunk.push_back(td);
			m_vNewiid.push_back(iid);
		}
		else
		{
			FileIter->originalfirstthunk.push_back(td);
			FileIter->firstthunk.push_back(td);
		}
		
		return NO_ERROR;
	}

	/**
	* Add a function to the Import Directory.
	* @param strFilename Name of the file which will be imported
	* @param strFuncname Name of the function which will be imported.
	**/
	template<int bits>
	int ImportDirectory<bits>::addFunction(const std::string& strFilename, const std::string& strFuncname)
	{
		if (hasFunction(strFilename, strFuncname, &PELIB_THUNK_DATA<bits>::equalFunctionName))
		{
			return ERROR_DUPLICATE_ENTRY;
		}
		
	 	// Find the imported file.
		ImpDirFileIterator FileIter = std::find_if(m_vNewiid.begin(), m_vNewiid.end(), std::bind2nd(std::mem_fun_ref(&PELIB_IMAGE_IMPORT_DIRECTORY<bits>::operator==), strFilename));

		PELIB_IMAGE_IMPORT_DIRECTORY<bits> iid;
		PELIB_THUNK_DATA<bits> td;
		td.fname = strFuncname;
		iid.name = strFilename;
		if (FileIter == m_vNewiid.end())
		{
			iid.originalfirstthunk.push_back(td);
			iid.firstthunk.push_back(td);
			m_vNewiid.push_back(iid);
		}
		else
		{
			FileIter->originalfirstthunk.push_back(td);
			FileIter->firstthunk.push_back(td);
		}
		
		return NO_ERROR;
	}

	/**
	* Searches through the import directory and returns the number of the import
	* directory entry which belongs to the given filename.
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return The ID of an imported file.
	**/
	template<int bits>
	unsigned int ImportDirectory<bits>::getFileIndex(const std::string& strFilename, currdir cdDir) const
	{
		const std::vector<PELIB_IMAGE_IMPORT_DIRECTORY<bits> >* currDir;
		
		if (cdDir == OLDDIR)
		{
			 currDir = &m_vOldiid;
		}
		else
		{
			 currDir = &m_vNewiid;
		}

		ConstImpDirFileIterator FileIter = std::find_if(currDir->begin(), currDir->end(), std::bind2nd(std::mem_fun_ref(&PELIB_IMAGE_IMPORT_DIRECTORY<bits>::operator==), strFilename));

		if (FileIter != currDir->end())
		{
			return static_cast<unsigned int>(std::distance(currDir->begin(), FileIter));
		}
		else
		{
			return -1;
			// throw Exceptions::InvalidName(ImportDirectoryId, __LINE__);
		}

		return NO_ERROR;
	}

	/**
	* Searches through an imported file for a specific function.
	* @param strFilename Name of the imported file.
	* @param strFuncname Name of the imported function.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return ID of the imported function.
	**/
	template<int bits>
	unsigned int ImportDirectory<bits>::getFunctionIndex(const std::string& strFilename, const std::string& strFuncname, currdir cdDir) const
	{
		unsigned int uiFile = getFileIndex(strFilename, cdDir);

		for (unsigned int i=0;i<getNumberOfFunctions(uiFile, cdDir);i++)
		{
			if (getFunctionName(uiFile, i, cdDir) == strFuncname) return i;
		}

		return -1;
	}

	/**
	* Get the name of an imported file.
	* @param dwFilenr Identifies which file should be checked.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Name of an imported file.
	**/
	template<int bits>
	std::string ImportDirectory<bits>::getFileName(dword dwFilenr, currdir cdDir) const
	{
		if (cdDir == OLDDIR) return m_vOldiid[dwFilenr].name;
		else return m_vNewiid[dwFilenr].name;
	}

	template<int bits>
	void ImportDirectory<bits>::setFileName(dword filenr, currdir dir, const std::string& name)
	{
		if (dir == OLDDIR) m_vOldiid[filenr].name = name;
		else m_vNewiid[filenr].name = name;
	}

	/**
	* Get the name of an imported function.
	* @param dwFilenr Identifies which file should be checked.
	* @param dwFuncnr Identifies which function should be checked.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Name of an imported function.
	* \todo Marked line is unsafe (function should be rewritten).
	**/
	template<int bits>
	std::string ImportDirectory<bits>::getFunctionName(dword dwFilenr, dword dwFuncnr, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			// Unsafe
			if (m_vOldiid[dwFilenr].impdesc.OriginalFirstThunk)
			{
				return m_vOldiid[dwFilenr].originalfirstthunk[dwFuncnr].fname;
			}
			else
			{
				return m_vOldiid[dwFilenr].firstthunk[dwFuncnr].fname;
			}
		}
		else
		{
			if (m_vNewiid[dwFilenr].impdesc.OriginalFirstThunk)
			{
				return m_vNewiid[dwFilenr].originalfirstthunk[dwFuncnr].fname;
			}
			else
			{
				return m_vNewiid[dwFilenr].firstthunk[dwFuncnr].fname;
			}
		}
	}

	template<int bits>
	void ImportDirectory<bits>::setFunctionName(dword dwFilenr, dword dwFuncnr, currdir cdDir, const std::string& functionName)
	{
		if (cdDir == OLDDIR)
		{
			// Unsafe
			if (m_vOldiid[dwFilenr].impdesc.OriginalFirstThunk)
			{
				m_vOldiid[dwFilenr].originalfirstthunk[dwFuncnr].fname = functionName;
			}
			else
			{
				m_vOldiid[dwFilenr].firstthunk[dwFuncnr].fname = functionName;
			}
		}
		else
		{
			if (m_vNewiid[dwFilenr].impdesc.OriginalFirstThunk)
			{
				m_vNewiid[dwFilenr].originalfirstthunk[dwFuncnr].fname = functionName;
			}
			else
			{
				m_vNewiid[dwFilenr].firstthunk[dwFuncnr].fname = functionName;
			}
		}
	}

	/**
	* Get the hint of an imported function.
	* @param dwFilenr Identifies which file should be checked.
	* @param dwFuncnr Identifies which function should be checked.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Hint of an imported function.
	**/
	template<int bits>
	word ImportDirectory<bits>::getFunctionHint(dword dwFilenr, dword dwFuncnr, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			if (m_vOldiid[dwFilenr].impdesc.OriginalFirstThunk)
			{
				return m_vOldiid[dwFilenr].originalfirstthunk[dwFuncnr].hint;
			}
			else
			{
				return m_vOldiid[dwFilenr].firstthunk[dwFuncnr].hint;
			}
		}
		else return m_vNewiid[dwFilenr].originalfirstthunk[dwFuncnr].hint;
	}

	template<int bits>
	void ImportDirectory<bits>::setFunctionHint(dword dwFilenr, dword dwFuncnr, currdir cdDir, word value)
	{
		if (cdDir == OLDDIR)
		{
			if (m_vOldiid[dwFilenr].impdesc.OriginalFirstThunk)
			{
				m_vOldiid[dwFilenr].originalfirstthunk[dwFuncnr].hint = value;
			}
			else
			{
				m_vOldiid[dwFilenr].firstthunk[dwFuncnr].hint = value;
			}
		}
		else m_vNewiid[dwFilenr].originalfirstthunk[dwFuncnr].hint = value;
	}

	/**
	* Get the number of files which are currently being imported.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Number of files which are currently being imported.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getNumberOfFiles(currdir cdDir) const
	{
		if (cdDir == OLDDIR) return static_cast<dword>(m_vOldiid.size());
		else return static_cast<dword>(m_vNewiid.size());
	}

	/**
	* Get the number of functions which are currently being imported from a specific file.
	* @param dwFilenr Identifies which file should be checked.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return Number of functions which are currently being imported from a specific file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getNumberOfFunctions(dword dwFilenr, currdir cdDir) const
	{
		if (cdDir == OLDDIR) return static_cast<unsigned int>(m_vOldiid[dwFilenr].firstthunk.size());
		else return static_cast<unsigned int>(m_vNewiid[dwFilenr].firstthunk.size());
	}

	/**
	* Read an import directory from a file.
	* \todo Check if streams failed.
	* @param strFilename Name of the file which will be read.
	* @param uiOffset Offset of the import directory (see #PeLib::PeHeader::getIDImportRVA).
	* @param uiSize Size of the import directory (see #PeLib::PeHeader::getIDImportSize).
	* @param pehHeader A valid PE header.
	**/
	template<int bits>
	int ImportDirectory<bits>::read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize, const PeHeaderT<bits>& pehHeader)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios_base::binary);

		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		unsigned int uiFileSize = fileSize(ifFile);
		
		if (uiFileSize < uiOffset + uiSize)
		{
			return ERROR_INVALID_FILE;
		}

		ifFile.seekg(uiOffset, std::ios_base::beg);

		std::vector<unsigned char> vImportdirectory(uiSize);
		ifFile.read(reinterpret_cast<char*>(&vImportdirectory[0]), uiSize);

		PELIB_IMAGE_IMPORT_DIRECTORY<bits> iidCurr;
		unsigned int uiDesccounter = 0;

		InputBuffer inpBuffer(vImportdirectory);

		std::vector<PELIB_IMAGE_IMPORT_DIRECTORY<bits> > vOldIidCurr;

		do // Read and store all descriptors
		{
			inpBuffer >> iidCurr.impdesc.OriginalFirstThunk;
			inpBuffer >> iidCurr.impdesc.TimeDateStamp;
			inpBuffer >> iidCurr.impdesc.ForwarderChain;
			inpBuffer >> iidCurr.impdesc.Name;
			inpBuffer >> iidCurr.impdesc.FirstThunk;

			if (iidCurr.impdesc.OriginalFirstThunk != 0 || iidCurr.impdesc.TimeDateStamp != 0 || iidCurr.impdesc.ForwarderChain != 0 ||
			iidCurr.impdesc.Name != 0 || iidCurr.impdesc.FirstThunk != 0)
			{
				vOldIidCurr.push_back(iidCurr);
			}

			uiDesccounter++;

			if (uiSize < (uiDesccounter + 1) * PELIB_IMAGE_IMPORT_DESCRIPTOR::size()) break;
		} while (iidCurr.impdesc.OriginalFirstThunk != 0 || iidCurr.impdesc.TimeDateStamp != 0 || iidCurr.impdesc.ForwarderChain != 0 ||
				iidCurr.impdesc.Name != 0 || iidCurr.impdesc.FirstThunk != 0);

		char namebuffer[2] = {0};
			
		// Name
		for (unsigned int i=0;i<vOldIidCurr.size();i++)
		{
			ifFile.seekg(static_cast<unsigned int>(pehHeader.rvaToOffset(vOldIidCurr[i].impdesc.Name)), std::ios_base::beg);

			std::string dllname = "";
			
			do
			{
				ifFile.read(namebuffer, 1);
				if (!ifFile || !namebuffer[0]) break; // reached end of file or 0-byte
				dllname += namebuffer;
			} while (true);
			
			vOldIidCurr[i].name = dllname;
			
		}
		
		// OriginalFirstThunk
		for (unsigned int i=0;i<vOldIidCurr.size();i++)
		{
			PELIB_THUNK_DATA<bits> tdCurr;
			dword uiVaoft = vOldIidCurr[i].impdesc.OriginalFirstThunk;

			if (!uiVaoft)
			{
				continue;
			}

			ifFile.seekg(static_cast<unsigned int>(pehHeader.rvaToOffset(uiVaoft)), std::ios_base::beg);

			do
			{
				if (uiFileSize < pehHeader.rvaToOffset(uiVaoft) + sizeof(tdCurr.itd.Ordinal))
				{
					return ERROR_INVALID_FILE;
				}
				uiVaoft += sizeof(tdCurr.itd.Ordinal);
				
				ifFile.read(reinterpret_cast<char*>(&tdCurr.itd.Ordinal), sizeof(tdCurr.itd.Ordinal));
				if (tdCurr.itd.Ordinal) vOldIidCurr[i].originalfirstthunk.push_back(tdCurr);
			} while (tdCurr.itd.Ordinal);
		}

		// FirstThunk
		for (unsigned int i=0;i<vOldIidCurr.size();i++)
		{
			dword uiVaoft = vOldIidCurr[i].impdesc.FirstThunk;
			PELIB_THUNK_DATA<bits> tdCurr;

			ifFile.seekg(static_cast<unsigned int>(pehHeader.rvaToOffset(uiVaoft)), std::ios_base::beg);

			do
			{
				if (uiFileSize < pehHeader.rvaToOffset(uiVaoft) + sizeof(tdCurr.itd.Ordinal))
				{
					return ERROR_INVALID_FILE;
				}
				
				uiVaoft += sizeof(tdCurr.itd.Ordinal);
				
				ifFile.read(reinterpret_cast<char*>(&tdCurr.itd.Ordinal), sizeof(tdCurr.itd.Ordinal));
				if (tdCurr.itd.Ordinal) vOldIidCurr[i].firstthunk.push_back(tdCurr);
			} while (tdCurr.itd.Ordinal);
		}

		// Names
		for (unsigned int i=0;i<vOldIidCurr.size();i++)
		{
			if (vOldIidCurr[i].impdesc.OriginalFirstThunk)
			{
				for (unsigned int j=0;j<vOldIidCurr[i].originalfirstthunk.size();j++)
				{
					if (vOldIidCurr[i].originalfirstthunk[j].itd.Ordinal & PELIB_IMAGE_ORDINAL_FLAGS<bits>::IMAGE_ORDINAL_FLAG)
					{
						vOldIidCurr[i].originalfirstthunk[j].hint = 0;
						continue;
					}

					ifFile.seekg(static_cast<unsigned int>(pehHeader.rvaToOffset(vOldIidCurr[i].originalfirstthunk[j].itd.Ordinal)), std::ios_base::beg);

					ifFile.read(reinterpret_cast<char*>(&vOldIidCurr[i].originalfirstthunk[j].hint), sizeof(vOldIidCurr[i].originalfirstthunk[j].hint));
					
					if (!ifFile)
						return ERROR_INVALID_FILE;

					std::string funcname = "";
					do
					{
						ifFile.read(namebuffer, 1);
						if (!ifFile || !namebuffer[0]) break; // reached end of file or 0-byte
						funcname += namebuffer;
					} while (true);
			
					vOldIidCurr[i].originalfirstthunk[j].fname = funcname;
				}
			}
			else
			{
				for (unsigned int j=0;j<vOldIidCurr[i].firstthunk.size();j++)
				{
					if (vOldIidCurr[i].firstthunk[j].itd.Ordinal & PELIB_IMAGE_ORDINAL_FLAGS<bits>::IMAGE_ORDINAL_FLAG)
					{
						continue;
					}

					ifFile.seekg(static_cast<unsigned int>(pehHeader.rvaToOffset(vOldIidCurr[i].firstthunk[j].itd.Ordinal)), std::ios_base::beg);

					ifFile.read(reinterpret_cast<char*>(&vOldIidCurr[i].firstthunk[j].hint), sizeof(vOldIidCurr[i].firstthunk[j].hint));
					
					if (!ifFile)
						return ERROR_INVALID_FILE;

					std::string funcname = "";
					do
					{
						ifFile.read(namebuffer, 1);
						if (!ifFile || !namebuffer[0]) break; // reached end of file or 0-byte
						funcname += namebuffer;
					} while (true);
			
					vOldIidCurr[i].firstthunk[j].fname = funcname;
				}
			}
		}
		std::swap(vOldIidCurr, m_vOldiid);
		return NO_ERROR;
	}

	/**
	* Rebuilds the import directory.
	* @param vBuffer Buffer the rebuilt import directory will be written to.
	* @param dwRva The RVA of the ImportDirectory in the file.
	* \todo uiSizeoffuncnames is not used.
	**/
	template<int bits>
	void ImportDirectory<bits>::rebuild(std::vector<byte>& vBuffer, dword dwRva, bool fixEntries) const
	{
		unsigned int uiImprva = dwRva;
		unsigned int uiSizeofdescriptors = (static_cast<unsigned int>(m_vNewiid.size() + m_vOldiid.size()) + 1) * PELIB_IMAGE_IMPORT_DESCRIPTOR::size();
		
		unsigned int uiSizeofdllnames = 0, uiSizeoffuncnames = 0;
		unsigned int uiSizeofoft = 0;

		for (unsigned int i=0;i<m_vNewiid.size();i++)
		{
			uiSizeofdllnames += static_cast<unsigned int>(m_vNewiid[i].name.size()) + 1;
			uiSizeofoft += (static_cast<unsigned int>(m_vNewiid[i].originalfirstthunk.size())+1) * PELIB_IMAGE_THUNK_DATA<bits>::size();

			for(unsigned int j=0;j<m_vNewiid[i].originalfirstthunk.size();j++)
			{
				// +3 for hint (word) and 00-byte
				uiSizeoffuncnames += (static_cast<unsigned int>(m_vNewiid[i].originalfirstthunk[j].fname.size()) + 3);
			}
		}

//		for (unsigned int i=0;i<m_vNewiid.size();i++)
//		{
//			uiSizeofoft += (static_cast<unsigned int>(m_vNewiid[i].originalfirstthunk.size())+1) * PELIB_IMAGE_THUNK_DATA<bits>::size();
//		}
		
		OutputBuffer obBuffer(vBuffer);

		// Rebuild IMAGE_IMPORT_DESCRIPTORS
		for (unsigned int i=0;i<m_vOldiid.size();i++)
		{
			obBuffer << m_vOldiid[i].impdesc.OriginalFirstThunk;
			obBuffer << m_vOldiid[i].impdesc.TimeDateStamp;
			obBuffer << m_vOldiid[i].impdesc.ForwarderChain;
			obBuffer << m_vOldiid[i].impdesc.Name;
			obBuffer << m_vOldiid[i].impdesc.FirstThunk;
		}

		unsigned int dllsize = 0;

		for (unsigned int i=0;i<m_vNewiid.size();i++)
		{
			dword dwPoft = uiSizeofdescriptors + uiImprva;

			for (unsigned int j=1;j<=i;j++)
			{
				dwPoft += (static_cast<unsigned int>(m_vNewiid[j-1].originalfirstthunk.size()) + 1) * PELIB_IMAGE_THUNK_DATA<bits>::size();
			}

			obBuffer << (fixEntries ? dwPoft : m_vNewiid[i].impdesc.OriginalFirstThunk);
			obBuffer << m_vNewiid[i].impdesc.TimeDateStamp;
			obBuffer << m_vNewiid[i].impdesc.ForwarderChain;
			dword dwPdll = uiSizeofdescriptors + uiSizeofoft + uiImprva + dllsize;
			obBuffer << (fixEntries ? dwPdll : m_vNewiid[i].impdesc.Name);
			obBuffer << (fixEntries ? dwPoft : m_vNewiid[i].impdesc.FirstThunk);

			dllsize += static_cast<unsigned int>(m_vNewiid[i].name.size()) + 1;
		}

		obBuffer << (dword)0;
		obBuffer << (dword)0;
		obBuffer << (dword)0;
		obBuffer << (dword)0;
		obBuffer << (dword)0;

		unsigned int uiPfunc = uiSizeofdescriptors + uiSizeofoft + uiSizeofdllnames + uiImprva;

		// Rebuild original first thunk
		for (unsigned int i=0;i<m_vNewiid.size();i++)
		{
			for (unsigned int j=0;j<m_vNewiid[i].originalfirstthunk.size();j++)
			{
				if (m_vNewiid[i].originalfirstthunk[j].itd.Ordinal & PELIB_IMAGE_ORDINAL_FLAGS<bits>::IMAGE_ORDINAL_FLAG
					|| fixEntries == false)
				{
					obBuffer << m_vNewiid[i].originalfirstthunk[j].itd.Ordinal;
				}
				else
				{
					obBuffer << uiPfunc;
				}
				uiPfunc += static_cast<unsigned int>(m_vNewiid[i].originalfirstthunk[j].fname.size()) + 3;
			}
			obBuffer << (dword)0;
		}

		// Write dllnames into import directory
		for (unsigned int i=0;i<m_vNewiid.size();i++)
		{
			obBuffer.add(m_vNewiid[i].name.c_str(), static_cast<unsigned int>(m_vNewiid[i].name.size())+1);
		}

		// Write function names into directory
		for (unsigned int i=0;i<m_vNewiid.size();i++)
		{
			for (unsigned int j=0;j<m_vNewiid[i].originalfirstthunk.size();j++)
			{
				obBuffer << m_vNewiid[i].originalfirstthunk[j].hint;
				obBuffer.add(m_vNewiid[i].originalfirstthunk[j].fname.c_str(), static_cast<unsigned int>(m_vNewiid[i].originalfirstthunk[j].fname.size()) + 1);
			}
		}
	}

	/**
	* Removes a specific file and all functions of it from the import directory.
	* @param strFilename Name of the file which will be removed.
	**/
	template<int bits>
	int ImportDirectory<bits>::removeFile(const std::string& strFilename)
	{
		unsigned int oldSize = static_cast<unsigned int>(m_vNewiid.size());

		m_vNewiid.erase(std::remove_if(m_vNewiid.begin(), m_vNewiid.end(), std::bind2nd(std::mem_fun_ref(&PELIB_IMAGE_IMPORT_DIRECTORY<bits>::operator==), strFilename)), m_vNewiid.end());
		
		return oldSize == m_vNewiid.size() ? 1 : 0;
	}

	/**
	* Removes a specific function from the import directory.
	* @param strFilename Name of the file which exports the function.
	* @param strFuncname Name of the imported function.
	**/
	template<int bits>
	int ImportDirectory<bits>::removeFunction(const std::string& strFilename, const std::string& strFuncname)
	{
		ImpDirFileIterator viPos = m_vNewiid.begin();

		int notFound = 1;

		while (viPos != m_vNewiid.end())
		{
			if (isEqualNc(viPos->name, strFilename))
			{
				unsigned int oldSize = static_cast<unsigned int>(viPos->originalfirstthunk.size());
				viPos->originalfirstthunk.erase(std::remove_if(viPos->originalfirstthunk.begin(), viPos->originalfirstthunk.end(), std::bind2nd(std::mem_fun_ref(&PELIB_THUNK_DATA<bits>::equalFunctionName), strFuncname)), viPos->originalfirstthunk.end());
				//viPos->originalfirstthunk.erase(std::remove_if(viPos->originalfirstthunk.begin(), viPos->originalfirstthunk.end(), std::bind2nd(CompPolicy<PELIB_THUNK_DATA, std::string>(), strFuncname)));
				if (viPos->originalfirstthunk.size() != oldSize) notFound = 0;
			}
			++viPos;
		}
		
		return notFound;
	}

	/**
	* Removes a specific function from the import directory.
	* @param strFilename Name of the file which exports the function.
	* @param wHint The hint of the function.
	**/
	template<int bits>
	int ImportDirectory<bits>::removeFunction(const std::string& strFilename, word wHint)
	{
		ImpDirFileIterator viPos = m_vNewiid.begin();
		int notFound = 1;

		while (viPos != m_vNewiid.end())
		{
			if (isEqualNc(viPos->name, strFilename))
			{
				unsigned int oldSize = static_cast<unsigned int>(viPos->originalfirstthunk.size());
				viPos->originalfirstthunk.erase(std::remove_if(viPos->originalfirstthunk.begin(), viPos->originalfirstthunk.end(), std::bind2nd(std::mem_fun_ref(&PELIB_THUNK_DATA<bits>::equalHint), wHint)), viPos->originalfirstthunk.end());
				unsigned int newPos = static_cast<unsigned int>(viPos->originalfirstthunk.size());
				if (viPos->originalfirstthunk.size() != oldSize) notFound = 0;
			}
			++viPos;
		}
		
		return notFound;
	}

	/**
	* Writes the current import directory to a file.
	* @param strFilename Name of the file.
	* @param uiOffset File Offset of the new import directory.
	* @param uiRva RVA which belongs to that file offset.
	**/
	template<int bits>
	int ImportDirectory<bits>::write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva)
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}
		
		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios_base::beg);

		std::vector<byte> vBuffer;

		rebuild(vBuffer, uiRva);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), vBuffer.size());
		ofFile.close();

		std::copy(m_vNewiid.begin(), m_vNewiid.end(), std::back_inserter(m_vOldiid));
		m_vNewiid.clear();
		
		return NO_ERROR;
	}

	/**
	* Returns the size of the import directory.
	* @return Size of the import directory.
	**/
	template<int bits>
	unsigned int ImportDirectory<bits>::size() const
	{
		// Only the descriptors of m_vOldiid must be rebuilt, not the data they point to.
		return std::accumulate(m_vNewiid.begin(), m_vNewiid.end(), 0, accumulate<PELIB_IMAGE_IMPORT_DIRECTORY<bits> >)
		+ (m_vOldiid.size() + 1) * PELIB_IMAGE_IMPORT_DESCRIPTOR::size();
	}

	/**
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return FirstThunk value of an imported file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getFirstThunk(const std::string& strFilename, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[getFileIndex(strFilename, cdDir)].impdesc.FirstThunk;
		}
		else
		{
			return m_vNewiid[getFileIndex(strFilename, cdDir)].impdesc.FirstThunk;
		}
	}

	/**
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return OriginalFirstThunk value of an imported file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getOriginalFirstThunk(const std::string& strFilename, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[getFileIndex(strFilename, cdDir)].impdesc.OriginalFirstThunk;
		}
		else
		{
			return m_vNewiid[getFileIndex(strFilename, cdDir)].impdesc.OriginalFirstThunk;
		}
	}

	/**
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return ForwarderChain value of an imported file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getForwarderChain(const std::string& strFilename, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[getFileIndex(strFilename, cdDir)].impdesc.ForwarderChain;
		}
		else
		{
			return m_vNewiid[getFileIndex(strFilename, cdDir)].impdesc.ForwarderChain;
		}
	}

	/**
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return TimeDateStamp value of an imported file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getTimeDateStamp(const std::string& strFilename, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[getFileIndex(strFilename, cdDir)].impdesc.TimeDateStamp;
		}
		else
		{
			return m_vNewiid[getFileIndex(strFilename, cdDir)].impdesc.TimeDateStamp;
		}
	}

	template<int bits>
	dword ImportDirectory<bits>::getRvaOfName(const std::string& strFilename, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[getFileIndex(strFilename, cdDir)].impdesc.Name;
		}
		else
		{
			return m_vNewiid[getFileIndex(strFilename, cdDir)].impdesc.Name;
		}
	}

	/**
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return FirstThunk value of an imported file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getFirstThunk(dword dwFilenr, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[dwFilenr].impdesc.FirstThunk;
		}
		else
		{
			return m_vNewiid[dwFilenr].impdesc.FirstThunk;
		}
	}

	template<int bits>
	void ImportDirectory<bits>::setFirstThunk(dword dwFilenr, currdir cdDir, dword value)
	{
		if (cdDir == OLDDIR)
		{
			m_vOldiid[dwFilenr].impdesc.FirstThunk = value;
		}
		else
		{
			m_vNewiid[dwFilenr].impdesc.FirstThunk = value;
		}
	}

	/**
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return OriginalFirstThunk value of an imported file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getOriginalFirstThunk(dword dwFilenr, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[dwFilenr].impdesc.OriginalFirstThunk;
		}
		else
		{
			return m_vNewiid[dwFilenr].impdesc.OriginalFirstThunk;
		}
	}

	template<int bits>
	void ImportDirectory<bits>::setOriginalFirstThunk(dword dwFilenr, currdir cdDir, dword value)
	{
		if (cdDir == OLDDIR)
		{
			m_vOldiid[dwFilenr].impdesc.OriginalFirstThunk = value;
		}
		else
		{
			m_vNewiid[dwFilenr].impdesc.OriginalFirstThunk = value;
		}
	}

	/**
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return ForwarderChain value of an imported file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getForwarderChain(dword dwFilenr, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[dwFilenr].impdesc.ForwarderChain;
		}
		else
		{
			return m_vNewiid[dwFilenr].impdesc.ForwarderChain;
		}
	}

	template<int bits>
	void ImportDirectory<bits>::setForwarderChain(dword dwFilenr, currdir cdDir, dword value)
	{
		if (cdDir == OLDDIR)
		{
			m_vOldiid[dwFilenr].impdesc.ForwarderChain = value;
		}
		else
		{
			m_vNewiid[dwFilenr].impdesc.ForwarderChain = value;
		}
	}

	/**
	* @param strFilename Name of the imported file.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return TimeDateStamp value of an imported file.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getTimeDateStamp(dword dwFilenr, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[dwFilenr].impdesc.TimeDateStamp;
		}
		else
		{
			return m_vNewiid[dwFilenr].impdesc.TimeDateStamp;
		}
	}

	template<int bits>
	void ImportDirectory<bits>::setTimeDateStamp(dword dwFilenr, currdir cdDir, dword value)
	{
		if (cdDir == OLDDIR)
		{
			m_vOldiid[dwFilenr].impdesc.TimeDateStamp = value;
		}
		else
		{
			m_vNewiid[dwFilenr].impdesc.TimeDateStamp = value;
		}
	}

	template<int bits>
	dword ImportDirectory<bits>::getRvaOfName(dword dwFilenr, currdir cdDir) const
	{
		if (cdDir == OLDDIR)
		{
			return m_vOldiid[dwFilenr].impdesc.Name;
		}
		else
		{
			return m_vNewiid[dwFilenr].impdesc.Name;
		}
	}

	template<int bits>
	void ImportDirectory<bits>::setRvaOfName(dword dwFilenr, currdir cdDir, dword value)
	{
		if (cdDir == OLDDIR)
		{
			m_vOldiid[dwFilenr].impdesc.Name = value;
		}
		else
		{
			m_vNewiid[dwFilenr].impdesc.Name = value;
		}
	}

	/**
	* @param dwFilenr ID of the imported file.
	* @param dwFuncnr ID of the imported function.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return FirstThunk value of an imported function.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getFirstThunk(dword dwFilenr, dword dwFuncnr, currdir cdDir) const
	{
		if (cdDir == OLDDIR) return m_vOldiid[dwFilenr].firstthunk[dwFuncnr].itd.Ordinal;
		else return m_vNewiid[dwFilenr].firstthunk[dwFuncnr].itd.Ordinal;
	}
	
	template<int bits>
	void ImportDirectory<bits>::setFirstThunk(dword dwFilenr, dword dwFuncnr, currdir cdDir, dword value)
	{
		if (cdDir == OLDDIR) m_vOldiid[dwFilenr].firstthunk[dwFuncnr].itd.Ordinal = value;
		else m_vNewiid[dwFilenr].firstthunk[dwFuncnr].itd.Ordinal = value;
	}
	
	/**
	* @param dwFilenr ID of the imported file.
	* @param dwFuncnr ID of the imported function.
	* @param cdDir Flag to decide if the OLDDIR or new import directory is used.
	* @return OriginalFirstThunk value of an imported function.
	**/
	template<int bits>
	dword ImportDirectory<bits>::getOriginalFirstThunk(dword dwFilenr, dword dwFuncnr, currdir cdDir) const
	{
		if (cdDir == OLDDIR) return m_vOldiid[dwFilenr].originalfirstthunk[dwFuncnr].itd.Ordinal;
		else return m_vNewiid[dwFilenr].originalfirstthunk[dwFuncnr].itd.Ordinal;
	}

	template<int bits>
	void ImportDirectory<bits>::setOriginalFirstThunk(dword dwFilenr, dword dwFuncnr, currdir cdDir, dword value)
	{
		if (cdDir == OLDDIR) m_vOldiid[dwFilenr].originalfirstthunk[dwFuncnr].itd.Ordinal = value;
		else m_vNewiid[dwFilenr].originalfirstthunk[dwFuncnr].itd.Ordinal = value;
	}

	typedef ImportDirectory<32> ImportDirectory32;
	typedef ImportDirectory<64> ImportDirectory64;
}

#endif

```

`deps/PeLib/MzHeader.cpp`:

```cpp
/*
* MzHeader.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "MzHeader.h"
#include <iostream>

namespace PeLib
{
	/**
	* Reads data from an InputBuffer into the struct that represents the MZ header.
	* It's required that the size of the input buffer is at least as big as the
	* size of a MZ header. Otherwise we get undefined behaviour.
	* @param ibBuffer InputBuffer that holds the data.
	* @return A non-zero value is returned if a problem occured.
	**/
	void MzHeader::read(InputBuffer& ibBuffer)
	{
		ibBuffer >> m_idhHeader.e_magic;
		ibBuffer >> m_idhHeader.e_cblp;
		ibBuffer >> m_idhHeader.e_cp;
		ibBuffer >> m_idhHeader.e_crlc;
		ibBuffer >> m_idhHeader.e_cparhdr;
		ibBuffer >> m_idhHeader.e_minalloc;
		ibBuffer >> m_idhHeader.e_maxalloc;
		ibBuffer >> m_idhHeader.e_ss;
		ibBuffer >> m_idhHeader.e_sp;
		ibBuffer >> m_idhHeader.e_csum;
		ibBuffer >> m_idhHeader.e_ip;
		ibBuffer >> m_idhHeader.e_cs;
		ibBuffer >> m_idhHeader.e_lfarlc;
		ibBuffer >> m_idhHeader.e_ovno;

		for (unsigned int i=0;i<sizeof(m_idhHeader.e_res)/sizeof(m_idhHeader.e_res[0]);i++)
		{
			ibBuffer >> m_idhHeader.e_res[i];
		}

		ibBuffer >> m_idhHeader.e_oemid;
		ibBuffer >> m_idhHeader.e_oeminfo;

		for (unsigned int i=0;i<sizeof(m_idhHeader.e_res2)/sizeof(m_idhHeader.e_res2[0]);i++)
		{
			ibBuffer >> m_idhHeader.e_res2[i];
		}

		ibBuffer >> m_idhHeader.e_lfanew;
	}
	
	/**
	* Tests if the currently loaded MZ header is a valid MZ header. 
	* Note that this function does not check if the address to the PE header is valid as this is not possible.
	* Actually, the only thing this function checks is if the e_magic value is set to 0x5A4D (IMAGE_DOS_SIGNATURE).
	* Everything else is not relevant for Windows 2000 and that's the system PeLib is focusing on for now.
	* @return A boolean value that indicates if the MZ header is correct or not.
	**/
	bool MzHeader::isValid() const
	{
		// The only thing that matters on Windows 2K is the e_magic value. The entire rest is for DOS compatibility.
		return isValid(e_magic);
	}

    bool MzHeader::isValid(Field f) const
    {
        if (f == e_magic)
        {
            return m_idhHeader.e_magic == PELIB_IMAGE_DOS_SIGNATURE;
        }
        else
        {
            return true;
        }
    }

	/**
	* Corrects all erroneous values of the current MZ header. Note that this function does not correct the
	* pointer to the PE header.	
	* Actually, the only thing this function corrects is the e_magic value.
	* Everything else is not relevant for Windows 2000 and that's the system PeLib is focusing on for now.
	**/
	void MzHeader::makeValid()
	{
		// The only thing that matters on Windows is the e_magic value. The entire rest is for DOS compatibility.
		setMagicNumber(PELIB_IMAGE_DOS_SIGNATURE);
	}

    void MzHeader::makeValid(Field f)
    {
        if (f == e_magic)
        {
            setMagicNumber(PELIB_IMAGE_DOS_SIGNATURE);
        }
    }

	/**
	* Reads the MZ header from a file. Note that this function does not verify if a file is actually a MZ file.
	* For this purpose see #PeFile::MzHeader::isValid. The reason for this is simple: Otherwise it might not
	* be possible to load damaged PE files to repair them.
	* @param strFilename Name of the file which will be read.
	* @return A non-zero value is returned if a problem occured.
	**/
	int MzHeader::read(const std::string& strFilename)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);

		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}

		if (fileSize(ifFile) < PELIB_IMAGE_DOS_HEADER::size())
		{
			return ERROR_INVALID_FILE;
		}

		ifFile.seekg(0, std::ios::beg);

		originalOffset = 0;
		
		std::vector<byte> vBuffer(PELIB_IMAGE_DOS_HEADER::size());
		ifFile.read(reinterpret_cast<char*>(&vBuffer[0]), static_cast<unsigned int>(vBuffer.size()));
		ifFile.close();

		InputBuffer ibBuffer(vBuffer);
		read(ibBuffer);
		return NO_ERROR;
	}

	/**
	* Reads the MZ header from memory. A pointer to a location in memory is passed and the data
	* at this location is treated like a MZ header structure. The MZ header does not need to be valid.
	* @param pcBuffer Pointer to a MZ header.
	* @param uiSize Length of the buffer.
	* @return A non-zero value is returned if a problem occured.
	**/
	int MzHeader::read(unsigned char* pcBuffer, unsigned int uiSize, unsigned int originalOffs)
	{
		if (uiSize < PELIB_IMAGE_DOS_HEADER::size())
		{
			return ERROR_INVALID_FILE;
		}
		
		std::vector<byte> vBuffer(pcBuffer, pcBuffer + uiSize);
		for (int i=0;i<0x40;i++) std::cout << std::hex << (int)vBuffer[i] << " ";

		originalOffset = originalOffs;
		
		InputBuffer ibBuffer(vBuffer);
		read(ibBuffer);
		return NO_ERROR;
	}

	/**
	* Rebuilds the MZ header so that it can be written to a file. It's not guaranteed that the
	* MZ header will be valid. If you want to make sure that the MZ header will be valid you
	* must call #PeLib::MzHeader::makeValid first.
	* @param vBuffer Buffer where the rebuilt MZ header will be stored.
	**/
	void MzHeader::rebuild(std::vector<byte>& vBuffer) const
	{
		OutputBuffer obBuffer(vBuffer);

		obBuffer << m_idhHeader.e_magic;
		obBuffer << m_idhHeader.e_cblp;
		obBuffer << m_idhHeader.e_cp;
		obBuffer << m_idhHeader.e_crlc;
		obBuffer << m_idhHeader.e_cparhdr;
		obBuffer << m_idhHeader.e_minalloc;
		obBuffer << m_idhHeader.e_maxalloc;
		obBuffer << m_idhHeader.e_ss;
		obBuffer << m_idhHeader.e_sp;
		obBuffer << m_idhHeader.e_csum;
		obBuffer << m_idhHeader.e_ip;
		obBuffer << m_idhHeader.e_cs;
		obBuffer << m_idhHeader.e_lfarlc;
		obBuffer << m_idhHeader.e_ovno;

		for (unsigned int i=0;i<sizeof(m_idhHeader.e_res)/sizeof(m_idhHeader.e_res[0]);i++)
		{
			obBuffer << m_idhHeader.e_res[i];
		}

		obBuffer << m_idhHeader.e_oemid;
		obBuffer << m_idhHeader.e_oeminfo;

		for (unsigned int i=0;i<sizeof(m_idhHeader.e_res2)/sizeof(m_idhHeader.e_res2[0]);i++)
		{
			obBuffer << m_idhHeader.e_res2[i];
		}

		obBuffer << m_idhHeader.e_lfanew;
	}

	/**
	* Returns the size of the MZ header. This size is actually always sizeof(IMAGE_DOS_HEADER) (== 0x40)
	* because the MZ header is a header of constant size if you disregard the dos stub. If you want to know the
	* size of the MZ header + the size of the dos stub check #PeLib::MzHeader::getAddressOfPeHeader.
	* @return Size of the MZ header.
	**/
	unsigned int MzHeader::size() const
	{
		return sizeof(m_idhHeader);
	}

	/**
	* Writes the current MZ header to a file. The file does not have to exist. If it doesn't exist
	* it will be created.
	* @param strFilename Name of the file the header will be written to.
	* @param dwOffset Offset the header will be written to (defaults to 0).
	* @return A non-zero value is returned if a problem occured.
	**/
	int MzHeader::write(const std::string& strFilename, dword dwOffset = 0) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}
		
		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(dwOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;

		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();
		
		return NO_ERROR;
	}

	/**
	* Returns the MZ header's e_magic value.
	**/
	word MzHeader::getMagicNumber() const
	{
		return m_idhHeader.e_magic;
	}

	/**
	* Returns the MZ header's e_cblp value.
	**/
	word MzHeader::getBytesOnLastPage() const
	{
		return m_idhHeader.e_cblp;
	}

	/**
	* Returns the MZ header's e_cp value.
	**/
	word MzHeader::getPagesInFile() const
	{
		return m_idhHeader.e_cp;
	}

	/**
	* Returns the MZ header's e_crlc value.
	**/
	word MzHeader::getRelocations() const
	{
		return m_idhHeader.e_crlc;
	}

	/**
	* Returns the MZ header's e_cparhdr value.
	**/
	word MzHeader::getSizeOfHeader() const
	{
		return m_idhHeader.e_cparhdr;
	}

	/**
	* Returns the MZ header's e_minalloc value.
	**/
	word MzHeader::getMinExtraParagraphs() const
	{
		return m_idhHeader.e_minalloc;
	}

	/**
	* Returns the MZ header's e_maxalloc value.
	**/
	word MzHeader::getMaxExtraParagraphs() const
	{
		return m_idhHeader.e_maxalloc;
	}

	/**
	* Returns the MZ header's e_ss value.
	**/
	word MzHeader::getSsValue() const
	{
		return m_idhHeader.e_ss;
	}

	/**
	* Returns the MZ header's e_sp value.
	**/
	word MzHeader::getSpValue() const
	{
		return m_idhHeader.e_sp;
	}

	/**
	* Returns the MZ header's e_csum value.
	**/
	word MzHeader::getChecksum() const
	{
		return m_idhHeader.e_csum;
	}

	/**
	* Returns the MZ header's e_ip value.
	**/
	word MzHeader::getIpValue() const
	{
		return m_idhHeader.e_ip;
	}

	/**
	* Returns the MZ header's e_cs value.
	**/
	word MzHeader::getCsValue() const
	{
		return m_idhHeader.e_cs;
	}

	/**
	* Returns the MZ header's e_lfarlc value.
	**/
	word MzHeader::getAddrOfRelocationTable() const
	{
		return m_idhHeader.e_lfarlc;
	}

	/**
	* Returns the MZ header's e_ovno value.
	**/
	word MzHeader::getOverlayNumber() const
	{
		return m_idhHeader.e_ovno;
	}

	/**
	* Returns the MZ header's e_oemid value.
	**/
	word MzHeader::getOemIdentifier() const
	{
		return m_idhHeader.e_oemid;
	}

	/**
	* Returns the MZ header's e_oeminfo value.
	**/
	word MzHeader::getOemInformation() const
	{
		return m_idhHeader.e_oeminfo;
	}

	/**
	* Returns the MZ header's e_lfanew value.
	**/
	dword MzHeader::getAddressOfPeHeader() const
	{
		return m_idhHeader.e_lfanew;
	}

	/**
	* Returns the MZ header's e_res[uiNr] value. If the parameter uiNr is out of range 
	* you will get undefined behaviour.
	* @param uiNr The index of the word in the e_res array (valid range: 0-3)
	**/
	word MzHeader::getReservedWords1(unsigned int uiNr) const
	{
		return m_idhHeader.e_res[uiNr];
	}

	/**
	* Returns the MZ header's e_res2[uiNr] value. If the parameter uiNr is out of range 
	* you will get undefined behaviour.
	* @param uiNr The index of the word in the e_res array (valid range: 0-9)
	**/
	word MzHeader::getReservedWords2(unsigned int uiNr) const
	{
		return m_idhHeader.e_res2[uiNr];
	}
	
	/**
	* Sets the MZ header's e_magic value.
	* @param wValue The new value of e_magic.
	**/
	void MzHeader::setMagicNumber(word wValue)
	{
		m_idhHeader.e_magic = wValue;
	}

	/**
	* Sets the MZ header's e_cblp value.
	* @param wValue The new value of e_cblp.
	**/
	void MzHeader::setBytesOnLastPage(word wValue)
	{
		m_idhHeader.e_cblp = wValue;
	}

	/**
	* Sets the MZ header's e_cp value.
	* @param wValue The new value of e_cp.
	**/
	void MzHeader::setPagesInFile(word wValue)
	{
		m_idhHeader.e_cp = wValue;
	}

	/**
	* Sets the MZ header's e_crlc value.
	* @param wValue The new value of e_crlc.
	**/  
	void MzHeader::setRelocations(word wValue)
	{
		m_idhHeader.e_crlc = wValue;
	}

	/**
	* Sets the MZ header's e_cparhdr value.
	* @param wValue The new value of e_cparhdr.
	**/  
	void MzHeader::setSizeOfHeader(word wValue)
	{
		m_idhHeader.e_cparhdr = wValue;
	}

	/**
	* Sets the MZ header's e_minalloc value.
	* @param wValue The new value of e_minalloc.
	**/  
	void MzHeader::setMinExtraParagraphs(word wValue)
	{
		m_idhHeader.e_minalloc = wValue;
	}

	/**
	* Sets the MZ header's e_maxalloc value.
	* @param wValue The new value of e_maxalloc.
	**/  
	void MzHeader::setMaxExtraParagraphs(word wValue)
	{
		m_idhHeader.e_maxalloc = wValue;
	}

	/**
	* Sets the MZ header's e_ss value.
	* @param wValue The new value of e_ss.
	**/  
	void MzHeader::setSsValue(word wValue)
	{
		m_idhHeader.e_ss = wValue;
	}

	/**
	* Sets the MZ header's e_sp value.
	* @param wValue The new value of e_sp.
	**/  
	void MzHeader::setSpValue(word wValue)
	{
		m_idhHeader.e_sp = wValue;
	}

	/**
	* Sets the MZ header's e_csum value.
	* @param wValue The new value of e_csum.
	**/  
	void MzHeader::setChecksum(word wValue)
	{
		m_idhHeader.e_csum = wValue;
	}

	/**
	* Sets the MZ header's e_ip value.
	* @param wValue The new value of e_ip.
	**/  
	void MzHeader::setIpValue(word wValue)
	{
		m_idhHeader.e_ip = wValue;
	}

	/**
	* Sets the MZ header's e_cs value.
	* @param wValue The new value of e_cs.
	**/  
	void MzHeader::setCsValue(word wValue)
	{
		m_idhHeader.e_cs = wValue;
	}

	/**
	* Sets the MZ header's e_lfarlc value.
	* @param wValue The new value of e_lfarlc.
	**/  
	void MzHeader::setAddrOfRelocationTable(word wValue)
	{
		m_idhHeader.e_lfarlc = wValue;
	}

	/**
	* Sets the MZ header's e_ovno value.
	* @param wValue The new value of e_ovno.
	**/  
	void MzHeader::setOverlayNumber(word wValue)
	{
		m_idhHeader.e_ovno = wValue;
	}

	/**
	* Sets the MZ header's e_oemid value.
	* @param wValue The new value of e_oemid.
	**/  
	void MzHeader::setOemIdentifier(word wValue)
	{
		m_idhHeader.e_oemid = wValue;
	}

	/**
	* Sets the MZ header's e_oeminfo value.
	* @param wValue The new value of e_oeminfo.
	**/  
	void MzHeader::setOemInformation(word wValue)
	{
		m_idhHeader.e_oeminfo = wValue;
	}

	/**
	* Sets the MZ header's e_lfanew value.
	* @param lValue The new value of e_lfanew.
	**/  
	void MzHeader::setAddressOfPeHeader(dword lValue)
	{
		m_idhHeader.e_lfanew = lValue;
	}
	
	/**
	* Sets the MZ header's e_res[uiNr] value. If the parameter uiNr is out of range 
	* you will get undefined behaviour.
	* @param uiNr The index of the word in the e_res array (valid range: 0-3)
	* @param wValue The new value of e_res[nr].
	**/
	void MzHeader::setReservedWords1(unsigned int uiNr, word wValue)
	{
		m_idhHeader.e_res[uiNr] = wValue;
	}

	/**
	* Sets the MZ header's e_res2[uiNr] value. If the parameter uiNr is out of range 
	* you will get undefined behaviour.
	* @param uiNr The index of the word in the e_res2 array (valid range: 0-9)
	* @param wValue The new value of e_res[nr].
	**/
	void MzHeader::setReservedWords2(unsigned int uiNr, word wValue)
	{
		m_idhHeader.e_res2[uiNr] = wValue;
	}

}

```

`deps/PeLib/MzHeader.h`:

```h
/*
* MzHeader.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef MZHEADER_H
#define MZHEADER_H

#include "PeLibInc.h"

namespace PeLib
{
	/// Class that handles the MZ header of files.
	/**
	* This class can read and modify MZ headers. It provides set- and get functions to access
	* all individual members of a MZ header. Furthermore it's possible to validate and rebuild
	* MZ headers.
	**/
	class MzHeader
	{
		private:
		  PELIB_IMAGE_DOS_HEADER m_idhHeader; ///< Stores all MZ header information.
		  
		  /// Reads data from an InputBuffer into a MZ header struct.
		  void read(InputBuffer& ibBuffer);
		  
		  /// Offset of the MZ header in the original file.
		  unsigned int originalOffset;
		  
		public:

          enum Field {e_magic, e_cblp, e_cp, e_crlc, e_cparhdr, e_minalloc, e_maxalloc,
                        e_ss, e_sp, e_csum, e_ip, e_cs, e_lfarlc, e_ovno, e_res, e_oemid,
                        e_oeminfo, e_res2, e_lfanew};

		  /// Checks if the current MZ header is valid.
		  bool isValid() const; // EXPORT
          
		  bool isValid(Field field) const; // EXPORT _field

		  /// Corrects the current MZ header.
		  void makeValid(); // EXPORT

		  void makeValid(Field field); // EXPORT _field

		  /// Reads the MZ header of a file.
		  int read(const std::string& strFilename); // EXPORT

		  /// Reads the MZ header from a memory location.
		  int read(unsigned char* pcBuffer, unsigned int uiSize, unsigned int originalOffs = 0); // EXPORT _fromMemory

		  /// Rebuild the MZ header.
		  void rebuild(std::vector<byte>& vBuffer) const; // EXPORT

		  /// Returns the size of the current MZ header.
		  unsigned int size() const; // EXPORT

		  /// Writes the current MZ header to offset 0 of a file.
		  int write(const std::string& strFilename, dword dwOffset) const; // EXPORT

		  /// Gets the e_magic value of the MZ header.
		  word getMagicNumber() const; // EXPORT
		  /// Gets the e_cblp value of the MZ header.
		  word getBytesOnLastPage() const; // EXPORT
		  /// Gets the e_cp value of the MZ header.
		  word getPagesInFile() const; // EXPORT
		  /// Gets the e_crlc value of the MZ header.
		  word getRelocations() const; // EXPORT
		  /// Gets the e_cparhdr value of the MZ header.
		  word getSizeOfHeader() const; // EXPORT
		  /// Gets the e_minalloc value of the MZ header.
		  word getMinExtraParagraphs() const; // EXPORT
		  /// Gets the e_maxalloc value of the MZ header.
		  word getMaxExtraParagraphs() const; // EXPORT
		  /// Gets the e_ss value of the MZ header.
		  word getSsValue() const; // EXPORT
		  /// Gets the e_sp value of the MZ header.
		  word getSpValue() const; // EXPORT
		  /// Gets the e_csum value of the MZ header.
		  word getChecksum() const; // EXPORT
		  /// Gets the e_ip value of the MZ header.
		  word getIpValue() const; // EXPORT
		  /// Gets the e_cs value of the MZ header.
		  word getCsValue() const; // EXPORT
		  /// Gets the e_lfarlc value of the MZ header.
		  word getAddrOfRelocationTable() const; // EXPORT
		  /// Gets the e_ovnovalue of the MZ header.
		  word getOverlayNumber() const; // EXPORT
		  /// Gets the e_oemid value of the MZ header.
		  word getOemIdentifier() const; // EXPORT
		  /// Gets the e_oeminfo value of the MZ header.
		  word getOemInformation() const; // EXPORT
		  /// Gets the e_lfanew value of the MZ header.
		  dword getAddressOfPeHeader() const; // EXPORT
		  /// Gets the e_res of the MZ header.
		  word getReservedWords1(unsigned int uiNr) const; // EXPORT
		  /// Gets the e_res2 of the MZ header.
		  word getReservedWords2(unsigned int uiNr) const; // EXPORT
	
		  /// Sets the e_magic value of the MZ header.
		  void setMagicNumber(word wValue); // EXPORT
		  /// Sets the e_cblp value of the MZ header.
		  void setBytesOnLastPage(word wValue); // EXPORT
		  /// Sets the e_cp value of the MZ header.
		  void setPagesInFile(word wValue); // EXPORT
		  /// Sets the e_crlc value of the MZ header.
		  void setRelocations(word wValue); // EXPORT
		  /// Sets the e_cparhdr value of the MZ header.
		  void setSizeOfHeader(word wValue); // EXPORT
		  /// Sets the e_minalloc value of the MZ header.
		  void setMinExtraParagraphs(word wValue); // EXPORT
		  /// Sets the e_maxalloc value of the MZ header.
		  void setMaxExtraParagraphs(word wValue); // EXPORT
		  /// Sets the e_ss value of the MZ header.
		  void setSsValue(word wValue); // EXPORT
		  /// Sets the e_sp value of the MZ header.
		  void setSpValue(word wValue); // EXPORT
		  /// Sets the e_csum value of the MZ header.
		  void setChecksum(word wValue); // EXPORT
		  /// Sets the e_ip value of the MZ header.
		  void setIpValue(word wValue); // EXPORT
		  /// Sets the e_cs value of the MZ header.
		  void setCsValue(word wValue); // EXPORT
		  /// Sets the e_lfarlc value of the MZ header.
		  void setAddrOfRelocationTable(word wValue); // EXPORT
		  /// Sets the e_ovno value of the MZ header.
		  void setOverlayNumber(word wValue); // EXPORT
		  /// Sets the e_oemid value of the MZ header.
		  void setOemIdentifier(word wValue); // EXPORT
		  /// Sets the e_oeminfo value of the MZ header.
		  void setOemInformation(word wValue); // EXPORT
		  /// Sets the e_lfanew value of the MZ header.
		  void setAddressOfPeHeader(dword dwValue); // EXPORT
		  /// Sets the e_res value of the MZ header.
		  void setReservedWords1(unsigned int uiNr, word wValue); // EXPORT
		  /// Sets the e_res2 value of the MZ header.
		  void setReservedWords2(unsigned int uiNr, word wValue); // EXPORT
	};
}

#endif

```

`deps/PeLib/PeFile.cpp`:

```cpp
/*
* PeLib.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "PeFile.h"

namespace PeLib
{
	PeFile::~PeFile()
	{
	}
	
	PeFile32::PeFile32() : PeFileT<32>()
	{
	}
	
	PeFile32::PeFile32(const std::string& strFlename) : PeFileT<32>(strFlename)
	{
	}
	
	PeFile64::PeFile64() : PeFileT<64>()
	{
	}
	
	PeFile64::PeFile64(const std::string& strFlename) : PeFileT<64>(strFlename)
	{
	}
	
	/**
	* @return A reference to the file's MZ header.
	**/
	
	const MzHeader& PeFile::mzHeader() const
	{
		return m_mzh;
	}

	/**
	* @return A reference to the file's MZ header.
	**/
	
	MzHeader& PeFile::mzHeader()
	{
		return m_mzh;
	}

	/**
	* @return A reference to the file's export directory.
	**/
	
	const ExportDirectory& PeFile::expDir() const
	{
		return m_expdir;
	}

	/**
	* @return A reference to the file's export directory.
	**/
	
	ExportDirectory& PeFile::expDir()
	{
		return m_expdir;
	}
	
	/**
	* @return A reference to the file's bound import directory.
	**/
	
	const BoundImportDirectory& PeFile::boundImpDir() const
	{
		return m_boundimpdir;
	}
	
	/**
	* @return A reference to the file's bound import directory.
	**/
	
	BoundImportDirectory& PeFile::boundImpDir()
	{
		return m_boundimpdir;
	}
	
	/**
	* @return A reference to the file's resource directory.
	**/
	
	const ResourceDirectory& PeFile::resDir() const
	{
		return m_resdir;
	}
	
	/**
	* @return A reference to the file's resource directory.
	**/
	
	ResourceDirectory& PeFile::resDir()
	{
		return m_resdir;
	}
	
	/**
	* @return A reference to the file's relocations directory.
	**/
	
	const RelocationsDirectory& PeFile::relocDir() const
	{
		return m_relocs;
	}

	/**
	* @return A reference to the file's relocations directory.
	**/
	
	RelocationsDirectory& PeFile::relocDir()
	{
		return m_relocs;
	}

	/**
	* @return A reference to the file's COM+ descriptor directory.
	**/
	
	const ComHeaderDirectory& PeFile::comDir() const
	{
		return m_comdesc;
	}

	/**
	* @return A reference to the file's COM+ descriptor directory.
	**/
	
	ComHeaderDirectory & PeFile::comDir()
	{
		return m_comdesc;
	}

	
	const IatDirectory& PeFile::iatDir() const
	{
		return m_iat;
	}

	
	IatDirectory& PeFile::iatDir()
	{
		return m_iat;
	}

	
	const DebugDirectory& PeFile::debugDir() const
	{
		return m_debugdir;
	}

	
	DebugDirectory& PeFile::debugDir()
	{
		return m_debugdir;
	}

}

```

`deps/PeLib/PeFile.h`:

```h
/*
* PeFile.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef PEFILE_H
#define PEFILE_H

#include "PeLibInc.h"
#include "MzHeader.h"
#include "PeHeader.h"
#include "ImportDirectory.h"
#include "ExportDirectory.h"
#include "BoundImportDirectory.h"
#include "ResourceDirectory.h"
#include "RelocationsDirectory.h"
#include "ComHeaderDirectory.h"
#include "IatDirectory.h"
#include "DebugDirectory.h"
#include "TlsDirectory.h"

namespace PeLib
{
	class PeFile32;
	class PeFile64;
	
	/**
	* Visitor base class for PeFiles.
	**/
	class PeFileVisitor
	{
		public:
		  virtual void callback(PeFile32 &file){}
		  virtual void callback(PeFile64 &file){}
		  virtual ~PeFileVisitor(){}
	};

	/**
	* Traits class that's used to decide of what type the PeHeader in a PeFile is.
	**/
	template<int>
	struct PeFile_Traits;

	template<>
	struct PeFile_Traits<32>
	{
		typedef PeHeader32 PeHeader32_64;
	};
	
	template<>
	struct PeFile_Traits<64>
	{
		typedef PeHeader64 PeHeader32_64;
	};
	
	/**
	* This class represents the common structures of PE and PE+ files.
	**/
	class PeFile
	{
		protected:
		  std::string m_filename; ///< Name of the current file.
		  MzHeader m_mzh; ///< MZ header of the current file.
		  ExportDirectory m_expdir; ///< Export directory of the current file.
		  BoundImportDirectory m_boundimpdir; ///< BoundImportDirectory of the current file.
		  ResourceDirectory m_resdir; ///< ResourceDirectory of the current file.
		  RelocationsDirectory m_relocs; ///< Relocations directory of the current file.
		  ComHeaderDirectory m_comdesc; ///< COM+ descriptor directory of the current file.
		  IatDirectory m_iat; ///< Import address table of the current file.
		  DebugDirectory m_debugdir;
		public:
		  virtual ~PeFile();
		  
		  /// Returns the name of the current file.
		  virtual std::string getFileName() const = 0; // EXPORT
		  /// Changes the name of the current file.
		  virtual void setFileName(std::string strFilename) = 0; // EXPORT
		  
		  virtual void visit(PeFileVisitor &v) = 0;
		  
		  /// Reads the MZ header of the current file from disc.
		  virtual int readMzHeader() = 0; // EXPORT
		  /// Reads the export directory of the current file from disc.
		  virtual int readExportDirectory()  = 0; // EXPORT
		  /// Reads the PE header of the current file from disc.
		  virtual int readPeHeader()  = 0; // EXPORT
		  /// Reads the import directory of the current file from disc.
		  virtual int readImportDirectory()  = 0; // EXPORT
		  /// Reads the bound import directory of the current file from disc.
		  virtual int readBoundImportDirectory()  = 0; // EXPORT
		  /// Reads the resource directory of the current file from disc.
		  virtual int readResourceDirectory()  = 0; // EXPORT
		  /// Reads the relocations directory of the current file from disc.
		  virtual int readRelocationsDirectory()  = 0; // EXPORT
		  /// Reads the COM+ descriptor directory of the current file from disc.
		  virtual int readComHeaderDirectory()  = 0; // EXPORT
		  /// Reads the IAT directory of the current file from disc.
		  virtual int readIatDirectory()  = 0; // EXPORT
		  /// Reads the Debug directory of the current file.		  
		  virtual int readDebugDirectory()  = 0; // EXPORT
		  virtual int readTlsDirectory()  = 0; // EXPORT
		  
		  virtual unsigned int getBits() const = 0;

		  /// Accessor function for the MZ header.
		  const MzHeader& mzHeader() const;
		  /// Accessor function for the MZ header.
		  MzHeader& mzHeader(); // EXPORT

		  /// Accessor function for the export directory.
		  const ExportDirectory& expDir() const;
		  /// Accessor function for the export directory.
		  ExportDirectory& expDir(); // EXPORT
		  
		  /// Accessor function for the bound import directory.
		  const BoundImportDirectory& boundImpDir() const;
		  /// Accessor function for the bound import directory.
		  BoundImportDirectory& boundImpDir(); // EXPORT
		  
		  /// Accessor function for the resource directory.
		  const ResourceDirectory& resDir() const;
		  /// Accessor function for the resource directory.
		  ResourceDirectory& resDir(); // EXPORT

		  /// Accessor function for the relocations directory.
		  const RelocationsDirectory& relocDir() const;
		  /// Accessor function for the relocations directory.
		  RelocationsDirectory& relocDir(); // EXPORT

		  /// Accessor function for the COM+ descriptor directory.
		  const ComHeaderDirectory& comDir() const;
		  /// Accessor function for the COM+ descriptor directory.
		  ComHeaderDirectory& comDir(); // EXPORT

		  /// Accessor function for the IAT directory.
		  const IatDirectory& iatDir() const;
		  /// Accessor function for the IAT directory.
		  IatDirectory& iatDir(); // EXPORT
		  
		  /// Accessor function for the debug directory.
		  const DebugDirectory& debugDir() const;
		  /// Accessor function for the debug directory.
		  DebugDirectory& debugDir(); // EXPORT
		  
	};
	
	/**
	* This class implements the common structures of PE and PE+ files.
	**/
	template<int bits>
	class PeFileT : public PeFile
	{
		typedef typename PeFile_Traits<bits>::PeHeader32_64 PeHeader32_64;
		
		private:
		  PeHeader32_64 m_peh; ///< PE header of the current file.
		  ImportDirectory<bits> m_impdir; ///< Import directory of the current file.
		  TlsDirectory<bits> m_tlsdir;
		
		public:
		  /// Default constructor which exists only for the sake of allowing to construct files without filenames.
		  PeFileT();
		  
		  virtual ~PeFileT() {}
		  
		  /// Initializes a PeFile with a filename
		  explicit PeFileT(const std::string& strFilename);
		  
		  /// Returns the name of the current file.
		  std::string getFileName() const;
		  /// Changes the name of the current file.
		  void setFileName(std::string strFilename);

		  /// Reads the MZ header of the current file from disc.
		  int readMzHeader() ;
		  /// Reads the export directory of the current file from disc.
		  int readExportDirectory() ;
		  /// Reads the PE header of the current file from disc.
		  int readPeHeader() ;
		  /// Reads the import directory of the current file from disc.
		  int readImportDirectory() ;
		  /// Reads the bound import directory of the current file from disc.
		  int readBoundImportDirectory() ;
		  /// Reads the resource directory of the current file from disc.
		  int readResourceDirectory() ;
		  /// Reads the relocations directory of the current file from disc.
		  int readRelocationsDirectory() ;
		  /// Reads the COM+ descriptor directory of the current file from disc.
		  int readComHeaderDirectory() ;
		  /// Reads the IAT directory of the current file from disc.
		  int readIatDirectory() ;
		  /// Reads the Debug directory of the current file.		  
		  int readDebugDirectory() ;
		  int readTlsDirectory() ;
		  
		  unsigned int getBits() const
		  {
			  return bits;
		  }
		  
		  /// Accessor function for the PE header.
		  const PeHeader32_64& peHeader() const;
		  /// Accessor function for the PE header.
		  PeHeader32_64& peHeader();

		  /// Accessor function for the import directory.
		  const ImportDirectory<bits>& impDir() const;
		  /// Accessor function for the import directory.
		  ImportDirectory<bits>& impDir();
		  
		  const TlsDirectory<bits>& tlsDir() const;
		  TlsDirectory<bits>& tlsDir();
	};

	/**
	* This class is the main class for handling PE files.
	**/
	class PeFile32 : public PeFileT<32>
	{
		public:
		  /// Default constructor which exists only for the sake of allowing to construct files without filenames.
		  PeFile32();

		  /// Initializes a PeFile with a filename
		  explicit PeFile32(const std::string& strFlename);
		  virtual void visit(PeFileVisitor &v) { v.callback( *this ); }
	};
	
	/**
	* This class is the main class for handling PE+ files.
	**/
	class PeFile64 : public PeFileT<64>
	{
		public:
		  /// Default constructor which exists only for the sake of allowing to construct files without filenames.
		  PeFile64();

		  /// Initializes a PeFile with a filename
		  explicit PeFile64(const std::string& strFlename);
		  virtual void visit(PeFileVisitor &v) { v.callback( *this ); }
	};
	
	//typedef PeFileT<32> PeFile32;
	//typedef PeFileT<64> PeFile64;
	
	/**
	* @param strFilename Name of the current file.
	**/
	template<int bits>
	PeFileT<bits>::PeFileT(const std::string& strFilename)
	{
 		m_filename = strFilename;
 	}

	template<int bits>
	PeFileT<bits>::PeFileT()
	{
	}

	template<int bits>
	int PeFileT<bits>::readPeHeader() 
	{
		return peHeader().read(getFileName(), mzHeader().getAddressOfPeHeader());
	}

	
	template<int bits>
	int PeFileT<bits>::readImportDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 2
			&& peHeader().getIddImportRva()
			&& peHeader().getIddImportSize())
		{
			return impDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddImportRva())), peHeader().getIddImportSize(), peHeader());
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	/**
	* @return A reference to the file's PE header.
	**/
	template<int bits>
	const typename PeFile_Traits<bits>::PeHeader32_64& PeFileT<bits>::peHeader() const
	{
		return m_peh;
	}

	/**
	* @return A reference to the file's PE header.
	**/
	template<int bits>
	typename PeFile_Traits<bits>::PeHeader32_64& PeFileT<bits>::peHeader()
	{
		return m_peh;
	}

	/**
	* @return A reference to the file's import directory.
	**/
	template<int bits>
	const ImportDirectory<bits>& PeFileT<bits>::impDir() const
	{
		return m_impdir;
	}

	/**
	* @return A reference to the file's import directory.
	**/
	template<int bits>
	ImportDirectory<bits>& PeFileT<bits>::impDir()
	{
		return m_impdir;
	}

	template<int bits>
	const TlsDirectory<bits>& PeFileT<bits>::tlsDir() const
	{
		return m_tlsdir;
	}

	template<int bits>
	TlsDirectory<bits>& PeFileT<bits>::tlsDir()
	{
		return m_tlsdir;
	}

	/**
	* @return Filename of the current file.
	**/
	template<int bits>
	std::string PeFileT<bits>::getFileName() const
	{
		return m_filename;
	}

	/**
	* @param strFilename New filename.
	**/
	template<int bits>
	void PeFileT<bits>::setFileName(std::string strFilename)
	{
		m_filename = strFilename;
	}

	template<int bits>
	int PeFileT<bits>::readMzHeader() 
	{
		return mzHeader().read(getFileName());
	}
	
	template<int bits>
	int PeFileT<bits>::readExportDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 1
			&& peHeader().getIddExportRva() && peHeader().getIddExportSize())
		{
			return expDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddExportRva())), peHeader().getIddExportSize(), peHeader());
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	
	template<int bits>
	int PeFileT<bits>::readBoundImportDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 12
			&& peHeader().getIddBoundImportRva() && peHeader().getIddBoundImportSize())
		{
			return boundImpDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddBoundImportRva())), peHeader().getIddBoundImportSize());
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	template<int bits>
	int PeFileT<bits>::readResourceDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 3
			&& peHeader().getIddResourceRva() && peHeader().getIddResourceSize())
		{
			return resDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddResourceRva())), peHeader().getIddResourceSize(), peHeader().getIddResourceRva());
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	template<int bits>
	int PeFileT<bits>::readRelocationsDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 6
			&& peHeader().getIddBaseRelocRva() && peHeader().getIddBaseRelocSize())
		{
			return relocDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddBaseRelocRva())), peHeader().getIddBaseRelocSize());
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	template<int bits>
	int PeFileT<bits>::readComHeaderDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 15
			&& peHeader().getIddComHeaderRva() && peHeader().getIddComHeaderSize())
		{
			return comDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddComHeaderRva())), peHeader().getIddComHeaderSize());
		}
			std::cout << peHeader().getIddComHeaderRva() << std::endl;
			std::exit(0);
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	template<int bits>
	int PeFileT<bits>::readIatDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 13
			&& peHeader().getIddIatRva() && peHeader().getIddIatSize())
		{
			return iatDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddIatRva())), peHeader().getIddIatSize());
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	template<int bits>
	int PeFileT<bits>::readDebugDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 7
			&& peHeader().getIddDebugRva() && peHeader().getIddDebugSize())
		{
			return debugDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddDebugRva())), peHeader().getIddDebugSize());
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

	template<int bits>
	int PeFileT<bits>::readTlsDirectory() 
	{
		if (peHeader().calcNumberOfRvaAndSizes() >= 10
			&& peHeader().getIddTlsRva() && peHeader().getIddTlsSize())
		{
			return tlsDir().read(getFileName(), static_cast<unsigned int>(peHeader().rvaToOffset(peHeader().getIddTlsRva())), peHeader().getIddTlsSize());
		}
		return ERROR_DIRECTORY_DOES_NOT_EXIST;
	}

}

#endif

```

`deps/PeLib/PeHeader.cpp`:

```cpp
/*
* PeHeader.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "PeLibInc.h"
#include "PeHeader.h"

namespace PeLib
{
	template<>
	void PeHeaderT<32>::readBaseOfData(InputBuffer& ibBuffer, PELIB_IMAGE_NT_HEADERS<32>& header) const
	{
		ibBuffer >> header.OptionalHeader.BaseOfData;
	}
	
	template<>
	void PeHeaderT<64>::readBaseOfData(InputBuffer&, PELIB_IMAGE_NT_HEADERS<64>&) const
	{
	}
	
	template<>
	void PeHeaderT<32>::rebuildBaseOfData(OutputBuffer& obBuffer) const
	{
		obBuffer << m_inthHeader.OptionalHeader.BaseOfData;
	}
	
	template<>
	void PeHeaderT<64>::rebuildBaseOfData(OutputBuffer&) const
	{
	}
	
    template<>
    bool PeHeaderT<32>::isValid() const
    {
		return true;
    }
    
    template<>
    bool PeHeaderT<64>::isValid() const
    {
		return true;
    }
    
    template<>
    bool PeHeaderT<32>::isValid(unsigned int pehf) const
    {
    /*
        if (pehf == NtSignature)
        {
            return m_inthHeader.Signature == IMAGE_NT_SIGNATURE;
        }
        else if (pehf == NumberOfSections)
        {
            return getNumberOfSections() == calcNumberOfSections();
        }      */
        return false;
    }

    template<>
    bool PeHeaderT<64>::isValid(unsigned int pehf) const
    {
        return false;
    }

	/**
	* @return The BaseOfData value from the PE header.
	**/
	dword PeHeader32::getBaseOfData() const
	{
		return m_inthHeader.OptionalHeader.BaseOfData;
	}

	/**
	* Changes the file's BaseOfData.
	* @param dwValue New value.
	**/
	void PeHeader32::setBaseOfData(dword dwValue)
	{
		m_inthHeader.OptionalHeader.BaseOfData = dwValue;
	}

}

```

`deps/PeLib/PeHeader.h`:

```h
/*
* PeHeader.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef PEHEADER_H
#define PEHEADER_H

#include "PeLibAux.h"

namespace PeLib
{
	class PeHeader
	{
//		protected:
//			virtual void readBaseOfData(InputBuffer& ibBuffer) = 0;
//			virtual void rebuildBaseOfData(OutputBuffer& obBuffer) const = 0;
			
		public:
			virtual ~PeHeader(){};
	};
	
	/// Class that handles the PE header of files.
	/**
	* This class can read and modify PE headers. It provides set- and get functions to access
	* all individual members of a PE header. Furthermore it's possible to validate and rebuild
	* PE headers. A PE header includes the IMAGE_Nt_HEADERS and the section definitions of a PE file.
	* \todo getIdReservedRva
	**/
	template<int x>
	class PeHeaderT : public PeHeader
	{
		private:
			void readBaseOfData(InputBuffer& ibBuffer, PELIB_IMAGE_NT_HEADERS<x>& header) const;
			void rebuildBaseOfData(OutputBuffer& obBuffer) const;
		
		protected:
		  std::vector<PELIB_IMAGE_SECTION_HEADER> m_vIsh; ///< Stores section header information.
		  PELIB_IMAGE_NT_HEADERS<x> m_inthHeader; ///< Stores Nt header information.
		  dword m_uiOffset; ///< Equivalent to the value returned by #PeLib::MzHeader::getAddressOfPeFile

		public:
		  typedef typename FieldSizes<x>::VAR4_8 VAR4_8;
		
		  PeHeaderT() : m_uiOffset(0)
		  {
		  }
			
		  /// Add a section to the header.
		  int addSection(const std::string& strName, dword dwSize); // EXPORT
		  
		  unsigned int calcSizeOfImage() const; // EXPORT
		  
		  /// Returns the unused space after the header.
		  unsigned int calcSpaceAfterHeader() const; // EXPORT
		  
		  /// Returns the address of the physically first section (not the first defined section).
		  unsigned int calcStartOfCode() const; // EXPORT

		  /// Calculates the offset for a new section of size uiSize.
		  unsigned int calcOffset() const; // EXPORT

		  /// Calculates the Rva for a new section of size uiSize.
		  unsigned int calcRva() const; // EXPORT
		  
		  /// Returns the number of sections in the current file.
		  word calcNumberOfSections() const; // EXPORT

		  void enlargeLastSection(unsigned int uiSize); // EXPORT
		  
		  /// Returns the section Id of the section that contains the offset.
		  word getSectionWithOffset(VAR4_8 dwOffset) const; // EXPORT

		  /// Returns the number of the section which the given relative address points to.
		  word getSectionWithRva(VAR4_8 rva) const; // EXPORT

          bool isValid() const; // EXPORT
          bool isValid(unsigned int foo) const; // EXPORT

		  /// Corrects the current PE header.
		  void makeValid(dword dwOffset); // EXPORT

		  /// Converts a file offset to a relative virtual offset.
		  unsigned int offsetToRva(VAR4_8 dwOffset) const; // EXPORT

		  /// Converts a file offset to a virtual address.
		  unsigned int offsetToVa(VAR4_8 dwOffset) const; // EXPORT

		  /// Reads the PE header of a file.
		  int read(std::string strFilename, unsigned int uiOffset); // EXPORT

		  int read(const unsigned char* pcBuffer, unsigned int uiSize, unsigned int uiOffset); // EXPORT

		  void readHeader(InputBuffer& ibBuffer, PELIB_IMAGE_NT_HEADERS<x>& header) const;
		  void readDataDirectories(InputBuffer& ibBuffer, PELIB_IMAGE_NT_HEADERS<x>& header) const;
		  std::vector<PELIB_IMAGE_SECTION_HEADER> readSections(InputBuffer& ibBuffer, PELIB_IMAGE_NT_HEADERS<x>& header) const;
	
		  /// Rebuilds the current PE header.
		  void rebuild(std::vector<byte>& vBuffer) const; // EXPORT

		  /// Converts a relative virtual address to a file offset.
		  VAR4_8 rvaToOffset(VAR4_8 dwRva) const; // EXPORT

		  /// Converts a relative virtual address to a virtual address.
		  VAR4_8 rvaToVa(VAR4_8 dwRva) const; // EXPORT

		  /// Calculates the size for the current PE header including all section definitions.
		  unsigned int size() const;

		  VAR4_8 vaToRva(VAR4_8 dwRva) const; // EXPORT
		  VAR4_8 vaToOffset(VAR4_8 dwRva) const; // EXPORT

		  /// Save the PE header to a file.
		  int write(std::string strFilename, unsigned int uiOffset) const; // EXPORT

		  /// Writes sections to a file.
		  int writeSections(const std::string& strFilename) const; // EXPORT
		  /// Overwrites a section with new data.
		  int writeSectionData(const std::string& strFilename, word wSecnr, const std::vector<byte>& vBuffer) const; // EXPORT

// header getters
		  /// Returns the Signature value of the header.
		  dword getNtSignature() const; // EXPORT
		  /// Returns the Machine value of the header.
		  word getMachine() const; // EXPORT
		  /// Returns the Sections value of the header.
		  word getNumberOfSections() const; // EXPORT
		  /// Returns the TimeDateStamp value of the header.
		  dword getTimeDateStamp() const; // EXPORT
		  /// Returns the PointerToSymbolTable value of the header.
		  dword getPointerToSymbolTable() const; // EXPORT
		  /// Returns the NumberOfSymbols value of the header.
		  dword getNumberOfSymbols() const; // EXPORT
		  /// Returns the SizeOfOptionalHeader value of the header.
		  word getSizeOfOptionalHeader() const; // EXPORT
		  /// Returns the Characteristics value of the header.
		  word getCharacteristics() const; // EXPORT

		  /// Returns the Magic value of the header.
		  word getMagic() const; // EXPORT
		  /// Returns the MajorLinkerVersion value of the header.
		  byte getMajorLinkerVersion() const; // EXPORT
		  /// Returns the MinorLinkerVersion value of the header.
		  byte getMinorLinkerVersion() const; // EXPORT
		  /// Returns the SizeOfCode value of the header.
		  dword getSizeOfCode() const; // EXPORT
		  /// Returns the SizeOfInitializedData value of the header.
		  dword getSizeOfInitializedData() const; // EXPORT
		  /// Returns the SizeOfUninitializedData value of the header.
		  dword getSizeOfUninitializedData() const; // EXPORT
		  /// Returns the AddressOfEntryPoint value of the header.
		  dword getAddressOfEntryPoint() const; // EXPORT
		  /// Returns the BaseOfCode value of the header.
		  dword getBaseOfCode() const; // EXPORT
		  /// Returns the ImageBase value of the header.
		  VAR4_8 getImageBase() const; // EXPORT
		  /// Returns the SectionAlignment value of the header.
		  dword getSectionAlignment() const; // EXPORT
		  /// Returns the FileAlignment value of the header.
		  dword getFileAlignment() const; // EXPORT
		  /// Returns the MajorOperatingSystemVersion value of the header.
		  word getMajorOperatingSystemVersion() const; // EXPORT
		  /// Returns the MinorOperatingSystemVersion value of the header.
		  word getMinorOperatingSystemVersion() const; // EXPORT
		  /// Returns the MajorImageVersion value of the header.
		  word getMajorImageVersion() const; // EXPORT
		  /// Returns the MinorImageVersion value of the header.
		  word getMinorImageVersion() const; // EXPORT
		  /// Returns the MajorSubsystemVersion value of the header.
		  word getMajorSubsystemVersion() const; // EXPORT
		  /// Returns the MinorSubsystemVersion value of the header.
		  word getMinorSubsystemVersion() const; // EXPORT
		  /// Returns the Reserved1 value of the header.
		  dword getWin32VersionValue() const; // EXPORT
		  /// Returns the SizeOfImage value of the header.
		  dword getSizeOfImage() const; // EXPORT
		  /// Returns the SizeOfHeaders value of the header.
		  dword getSizeOfHeaders() const; // EXPORT
		  /// Returns the CheckSum value of the header.
		  dword getCheckSum() const; // EXPORT
		  /// Returns the Subsystem value of the header.
		  word getSubsystem() const; // EXPORT
		  /// Returns the DllCharacteristics value of the header.
		  word getDllCharacteristics() const; // EXPORT
		  /// Returns the SizeOfStackReserve value of the header.
		  VAR4_8 getSizeOfStackReserve() const; // EXPORT
		  /// Returns the SizeOfStackCommit value of the header.
		  VAR4_8 getSizeOfStackCommit() const; // EXPORT
		  /// Returns the SizeOfHeapReserve value of the header.
		  VAR4_8 getSizeOfHeapReserve() const; // EXPORT
		  /// Returns the SizeOfHeapCommit value of the header.
		  VAR4_8 getSizeOfHeapCommit() const; // EXPORT
		  /// Returns the LoaderFlags value of the header.
		  dword getLoaderFlags() const; // EXPORT
		  /// Returns the NumberOfRvaAndSizes value of the header.
		  dword getNumberOfRvaAndSizes() const; // EXPORT
		  dword calcNumberOfRvaAndSizes() const; // EXPORT

		  void addDataDirectory(); // EXPORT
		  void removeDataDirectory(dword index); // EXPORT
		  
// image directory getters
		  /// Returns the relative virtual address of the image directory Export.
		  dword getIddExportRva() const; // EXPORT
		  /// Returns the size of the image directory Export.
		  dword getIddExportSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Import.
		  dword getIddImportRva() const; // EXPORT
		  /// Returns the size of the image directory Import.
		  dword getIddImportSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Resource.
		  dword getIddResourceRva() const; // EXPORT
		  /// Returns the size of the image directory Resource.
		  dword getIddResourceSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Exception.
		  dword getIddExceptionRva() const; // EXPORT
		  /// Returns the size of the image directory Exception.
		  dword getIddExceptionSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Security.
		  dword getIddSecurityRva() const; // EXPORT
		  /// Returns the size of the image directory Security.
		  dword getIddSecuritySize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Base Reloc.
		  dword getIddBaseRelocRva() const; // EXPORT
		  /// Returns the size of the image directory Base Reloc.
		  dword getIddBaseRelocSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Debug.
		  dword getIddDebugRva() const; // EXPORT
		  /// Returns the size of the image directory Debug.
		  dword getIddDebugSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Architecture.
		  dword getIddArchitectureRva() const; // EXPORT
		  /// Returns the size of the image directory Architecture.
		  dword getIddArchitectureSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory GlobalPtr.
		  dword getIddGlobalPtrRva() const; // EXPORT
		  /// Returns the size of the image directory GlobalPtr.
		  dword getIddGlobalPtrSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Tls.
		  dword getIddTlsRva() const; // EXPORT
		  /// Returns the size of the image directory Tls.
		  dword getIddTlsSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory LoadConfig.
		  dword getIddLoadConfigRva() const; // EXPORT
		  /// Returns the size of the image directory LoadConfig.
		  dword getIddLoadConfigSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory BoundImport.
		  dword getIddBoundImportRva() const; // EXPORT
		  /// Returns the size of the image directory BoundImport.
		  dword getIddBoundImportSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory Iat.
		  dword getIddIatRva() const; // EXPORT
		  /// Returns the size of the image directory Iat.
		  dword getIddIatSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory DelayImport.
		  dword getIddDelayImportRva() const; // EXPORT
		  /// Returns the size of the image directory DelayImport.
		  dword getIddDelayImportSize() const; // EXPORT
		  /// Returns the relative virtual address of the image directory COM Descriptor.
		  dword getIddComHeaderRva() const; // EXPORT
		  /// Returns the size of the image directory COM Descriptor.
		  dword getIddComHeaderSize() const; // EXPORT

		  /// Returns the relative virtual address of an image directory.
		  dword getImageDataDirectoryRva(dword dwDirectory) const; // EXPORT
		  /// Returns the size of an image directory.
		  dword getImageDataDirectorySize(dword dwDirectory) const; // EXPORT
		  
		  void setImageDataDirectoryRva(dword dwDirectory, dword value); // EXPORT
		  void setImageDataDirectorySize(dword dwDirectory, dword value); // EXPORT

// section getters
		  /// Returns the name of a section.
		  std::string getSectionName(word uiSectionnr) const; // EXPORT
		  /// Returns the virtual size of a section.
		  dword getVirtualSize(word uiSectionnr) const; // EXPORT
		  /// Returns the virtual address of a section.
		  dword getVirtualAddress(word uiSectionnr) const; // EXPORT
		  /// Returns the size of a section's raw data.
		  dword getSizeOfRawData(word uiSectionnr) const; // EXPORT
		  /// Returns file offset of the data of a section.
		  dword getPointerToRawData(word uiSectionnr) const; // EXPORT
		  /// Returns the rva of the relocations of a section.
		  dword getPointerToRelocations(word uiSectionnr) const; // EXPORT
		  /// Returns the rva of the line numbers of a section.
		  dword getPointerToLinenumbers(word uiSectionnr) const; // EXPORT
		  /// Returns the number of relocations of a section.
		  dword getNumberOfRelocations(word uiSectionnr) const; // EXPORT
		  /// Returns the number of line numbers of a section.
		  dword getNumberOfLinenumbers(word uiSectionnr) const; // EXPORT
		  /// Returns the characteristics of a section.
		  dword getCharacteristics(word uiSectionnr) const; // EXPORT _section

// header setters
		  /// Sets the Signature value of the header.
		  void setNtSignature(dword value); // EXPORT
		  /// Sets the Machine value of the header.
		  void setMachine(word value); // EXPORT
		  /// Sets the Sections value of the header.
		  void setNumberOfSections(word value); // EXPORT
		  /// Sets the TimeDateStamp value of the header.
		  void setTimeDateStamp(dword value); // EXPORT
		  /// Sets the PointerToSymbolTable value of the header.
		  void setPointerToSymbolTable(dword value); // EXPORT
		  /// Sets the NumberOfSymbols value of the header.
		  void setNumberOfSymbols(dword value); // EXPORT
		  /// Sets the SizeOfOptionalHeader value of the header.
		  void setSizeOfOptionalHeader(word value); // EXPORT
		  /// Sets the Characteristics value of the header.
		  void setCharacteristics(word value); // EXPORT _section

		  /// Sets the Magic value of the header.
		  void setMagic(word value); // EXPORT
		  /// Sets the MajorLinkerVersion value of the header.
		  void setMajorLinkerVersion(byte value); // EXPORT
		  /// Sets the MinorLinkerVersion value of the header.
		  void setMinorLinkerVersion(byte value); // EXPORT
		  /// Sets the SizeOfCode value of the header.
		  void setSizeOfCode(dword value); // EXPORT
		  /// Sets the SizeOfInitializedData value of the header.
		  void setSizeOfInitializedData(dword value); // EXPORT
		  /// Sets the SizeOfUninitializedData value of the header.
		  void setSizeOfUninitializedData(dword value); // EXPORT
		  /// Sets the AddressOfEntryPoint value of the header.
		  void setAddressOfEntryPoint(dword value); // EXPORT
		  /// Sets the BaseOfCode value of the header.
		  void setBaseOfCode(dword value); // EXPORT
		  /// Sets the ImageBase value of the header.
		  void setImageBase(VAR4_8 value); // EXPORT
		  /// Sets the SectionAlignment value of the header.
		  void setSectionAlignment(dword value); // EXPORT
		  /// Sets the FileAlignment value of the header.
		  void setFileAlignment(dword value); // EXPORT
		  /// Sets the MajorOperatingSystemVersion value of the header.
		  void setMajorOperatingSystemVersion(word value); // EXPORT
		  /// Sets the MinorOperatingSystemVersion value of the header.
		  void setMinorOperatingSystemVersion(word value); // EXPORT
		  /// Sets the MajorImageVersion value of the header.
		  void setMajorImageVersion(word value); // EXPORT
		  /// Sets the MinorImageVersion value of the header.
		  void setMinorImageVersion(word value); // EXPORT
		  /// Sets the MajorSubsystemVersion value of the header.
		  void setMajorSubsystemVersion(word value); // EXPORT
		  /// Sets the MinorSubsystemVersion value of the header.
		  void setMinorSubsystemVersion(word value); // EXPORT
		  /// Sets the Reserved1 value of the header.
		  void setWin32VersionValue(dword value); // EXPORT
		  /// Sets the SizeOfImage value of the header.
		  void setSizeOfImage(dword value); // EXPORT
		  /// Sets the SizeOfHeaders value of the header.
		  void setSizeOfHeaders(dword value); // EXPORT
		  /// Sets the CheckSum value of the header.
		  void setCheckSum(dword value); // EXPORT
		  /// Sets the Subsystem value of the header.
		  void setSubsystem(word value); // EXPORT
		  /// Sets the DllCharacteristics value of the header.
		  void setDllCharacteristics(word value); // EXPORT
		  /// Sets the SizeOfStackReserve value of the header.
		  void setSizeOfStackReserve(VAR4_8 value); // EXPORT
		  /// Sets the SizeOfStackCommit value of the header.
		  void setSizeOfStackCommit(VAR4_8 value); // EXPORT
		  /// Sets the SizeOfHeapReserve value of the header.
		  void setSizeOfHeapReserve(VAR4_8 value); // EXPORT
		  /// Sets the SizeOfHeapCommit value of the header.
		  void setSizeOfHeapCommit(VAR4_8 value); // EXPORT
		  /// Sets the LoaderFlags value of the header.
		  void setLoaderFlags(dword value); // EXPORT
		  /// Sets the NumberOfRvaAndSizes value of the header.
		  void setNumberOfRvaAndSizes(dword value); // EXPORT

// image directory getters
		  void setIddDebugRva(dword dwValue); // EXPORT
		  void setIddDebugSize(dword dwValue); // EXPORT
		  void setIddDelayImportRva(dword dwValue); // EXPORT
		  void setIddDelayImportSize(dword dwValue); // EXPORT
		  void setIddExceptionRva(dword dwValue); // EXPORT
		  void setIddExceptionSize(dword dwValue); // EXPORT
		  void setIddGlobalPtrRva(dword dwValue); // EXPORT
		  void setIddGlobalPtrSize(dword dwValue); // EXPORT
		  void setIddIatRva(dword dwValue); // EXPORT
		  void setIddIatSize(dword dwValue); // EXPORT
		  void setIddLoadConfigRva(dword dwValue); // EXPORT
		  void setIddLoadConfigSize(dword dwValue); // EXPORT
		  void setIddResourceRva(dword dwValue); // EXPORT
		  void setIddResourceSize(dword dwValue); // EXPORT
		  void setIddSecurityRva(dword dwValue); // EXPORT
		  void setIddSecuritySize(dword dwValue); // EXPORT
		  void setIddTlsRva(dword dwValue); // EXPORT
		  void setIddTlsSize(dword dwValue); // EXPORT

		  void setIddImportRva(dword dwValue); // EXPORT
		  void setIddImportSize(dword dwValue); // EXPORT
		  void setIddExportRva(dword dwValue); // EXPORT
		  void setIddExportSize(dword dwValue); // EXPORT
		  
		  void setIddBaseRelocRva(dword value); // EXPORT
		  void setIddBaseRelocSize(dword value); // EXPORT
		  void setIddArchitectureRva(dword value); // EXPORT
		  void setIddArchitectureSize(dword value); // EXPORT
		  void setIddComHeaderRva(dword value); // EXPORT
		  void setIddComHeaderSize(dword value); // EXPORT

		  /// Set the name of a section.
		  void setSectionName(word uiSectionnr, std::string strName); // EXPORT
		  /// Set the virtual size of a section.
		  void setVirtualSize(word uiSectionnr, dword dwValue); // EXPORT
		  /// Set the virtual address of a section.
		  void setVirtualAddress(word uiSectionnr, dword dwValue); // EXPORT
		  /// Set the size of raw data of a section.
		  void setSizeOfRawData(word uiSectionnr, dword dwValue); // EXPORT
		  /// Set the file offset of a section.
		  void setPointerToRawData(word uiSectionnr, dword dwValue); // EXPORT
		  /// Set the pointer to relocations of a section.
		  void setPointerToRelocations(word uiSectionnr, dword dwValue); // EXPORT
		  /// Set the pointer to linenumbers of a section.
		  void setPointerToLinenumbers(word uiSectionnr, dword dwValue); // EXPORT
		  /// Set the number of relocations a section.
		  void setNumberOfRelocations(word uiSectionnr, dword dwValue); // EXPORT
		  /// Set the number of linenumbers section.
		  void setNumberOfLinenumbers(word uiSectionnr, dword dwValue); // EXPORT
		  /// Set the characteristics of a section.
		  void setCharacteristics(word uiSectionnr, dword dwValue); // EXPORT
	};
	
	class PeHeader32 : public PeHeaderT<32>
	{
		public:
		  /// Returns the BaseOfData value of the header.
		  dword getBaseOfData() const; // EXPORT
		  /// Sets the BaseOfData value of the header.
		  void setBaseOfData(dword value); // EXPORT
	};
	
	class PeHeader64 : public PeHeaderT<64>
	{
	};
	
	template<int x>
	void PeHeaderT<x>::addDataDirectory()
	{
		m_inthHeader.dataDirectories.push_back(PELIB_IMAGE_DATA_DIRECTORY());
	}

	template<int x>
	void PeHeaderT<x>::removeDataDirectory(dword index)
	{
		m_inthHeader.dataDirectories.erase(m_inthHeader.dataDirectories.begin() + index);
	}
		  
	/**
	* Adds a new section to the header. The physical and virtual address as well as the virtual
	* size of the section will be determined automatically from the raw size. The section
	* characteristics will be set to IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ |
	* IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_CODE. All other values will be set to 0.
	* Note: It's important that if the current header's FileAlignment and/or SectionAlignment values are
	* 0 this function will fail.
	* @param strName Name of the new section. If this name is longer than 8 bytes only the first 8 bytes will be used.
	* @param dwSize Physical size of the new section in bytes.
	* \todo Better code that handles files with 0 sections.
	**/
	template<int x>
	int PeHeaderT<x>::addSection(const std::string& strName, dword dwSize)
	{
		unsigned int uiSecnr = calcNumberOfSections();

		if (!getFileAlignment())
		{
			return ERROR_NO_FILE_ALIGNMENT;
		}
		else if (!getSectionAlignment())
		{
			return ERROR_NO_SECTION_ALIGNMENT;
		}
			
		if (uiSecnr) // Always allow 1 section.
		{
			if (uiSecnr == 0xFFFF)
			{
				return ERROR_TOO_MANY_SECTIONS;
			}
			else if (calcSpaceAfterHeader() < PELIB_IMAGE_SECTION_HEADER::size())
			{
				return ERROR_NOT_ENOUGH_SPACE;
			}
		}

		dword dwOffset = calcOffset(/*dwSize*/);
		dword dwRva = calcRva(/*dwSize*/);

		PELIB_IMAGE_SECTION_HEADER ishdCurr;
		m_vIsh.push_back(ishdCurr);

		setSectionName(uiSecnr, strName);
		setSizeOfRawData(uiSecnr, alignOffset(dwSize, getFileAlignment()));
		setPointerToRawData(uiSecnr, dwOffset);
		setVirtualSize(uiSecnr, alignOffset(dwSize, getSectionAlignment()));
		setVirtualAddress(uiSecnr, dwRva);
		setCharacteristics(uiSecnr, PELIB_IMAGE_SCN_MEM_WRITE | PELIB_IMAGE_SCN_MEM_READ | PELIB_IMAGE_SCN_CNT_INITIALIZED_DATA | PELIB_IMAGE_SCN_CNT_CODE);
		
		return NO_ERROR;
	}

	/**
	* Calculates a valid SizeOfImage value given the information from the current PE header.
	* Note that this calculation works in Win2K but probably does not work in Win9X. I didn't test that though.
	* @return Valid SizeOfImage value.
	**/
	template<int x>
	unsigned int PeHeaderT<x>::calcSizeOfImage() const
	{
		// Major note here: It's possible for sections to exist with a Virtual Size of 0.
		//                  That's why it's necessary to use std::max(Vsize, RawSize) here.
		//                  An example for such a file is dbeng6.exe (made by Sybase).
		//                  In this file each and every section has a VSize of 0 but it still runs.
		
		std::vector<PELIB_IMAGE_SECTION_HEADER>::const_iterator ishLastSection = std::max_element(m_vIsh.begin(), m_vIsh.end(), std::mem_fun_ref(&PELIB_IMAGE_SECTION_HEADER::biggerVirtualAddress));
		if (ishLastSection->VirtualSize != 0) return ishLastSection->VirtualAddress + ishLastSection->VirtualSize;
		return ishLastSection->VirtualAddress + std::max(ishLastSection->VirtualSize, ishLastSection->SizeOfRawData);
	}

	/**
	* Calculates the space between the last byte of the header and the first byte that's used for something
	* else (that's either the first section or an image directory).
	* @return Unused space after the header.
	* \todo There are PE files with sections beginning at offset 0. They
	* need to be considered.
	**/
	template<int x>
	unsigned int PeHeaderT<x>::calcSpaceAfterHeader() const
	{
		return (calcStartOfCode() > size() + m_uiOffset) ? calcStartOfCode() - (size() + m_uiOffset) : 0;
	}

	/**
	* Returns the first offset of the file that's actually used for something different than the header.
	* That something is not necessarily code, it can be a data directory too.
	* This offset can be the beginning of a section or the beginning of a directory.
	* \todo Some optimizization is surely possible here.
	* \todo There are PE files with sections beginning at offset 0. They
	* need to be considered. Returning 0 for these files doesn't really make sense.
	* So far these sections are disregarded.
	**/
	template<int x>
	unsigned int PeHeaderT<x>::calcStartOfCode() const
	{
		unsigned int directories = calcNumberOfRvaAndSizes();
		dword dwMinOffset = 0xFFFFFFFF;
		if (directories >= 1 && getIddExportRva() && rvaToOffset(getIddExportRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddExportRva());
		if (directories >= 2 && getIddImportRva() && rvaToOffset(getIddImportRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddImportRva());
		if (directories >= 3 && getIddResourceRva() && rvaToOffset(getIddResourceRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddResourceRva());
		if (directories >= 4 && getIddExceptionRva()  && rvaToOffset(getIddExceptionRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddExceptionRva());
		if (directories >= 5 && getIddSecurityRva()  && rvaToOffset(getIddSecurityRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddSecurityRva());
		if (directories >= 6 && getIddBaseRelocRva()  && rvaToOffset(getIddBaseRelocRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddBaseRelocRva());
		if (directories >= 7 && getIddDebugRva()  && rvaToOffset(getIddDebugRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddDebugRva());
		if (directories >= 8 && getIddArchitectureRva()  && rvaToOffset(getIddArchitectureRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddArchitectureRva());
		if (directories >= 9 && getIddGlobalPtrRva()  && rvaToOffset(getIddGlobalPtrRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddGlobalPtrRva());
		if (directories >= 10 && getIddTlsRva()  && rvaToOffset(getIddTlsRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddTlsRva());
		if (directories >= 11 && getIddLoadConfigRva()  && rvaToOffset(getIddLoadConfigRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddLoadConfigRva());
		if (directories >= 12 && getIddBoundImportRva()  && rvaToOffset(getIddBoundImportRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddBoundImportRva());
		if (directories >= 13 && getIddIatRva()  && rvaToOffset(getIddIatRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddIatRva());
		if (directories >= 14 && getIddDelayImportRva()  && rvaToOffset(getIddDelayImportRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddDelayImportRva());
		if (directories >= 15 && getIddComHeaderRva()  && rvaToOffset(getIddComHeaderRva()) < dwMinOffset) dwMinOffset = rvaToOffset(getIddComHeaderRva());
		
		for (word i=0;i<calcNumberOfSections();i++)
		{
			if ((getPointerToRawData(i) < dwMinOffset || dwMinOffset == 0xFFFFFFFF) && getSizeOfRawData(i))
			{
				if (getPointerToRawData(i)) dwMinOffset = getPointerToRawData(i);
			}
		}
		return dwMinOffset;
	}

	/**
	* Calculates the file offset for a new section. The file offset will already be aligned to the file's FileAlignment.
	* @return Aligned file offset.
	* \todo uiSize isn't used yet. Will be used later on to search for caves.
	**/
	template<int x>
	unsigned int PeHeaderT<x>::calcOffset(/*unsigned int uiSize*/) const
	{
		unsigned int maxoffset = size();

		for (word i=0;i<calcNumberOfSections();i++)
		{
			if (getPointerToRawData(i) + getSizeOfRawData(i) > maxoffset) maxoffset = getPointerToRawData(i) + getSizeOfRawData(i);
		}

		return alignOffset(maxoffset, getFileAlignment());
	}

	/**
	* Calculates the Rva for a new section. The Rva will already be aligned to the file's SectionAlignment.
	* \todo uiSize isn't used yet. Will be used later on to search for caves.
	* @return Aligned Rva.
	**/
	template<int x>
	unsigned int PeHeaderT<x>::calcRva(/*unsigned int uiSize*/) const
	{
		// Major note here: It's possible for sections to exist with a Virtual Size of 0.
		//                  That's why it's necessary to use std::max(Vsize, RawSize) here.
		//                  An example for such a file is dbeng6.exe (made by Sybase).
		//                  In this file each and every section has a VSize of 0 but it still runs.
		
		unsigned int maxoffset = size();
		for (word i=0;i<calcNumberOfSections();i++)
		{
			if (getVirtualAddress(i) + std::max(getVirtualSize(i), getSizeOfRawData(i)) > maxoffset) maxoffset = getVirtualAddress(i) + std::max(getVirtualSize(i), getSizeOfRawData(i));
		}

		return alignOffset(maxoffset, getSectionAlignment());
	}

	/**
	* Returns the number of currently defined sections. Note that this value can be different from the number
	* of sections according to the header (see #PeLib::PeHeaderT<x>::getNumberOfSections).
	* @return Number of currently defined sections.
	**/
	template<int x>
	word PeHeaderT<x>::calcNumberOfSections() const
	{
		return static_cast<PeLib::word>(m_vIsh.size());
	}

	/**
	* Enlarges the physically last section in the file.
	* @param uiSize Additional size that's added to the section's size.
	**/
	template<int x>
	void PeHeaderT<x>::enlargeLastSection(unsigned int uiSize)
	{
		std::vector<PELIB_IMAGE_SECTION_HEADER>::iterator ishLastSection = std::max_element(m_vIsh.begin(), m_vIsh.end(), std::mem_fun_ref(&PELIB_IMAGE_SECTION_HEADER::biggerFileOffset));
		unsigned int uiRawDataSize = alignOffset(ishLastSection->SizeOfRawData + uiSize, getFileAlignment());
		
		ishLastSection->SizeOfRawData = uiRawDataSize;
		ishLastSection->VirtualSize = ishLastSection->SizeOfRawData;
		
		setSizeOfImage(calcSizeOfImage());
	}

	/**
	* Determines the section which contains the file offset.
	* @param dwOffset File offset.
	* @return Section Id of the section which contains the offset.
	**/
	template<int x>
	word PeHeaderT<x>::getSectionWithOffset(VAR4_8 dwOffset) const
	{
		// Offset = 0 must be handled explicitly as there are files
		// with sections that begin at offset 0, that means the section
		// only exists in memory.
		
		if (!dwOffset) return std::numeric_limits<word>::max();
		
		for (word i=0;i<calcNumberOfSections();i++)
		{
			// Explicity exclude sections with raw pointer = 0.
			dword rawptr = getPointerToRawData(i);
			if (rawptr && rawptr <= dwOffset && rawptr + getSizeOfRawData(i) > dwOffset) return i;
		}
		
		return std::numeric_limits<word>::max();
	}

	/**
	* Determines the section which contains the Rva.
	* @param dwRva A relative virtual address.
	* @return Section Id of the section which contains the Rva.
	**/
	template<int x>
	word PeHeaderT<x>::getSectionWithRva(VAR4_8 dwRva) const
	{
		// Major note here: It's possible for sections to exist with a Virtual Size of 0.
		//                  That's why it's necessary to use std::max(Vsize, RawSize) here.
		//                  An example for such a file is dbeng6.exe (made by Sybase).
		//                  In this file each and every section has a VSize of 0 but it still runs.
		
		for (word i=0;i<calcNumberOfSections();i++)
		{
			// Weird VC++7 error doesn't allow me to use std::max here.
			dword max = getVirtualSize(i) >= getSizeOfRawData(i) ? getVirtualSize(i) : getSizeOfRawData(i);
			if (getVirtualAddress(i) <= dwRva && getVirtualAddress(i) + max > dwRva) return i;
		}
		
		return -1;
	}

	/**
	* Corrects all faulty values of the current PE header. The following values will be corrected: NtSignature,
	* NumberOfSections, SizeOfOptionalHeader, FileAlignment (will be aligned to n*0x200),
	* SectionAlignment (will be aligned to n*0x1000), NumberOfRvaAndSizes, SizeOfHeaders, SizeOfImage,
	* Magic, Characteristics.
	* @param dwOffset Beginning of PeHeader (see #PeLib::MzHeader::getAddressOfPeHeader).
    * \todo 32bit and 64bit versions.
	**/
	template<int x>
	void PeHeaderT<x>::makeValid(dword dwOffset)
	{
		setNtSignature(PELIB_IMAGE_NT_SIGNATURE); // 'PE'
		setMachine(PELIB_IMAGE_FILE_MACHINE_I386);
		setNumberOfSections(calcNumberOfSections());
		
		// Check if 64 bits.
		setSizeOfOptionalHeader(PELIB_IMAGE_OPTIONAL_HEADER<x>::size() + calcNumberOfRvaAndSizes() * 8);

		// Check if 64 bits.
		dword dwCharacteristics = PELIB_IMAGE_FILE_EXECUTABLE_IMAGE | PELIB_IMAGE_FILE_32BIT_MACHINE;
		setCharacteristics(dwCharacteristics);

		// Check if 64 bits.
		setMagic(PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC);

		// setImageBase(0x01000000);

		// Align file and section alignment values
		unsigned int dwAlignedOffset = alignOffset(getSectionAlignment(), 0x1000);
		setSectionAlignment(dwAlignedOffset ? dwAlignedOffset : 0x1000);

		dwAlignedOffset = alignOffset(getFileAlignment(), 0x200);
		setFileAlignment(dwAlignedOffset ? dwAlignedOffset : 0x200);

//		setMajorSubsystemVersion(4);
//		setSubsystem(IMAGE_SUBSYSTEM_WINDOWS_GUI);
		setNumberOfRvaAndSizes(calcNumberOfRvaAndSizes());
		
		// Code below depends on code above. Don't change the order.
		dword dwSizeOfHeaders = alignOffset(dwOffset + size(), getFileAlignment());
		setSizeOfHeaders(dwSizeOfHeaders);

		dword dwSizeOfImage = alignOffset(dwSizeOfHeaders, getSectionAlignment());

		for (int i=0;i<calcNumberOfSections();i++)
		{
			dwSizeOfImage += alignOffset(getVirtualSize(i), getSectionAlignment());
		}

		dwSizeOfImage = alignOffset(dwSizeOfImage, getSectionAlignment());
		setSizeOfImage(dwSizeOfImage);
	}

	template<int x>
	unsigned int PeHeaderT<x>::offsetToRva(VAR4_8 dwOffset) const
	{
		if (dwOffset < calcStartOfCode()) return dwOffset;
	
		PeLib::word uiSecnr = getSectionWithOffset(dwOffset);
		
		if (uiSecnr == 0xFFFF) return -1;
		
		return getVirtualAddress(uiSecnr) + dwOffset - getPointerToRawData(uiSecnr);
	}

	/**
	* Converts a file offset to a virtual address.
	* @param dwOffset File offset.
	* @return Virtual Address.
	**/
	template<int x>
	unsigned int PeHeaderT<x>::offsetToVa(VAR4_8 dwOffset) const
	{
		if (dwOffset < calcStartOfCode()) return getImageBase() + dwOffset;
		
		PeLib::word uiSecnr = getSectionWithOffset(dwOffset);
		
		if (uiSecnr == 0xFFFF) return -1;
		
		return getImageBase() + getVirtualAddress(uiSecnr) + dwOffset - getPointerToRawData(uiSecnr);
	}

	template<int x>
	void PeHeaderT<x>::readHeader(InputBuffer& ibBuffer, PELIB_IMAGE_NT_HEADERS<x>& header) const
	{
		ibBuffer >> header.Signature;
		
		ibBuffer >> header.FileHeader.Machine;
		ibBuffer >> header.FileHeader.NumberOfSections;
		ibBuffer >> header.FileHeader.TimeDateStamp;
		ibBuffer >> header.FileHeader.PointerToSymbolTable;
		ibBuffer >> header.FileHeader.NumberOfSymbols;
		ibBuffer >> header.FileHeader.SizeOfOptionalHeader;
		ibBuffer >> header.FileHeader.Characteristics;
		ibBuffer >> header.OptionalHeader.Magic;

		ibBuffer >> header.OptionalHeader.MajorLinkerVersion;
		ibBuffer >> header.OptionalHeader.MinorLinkerVersion;
		ibBuffer >> header.OptionalHeader.SizeOfCode;
		ibBuffer >> header.OptionalHeader.SizeOfInitializedData;
		ibBuffer >> header.OptionalHeader.SizeOfUninitializedData;
		ibBuffer >> header.OptionalHeader.AddressOfEntryPoint;
		ibBuffer >> header.OptionalHeader.BaseOfCode;
		readBaseOfData(ibBuffer, header);
		ibBuffer >> header.OptionalHeader.ImageBase;
		ibBuffer >> header.OptionalHeader.SectionAlignment;
		ibBuffer >> header.OptionalHeader.FileAlignment;
		ibBuffer >> header.OptionalHeader.MajorOperatingSystemVersion;
		ibBuffer >> header.OptionalHeader.MinorOperatingSystemVersion;
		ibBuffer >> header.OptionalHeader.MajorImageVersion;
		ibBuffer >> header.OptionalHeader.MinorImageVersion;
		ibBuffer >> header.OptionalHeader.MajorSubsystemVersion;
		ibBuffer >> header.OptionalHeader.MinorSubsystemVersion;
		ibBuffer >> header.OptionalHeader.Win32VersionValue;
		ibBuffer >> header.OptionalHeader.SizeOfImage;
		ibBuffer >> header.OptionalHeader.SizeOfHeaders;
		ibBuffer >> header.OptionalHeader.CheckSum;
		ibBuffer >> header.OptionalHeader.Subsystem;
		ibBuffer >> header.OptionalHeader.DllCharacteristics;
		ibBuffer >> header.OptionalHeader.SizeOfStackReserve;
		ibBuffer >> header.OptionalHeader.SizeOfStackCommit;
		ibBuffer >> header.OptionalHeader.SizeOfHeapReserve;
		ibBuffer >> header.OptionalHeader.SizeOfHeapCommit;
		ibBuffer >> header.OptionalHeader.LoaderFlags;
		ibBuffer >> header.OptionalHeader.NumberOfRvaAndSizes;
	}
	
	template<int x>
	void PeHeaderT<x>::readDataDirectories(InputBuffer& ibBuffer, PELIB_IMAGE_NT_HEADERS<x>& header) const
	{
		PELIB_IMAGE_DATA_DIRECTORY idd;

		for (unsigned int i=0;i<header.OptionalHeader.NumberOfRvaAndSizes;i++)
		{
			ibBuffer >> idd.VirtualAddress;
			ibBuffer >> idd.Size;
			header.dataDirectories.push_back(idd);
		}
	}
	
	template<int x>
	std::vector<PELIB_IMAGE_SECTION_HEADER> PeHeaderT<x>::readSections(InputBuffer& ibBuffer, PELIB_IMAGE_NT_HEADERS<x>& header) const
	{
		const unsigned int nrSections = header.FileHeader.NumberOfSections;
		PELIB_IMAGE_SECTION_HEADER ishCurr;

		std::vector<PELIB_IMAGE_SECTION_HEADER> vIshdCurr;

		for (unsigned int i=0;i<nrSections;i++)
		{
			ibBuffer.read(reinterpret_cast<char*>(ishCurr.Name), 8);
			ibBuffer >> ishCurr.VirtualSize;
			ibBuffer >> ishCurr.VirtualAddress;
			ibBuffer >> ishCurr.SizeOfRawData;
			ibBuffer >> ishCurr.PointerToRawData;
			ibBuffer >> ishCurr.PointerToRelocations;
			ibBuffer >> ishCurr.PointerToLinenumbers;
			ibBuffer >> ishCurr.NumberOfRelocations;
			ibBuffer >> ishCurr.NumberOfLinenumbers;
			ibBuffer >> ishCurr.Characteristics;
			vIshdCurr.push_back(ishCurr);
		}

		return vIshdCurr;
	}
	
	template<int x>
	int PeHeaderT<x>::read(const unsigned char* pcBuffer, unsigned int uiSize, unsigned int uiOffset)
	{
		if (uiSize < m_inthHeader.size())
		{
			return ERROR_INVALID_FILE;
		}
		
		std::vector<unsigned char> vBuffer(pcBuffer, pcBuffer + m_inthHeader.size());

		InputBuffer ibBuffer(vBuffer);
		PELIB_IMAGE_NT_HEADERS<x> header;
		
		readHeader(ibBuffer, header);
		
		if (uiSize < m_inthHeader.size() + header.OptionalHeader.NumberOfRvaAndSizes * 8 + header.FileHeader.NumberOfSections * 0x28)
		{
			return ERROR_INVALID_FILE;
		}
		
		vBuffer.resize(header.OptionalHeader.NumberOfRvaAndSizes * 8 + header.FileHeader.NumberOfSections * 0x28);
		vBuffer.assign(pcBuffer + m_inthHeader.size(), pcBuffer + m_inthHeader.size() + header.OptionalHeader.NumberOfRvaAndSizes * 8 + header.FileHeader.NumberOfSections * 0x28);
		
		ibBuffer.setBuffer(vBuffer);
		
		readDataDirectories(ibBuffer, header);
		
		m_vIsh = readSections(ibBuffer, header);

		std::swap(m_inthHeader, header);

		m_uiOffset = uiOffset;

		return NO_ERROR;
	}
	
	/**
	* Reads the PE header from a file Note that this function does not verify if a file is actually a MZ file.
	* For this purpose see #PeLib::PeHeaderT<x>::isValid. The only check this function makes is a check to see if
	* the file is large enough to be a PE header. If the data is valid doesn't matter.
	* @param strFilename Name of the file which will be read.
	* @param uiOffset File offset of PE header (see #PeLib::MzHeader::getAddressOfPeHeader).
	**/
	template<int x>
	int PeHeaderT<x>::read(std::string strFilename, unsigned int uiOffset)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);
		
		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		// File too small
		if (fileSize(ifFile) < uiOffset + m_inthHeader.size())
		{
			return ERROR_INVALID_FILE;
		}
		
		std::vector<unsigned char> vBuffer(m_inthHeader.size());

		ifFile.seekg(uiOffset, std::ios::beg);
		ifFile.read(reinterpret_cast<char*>(&vBuffer[0]), static_cast<std::streamsize>(vBuffer.size()));

		InputBuffer ibBuffer(vBuffer);
		PELIB_IMAGE_NT_HEADERS<x> header;
		
		readHeader(ibBuffer, header);

		vBuffer.resize(header.OptionalHeader.NumberOfRvaAndSizes * 8 + header.FileHeader.NumberOfSections * 0x28);

		ifFile.read(reinterpret_cast<char*>(&vBuffer[0]), static_cast<std::streamsize>(vBuffer.size()));
		if (!ifFile)
		{
			return ERROR_INVALID_FILE;
		}

		ibBuffer.setBuffer(vBuffer);
		
		readDataDirectories(ibBuffer, header);
		
		// Sections
//		const unsigned int nrSections = header.FileHeader.NumberOfSections;
//		if (fileSize(ifFile) < uiOffset + m_inthHeader.size() + nrSections * PELIB_IMAGE_SECTION_HEADER::size())
//		{
//			return ERROR_INVALID_FILE;
//		}
		
		m_vIsh = readSections(ibBuffer, header);

		std::swap(m_inthHeader, header);

		m_uiOffset = uiOffset;

		ifFile.close();
		
		return NO_ERROR;
	}

	/**
	* Rebuilds the PE header so that it can be written to a file. It's not guaranteed that the
	* header will be valid. If you want to make sure that the header will be valid you
	* must call #PeLib::PeHeaderT<x>::makeValid first.
	* @param vBuffer Buffer where the rebuilt header will be stored.
	**/
	template<int x>
	void PeHeaderT<x>::rebuild(std::vector<byte>& vBuffer) const
	{
		OutputBuffer obBuffer(vBuffer);

		obBuffer << m_inthHeader.Signature;

		obBuffer << m_inthHeader.FileHeader.Machine;
		obBuffer << m_inthHeader.FileHeader.NumberOfSections;
		obBuffer << m_inthHeader.FileHeader.TimeDateStamp;
		obBuffer << m_inthHeader.FileHeader.PointerToSymbolTable;
		obBuffer << m_inthHeader.FileHeader.NumberOfSymbols;
		obBuffer << m_inthHeader.FileHeader.SizeOfOptionalHeader;
		obBuffer << m_inthHeader.FileHeader.Characteristics;
		obBuffer << m_inthHeader.OptionalHeader.Magic;
		obBuffer << m_inthHeader.OptionalHeader.MajorLinkerVersion;
		obBuffer << m_inthHeader.OptionalHeader.MinorLinkerVersion;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfCode;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfInitializedData;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfUninitializedData;
		obBuffer << m_inthHeader.OptionalHeader.AddressOfEntryPoint;
		obBuffer << m_inthHeader.OptionalHeader.BaseOfCode;
		rebuildBaseOfData(obBuffer);
//		obBuffer << m_inthHeader.OptionalHeader.BaseOfData;
		obBuffer << m_inthHeader.OptionalHeader.ImageBase;
		obBuffer << m_inthHeader.OptionalHeader.SectionAlignment;
		obBuffer << m_inthHeader.OptionalHeader.FileAlignment;
		obBuffer << m_inthHeader.OptionalHeader.MajorOperatingSystemVersion;
		obBuffer << m_inthHeader.OptionalHeader.MinorOperatingSystemVersion;
		obBuffer << m_inthHeader.OptionalHeader.MajorImageVersion;
		obBuffer << m_inthHeader.OptionalHeader.MinorImageVersion;
		obBuffer << m_inthHeader.OptionalHeader.MajorSubsystemVersion;
		obBuffer << m_inthHeader.OptionalHeader.MinorSubsystemVersion;
		obBuffer << m_inthHeader.OptionalHeader.Win32VersionValue;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfImage;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfHeaders;
		obBuffer << m_inthHeader.OptionalHeader.CheckSum;
		obBuffer << m_inthHeader.OptionalHeader.Subsystem;
		obBuffer << m_inthHeader.OptionalHeader.DllCharacteristics;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfStackReserve;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfStackCommit;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfHeapReserve;
		obBuffer << m_inthHeader.OptionalHeader.SizeOfHeapCommit;
		obBuffer << m_inthHeader.OptionalHeader.LoaderFlags;
		obBuffer << m_inthHeader.OptionalHeader.NumberOfRvaAndSizes;

		// The 0x10 data directories
		for (unsigned int i=0;i<calcNumberOfRvaAndSizes();i++)
		{
			obBuffer << m_inthHeader.dataDirectories[i].VirtualAddress;
			obBuffer << m_inthHeader.dataDirectories[i].Size;
		}
		
		// The section definitions
		const unsigned int nrSections = calcNumberOfSections();
		for (unsigned int i=0;i<nrSections;i++)
		{
			char temp[9] = {0};
			strcpy(temp, getSectionName(i).c_str());
			obBuffer.add(temp, 8);
			obBuffer << m_vIsh[i].VirtualSize;
			obBuffer << m_vIsh[i].VirtualAddress;
			obBuffer << m_vIsh[i].SizeOfRawData;
			obBuffer << m_vIsh[i].PointerToRawData;
			obBuffer << m_vIsh[i].PointerToRelocations;
			obBuffer << m_vIsh[i].PointerToLinenumbers;
			obBuffer << m_vIsh[i].NumberOfRelocations;
			obBuffer << m_vIsh[i].NumberOfLinenumbers;
			obBuffer << m_vIsh[i].Characteristics;
		}
	}

	/**
	* Converts a relative virtual offset to a file offset.
	* @param dwRva A relative virtual offset.
	* @return A file offset.
	* \todo It's not always 0x1000.
	**/
	template<int x>
	typename FieldSizes<x>::VAR4_8 PeHeaderT<x>::rvaToOffset(VAR4_8 dwRva) const
	{
		// XXX: Not correct
		if (dwRva < 0x1000) return dwRva;
		
		PeLib::word uiSecnr = getSectionWithRva(dwRva);
		if (uiSecnr == 0xFFFF || dwRva > getVirtualAddress(uiSecnr) + getSizeOfRawData(uiSecnr))
		{
			return std::numeric_limits<VAR4_8>::max();
		}
		
		return getPointerToRawData(uiSecnr) + dwRva - getVirtualAddress(uiSecnr);
	}

	/**
	* Converts a relative virtual offset to a virtual offset.
	* @param dwRva A relative virtual offset.
	* @return A virtual offset.
	**/
	template<int x>
	typename FieldSizes<x>::VAR4_8 PeHeaderT<x>::rvaToVa(VAR4_8 dwRva) const
	{
		return getImageBase() + dwRva;
	}

	/**
	* Calculates the size of the current PE header. This includes the actual header and the section definitions.
	* @return Size of the current PE header.
	* \todo Better handling of files with less than 0x10 directories.
	**/
	template<int x>
	unsigned int PeHeaderT<x>::size() const
	{
		return m_inthHeader.size() + getNumberOfSections() * PELIB_IMAGE_SECTION_HEADER::size();
	}

	// \todo Not sure if this works.
	template<int x>
	typename FieldSizes<x>::VAR4_8 PeHeaderT<x>::vaToRva(VAR4_8 dwRva) const
	{
		if (dwRva - getImageBase() < calcStartOfCode()) return dwRva - getImageBase();
		
		if (getSectionWithRva(dwRva - getImageBase()) == 0xFFFF) return -1;
		
		return dwRva - getImageBase();
	}

	template<int x>
	typename FieldSizes<x>::VAR4_8 PeHeaderT<x>::vaToOffset(VAR4_8 dwRva) const
	{
		return rvaToOffset(dwRva - getImageBase());
	}

	/**
	* Saves the PE header to a file. Note that this only saves the header information, if you have added sections
	* and want to save these to the file you have to call #PeLib::PeHeaderT<x>::saveSections too. This function also
	* does not verify if the PE header is correct. If you want to make sure that the current PE header is valid,
	* call #PeLib::PeHeaderT<x>::isValid and #PeLib::PeHeaderT<x>::makeValid first.
	* @param strFilename Filename of the file the header will be written to.
	* @param uiOffset File offset the header will be written to.
	**/
	template<int x>
	int PeHeaderT<x>::write(std::string strFilename, unsigned int uiOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}
		
		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;

		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();
		
		return NO_ERROR;
	}


	/**
	* Overwrites a section's data.
	* @param wSecnr Number of the section which will be overwritten.
	* @param strFilename Name of the file where the section will be written to.
	* @param wSecnr Number of the section that will be written.
	* @param vBuffer New data of the section.
	**/
	template<int x>
	int PeHeaderT<x>::writeSectionData(const std::string& strFilename, word wSecnr, const std::vector<byte>& vBuffer) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			ofFile.clear();

			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(getPointerToRawData(wSecnr), std::ios::beg);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), std::min(static_cast<unsigned int>(vBuffer.size()), getSizeOfRawData(wSecnr)));

		ofFile.close();
		
		return NO_ERROR;
	}

	template<int x>
	int PeHeaderT<x>::writeSections(const std::string& strFilename) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		unsigned int uiFilesize = fileSize(ofFile);

		for (int i=0;i<calcNumberOfSections();i++)
		{
			if (uiFilesize < getPointerToRawData(i) + getSizeOfRawData(i))
			{
				unsigned int uiToWrite = getPointerToRawData(i) + getSizeOfRawData(i) - uiFilesize;
				std::vector<char> vBuffer(uiToWrite);
				ofFile.seekp(0, std::ios::end);
				ofFile.write(&vBuffer[0], static_cast<unsigned int>(vBuffer.size()));
				uiFilesize = getPointerToRawData(i) + getSizeOfRawData(i);
			}
		}

		ofFile.close();
		
		return NO_ERROR;
	}

	/**
	* Returns the file's Nt signature.
	* @return The Nt signature value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getNtSignature() const
	{
		return m_inthHeader.Signature;
	}

	/**
	* Returns the file's machine.
	* @return The Machine value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getMachine() const
	{
		return m_inthHeader.FileHeader.Machine;
	}


	/**
	* Returns the file's number of sections as defined in the header. Note that this value can be different
	* from the number of defined sections (#see PeLib::PeHeaderT<x>::getNumberOfSections).
	* @return The NumberOfSections value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getNumberOfSections() const
	{
		return m_inthHeader.FileHeader.NumberOfSections;
	}

	/** 
	* Returns the file's TimeDateStamp.
	* @return The TimeDateStamp value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getTimeDateStamp() const
	{
		return m_inthHeader.FileHeader.TimeDateStamp;
	}

	/**
	* Returns the relative virtual address of the file's symbol table.
	* @return The PointerToSymbolTable value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getPointerToSymbolTable() const
	{
		return m_inthHeader.FileHeader.PointerToSymbolTable;
	}

	/**
	* Returns the number of symbols of the file's symbol table.
	* @return The NumberOfSymbols value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getNumberOfSymbols() const
	{
		return m_inthHeader.FileHeader.NumberOfSymbols;
	}

	/**
	* Returns the size of optional header of the file.
	* @return The SizeOfOptionalHeader value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getSizeOfOptionalHeader() const
	{
		return m_inthHeader.FileHeader.SizeOfOptionalHeader;
	}

	/**
	* @return The Characteristics value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getCharacteristics() const
	{
		return m_inthHeader.FileHeader.Characteristics;
	}

	/**
	* @return The Magic value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getMagic() const
	{
		return m_inthHeader.OptionalHeader.Magic;
	}

	/**
	* @return The MajorLinkerVersion value from the PE header.
	**/
	template<int x>
	byte PeHeaderT<x>::getMajorLinkerVersion() const
	{
		return m_inthHeader.OptionalHeader.MajorLinkerVersion;
	}

	/**
	* @return The MinorLinkerVersion value from the PE header.
	**/
	template<int x>
	byte PeHeaderT<x>::getMinorLinkerVersion() const
	{
		return m_inthHeader.OptionalHeader.MinorLinkerVersion;
	}

	/**
	* @return The SizeOfCode value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getSizeOfCode() const
	{
		return m_inthHeader.OptionalHeader.SizeOfCode;
	}

	/**
	* @return The SizeOfInitializedData value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getSizeOfInitializedData() const
	{
		return m_inthHeader.OptionalHeader.SizeOfInitializedData;
	}

	/**
	* @return The SizeOfUninitializedData value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getSizeOfUninitializedData() const
	{
		return m_inthHeader.OptionalHeader.SizeOfUninitializedData;
	}

	/**
	* @return The AddressOfEntryPoint value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getAddressOfEntryPoint() const
	{
		return m_inthHeader.OptionalHeader.AddressOfEntryPoint;
	}

	/**
	* @return The BaseOfCode value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getBaseOfCode() const
	{
		return m_inthHeader.OptionalHeader.BaseOfCode;
	}

	/**
	* @return The ImageBase value from the PE header.
	**/
	template<int x>
	typename FieldSizes<x>::VAR4_8 PeHeaderT<x>::getImageBase() const
	{
		return m_inthHeader.OptionalHeader.ImageBase;
	}

	/**
	* @return The SectionAlignment value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getSectionAlignment() const
	{
		return m_inthHeader.OptionalHeader.SectionAlignment;
	}

	/**
	* @return The FileAlignment value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getFileAlignment() const
	{
		return m_inthHeader.OptionalHeader.FileAlignment;
	}

	/**
	* @return The MajorOperatingSystemVersion value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getMajorOperatingSystemVersion() const
	{
		return m_inthHeader.OptionalHeader.MajorOperatingSystemVersion;
	}

	/**
	* @return The MinorOperatingSystemVersion value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getMinorOperatingSystemVersion() const
	{
		return m_inthHeader.OptionalHeader.MinorOperatingSystemVersion;
	}

	/**
	* @return The MajorImageVersion value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getMajorImageVersion() const
	{
		return m_inthHeader.OptionalHeader.MajorImageVersion;
	}

	/**
	* @return The MinorImageVersion value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getMinorImageVersion() const
	{
		return m_inthHeader.OptionalHeader.MinorImageVersion;
	}

	/**
	* @return The MajorSubsystemVersion value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getMajorSubsystemVersion() const
	{
		return m_inthHeader.OptionalHeader.MajorSubsystemVersion;
	}

	/**
	* @return The MinorSubsystemVersion value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getMinorSubsystemVersion() const
	{
		return m_inthHeader.OptionalHeader.MinorSubsystemVersion;
	}

	/**
	* @return The WinVersionValue value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getWin32VersionValue() const
	{
		return m_inthHeader.OptionalHeader.Win32VersionValue;
	}

	/**
	* @return The SizeOfImage value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getSizeOfImage() const
	{
		return m_inthHeader.OptionalHeader.SizeOfImage;
	}

	/**
	* @return The SizeOfHeaders value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getSizeOfHeaders() const
	{
		return m_inthHeader.OptionalHeader.SizeOfHeaders;
	}

	/**
	* @return The CheckSums value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getCheckSum() const
	{
		return m_inthHeader.OptionalHeader.CheckSum;
	}

	/**
	* @return The Subsystem value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getSubsystem() const
	{
		return m_inthHeader.OptionalHeader.Subsystem;
	}

	/**
	* @return The DllCharacteristics value from the PE header.
	**/
	template<int x>
	word PeHeaderT<x>::getDllCharacteristics() const
	{
		return m_inthHeader.OptionalHeader.DllCharacteristics;
	}

	/**
	* @return The SizeOfStackReserve value from the PE header.
	**/
	template<int x>
	typename FieldSizes<x>::VAR4_8 PeHeaderT<x>::getSizeOfStackReserve() const
	{
		return m_inthHeader.OptionalHeader.SizeOfStackReserve;
	}

	/**
	* @return The SizeOfStackCommit value from the PE header.
	**/
	template<int x>
	typename FieldSizes<x>::VAR4_8  PeHeaderT<x>::getSizeOfStackCommit() const
	{
		return m_inthHeader.OptionalHeader.SizeOfStackCommit;
	}

	/**
	* @return The SizeOfHeapReserve value from the PE header.
	**/
	template<int x>
	typename FieldSizes<x>::VAR4_8  PeHeaderT<x>::getSizeOfHeapReserve() const
	{
		return m_inthHeader.OptionalHeader.SizeOfHeapReserve;
	}

	/**
	* @return The SizeOfHeapCommit value from the PE header.
	**/
	template<int x>
	typename FieldSizes<x>::VAR4_8  PeHeaderT<x>::getSizeOfHeapCommit() const
	{
		return m_inthHeader.OptionalHeader.SizeOfHeapCommit;
	}

	/**
	* @return The LoaderFlags value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getLoaderFlags() const
	{
		return m_inthHeader.OptionalHeader.LoaderFlags;
	}

	/**
	* @return The NumberOfRvaAndSizes value from the PE header.
	**/
	template<int x>
	dword PeHeaderT<x>::getNumberOfRvaAndSizes() const
	{
		return m_inthHeader.OptionalHeader.NumberOfRvaAndSizes;
	}

	template<int x>
	dword PeHeaderT<x>::calcNumberOfRvaAndSizes() const
	{
		return static_cast<dword>(m_inthHeader.dataDirectories.size());
	}

	/**
	* Returns the relative virtual address of the current file's export directory.
	* @return The Rva of the Export directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddExportRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	}

	/**
	* Returns the size of the current file's export directory.
	* @return The sizeof the Export directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddExportSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
	}

	/**
	* Returns the relative virtual address of the current file's import directory.
	* @return The Rva of the Import directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddImportRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	}

	/**
	* Returns the size of the current file's import directory.
	* @return The size of the Import directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddImportSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
	}

	/**
	* Returns the relative virtual address of the current file's resource directory.
	* @return The Rva of the Resource directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddResourceRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
	}

	/**
	* Returns the size of the current file'resource resource directory.
	* @return The size of the Resource directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddResourceSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
	}

	/**
	* Returns the relative virtual address of the current file's exception directory.
	* @return The Rva of the Exception directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddExceptionRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
	}

	/**
	* Returns the size of the current file's exception directory.
	* @return The size of the Exception directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddExceptionSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
	}

	/**
	* Returns the relative virtual address of the current file's security directory.
	* @return The Rva of the Security directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddSecurityRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress;
	}

	/**
	* Returns the size of the current file's security directory.
	* @return The size of the Security directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddSecuritySize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY].Size;
	}

	/**
	* Returns the relative virtual address of the current file's base reloc directory.
	* @return The Rva of the Base Reloc directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddBaseRelocRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
	}

	/**
	* Returns the size of the current file's base reloc directory.
	* @return The size of the Base Reloc directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddBaseRelocSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
	}

	/**
	* Returns the relative virtual address of the current file's debug directory.
	* @return The Rva of the Debug directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddDebugRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
	}

	/**
	* Returns the size of the current file's debug directory.
	* @return The size of the Debug directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddDebugSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
	}

	/**
	* Returns the relative virtual address of the current file's Architecture directory.
	* @return The Rva of the Architecture directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddArchitectureRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_ARCHITECTURE].VirtualAddress;
	}

	/**
	* Returns the size of the current file's Architecture directory.
	* @return The size of the Architecture directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddArchitectureSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_ARCHITECTURE].Size;
	}

	/**
	* Returns the relative virtual address of the current file's global ptr directory.
	* @return The Rva of the GlobalPtr directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddGlobalPtrRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress;
	}

	/**
	* Returns the size of the current file's global ptr directory.
	* @return The size of the GlobalPtr directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddGlobalPtrSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_GLOBALPTR].Size;
	}

	/**
	* Returns the relative virtual address of the current file's TLS directory.
	* @return The Rva of the Tls directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddTlsRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
	}

	/**
	* Returns the size of the current file's TLS directory.
	* @return The size of the Tls directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddTlsSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_TLS].Size;
	}

	/**
	* Returns the relative virtual address of the current file's load config directory.
	* @return The Rva of the LoadConfig directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddLoadConfigRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
	}

	/**
	* Returns the size of the current file's load config directory.
	* @return The size of the LoadConfig directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddLoadConfigSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size;
	}

	/**
	* Returns the relative virtual address of the current file's bound import directory.
	* @return The Rva of the BoundImport directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddBoundImportRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
	}

	/**
	* Returns the size of the current file's bound import directory.
	* @return The size of the BoundImport directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddBoundImportSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;
	}

	/**
	* Returns the relative virtual address of the current file's IAT directory.
	* @return The Rva of the IAT directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddIatRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;
	}

	/**
	* Returns the size of the current file's IAT directory.
	* @return The size of the IAT directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddIatSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_IAT].Size;
	}

	/**
	* Returns the relative virtual address of the current file's Delay Import directory.
	* @return The Rva of the DelayImport directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddDelayImportRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress;
	}

	/**
	* Returns the size of the current file's Delay Import directory.
	* @return The size of the DelayImport directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddDelayImportSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size;
	}

	/**
	* Returns the relative virtual address of the current file's COM Descriptor directory.
	* @return The Rva of the COM Descriptor directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddComHeaderRva() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress;
	}
	
	/**
	* Returns the size of the current file's COM Descriptor directory.
	* @return The Rva of the COM Descriptor directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getIddComHeaderSize() const
	{
		return m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size;
	}

	/**
	* Returns the relative virtual address of an image directory.
	* @param dwDirectory The identifier of an image directory.
	* @return The Rva of the image directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getImageDataDirectoryRva(dword dwDirectory) const
	{
		return m_inthHeader.dataDirectories[dwDirectory].VirtualAddress;
	}

	template<int x>
	void PeHeaderT<x>::setImageDataDirectoryRva(dword dwDirectory, dword value)
	{
		m_inthHeader.dataDirectories[dwDirectory].VirtualAddress = value;
	}

	/**
	* Returns the size of an image directory.
	* @param dwDirectory The identifier of an image directory.
	* @return The size of the image directory.
	**/
	template<int x>
	dword PeHeaderT<x>::getImageDataDirectorySize(dword dwDirectory) const
	{
		return m_inthHeader.dataDirectories[dwDirectory].Size;
	}

	template<int x>
	void PeHeaderT<x>::setImageDataDirectorySize(dword dwDirectory, dword value)
	{
		m_inthHeader.dataDirectories[dwDirectory].Size = value;
	}

	/**
	* Returns the name of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The name of the section.
	**/
	template<int x>
	std::string PeHeaderT<x>::getSectionName(word wSectionnr) const
	{
		std::string sectionName = "";
		
		for (unsigned int i=0;i<sizeof(m_vIsh[wSectionnr].Name);i++)
		{
			if (m_vIsh[wSectionnr].Name[i]) sectionName += m_vIsh[wSectionnr].Name[i];
		}
		
		return sectionName;
	}
	
	/**
	* Returns the virtual size of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The virtual size of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getVirtualSize(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].VirtualSize;
	}
	
	/**
	* Returns the relative virtual address of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The Rva of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getVirtualAddress(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].VirtualAddress;
	}
	
	/**
	* Returns the size of raw data of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The size of raw data of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getSizeOfRawData(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].SizeOfRawData;
	}

	/**
	* Returns the file offset of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The file offset of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getPointerToRawData(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].PointerToRawData;
	}

	/**
	* Returns the pointer to relocations of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The pointer to relocations of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getPointerToRelocations(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].PointerToRelocations;
	}

	/**
	* Returns the poiner to line numbers of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The pointer to line numbers of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getPointerToLinenumbers(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].PointerToLinenumbers;
	}

	/**
	* Returns the number of relocations of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The number of relocations of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getNumberOfRelocations(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].NumberOfRelocations;
	}

	/**
	* Returns the number of line numbers of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The number of line numbers of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getNumberOfLinenumbers(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].NumberOfLinenumbers;
	}

	/**
	* Returns the characteristics of the section which is specified by the parameter wSectionnr.
	* @param wSectionnr Index of the section.
	* @return The characteristics of the section.
	**/
	template<int x>
	dword PeHeaderT<x>::getCharacteristics(word wSectionnr) const
	{
		return m_vIsh[wSectionnr].Characteristics;
	}

	/**
	* Changes the file's Nt signature.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setNtSignature(dword dwValue)
	{
		m_inthHeader.Signature = dwValue;
	}

	/**
	* Changes the file's Machine.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMachine(word wValue)
	{
		m_inthHeader.FileHeader.Machine = wValue;
	}

	/**
	* Changes the number of sections.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setNumberOfSections(word wValue)
	{
		m_inthHeader.FileHeader.NumberOfSections = wValue;
	}

	/**
	* Changes the file's TimeDateStamp.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setTimeDateStamp(dword dwValue)
	{
		m_inthHeader.FileHeader.TimeDateStamp = dwValue;
	}

	/**
	* Changes the file's PointerToSymbolTable.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setPointerToSymbolTable(dword dwValue)
	{
		m_inthHeader.FileHeader.PointerToSymbolTable = dwValue;
	}

	/**
	* Changes the file's NumberOfSymbols.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setNumberOfSymbols(dword dwValue)
	{
		m_inthHeader.FileHeader.NumberOfSymbols = dwValue;
	}

	/**
	* Changes the file's SizeOfOptionalHeader.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfOptionalHeader(word wValue)
	{
		m_inthHeader.FileHeader.SizeOfOptionalHeader = wValue;
	}

	/**
	* Changes the file's Characteristics.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setCharacteristics(word wValue)
	{
		m_inthHeader.FileHeader.Characteristics = wValue;
	}

	/**
	* Changes the file's Magic.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMagic(word wValue)
	{
		m_inthHeader.OptionalHeader.Magic = wValue;
	}

	/**
	* Changes the file's MajorLinkerVersion.
	* @param bValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMajorLinkerVersion(byte bValue)
	{
		m_inthHeader.OptionalHeader.MajorLinkerVersion = bValue;
	}

	/**
	* Changes the file's MinorLinkerVersion.
	* @param bValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMinorLinkerVersion(byte bValue)
	{
		m_inthHeader.OptionalHeader.MinorLinkerVersion = bValue;
	}

	/**
	* Changes the file's SizeOfCode.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfCode(dword dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfCode = dwValue;
	}

	/**
	* Changes the file's SizeOfInitializedData.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfInitializedData(dword dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfInitializedData = dwValue;
	}

	/**
	* Changes the file's SizeOfUninitializedData.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfUninitializedData(dword dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfUninitializedData = dwValue;
	}

	/**
	* Changes the file's AddressOfEntryPoint.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setAddressOfEntryPoint(dword dwValue)
	{
		m_inthHeader.OptionalHeader.AddressOfEntryPoint = dwValue;
	}

	/**
	* Changes the file's BaseOfCode.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setBaseOfCode(dword dwValue)
	{
		m_inthHeader.OptionalHeader.BaseOfCode = dwValue;
	}

	/**
	* Changes the file's ImageBase.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setImageBase(typename FieldSizes<x>::VAR4_8 dwValue)
	{
		m_inthHeader.OptionalHeader.ImageBase = dwValue;
	}

	/**
	* Changes the file's SectionAlignment.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSectionAlignment(dword dwValue)
	{
		m_inthHeader.OptionalHeader.SectionAlignment = dwValue;
	}

	/**
	* Changes the file's FileAlignment.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setFileAlignment(dword dwValue)
	{
		m_inthHeader.OptionalHeader.FileAlignment = dwValue;
	}

	/**
	* Changes the file's MajorOperatingSystemVersion.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMajorOperatingSystemVersion(word wValue)
	{
		m_inthHeader.OptionalHeader.MajorOperatingSystemVersion = wValue;
	}

	/**
	* Changes the file's MinorOperatingSystemVersion.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMinorOperatingSystemVersion(word wValue)
	{
		m_inthHeader.OptionalHeader.MinorOperatingSystemVersion = wValue;
	}

	/**
	* Changes the file's MajorImageVersion.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMajorImageVersion(word wValue)
	{
		m_inthHeader.OptionalHeader.MajorImageVersion = wValue;
	}

	/**
	* Changes the file's MinorImageVersion.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMinorImageVersion(word wValue)
	{
		m_inthHeader.OptionalHeader.MinorImageVersion = wValue;
	}

	/**
	* Changes the file's MajorSubsystemVersion.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMajorSubsystemVersion(word wValue)
	{
		m_inthHeader.OptionalHeader.MajorSubsystemVersion = wValue;
	}

	/**
	* Changes the file's MinorSubsystemVersion.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setMinorSubsystemVersion(word wValue)
	{
		m_inthHeader.OptionalHeader.MinorSubsystemVersion = wValue;
	}

	/**
	* Changes the file's Win32VersionValue.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setWin32VersionValue(dword dwValue)
	{
		m_inthHeader.OptionalHeader.Win32VersionValue = dwValue;
	}

	/**
	* Changes the file's SizeOfImage.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfImage(dword dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfImage = dwValue;
	}

	/**
	* Changes the file's SizeOfHeaders.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfHeaders(dword dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfHeaders = dwValue;
	}

	/**
	* Changes the file's CheckSum.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setCheckSum(dword dwValue)
	{
		m_inthHeader.OptionalHeader.CheckSum = dwValue;
	}

	/**
	* Changes the file's Subsystem.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSubsystem(word wValue)
	{
		m_inthHeader.OptionalHeader.Subsystem = wValue;
	}

	/**
	* Changes the file's DllCharacteristics.
	* @param wValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setDllCharacteristics(word wValue)
	{
		m_inthHeader.OptionalHeader.DllCharacteristics = wValue;
	}

	/**
	* Changes the file's SizeOfStackReserve.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfStackReserve(typename FieldSizes<x>::VAR4_8 dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfStackReserve = dwValue;
	}

	/**
	* Changes the file's SizeOfStackCommit.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfStackCommit(typename FieldSizes<x>::VAR4_8 dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfStackCommit = dwValue;
	}

	/**
	* Changes the file's SizeOfHeapReserve.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfHeapReserve(typename FieldSizes<x>::VAR4_8 dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfHeapReserve = dwValue;
	}

	/**
	* Changes the file's SizeOfHeapCommit.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfHeapCommit(typename FieldSizes<x>::VAR4_8 dwValue)
	{
		m_inthHeader.OptionalHeader.SizeOfHeapCommit = dwValue;
	}

	/**
	* Changes the file's LoaderFlags.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setLoaderFlags(dword dwValue)
	{
		m_inthHeader.OptionalHeader.LoaderFlags = dwValue;
	}

	/**
	* Changes the file's NumberOfRvaAndSizes.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setNumberOfRvaAndSizes(dword dwValue)
	{
		m_inthHeader.OptionalHeader.NumberOfRvaAndSizes = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddDebugRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddDebugSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG].Size = dwValue;
	}
	
	template<int x>
	void PeHeaderT<x>::setIddDelayImportRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddDelayImportSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size = dwValue;
	}
	
	template<int x>
	void PeHeaderT<x>::setIddExceptionRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddExceptionSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size = dwValue;
	}
	
	template<int x>
	void PeHeaderT<x>::setIddGlobalPtrRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddGlobalPtrSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_GLOBALPTR].Size = dwValue;
	}
	
	template<int x>
	void PeHeaderT<x>::setIddIatRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddIatSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_IAT].Size = dwValue;
	}
	
	template<int x>
	void PeHeaderT<x>::setIddLoadConfigRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddLoadConfigSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size = dwValue;
	}
	
	template<int x>
	void PeHeaderT<x>::setIddResourceRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddResourceSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = dwValue;
	}
	
	template<int x>
	void PeHeaderT<x>::setIddSecurityRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddSecuritySize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY].Size = dwValue;
	}
	
	template<int x>
	void PeHeaderT<x>::setIddTlsRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddTlsSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_TLS].Size = dwValue;
	}
	
	/**
	* Changes the rva of the file's export directory.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setIddExportRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = dwValue;
	}

	/**
	* Changes the size of the file's export directory.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setIddExportSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT].Size = dwValue;
	}

	template<int x>
	void PeHeaderT<x>::setIddBaseRelocRva(dword value)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = value;
	}

	template<int x>
	void PeHeaderT<x>::setIddBaseRelocSize(dword value)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = value;
	}

	template<int x>
	void PeHeaderT<x>::setIddArchitectureRva(dword value)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_ARCHITECTURE].VirtualAddress = value;
	}

	template<int x>
	void PeHeaderT<x>::setIddArchitectureSize(dword value)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_ARCHITECTURE].Size = value;
	}

	template<int x>
	void PeHeaderT<x>::setIddComHeaderRva(dword value)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress = value;
	}

	template<int x>
	void PeHeaderT<x>::setIddComHeaderSize(dword value)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].Size = value;
	}

	/**
	* Changes the rva of the file's import directory.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setIddImportRva(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = dwValue;
	}

	/**
	* Changes the size of the file's import directory.
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setIddImportSize(dword dwValue)
	{
		m_inthHeader.dataDirectories[PELIB_IMAGE_DIRECTORY_ENTRY_IMPORT].Size = dwValue;
	}

	/**
	* Changes the name of a section.
	* @param wSectionnr Identifier of the section
	* @param strName New name.
	**/
	template<int x>
	void PeHeaderT<x>::setSectionName(word wSectionnr, std::string strName)
	{
		strncpy(reinterpret_cast<char*>(m_vIsh[wSectionnr].Name), strName.c_str(), sizeof(m_vIsh[wSectionnr].Name));
	}

	/**
	* Changes the virtual size of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setVirtualSize(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].VirtualSize = dwValue;
	}

	/**
	* Changes the virtual address of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setVirtualAddress(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].VirtualAddress = dwValue;
	}

	/**
	* Changes the size of raw data of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setSizeOfRawData(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].SizeOfRawData = dwValue;
	}

	/**
	* Changes the size of raw data of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setPointerToRawData(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].PointerToRawData = dwValue;
	}

	/**
	* Changes the pointer to relocations of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setPointerToRelocations(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].PointerToRelocations = dwValue;
	}

	/**
	* Changes the pointer to line numbers of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setPointerToLinenumbers(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].PointerToLinenumbers = dwValue;
	}

	/**
	* Changes the number of relocations of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setNumberOfRelocations(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].NumberOfRelocations = dwValue;
	}

	/**
	* Changes the number of line numbers of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setNumberOfLinenumbers(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].NumberOfLinenumbers = dwValue;
	}

	/**
	* Changes the characteristics of a section.
	* @param wSectionnr Identifier of the section
	* @param dwValue New value.
	**/
	template<int x>
	void PeHeaderT<x>::setCharacteristics(word wSectionnr, dword dwValue)
	{
		m_vIsh[wSectionnr].Characteristics = dwValue;
	}

}

#endif

```

`deps/PeLib/PeLib.h`:

```h
/*
* PeLib.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/


/** \mainpage PeLib - An open-source C++ library to modify PE files.
*
* \section intro Introduction
*
* <b>What is PeLib?</b><br>
* PeLib is an open source C++ library with the purpose to ease the access and modification of PE (Portable executable) files. This is done through a multitude of classes which represent all important PE header and directory structures and which provide the necessary functions to read, modify and write these structures. As this library is fully ISO C++ compliant it should compile with all popular compilers for the Windows platform. For people who don't use C++ in their projects a dynamic link library is provided which encapsulates all of PeLib's functionality so that projects using programming languages as diverse as Win32 assembler, C# or Delphi can still benefit from PeLib's power
*/

#ifndef PELIB_H
#define PELIB_H

#include "PeFile.h"

#endif

```

`deps/PeLib/PeLib.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26730.12
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PeLib", "PeLib.vcxproj", "{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}.Debug|Win32.ActiveCfg = Debug|Win32
		{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}.Debug|Win32.Build.0 = Debug|Win32
		{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}.Debug|x64.ActiveCfg = Debug|x64
		{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}.Debug|x64.Build.0 = Debug|x64
		{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}.Release|Win32.ActiveCfg = Release|Win32
		{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}.Release|Win32.Build.0 = Release|Win32
		{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}.Release|x64.ActiveCfg = Release|x64
		{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`deps/PeLib/PeLib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3AC095C1-D5B3-4C77-8B1B-DE338EC27E82}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>pelib</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.15063.0</WindowsTargetPlatformVersion>
    <ProjectName>PeLib</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\</OutDir>
    <TargetName>$(ProjectName)32d</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)\</OutDir>
    <TargetName>$(ProjectName)64d</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\</OutDir>
    <TargetName>$(ProjectName)32</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\</OutDir>
    <TargetName>$(ProjectName)54</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;PELIB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ProgramDataBaseFileName>$(OutDir)$(ProjectName)32d.pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;PELIB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ProgramDataBaseFileName>$(OutDir)$(ProjectName)64d.pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;PELIB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ProgramDataBaseFileName>$(OutDir)$(ProjectName)32.pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;PELIB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ProgramDataBaseFileName>$(OutDir)$(ProjectName)64.pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="BoundImportDirectory.h" />
    <ClInclude Include="buffer\InputBuffer.h" />
    <ClInclude Include="buffer\OutputBuffer.h" />
    <ClInclude Include="ComHeaderDirectory.h" />
    <ClInclude Include="DebugDirectory.h" />
    <ClInclude Include="ExportDirectory.h" />
    <ClInclude Include="IatDirectory.h" />
    <ClInclude Include="ImportDirectory.h" />
    <ClInclude Include="MzHeader.h" />
    <ClInclude Include="PeFile.h" />
    <ClInclude Include="PeHeader.h" />
    <ClInclude Include="PeLib.h" />
    <ClInclude Include="PeLibAux.h" />
    <ClInclude Include="PeLibInc.h" />
    <ClInclude Include="RelocationsDirectory.h" />
    <ClInclude Include="ResourceDirectory.h" />
    <ClInclude Include="TlsDirectory.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="BoundImportDirectory.cpp" />
    <ClCompile Include="buffer\InputBuffer.cpp" />
    <ClCompile Include="buffer\OutputBuffer.cpp" />
    <ClCompile Include="ComHeaderDirectory.cpp" />
    <ClCompile Include="DebugDirectory.cpp" />
    <ClCompile Include="ExportDirectory.cpp" />
    <ClCompile Include="IatDirectory.cpp" />
    <ClCompile Include="MzHeader.cpp" />
    <ClCompile Include="PeFile.cpp" />
    <ClCompile Include="PeHeader.cpp" />
    <ClCompile Include="PeLibAux.cpp" />
    <ClCompile Include="RelocationsDirectory.cpp" />
    <ClCompile Include="ResourceDirectory.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`deps/PeLib/PeLibAux.cpp`:

```cpp
/*
* PeLibAux.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "PeLibInc.h"
#include "PeLibAux.h"
#include "PeFile.h"

#ifdef _MSC_VER
	#include <ctype.h>
#endif

namespace PeLib
{
    const qword PELIB_IMAGE_ORDINAL_FLAGS<64>::IMAGE_ORDINAL_FLAG = 0x8000000000000000ULL;
	
	bool PELIB_IMAGE_SECTION_HEADER::biggerFileOffset(const PELIB_IMAGE_SECTION_HEADER& ish) const
	{
		return PointerToRawData < ish.PointerToRawData;
	}

	bool PELIB_IMAGE_SECTION_HEADER::biggerVirtualAddress(const PELIB_IMAGE_SECTION_HEADER& ish) const
	{
		return VirtualAddress < ish.VirtualAddress;
	}

	unsigned int alignOffset(unsigned int uiOffset, unsigned int uiAlignment)
	{
		if (!uiAlignment) return uiAlignment;
		return (uiOffset % uiAlignment) ? uiOffset + (uiAlignment - uiOffset % uiAlignment) : uiOffset;
	}

	unsigned int fileSize(const std::string& filename)
	{
		std::fstream file(filename.c_str());
		file.seekg(0, std::ios::end);
		return file.tellg();
	}

	unsigned int fileSize(std::ifstream& file)
	{
		unsigned int oldpos = file.tellg();
		file.seekg(0, std::ios::end);
		unsigned int filesize = file.tellg();
		file.seekg(oldpos, std::ios::beg);
		return filesize;
	}
	
	unsigned int fileSize(std::fstream& file)
	{
		unsigned int oldpos = file.tellg();
		file.seekg(0, std::ios::end);
		unsigned int filesize = file.tellg();
		file.seekg(oldpos, std::ios::beg);
		return filesize;
	}
	
	unsigned int fileSize(std::ofstream& file)
	{
		unsigned int oldpos = file.tellp();
		file.seekp(0, std::ios::end);
		unsigned int filesize = file.tellp();
		file.seekp(oldpos, std::ios::beg);
		return filesize;
	}
	
	bool isEqualNc(const std::string& s1, const std::string& s2)
	{
		std::string t1 = s1;
		std::string t2 = s2;
	
		// No std:: to make VC++ happy
		#ifdef _MSC_VER
			std::transform(t1.begin(), t1.end(), t1.begin(), toupper);
			std::transform(t2.begin(), t2.end(), t2.begin(), toupper);
		#else
			// Weird syntax to make Borland C++ happy
			std::transform(t1.begin(), t1.end(), t1.begin(), (int(*)(int))std::toupper);
			std::transform(t2.begin(), t2.end(), t2.begin(), (int(*)(int))std::toupper);
		#endif
		return t1 == t2;
	}

	PELIB_IMAGE_DOS_HEADER::PELIB_IMAGE_DOS_HEADER()
	{
		e_magic = 0;
		e_cblp = 0;
		e_cp = 0;
		e_crlc = 0;
		e_cparhdr = 0;
		e_minalloc = 0;
		e_maxalloc = 0;
		e_ss = 0;
		e_sp = 0;
		e_csum = 0;
		e_ip = 0;
		e_cs = 0;
		e_lfarlc = 0;
		e_ovno = 0;

		for (unsigned int i=0;i<sizeof(e_res)/sizeof(e_res[0]);i++)
		{
			e_res[i] = 0;
		}

		e_oemid = 0;
		e_oeminfo = 0;

		for (unsigned int i=0;i<sizeof(e_res2)/sizeof(e_res2[0]);i++)
		{
			e_res2[i] = 0;
		}

		e_lfanew = 0;
	}

	PELIB_EXP_FUNC_INFORMATION::PELIB_EXP_FUNC_INFORMATION()
	{
		addroffunc = 0;
		addrofname = 0;
		ordinal = 0;
	}

	PELIB_IMAGE_RESOURCE_DIRECTORY::PELIB_IMAGE_RESOURCE_DIRECTORY()
	{
		Characteristics = 0;
		TimeDateStamp = 0;
		MajorVersion = 0;
		MinorVersion = 0;
		NumberOfNamedEntries = 0;
		NumberOfIdEntries = 0;
	}

	PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY()
	{
		Name = 0;
		OffsetToData = 0;
	}

	bool PELIB_IMG_RES_DIR_ENTRY::operator<(const PELIB_IMG_RES_DIR_ENTRY& first) const
	{
		if (irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING && first.irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
		{
			return wstrName < first.wstrName;
		}
		else if (irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
		{
			return true;
		}
		else if (first.irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
		{
			return false;
		}
		else
		{
			return irde.Name < first.irde.Name;
		}
	}

	PELIB_IMAGE_BASE_RELOCATION::PELIB_IMAGE_BASE_RELOCATION()
	{
		VirtualAddress = 0;
		SizeOfBlock = 0;
	}

	PELIB_IMAGE_COR20_HEADER::PELIB_IMAGE_COR20_HEADER()
	{
		cb = 0;
		MajorRuntimeVersion = 0;
		MinorRuntimeVersion = 0;
		MetaData.VirtualAddress = 0;
		MetaData.Size = 0;
		Flags = 0;
		EntryPointToken = 0;
		Resources.VirtualAddress = 0;
		Resources.Size = 0;
		StrongNameSignature.VirtualAddress = 0;
		StrongNameSignature.Size = 0;
		CodeManagerTable.VirtualAddress = 0;
		CodeManagerTable.Size = 0;
		VTableFixups.VirtualAddress = 0;
		VTableFixups.Size = 0;
		ExportAddressTableJumps.VirtualAddress = 0;
		ExportAddressTableJumps.Size = 0;
		ManagedNativeHeader.VirtualAddress = 0;
		ManagedNativeHeader.Size = 0;
	}

	/** Compares the passed filename to the struct's filename.
	* @param strModuleName A filename.
	* @return True, if the passed filename equals the struct's filename. The comparison is case-sensitive.
	**/
	bool PELIB_IMAGE_BOUND_DIRECTORY::equal(const std::string strModuleName) const
	{
		return this->strModuleName == strModuleName;
	}

	bool PELIB_EXP_FUNC_INFORMATION::equal(const std::string strFunctionName) const
	{
		return isEqualNc(this->funcname, strFunctionName);
	}
	
	/**
	* @param strFilename Name of a file.
	* @return Either PEFILE32, PEFILE64 or PEFILE_UNKNOWN
	**/
	unsigned int getFileType(const std::string strFilename)
	{
		word machine, magic;
		
		PeFile32 pef(strFilename);
		if (pef.readMzHeader() != NO_ERROR) return PEFILE_UNKNOWN;
		if (pef.readPeHeader() != NO_ERROR) return PEFILE_UNKNOWN;
			
		machine = pef.peHeader().getMachine();
		magic = pef.peHeader().getMagic();
	
		if (machine == PELIB_IMAGE_FILE_MACHINE_I386 && magic == PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC)
		{
			return PEFILE32;
		}
		// 0x8664 == AMD64; no named constant yet
		else if ((machine == 0x8664 || machine == PELIB_IMAGE_FILE_MACHINE_IA64) && magic == PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC)
		{
			return PEFILE64;
		}
		else
		{
			return PEFILE_UNKNOWN;
		}
	}
	
	/**
	* Opens a PE file. The return type is either PeFile32 or PeFile64 object. If an error occurs the return
	* value is 0.
	* @param strFilename Name of a file.
	* @return Either a PeFile32 object, a PeFil64 object or 0.
	**/
	PeFile* openPeFile(const std::string& strFilename)
	{
		unsigned int type = getFileType(strFilename);
		
		if (type == PEFILE32)
		{
			return new PeFile32(strFilename);
		}
		else if (type == PEFILE64)
		{
			return new PeFile64(strFilename);
		}
		else
		{
			return 0;
		}
	}
	
	unsigned int PELIB_IMAGE_BOUND_DIRECTORY::size() const
	{
		unsigned int size = 0;
		for (unsigned int i=0;i<moduleForwarders.size();i++)
		{
			size += moduleForwarders[i].size();
		}

		return size + PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR::size() + strModuleName.size() + 1;
	}
}

```

`deps/PeLib/PeLibAux.h`:

```h
/*
* PeLibAux.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef PELIBAUX_H
#define PELIBAUX_H

//#include "PeLibInc.h"
//#include "PeHeader.h"
#include "buffer/OutputBuffer.h"
#include "buffer/InputBuffer.h"
//#include "buffer/ResTree.h"
#include <numeric>
#include <limits>

namespace PeLib
{
	enum errorCodes
	{
		NO_ERROR = 0,
		ERROR_OPENING_FILE = -1,
		ERROR_INVALID_FILE = -2,
		ERROR_TOO_MANY_SECTIONS = -3,
		ERROR_NOT_ENOUGH_SPACE = -4,
		ERROR_NO_FILE_ALIGNMENT = -5,
		ERROR_NO_SECTION_ALIGNMENT = -6,
		ERROR_ENTRY_NOT_FOUND = -7,
		ERROR_DUPLICATE_ENTRY = -8,
		ERROR_DIRECTORY_DOES_NOT_EXIST = -9
	};

	class PeFile;
	
// It's necessary to make sure that a byte has 8 bits and that the platform has a 8 bit type,
// a 16bit type and a bit type. That's because binary PE files are pretty picky about their
// structure.

	#if CHAR_BIT == 8
		#if UCHAR_MAX == 255
			typedef unsigned char byte;
	//		typedef std::bitset<8> byte;
		#else
			#error You need to change some typedefs (Code: 8). Please read the PeLib documentation.
		#endif
	
		#if USHRT_MAX == 65535U
			typedef unsigned short word;
	//		typedef std::bitset<16> word;
		#else
			#error You need to change some typedefs (Code: 16). Please read the PeLib documentation.
		#endif
	
		#if UINT_MAX == 4294967295UL
			typedef unsigned int dword;
	//		typedef std::bitset<32> dword;
		#else
			#error You need to change some typedefs (Code: 32). Please read the PeLib documentation.
		#endif

		typedef unsigned long long qword;
	
//		#if ULLONG_MAX == 18446744073709551615
//			typedef unsigned long long qword;
//		#else
//			#error You need to change some typedefs (Code: 32). Please read the PeLib documentation.
//		#endif
	#else
		#error You need to change some typedefs. Please read the PeLib documentation.
	#endif


/*	enum bits {BITS_BYTE = 8, BITS_WORD = 16, BITS_DWORD = 32};

	template<bits value>
	class DataType
	{
		private:
		  std::bitset<value> bsValue;
		  unsigned long ulValue;
	  
		public:
		  void operator=(unsigned long ulValue)
		  {
			bsValue = ulValue;
		  }

		  operator unsigned long() const
		  {
			return bsValue.to_ulong();
		  }
		  
		  const int operator&()
		  {
		  	ulValue = bsValue;
		  	return ulValue;	
		  }

	};

	typedef DataType<BITS_BYTE> byte;
	typedef DataType<BITS_WORD> word;
	typedef DataType<BITS_DWORD> dword;
*/

	enum {PEFILE32 = 32,
		  PEFILE64 = 64,
		  PEFILE_UNKNOWN = 0};

	enum {BoundImportDirectoryId = 1,
	      ComHeaderDirectoryId,
	      ExportDirectoryId,
	      IatDirectoryId,
	      ImportDirectoryId,
	      MzHeaderId,
	      PeHeaderId,
	      RelocationsId,
	      PeFileId,
	      ResourceDirectoryId,
	      DebugDirectoryId,
	      TlsDirectoryId
	};

	const word PELIB_IMAGE_DOS_SIGNATURE = 0x5A4D;
	
	const dword PELIB_IMAGE_NT_SIGNATURE = 0x00004550;

	template<int bits>
	struct PELIB_IMAGE_ORDINAL_FLAGS;
	
	template<>
	struct PELIB_IMAGE_ORDINAL_FLAGS<32>
	{
		static const dword IMAGE_ORDINAL_FLAG = 0x80000000;
	};
	
	template<>
	struct PELIB_IMAGE_ORDINAL_FLAGS<64>
	{
		static const qword IMAGE_ORDINAL_FLAG;
	};

	const unsigned long PELIB_IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

	const unsigned long PELIB_IMAGE_RESOURCE_NAME_IS_STRING = 0x80000000;

	const unsigned long PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY = 0x80000000;

	enum
	{
		PELIB_IMAGE_DIRECTORY_ENTRY_EXPORT,		// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_IMPORT,		// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_RESOURCE,		// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_EXCEPTION,
		PELIB_IMAGE_DIRECTORY_ENTRY_SECURITY,
		PELIB_IMAGE_DIRECTORY_ENTRY_BASERELOC,	// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_DEBUG,
		PELIB_IMAGE_DIRECTORY_ENTRY_ARCHITECTURE,
		PELIB_IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
		PELIB_IMAGE_DIRECTORY_ENTRY_TLS,
		PELIB_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
		PELIB_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,	// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_IAT,		// OK
		PELIB_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT,
		PELIB_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR
	};

	enum
	{
		PELIB_IMAGE_SCN_TYPE_NO_PAD		= 0x00000008,
		PELIB_IMAGE_SCN_CNT_CODE		   = 0x00000020,
		PELIB_IMAGE_SCN_CNT_INITIALIZED_DATA       = 0x00000040,
		PELIB_IMAGE_SCN_CNT_UNINITIALIZED_DATA     = 0x00000080,
		PELIB_IMAGE_SCN_LNK_OTHER		  = 0x00000100,
		PELIB_IMAGE_SCN_LNK_INFO		   = 0x00000200,
		PELIB_IMAGE_SCN_LNK_REMOVE		 = 0x00000800,
		PELIB_IMAGE_SCN_LNK_COMDAT		 = 0x00001000,
		PELIB_IMAGE_SCN_NO_DEFER_SPEC_EXC	  = 0x00004000,
		PELIB_IMAGE_SCN_GPREL		      = 0x00008000,
		PELIB_IMAGE_SCN_MEM_FARDATA		= 0x00008000,
		PELIB_IMAGE_SCN_MEM_PURGEABLE	      = 0x00020000,
		PELIB_IMAGE_SCN_MEM_16BIT		  = 0x00020000,
		PELIB_IMAGE_SCN_MEM_LOCKED		 = 0x00040000,
		PELIB_IMAGE_SCN_MEM_PRELOAD		= 0x00080000,
		PELIB_IMAGE_SCN_ALIGN_1BYTES	       = 0x00100000,
		PELIB_IMAGE_SCN_ALIGN_2BYTES	       = 0x00200000,
		PELIB_IMAGE_SCN_ALIGN_4BYTES	       = 0x00300000,
		PELIB_IMAGE_SCN_ALIGN_8BYTES	       = 0x00400000,
		PELIB_IMAGE_SCN_ALIGN_16BYTES	      = 0x00500000,
		PELIB_IMAGE_SCN_ALIGN_BYTES		= 0x00600000,
		PELIB_IMAGE_SCN_ALIGN_64BYTES	      = 0x00700000,
		PELIB_IMAGE_SCN_ALIGN_128BYTES	     = 0x00800000,
		PELIB_IMAGE_SCN_ALIGN_256BYTES	     = 0x00900000,
		PELIB_IMAGE_SCN_ALIGN_512BYTES	     = 0x00A00000,
		PELIB_IMAGE_SCN_ALIGN_1024BYTES	    = 0x00B00000,
		PELIB_IMAGE_SCN_ALIGN_2048BYTES	    = 0x00C00000,
		PELIB_IMAGE_SCN_ALIGN_4096BYTES	    = 0x00D00000,
		PELIB_IMAGE_SCN_ALIGN_8192BYTES	    = 0x00E00000,
		PELIB_IMAGE_SCN_LNK_NRELOC_OVFL	    = 0x01000000,
		PELIB_IMAGE_SCN_MEM_DISCARDABLE	    = 0x02000000,
		PELIB_IMAGE_SCN_MEM_NOT_CACHED	     = 0x04000000,
		PELIB_IMAGE_SCN_MEM_NOT_PAGED	      = 0x08000000,
		PELIB_IMAGE_SCN_MEM_SHARED		 = 0x10000000,
		PELIB_IMAGE_SCN_MEM_EXECUTE		= 0x20000000,
		PELIB_IMAGE_SCN_MEM_READ		   = 0x40000000,
		PELIB_IMAGE_SCN_MEM_WRITE		  = 0x80000000
	};

	enum
	{
		PELIB_IMAGE_FILE_MACHINE_UNKNOWN	   = 0,
		PELIB_IMAGE_FILE_MACHINE_I386	      = 0x014c,
		PELIB_IMAGE_FILE_MACHINE_R3000	     = 0x0162,
		PELIB_IMAGE_FILE_MACHINE_R4000	     = 0x0166,
		PELIB_IMAGE_FILE_MACHINE_R10000	    = 0x0168,
		PELIB_IMAGE_FILE_MACHINE_WCEMIPSV2	 = 0x0169,
		PELIB_IMAGE_FILE_MACHINE_ALPHA	     = 0x0184,
		PELIB_IMAGE_FILE_MACHINE_POWERPC	   = 0x01F0,
		PELIB_IMAGE_FILE_MACHINE_SH3	       = 0x01a2,
		PELIB_IMAGE_FILE_MACHINE_SH3E	      = 0x01a4,
		PELIB_IMAGE_FILE_MACHINE_SH4	       = 0x01a6,
		PELIB_IMAGE_FILE_MACHINE_ARM	       = 0x01c0,
		PELIB_IMAGE_FILE_MACHINE_THUMB	     = 0x01c2,
		PELIB_IMAGE_FILE_MACHINE_IA64	      = 0x0200,
		PELIB_IMAGE_FILE_MACHINE_MIPS16	    = 0x0266,
		PELIB_IMAGE_FILE_MACHINE_MIPSFPU	   = 0x0366,
		PELIB_IMAGE_FILE_MACHINE_MIPSFPU16	 = 0x0466,
		PELIB_IMAGE_FILE_MACHINE_ALPHA64	   = 0x0284,
		PELIB_IMAGE_FILE_MACHINE_AXP64	     = PELIB_IMAGE_FILE_MACHINE_ALPHA64
	};

	enum
	{
		PELIB_IMAGE_FILE_RELOCS_STRIPPED	   = 0x0001,
		PELIB_IMAGE_FILE_EXECUTABLE_IMAGE	  = 0x0002,
		PELIB_IMAGE_FILE_LINE_NUMS_STRIPPED	= 0x0004,
		PELIB_IMAGE_FILE_LOCAL_SYMS_STRIPPED       = 0x0008,
		PELIB_IMAGE_FILE_AGGRESIVE_WS_TRIM	 = 0x0010,
		PELIB_IMAGE_FILE_LARGE_ADDRESS_AWARE       = 0x0020,
		PELIB_IMAGE_FILE_BYTES_REVERSED_LO	 = 0x0080,
		PELIB_IMAGE_FILE_32BIT_MACHINE	     = 0x0100,
		PELIB_IMAGE_FILE_DEBUG_STRIPPED	    = 0x0200,
		PELIB_IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   = 0x0400,
		PELIB_IMAGE_FILE_NET_RUN_FROM_SWAP	 = 0x0800,
		PELIB_IMAGE_FILE_SYSTEM		    = 0x1000,
		PELIB_IMAGE_FILE_DLL		       = 0x2000,
		PELIB_IMAGE_FILE_UP_SYSTEM_ONLY	    = 0x4000,
		PELIB_IMAGE_FILE_BYTES_REVERSED_HI	 = 0x8000
	};

	enum
	{
		PELIB_IMAGE_NT_OPTIONAL_HDR32_MAGIC      = 0x10b,
		PELIB_IMAGE_NT_OPTIONAL_HDR64_MAGIC      = 0x20b,
		PELIB_IMAGE_ROM_OPTIONAL_HDR_MAGIC       = 0x107
	};

	enum
	{
		PELIB_IMAGE_SUBSYSTEM_UNKNOWN	      = 0,
		PELIB_IMAGE_SUBSYSTEM_NATIVE	       = 1,
		PELIB_IMAGE_SUBSYSTEM_WINDOWS_GUI	  = 2,
		PELIB_IMAGE_SUBSYSTEM_WINDOWS_CUI	  = 3,
		PELIB_IMAGE_SUBSYSTEM_OS2_CUI	      = 5,
		PELIB_IMAGE_SUBSYSTEM_POSIX_CUI	    = 7,
		PELIB_IMAGE_SUBSYSTEM_NATIVE_WINDOWS       = 8,
		PELIB_IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       = 9
	};

	enum
	{
		PELIB_RT_CURSOR = 1,		// 1
		PELIB_RT_BITMAP,			// 2
		PELIB_RT_ICON,			// 3
		PELIB_RT_MENU,			// 4
		PELIB_RT_DIALOG,			// 5
		PELIB_RT_STRING,			// 6
		PELIB_RT_FONTDIR,			// 7
		PELIB_RT_FONT,			// 8
		PELIB_RT_ACCELERATOR,		// 9
		PELIB_RT_RCDATA,			// 10
		PELIB_RT_MESSAGETABLE,	// 11
		PELIB_RT_GROUP_CURSOR,	// 12
		PELIB_RT_GROUP_ICON = 14,	// 14
		PELIB_RT_VERSION = 16,
		PELIB_RT_DLGINCLUDE,
		PELIB_RT_PLUGPLAY = 19,
		PELIB_RT_VXD,
		PELIB_RT_ANICURSOR,
		PELIB_RT_ANIICON,
		PELIB_RT_HTML,
		PELIB_RT_MANIFEST
	};
	
	template<typename T>
	unsigned int accumulate(unsigned int size, const T& v)
	{
		return size + v.size();
	}

	
	struct PELIB_IMAGE_DOS_HEADER
	{
		word   e_magic;
		word   e_cblp;
		word   e_cp;
		word   e_crlc;
		word   e_cparhdr;
		word   e_minalloc;
		word   e_maxalloc;
		word   e_ss;
		word   e_sp;
		word   e_csum;
		word   e_ip;
		word   e_cs;
		word   e_lfarlc;
		word   e_ovno;
		word   e_res[4];
		word   e_oemid;
		word   e_oeminfo;
		word   e_res2[10];
		dword   e_lfanew;
		
		PELIB_IMAGE_DOS_HEADER();
		
		static inline unsigned int size() {return 64;}
	};

	struct PELIB_IMAGE_FILE_HEADER
	{
		word	Machine;
		word    NumberOfSections;
		dword   TimeDateStamp;
		dword   PointerToSymbolTable;
		dword   NumberOfSymbols;
		word    SizeOfOptionalHeader;
		word    Characteristics;
		
		PELIB_IMAGE_FILE_HEADER()
		{
			Machine = 0;
			NumberOfSections = 0;
			TimeDateStamp = 0;
			PointerToSymbolTable = 0;
			NumberOfSymbols = 0;
			SizeOfOptionalHeader = 0;
			Characteristics = 0;
		}
		
		static inline unsigned int size() {return 20;}
	};

	struct PELIB_IMAGE_DATA_DIRECTORY
	{
		dword   VirtualAddress;
		dword   Size;
		
		PELIB_IMAGE_DATA_DIRECTORY()
		{
			VirtualAddress = 0;
			Size = 0;
		}
		
		static inline unsigned int size() {return 8;}
	};

	template<int>
	struct FieldSizes;
	
	template<>
	struct FieldSizes<32>
	{
		typedef dword VAR4_8;
	};
	
	template<>
	struct FieldSizes<64>
	{
		typedef qword VAR4_8;
	};
	
	template<int x>
	struct PELIB_IMAGE_OPTIONAL_HEADER_BASE
	{
		typedef typename FieldSizes<x>::VAR4_8 VAR4_8;
		
		word    Magic;
		byte    MajorLinkerVersion;
		byte    MinorLinkerVersion;
		dword   SizeOfCode;
		dword   SizeOfInitializedData;
		dword   SizeOfUninitializedData;
		dword   AddressOfEntryPoint;
		dword   BaseOfCode;
		dword   BaseOfData;
		VAR4_8  ImageBase;
		dword   SectionAlignment;
		dword   FileAlignment;
		word    MajorOperatingSystemVersion;
		word    MinorOperatingSystemVersion;
		word    MajorImageVersion;
		word    MinorImageVersion;
		word    MajorSubsystemVersion;
		word    MinorSubsystemVersion;
		dword   Win32VersionValue;
		dword   SizeOfImage;
		dword   SizeOfHeaders;
		dword   CheckSum;
		word    Subsystem;
		word    DllCharacteristics;
		VAR4_8  SizeOfStackReserve;
		VAR4_8  SizeOfStackCommit;
		VAR4_8  SizeOfHeapReserve;
		VAR4_8  SizeOfHeapCommit;
		dword   LoaderFlags;
		dword   NumberOfRvaAndSizes;
//		PELIB_IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
		
		PELIB_IMAGE_OPTIONAL_HEADER_BASE();
	};
	
	template<int x>
	PELIB_IMAGE_OPTIONAL_HEADER_BASE<x>::PELIB_IMAGE_OPTIONAL_HEADER_BASE()
	{
		Magic = 0;
		MajorLinkerVersion = 0;
		MinorLinkerVersion = 0;
		SizeOfCode = 0;
		SizeOfInitializedData = 0;
		SizeOfUninitializedData = 0;
		AddressOfEntryPoint = 0;
		BaseOfCode = 0;
//		BaseOfData = 0;
		ImageBase = 0;
		SectionAlignment = 0;
		FileAlignment = 0;
		MajorOperatingSystemVersion = 0;
		MinorOperatingSystemVersion = 0;
		MajorImageVersion = 0;
		MinorImageVersion = 0;
		MajorSubsystemVersion = 0;
		MinorSubsystemVersion = 0;
		Win32VersionValue = 0;
		SizeOfImage = 0;
		SizeOfHeaders = 0;
		CheckSum = 0;
		Subsystem = 0;
		DllCharacteristics = 0;
		SizeOfStackReserve = 0;
		SizeOfStackCommit = 0;
		SizeOfHeapReserve = 0;
		SizeOfHeapCommit = 0;
		LoaderFlags = 0;
		NumberOfRvaAndSizes = 0;
	}

	template<int>
	struct PELIB_IMAGE_OPTIONAL_HEADER;
	
	template<>
	struct PELIB_IMAGE_OPTIONAL_HEADER<32> : public PELIB_IMAGE_OPTIONAL_HEADER_BASE<32>
	{
		dword  BaseOfData;
		
		static inline unsigned int size() {return 224 - 0x10 * 8;}
	};
	
	template<>
	struct PELIB_IMAGE_OPTIONAL_HEADER<64> : public PELIB_IMAGE_OPTIONAL_HEADER_BASE<64>
	{
		static inline unsigned int size() {return 240 - 0x10 * 8;}
	};
	
	template<int x>
	struct PELIB_IMAGE_NT_HEADERS
	{
		dword Signature;
		PELIB_IMAGE_FILE_HEADER FileHeader;
		PELIB_IMAGE_OPTIONAL_HEADER<x> OptionalHeader;
		std::vector<PELIB_IMAGE_DATA_DIRECTORY> dataDirectories;
		
		unsigned int size() const
		{
			return sizeof(dword)
				+ PELIB_IMAGE_FILE_HEADER::size()
				+ PELIB_IMAGE_OPTIONAL_HEADER<x>::size()
				+ static_cast<unsigned int>(dataDirectories.size()) * PELIB_IMAGE_DATA_DIRECTORY::size();
		}
		
		PELIB_IMAGE_NT_HEADERS()
		{
			Signature = 0;
		}
	};

	const unsigned int PELIB_IMAGE_SIZEOF_SHORT_NAME  = 8;

	struct PELIB_IMAGE_SECTION_HEADER
	{
		byte Name[PELIB_IMAGE_SIZEOF_SHORT_NAME];
		dword	VirtualSize;
		dword   VirtualAddress;
		dword   SizeOfRawData;
		dword   PointerToRawData;
		dword   PointerToRelocations;
		dword   PointerToLinenumbers;
		word    NumberOfRelocations;
		word    NumberOfLinenumbers;
		dword   Characteristics;
		
		PELIB_IMAGE_SECTION_HEADER()
		{
			VirtualSize = 0;
			VirtualAddress = 0;
			SizeOfRawData = 0;
			PointerToRawData = 0;
			PointerToRelocations = 0;
			PointerToLinenumbers = 0;
			NumberOfRelocations = 0;
			NumberOfLinenumbers = 0;
			Characteristics = 0;
		}
		
		static inline unsigned int size() {return 40;}
		bool biggerFileOffset(const PELIB_IMAGE_SECTION_HEADER& ish) const;
		bool biggerVirtualAddress(const PELIB_IMAGE_SECTION_HEADER& ish) const;
	};

	template<int bits>
	struct PELIB_IMAGE_THUNK_DATA
	{
		typename FieldSizes<bits>::VAR4_8 Ordinal;

		PELIB_IMAGE_THUNK_DATA()
		{
			Ordinal = 0;
		}
		
		static inline unsigned int size() {return 4;}
	};

	struct PELIB_IMAGE_IMPORT_DESCRIPTOR
	{
		dword   OriginalFirstThunk;
		dword   TimeDateStamp;
		dword   ForwarderChain;
		dword   Name;
		dword   FirstThunk;
		
		PELIB_IMAGE_IMPORT_DESCRIPTOR()
		{
			OriginalFirstThunk = 0;
			TimeDateStamp = 0;
			ForwarderChain = 0;
			Name = 0;
			FirstThunk = 0;
		}
		
		static inline unsigned int size() {return 20;}
	};
	
	struct PELIB_IMAGE_EXPORT_DIRECTORY
	{
		dword   Characteristics;
		dword   TimeDateStamp;
		word    MajorVersion;
		word    MinorVersion;
		dword   Name;
		dword   Base;
		dword   NumberOfFunctions;
		dword   NumberOfNames;
		dword   AddressOfFunctions;
		dword   AddressOfNames;
		dword   AddressOfNameOrdinals;
		
		PELIB_IMAGE_EXPORT_DIRECTORY()
		{
			Characteristics = 0;
			TimeDateStamp = 0;
			MajorVersion = 0;
			MinorVersion = 0;
			Name = 0;
			Base = 0;
			NumberOfFunctions = 0;
			NumberOfNames = 0;
			AddressOfFunctions = 0;
			NumberOfNames = 0;
			AddressOfNameOrdinals = 0;
		}
		
		static inline unsigned int size() {return 40;}
	};
	
	struct PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR
	{
		dword   TimeDateStamp;
		word    OffsetModuleName;
		word    NumberOfModuleForwarderRefs;
		
		PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR()
		{
			TimeDateStamp = 0;
			OffsetModuleName = 0;
			NumberOfModuleForwarderRefs = 0;
		}

		static unsigned int size()
		{
			return 8;
		}
	};
	
	// Stores all necessary information about a BoundImport field.
	struct PELIB_IMAGE_BOUND_DIRECTORY
	{
		PELIB_IMAGE_BOUND_IMPORT_DESCRIPTOR ibdDescriptor; ///< Information about the imported file.
		std::string strModuleName; ///< Name of the imported file.
		std::vector<PELIB_IMAGE_BOUND_DIRECTORY> moduleForwarders;

		// Will be used in std::find_if
		// Passing by-reference not possible (see C++ Standard Core Language Defect Reports, Revision 29, Issue 106)
		/// Compares the passed filename to the struct's filename.
		bool equal(const std::string strModuleName) const;
		
		unsigned int size() const;
	};

	struct PELIB_EXP_FUNC_INFORMATION
	{
		dword addroffunc;
		dword addrofname;
		word ordinal;
		std::string funcname;
		
		PELIB_EXP_FUNC_INFORMATION();

		bool equal(const std::string strFunctionName) const;
		inline unsigned int size() const
		{
			unsigned int uiSize = 4;
			if (addroffunc) uiSize += 2;// + 4;
			if (!funcname.empty()) uiSize += 4 + (unsigned int)funcname.size() + 1;
			return uiSize;
		}
	};

	struct PELIB_IMAGE_RESOURCE_DIRECTORY
	{
		dword Characteristics;
		dword TimeDateStamp;
		word MajorVersion;
		word MinorVersion;
		word NumberOfNamedEntries;
		word NumberOfIdEntries;
		
		PELIB_IMAGE_RESOURCE_DIRECTORY();

		static inline unsigned int size() {return 16;}
	};

	struct PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY
	{
		dword Name;
		dword OffsetToData;
		PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY();
		static inline unsigned int size() {return 8;}
	};

	const unsigned int PELIB_IMAGE_SIZEOF_BASE_RELOCATION = 8;

	struct PELIB_IMG_RES_DIR_ENTRY
	{
		PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY irde;
		std::string wstrName;

		bool operator<(const PELIB_IMG_RES_DIR_ENTRY& first) const;

	};
	
	struct PELIB_IMAGE_BASE_RELOCATION
	{
		dword VirtualAddress;
		dword SizeOfBlock;
		
		PELIB_IMAGE_BASE_RELOCATION();
		static inline unsigned int size() {return 8;}
	};

	struct PELIB_IMAGE_COR20_HEADER
	{
		dword cb;
		word MajorRuntimeVersion;
		word MinorRuntimeVersion;
		PELIB_IMAGE_DATA_DIRECTORY MetaData;
		dword Flags;
		dword EntryPointToken;
		PELIB_IMAGE_DATA_DIRECTORY Resources;
		PELIB_IMAGE_DATA_DIRECTORY StrongNameSignature;
		PELIB_IMAGE_DATA_DIRECTORY CodeManagerTable;
		PELIB_IMAGE_DATA_DIRECTORY VTableFixups;
		PELIB_IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
		PELIB_IMAGE_DATA_DIRECTORY ManagedNativeHeader;
		
		PELIB_IMAGE_COR20_HEADER();
		static inline unsigned int size() {return 72;}
	};

	// Used to store a file's export table.
	struct PELIB_IMAGE_EXP_DIRECTORY
	{
		/// The IMAGE_EXPORTED_DIRECTORY of a file's export table.
		PELIB_IMAGE_EXPORT_DIRECTORY ied;
		/// The original filename of current file.
		std::string name;
		std::vector<PELIB_EXP_FUNC_INFORMATION> functions;
		inline unsigned int size() const
		{
			return PELIB_IMAGE_EXPORT_DIRECTORY::size() + name.size() + 1 + 
			std::accumulate(functions.begin(), functions.end(), 0, accumulate<PELIB_EXP_FUNC_INFORMATION>);
		}
	};

	// Used for parsing a file's import table. It combines the function name, the hint
	// and the IMAGE_THUNK_DATA of an imported function.
	template<int bits>
	struct PELIB_THUNK_DATA
	{
		/// The IMAGE_THUNK_DATA struct of an imported function.
		PELIB_IMAGE_THUNK_DATA<bits> itd;
		/// The hint of an imported function.
		word hint;
		/// The function name of an imported function.
		std::string fname;
		
		bool equalHint(word wHint) const
		{
			return hint == wHint;
//			return itd.Ordinal == (wHint | IMAGE_ORDINAL_FLAGS<bits>::IMAGE_ORDINAL_FLAG);
		}
		
		bool equalFunctionName(std::string strFunctionName) const
		{
			return isEqualNc(fname, strFunctionName);
		}
		
		unsigned int size() const {return PELIB_IMAGE_THUNK_DATA<bits>::size() + fname.size() + 1 + sizeof(hint);}
	};

	// Used to store a file's import table. Every struct of this sort
	// can store import information of one DLL.
	template<int bits>
	struct PELIB_IMAGE_IMPORT_DIRECTORY
	{
		/// The IMAGE_IMPORT_DESCRIPTOR of an imported DLL.
		PELIB_IMAGE_IMPORT_DESCRIPTOR impdesc;
		/// The name of an imported DLL.
		std::string name;
		/// All original first thunk values of an imported DLL.
		std::vector<PELIB_THUNK_DATA<bits> > originalfirstthunk;
		/// All first thunk value of an imported DLL.
		std::vector<PELIB_THUNK_DATA<bits> > firstthunk;
		
//		bool operator==(std::string strFilename) const;
		inline unsigned int size() const
		{
			return PELIB_IMAGE_IMPORT_DESCRIPTOR::size() + name.size() + 1 + // descriptor + dllname
			std::accumulate(originalfirstthunk.begin(), originalfirstthunk.end(), 0, accumulate<PELIB_THUNK_DATA<bits> >) + // thunks (PeLib uses only one thunk)
			PELIB_IMAGE_THUNK_DATA<bits>::size(); // zero-termination
		}
		
		bool operator==(std::string strFilename) const
		{
			return isEqualNc(this->name, strFilename);
		}
	};

    struct PELIB_IMAGE_RESOURCE_DATA_ENTRY
    {
	    dword OffsetToData;
	    dword Size;
	    dword CodePage;
	    dword Reserved;

		static inline unsigned int size() {return 16;}
    };

    struct PELIB_IMAGE_RESOURCE_DATA
    {
	    PELIB_IMAGE_RESOURCE_DATA_ENTRY irdEntry;
	    std::vector<byte> vData;
    };

	struct IMG_BASE_RELOC
    {
		PELIB_IMAGE_BASE_RELOCATION ibrRelocation;
		std::vector<word> vRelocData;
	};
	
	struct PELIB_IMAGE_DEBUG_DIRECTORY
	{
		dword Characteristics;
		dword TimeDateStamp;
		word MajorVersion;
		word MinorVersion;
		dword Type;
		dword SizeOfData;
		dword AddressOfRawData;
		dword PointerToRawData;
		
		static unsigned int size() {return 28;}
	};
	
	struct PELIB_IMG_DEBUG_DIRECTORY
	{
		PELIB_IMAGE_DEBUG_DIRECTORY idd;
		std::vector<byte> data;
	};

	template<int bits>
	struct PELIB_IMAGE_TLS_DIRECTORY_BASE
	{
	    typename FieldSizes<bits>::VAR4_8 StartAddressOfRawData;
	    typename FieldSizes<bits>::VAR4_8 EndAddressOfRawData;
	    typename FieldSizes<bits>::VAR4_8 AddressOfIndex;
	    typename FieldSizes<bits>::VAR4_8 AddressOfCallBacks;
	    dword SizeOfZeroFill;
	    dword Characteristics;
	};    
	
	template<int bits>
	struct PELIB_IMAGE_TLS_DIRECTORY;// : public PELIB_IMAGE_TLS_DIRECTORY_BASE<bits>
	
	template<>
	struct PELIB_IMAGE_TLS_DIRECTORY<32> : public PELIB_IMAGE_TLS_DIRECTORY_BASE<32>
	{
//		enum {size = 24};
	    static unsigned int size(){return 24;}
	};

	template<>
	struct PELIB_IMAGE_TLS_DIRECTORY<64> : public PELIB_IMAGE_TLS_DIRECTORY_BASE<64>
	{
//		enum {size = 40};
	    static unsigned int size(){return 40;}
	};

	unsigned int fileSize(const std::string& filename);
	unsigned int fileSize(std::ifstream& file);
	unsigned int fileSize(std::ofstream& file);
	unsigned int fileSize(std::fstream& file);
	bool isEqualNc(const std::string& s1, const std::string& s2);
	unsigned int alignOffset(unsigned int uiOffset, unsigned int uiAlignment);
	
	/// Determines if a file is a 32bit or 64bit PE file.
	unsigned int getFileType(const std::string strFilename);
	
	/// Opens a PE file.
	PeFile* openPeFile(const std::string& strFilename);

  /*  enum MzHeader_Field {e_magic, e_cblp, e_cp, e_crlc, e_cparhdr, e_minalloc, e_maxalloc,
                        e_ss, e_sp, e_csum, e_ip, e_cs, e_lfarlc, e_ovno, e_res, e_oemid,
                        e_oeminfo, e_res2, e_lfanew};
    enum PeHeader_Field {NtSignature, Machine, NumberOfSections, TimeDateStamp, PointerToSymbolTable,
                        NumberOfSymbols, SizeOfOptionalHeader, Characteristics, Magic,
                        MajorLinkerVersion, MinorLinkerVersion, SizeOfCode, SizeOfInitializedData,
                        SizeOfUninitializedData, AddressOfEntryPoint, BaseOfCode, BaseOfData, ImageBase,
                        SectionAlignment, FileAlignment, MajorOperatingSystemVersion, MinorOperatingSystemVersion,
                        MajorImageVersion, MinorImageVersion, MajorSubsystemVersion, MinorSubsystemVersion,
                        Win32VersionValue, SizeOfImage, SizeOfHeaders, CheckSum, Subsystem, DllCharacteristics,
                        SizeOfStackReserve, SizeOfStackCommit, SizeOfHeapReserve, SizeOfHeapCommit,
                        LoaderFlags, NumberOfRvaAndSizes, DataDirectoryRva, DataDirectorySize};
    enum Section_Field {SectionName, VirtualSize, VirtualAddress, SizeOfRawData, PointerToRawData, PointerToRelocations,
                        PointerToLinenumbers, NumberOfRelocations, NumberOfLinenumbers, SectionCharacteristics};
*/
}

#endif

```

`deps/PeLib/PeLibInc.h`:

```h
/*
* PeLibInc.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef STD_H
#define STD_H

/*#ifdef _MSC_VER
	#ifndef for
		#define for if (0) {} else for
	#endif
#endif*/

#include <algorithm>
#include <climits>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <functional>
// #include "PeLib.h"
#include "PeLibAux.h"

#endif

```

`deps/PeLib/RelocationsDirectory.cpp`:

```cpp
/*
* Relocations.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "PeLibInc.h"
#include "RelocationsDirectory.h"

namespace PeLib
{
	void RelocationsDirectory::setRelocationData(unsigned int ulRelocation, unsigned int ulDataNumber, word wData)
	{
		m_vRelocations[ulRelocation].vRelocData[ulDataNumber] = wData;
	}
	
	void RelocationsDirectory::read(InputBuffer& inputbuffer, unsigned int uiSize)
	{
		IMG_BASE_RELOC ibrCurr;

		std::vector<IMG_BASE_RELOC> vCurrReloc;

		do
		{
			inputbuffer >> ibrCurr.ibrRelocation.VirtualAddress;
			inputbuffer >> ibrCurr.ibrRelocation.SizeOfBlock;

			ibrCurr.vRelocData.clear();

			// That's not how to check if there are relocations, some DLLs start at VA 0.
			// if (!ibrCurr.ibrRelocation.VirtualAddress) break;

			for (unsigned int i=0;i<(ibrCurr.ibrRelocation.SizeOfBlock - PELIB_IMAGE_SIZEOF_BASE_RELOCATION) / sizeof(word);i++)
			{
				word wData;
				inputbuffer >> wData;
				ibrCurr.vRelocData.push_back(wData);
			}

			vCurrReloc.push_back(ibrCurr);
		} while (ibrCurr.ibrRelocation.VirtualAddress && inputbuffer.get() < uiSize);

		std::swap(vCurrReloc, m_vRelocations);
	}
	
	// TODO: Return value is wrong if buffer was too small.
	int RelocationsDirectory::read(const unsigned char* buffer, unsigned int buffersize)
	{
		std::vector<unsigned char> vRelocDirectory(buffer, buffer + buffersize);

		InputBuffer ibBuffer(vRelocDirectory);
		read(ibBuffer, buffersize);
	
		return NO_ERROR;
	}

	int RelocationsDirectory::read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);
		unsigned int ulFileSize = fileSize(ifFile);

		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		if (ulFileSize < uiOffset + uiSize)
		{
			return ERROR_INVALID_FILE;
		}

		ifFile.seekg(uiOffset, std::ios::beg);

		std::vector<unsigned char> vRelocDirectory(uiSize);
		ifFile.read(reinterpret_cast<char*>(&vRelocDirectory[0]), uiSize);

		InputBuffer ibBuffer(vRelocDirectory);
		read(ibBuffer, uiSize);
		
		return NO_ERROR;
	}
	
	unsigned int RelocationsDirectory::size() const
	{
		unsigned int size = static_cast<unsigned int>(m_vRelocations.size()) * PELIB_IMAGE_BASE_RELOCATION::size();
		
		for (unsigned int i=0;i<m_vRelocations.size();i++)
		{
			size += static_cast<unsigned int>(m_vRelocations[i].vRelocData.size()) * sizeof(word);
		}
		
		return size;
	}
	
	void RelocationsDirectory::rebuild(std::vector<byte>& vBuffer) const
	{
		OutputBuffer obBuffer(vBuffer);
		
		for (unsigned int i=0;i<m_vRelocations.size();i++)
		{
			obBuffer << m_vRelocations[i].ibrRelocation.VirtualAddress;
			obBuffer << m_vRelocations[i].ibrRelocation.SizeOfBlock;

			for (unsigned int j=0;j<m_vRelocations[i].vRelocData.size();j++)
			{
				obBuffer << m_vRelocations[i].vRelocData[j];
			}
		}
	}

	unsigned int RelocationsDirectory::calcNumberOfRelocations() const
	{
		return static_cast<unsigned int>(m_vRelocations.size());
	}

	dword RelocationsDirectory::getVirtualAddress(unsigned int ulRelocation) const
	{
		return m_vRelocations[ulRelocation].ibrRelocation.VirtualAddress;
	}

	dword RelocationsDirectory::getSizeOfBlock(unsigned int ulRelocation) const
	{
		return m_vRelocations[ulRelocation].ibrRelocation.SizeOfBlock;
	}

	unsigned int RelocationsDirectory::calcNumberOfRelocationData(unsigned int ulRelocation) const
	{
		return static_cast<unsigned int>(m_vRelocations[ulRelocation].vRelocData.size());
	}

	word RelocationsDirectory::getRelocationData(unsigned int ulRelocation, unsigned int ulDataNumber) const
	{
		return m_vRelocations[ulRelocation].vRelocData[ulDataNumber];
	}

	void RelocationsDirectory::setVirtualAddress(unsigned int ulRelocation, dword dwValue)
	{
		m_vRelocations[ulRelocation].ibrRelocation.VirtualAddress = dwValue;
	}

	void RelocationsDirectory::setSizeOfBlock(unsigned int ulRelocation, dword dwValue)
	{
		m_vRelocations[ulRelocation].ibrRelocation.SizeOfBlock = dwValue;
	}
	
	void RelocationsDirectory::addRelocation()
	{
		IMG_BASE_RELOC newrelocation;
		m_vRelocations.push_back(newrelocation);
	}

	void RelocationsDirectory::addRelocationData(unsigned int ulRelocation, word wValue)
	{
		m_vRelocations[ulRelocation].vRelocData.push_back(wValue);
	}

/*	void RelocationsDirectory::removeRelocationData(unsigned int ulRelocation, word wValue)
	{
		// If you get an error with Borland C++ here you have two options: Upgrade your compiler
		// or use the commented line instead of the line below.
		m_vRelocations[ulRelocation].vRelocData.erase(std::remove(m_vRelocations[ulRelocation].vRelocData.begin(), m_vRelocations[ulRelocation].vRelocData.end(), wValue), m_vRelocations[ulRelocation].vRelocData.end());
	}
*/
	void RelocationsDirectory::removeRelocation(unsigned int index)
	{
		m_vRelocations.erase(m_vRelocations.begin() + index);
	}
	
	void RelocationsDirectory::removeRelocationData(unsigned int relocindex, unsigned int dataindex)
	{
		m_vRelocations[relocindex].vRelocData.erase(m_vRelocations[relocindex].vRelocData.begin() + dataindex);
	}
		  
	int RelocationsDirectory::write(const std::string& strFilename, unsigned int uiOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}
		
		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<std::streamsize>(vBuffer.size()));

		ofFile.close();
		
		return NO_ERROR;
	}
}

```

`deps/PeLib/RelocationsDirectory.h`:

```h
/*
* Relocations.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef RELOCATIONSDIRECTORY_H
#define RELOCATIONSDIRECTORY_H

namespace PeLib
{
	/// Class that handles the relocations directory.
	/**
	* This class handles the relocations directory.
	**/
	class RelocationsDirectory
	{
		private:
		  std::vector<IMG_BASE_RELOC> m_vRelocations; ///< Used to store the relocation data.

		  void read(InputBuffer& inputbuffer, unsigned int uiSize);

		public:
		  /// Returns the number of relocations in the relocations directory.
		  unsigned int calcNumberOfRelocations() const; // EXPORT
		  /// Returns the number of relocation data entries of a specific relocation.
		  unsigned int calcNumberOfRelocationData(unsigned int ulRelocation) const; // EXPORT

		  /// Read a file's relocations directory.
		  int read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize); // EXPORT
		  int read(const unsigned char* buffer, unsigned int buffersize); // EXPORT
		  /// Rebuilds the relocations directory.
		  void rebuild(std::vector<byte>& vBuffer) const; // EXPORT
		  /// Returns the size of the relocations directory.
		  unsigned int size() const; // EXPORT
		  /// Writes the relocations directory to a file.
		  int write(const std::string& strFilename, unsigned int dwOffset) const; // EXPORT

		  /// Returns the VA of a relocation.
		  dword getVirtualAddress(unsigned int ulRelocation) const; // EXPORT
		  /// Returns the SizeOfBlock value of a relocation.
		  dword getSizeOfBlock(unsigned int ulRelocation) const; // EXPORT
		  /// Returns the RelocationData of a relocation.
		  word getRelocationData(unsigned int ulRelocation, unsigned int ulDataNumber) const; // EXPORT
		  
		  /// Changes the relocation data of a relocation.
		  void setRelocationData(unsigned int ulRelocation, unsigned int ulDataNumber, word wData); // EXPORT
		  
		  /// Changes the VirtualAddress of a relocation.
		  void setVirtualAddress(unsigned int ulRelocation, dword dwValue); // EXPORT
		  /// Changes the SizeOfBlock of a relocation.
		  void setSizeOfBlock(unsigned int ulRelocation, dword dwValue); // EXPORT
		  
		  void addRelocation(); // EXPORT
		  /// Adds new data to a relocation.
		  void addRelocationData(unsigned int ulRelocation, word wValue); // EXPORT
		  /// Removes data from a relocation.
//		  void removeRelocationData(unsigned int ulRelocation, word wValue); // EXPORT
		  void removeRelocation(unsigned int index); // EXPORT
		  void removeRelocationData(unsigned int relocindex, unsigned int dataindex); // EXPORT
	};
}

#endif

```

`deps/PeLib/ResourceDirectory.cpp`:

```cpp
/*
* ResourceDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "ResourceDirectory.h"

namespace PeLib
{
// -------------------------------------------------- ResourceChild -------------------------------------------

	ResourceChild::ResourceChild()
	{
	}
	
	ResourceChild::ResourceChild(const ResourceChild& rhs)
	{
		if (dynamic_cast<ResourceNode*>(rhs.child))
		{
			ResourceNode* oldnode = static_cast<ResourceNode*>(rhs.child);
			
			entry = rhs.entry;

			child = new ResourceNode;
			child->uiElementRva = rhs.child->getElementRva();
			static_cast<ResourceNode*>(child)->header = oldnode->header;
			static_cast<ResourceNode*>(child)->children = oldnode->children;
		}
		else
		{
			ResourceLeaf* oldnode = static_cast<ResourceLeaf*>(rhs.child);
			
			child = new ResourceLeaf;
			child->uiElementRva = rhs.child->getElementRva();
			static_cast<ResourceLeaf*>(child)->m_data = oldnode->m_data;
			static_cast<ResourceLeaf*>(child)->entry = oldnode->entry;
		}
	}
	
	ResourceChild& ResourceChild::operator=(const ResourceChild& rhs)
	{
		if (this != &rhs)
		{
			if (dynamic_cast<ResourceNode*>(rhs.child))
			{
				ResourceNode* oldnode = static_cast<ResourceNode*>(rhs.child);
				
				entry = rhs.entry;
	
				child = new ResourceNode;
				child->uiElementRva = rhs.child->getElementRva();
				static_cast<ResourceNode*>(child)->header = oldnode->header;
				static_cast<ResourceNode*>(child)->children = oldnode->children;
			}
			else
			{
				ResourceLeaf* oldnode = static_cast<ResourceLeaf*>(rhs.child);
				
				child = new ResourceLeaf;
				child->uiElementRva = rhs.child->getElementRva();
				static_cast<ResourceLeaf*>(child)->m_data = oldnode->m_data;
				static_cast<ResourceLeaf*>(child)->entry = oldnode->entry;
			}
		}
		
		return *this;
	}
	
	ResourceChild::~ResourceChild()
	{
		delete child;
	}

	/**
	* Compares the resource child's id to the parameter dwId.
	* @param dwId ID of a resource.
	* @return True, if the resource child's id equals the parameter.
	**/
	bool ResourceChild::equalId(dword dwId) const
	{
		return entry.irde.Name == dwId;
	}
	
	/**
	* Compares the resource child's name to the parameter strName.
	* @param strName ID of a resource.
	* @return True, if the resource child's name equals the parameter.
	**/
	bool ResourceChild::equalName(std::string strName) const
	{
		return entry.wstrName == strName;
	}
	
	/**
	* Returns true if the resource was given a name.
	**/
	bool ResourceChild::isNamedResource() const
	{
		return entry.wstrName.size() != 0;
	}
	
	/**
	* The children of a resource must be ordered in a certain way. First come the named resources
	* in sorted order, afterwards followed the unnamed resources in sorted order.
	**/
	bool ResourceChild::operator<(const ResourceChild& rc) const
	{
		if (this->isNamedResource() && !rc.isNamedResource())
		{
			return true;
		}
		else if (!this->isNamedResource() && rc.isNamedResource())
		{
			return false;
		}
		else if (this->isNamedResource() && rc.isNamedResource())
		{
			return this->entry.wstrName < rc.entry.wstrName;
		}
		else
		{
			return this->entry.irde.Name < rc.entry.irde.Name;
		}
	}
	
/*	unsigned int ResourceChild::size() const
	{
		return PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::size()
		       + child->size()
		       + (entry.wstrName.size() ? entry.wstrName.size() + 2 : 0);
	}
*/
// -------------------------------------------------- ResourceElement -------------------------------------------

	/**
	* Returns the RVA of a ResourceElement. This is the RVA where the ResourceElement can be
	* found in the file.
	* @return RVA of the ResourceElement.
	**/
	unsigned int ResourceElement::getElementRva() const
	{
		return uiElementRva;
	}

// -------------------------------------------------- ResourceLeaf -------------------------------------------

	/**
	* Checks if a ResourceElement is a leaf or not.
	* @return Always returns true.
	**/
	bool ResourceLeaf::isLeaf() const
	{
		return true;
	}
	
	/**
	* Reads the next resource leaf from the InputBuffer.
	* @param inpBuffer An InputBuffer that holds the complete resource directory.
	* @param uiOffset Offset of the resource leaf that's to be read.
	* @param uiRva RVA of the beginning of the resource directory.
	* @param pad Used for debugging purposes.
	**/
	int ResourceLeaf::read(InputBuffer& inpBuffer, unsigned int uiOffset, unsigned int uiRva/*, const std::string& pad*/)
	{
//		std::cout << pad << "Leaf:" << std::endl;
		
		// Invalid leaf.
		if (uiOffset + PELIB_IMAGE_RESOURCE_DATA_ENTRY::size() > inpBuffer.size())
		{
			return 1;
		}

		uiElementRva = uiOffset + uiRva;

		inpBuffer.set(uiOffset);
		
		inpBuffer >> entry.OffsetToData;
		inpBuffer >> entry.Size;
		inpBuffer >> entry.CodePage;
		inpBuffer >> entry.Reserved;

/*		std::cout << pad << std::hex << "Offset: " << entry.OffsetToData << std::endl;
		std::cout << pad << std::hex << "Size: " << entry.Size << std::endl;
		std::cout << pad << std::hex << "CodePage: " << entry.CodePage << std::endl;
		std::cout << pad << std::hex << "Reserved: " << entry.Reserved << std::endl;
*/		
		// Invalid leaf.
		if (entry.OffsetToData - uiRva + entry.Size > inpBuffer.size())
		{
//			std::cout << entry.OffsetToData << " XXX " << uiRva << " - " << entry.Size << " - " << inpBuffer.size() << std::endl;
			return 1;
		}
		
//		std::cout << entry.OffsetToData << " - " << uiRva << " - " << entry.Size << " - " << inpBuffer.size() << std::endl;
		inpBuffer.set(entry.OffsetToData - uiRva);
		m_data.assign(inpBuffer.data() + inpBuffer.get(), inpBuffer.data() + inpBuffer.get() + entry.Size);
//		std::cout << pad << std::hex << "Vector: " << m_data.size() << std::endl;
//		std::copy(m_data.begin(), m_data.end(), std::ostream_iterator<int>(std::cout << std::hex, " "));
		return 0;
	}

	/**
	* Rebuilds the current resource leaf.
	* @param obBuffer OutputBuffer where the rebuilt resource leaf is stored.
	* @param uiOffset Offset of the resource leaf inside the resource directory.
	* @param uiRva RVA of the resource directory.
	**/
	void ResourceLeaf::rebuild(OutputBuffer& obBuffer, unsigned int& uiOffset, unsigned int uiRva, const std::string&) const
	{
//		std::cout << std::hex << pad << "Leaf: " << uiOffset << std::endl;
		uiOffset += PELIB_IMAGE_RESOURCE_DATA_ENTRY::size();
		
//		obBuffer << entry.OffsetToData;
//		obBuffer << uiOffset;
		obBuffer << uiRva + uiOffset + (uiOffset % 4);
		obBuffer << entry.Size;
		obBuffer << entry.CodePage;
		obBuffer << entry.Reserved;
		
		while (uiOffset % 4)
		{
			uiOffset++;
			obBuffer << (byte)0;
		}
		
		uiOffset += static_cast<unsigned int>(m_data.size());

		for (unsigned int i=0;i<m_data.size();i++)
		{
			obBuffer << m_data[i];
		}
//		std::cout << "LeafChild: " << std::endl;
	}

	void ResourceLeaf::makeValid()
	{
		entry.Size = static_cast<unsigned int>(m_data.size());
	}
	
/*	/// Returns the size of a resource leaf.
	unsigned int ResourceLeaf::size() const
	{
		return PELIB_IMAGE_RESOURCE_DATA_ENTRY::size() + m_data.size();
	}
*/

	/**
	* Returns a vector that contains the raw data of a resource leaf.
	* @return Raw data of the resource.
	**/
	std::vector<byte> ResourceLeaf::getData() const
	{
		return m_data;
	}
	
	/**
	* Overwrites the raw data of a resource.
	* @param vData New data of the resource.
	**/
	void ResourceLeaf::setData(const std::vector<byte>& vData)
	{
		m_data = vData;
	}

	/**
	* Returns the leaf's OffsetToData value. That's the RVA where the raw data of the resource
	* can be found.
	* @return The leaf's OffsetToData value.
	**/
	dword ResourceLeaf::getOffsetToData() const
	{
		return entry.OffsetToData;
	}
	
	/**
	* Returns the leaf's Size value. That's the size of the raw data of the resource.
	* @return The leaf's Size value.
	**/
	dword ResourceLeaf::getSize() const
	{
		return entry.Size;
	}
	
	/**
	* Returns the leaf's CodePage value.
	* @return The leaf's CodePage value.
	**/
	dword ResourceLeaf::getCodePage() const
	{
		return entry.CodePage;
	}
	
	/**
	* Returns the leaf's Reserved value.
	* @return The leaf's Reserved value.
	**/
	dword ResourceLeaf::getReserved() const
	{
		return entry.Reserved;
	}
	
	/**
	* Sets the leaf's OffsetToData value.
	* @param dwValue The leaf's new OffsetToData value.
	**/
	void ResourceLeaf::setOffsetToData(dword dwValue)
	{
		entry.OffsetToData = dwValue;
	}
	
	/**
	* Sets the leaf's Size value.
	* @param dwValue The leaf's new Size value.
	**/
	void ResourceLeaf::setSize(dword dwValue)
	{
		entry.Size = dwValue;
	}
	
	/**
	* Sets the leaf's CodePage value.
	* @param dwValue The leaf's new CodePage value.
	**/
	void ResourceLeaf::setCodePage(dword dwValue)
	{
		entry.CodePage = dwValue;
	}
	
	/**
	* Sets the leaf's Reserved value.
	* @param dwValue The leaf's new Reserved value.
	**/
	void ResourceLeaf::setReserved(dword dwValue)
	{
		entry.Reserved = dwValue;
	}
	

// -------------------------------------------------- ResourceNode -------------------------------------------

	/**
	* Checks if a ResourceElement is a leaf or not.
	* @return Always returns false.
	**/
	bool ResourceNode::isLeaf() const
	{
		return false;
	}
	
	/**
	* Sorts the node's children and corrects the node's header.
	**/
	void ResourceNode::makeValid()
	{
		std::sort(children.begin(), children.end());
		header.NumberOfNamedEntries = static_cast<PeLib::word>(std::count_if(children.begin(), children.end(), std::mem_fun_ref(&ResourceChild::isNamedResource)));
		header.NumberOfIdEntries = static_cast<unsigned int>(children.size()) - header.NumberOfNamedEntries;
	}

	/**
	* Rebuilds the current resource node.
	* @param obBuffer OutputBuffer where the rebuilt resource node is stored.
	* @param uiOffset Offset of the resource node inside the resource directory.
	* @param uiRva RVA of the resource directory.
	* @param pad Used for debugging.
	**/
	void ResourceNode::rebuild(OutputBuffer& obBuffer, unsigned int& uiOffset, unsigned int uiRva, const std::string& pad) const
	{
/*		std::cout << std::hex << pad << uiOffset << std::endl;
		
		std::cout << std::hex << pad << "header.Characteristics: " << header.Characteristics << std::endl;
		std::cout << std::hex << pad << "header.TimeDateStamp: " << header.TimeDateStamp << std::endl;
		std::cout << std::hex << pad << "header.MajorVersion: "  << header.MajorVersion << std::endl;
		std::cout << std::hex << pad << "header.MinorVersion: "  << header.MinorVersion << std::endl;
		std::cout << std::hex << pad << "header.NumberOfNamedEntries: "  << header.NumberOfNamedEntries << std::endl;
		std::cout << std::hex << pad << "header.NumberOfIdEntries: "  << header.NumberOfIdEntries << std::endl;
*/		
		obBuffer << header.Characteristics;
		obBuffer << header.TimeDateStamp;
		obBuffer << header.MajorVersion;
		obBuffer << header.MinorVersion;
		//std::cout << pad << "Children: " << children.size() << std::endl;
		//std::cout << pad << std::count_if(children.begin(), children.end(), std::mem_fun_ref(&ResourceChild::isNamedResource)) << std::endl;
		//std::cout << pad << children.size() - std::count_if(children.begin(), children.end(), std::mem_fun_ref(&ResourceChild::isNamedResource)) << std::endl;
//		obBuffer << std::count_if(children.begin(), children.end(), std::mem_fun_ref(&ResourceChild::isNamedResource));
//		obBuffer << children.size() - std::count_if(children.begin(), children.end(), std::mem_fun_ref(&ResourceChild::isNamedResource));
		obBuffer << header.NumberOfNamedEntries;
		obBuffer << header.NumberOfIdEntries;

		uiOffset += PELIB_IMAGE_RESOURCE_DIRECTORY::size();
		
		for (unsigned int i=0;i<children.size();i++)
		{
			obBuffer << (dword)0;
			obBuffer << (dword)0;
		}

		unsigned int newoffs = (uiOffset + children.size() * 8);
		
		for (unsigned int i=0;i<children.size();i++)
		{
			if (!children[i].entry.wstrName.size())
			{
				obBuffer.update(uiOffset, children[i].entry.irde.Name);
			}
			else
			{
				obBuffer.update(uiOffset, newoffs | PELIB_IMAGE_RESOURCE_NAME_IS_STRING);
				obBuffer << (word)children[i].entry.wstrName.size();
				newoffs += 2;
				for (unsigned int j=0;j<children[i].entry.wstrName.size();j++)
				{
//					std::cout << children[i].entry.wstrName[j];
					obBuffer << (word)children[i].entry.wstrName[j];
					newoffs += 2;
				}
			}
			uiOffset += 4;
//			obBuffer << children[i].entry.OffsetToData;
			obBuffer.update(uiOffset, newoffs | (children[i].entry.irde.OffsetToData & PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY));
			uiOffset += 4;
			children[i].child->rebuild(obBuffer, newoffs, uiRva, pad + "  ");
		}
		uiOffset = newoffs;
	}

	/**
	* Reads the next resource node from the InputBuffer.
	* @param inpBuffer An InputBuffer that holds the complete resource directory.
	* @param uiOffset Offset of the resource node that's to be read.
	* @param uiRva RVA of the beginning of the resource directory.
	* @param pad Something I need for debugging. Will be removed soon.
	**/
	int ResourceNode::read(InputBuffer& inpBuffer, unsigned int uiOffset, unsigned int uiRva/*, const std::string& pad*/)
	{
		// Not enough space to be a valid node.
		if (uiOffset + PELIB_IMAGE_RESOURCE_DIRECTORY::size() > inpBuffer.size())
		{
			return 1;
		}
		
		uiElementRva = uiOffset + uiRva;
		
		inpBuffer.set(uiOffset);
		
		inpBuffer >> header.Characteristics;
		inpBuffer >> header.TimeDateStamp;
		inpBuffer >> header.MajorVersion;
		inpBuffer >> header.MinorVersion;
		inpBuffer >> header.NumberOfNamedEntries;
		inpBuffer >> header.NumberOfIdEntries;
			
		// Not enough space to be a valid node.
		if (uiOffset + PELIB_IMAGE_RESOURCE_DIRECTORY::size()
		   + (header.NumberOfNamedEntries + header.NumberOfIdEntries) * PELIB_IMAGE_RESOURCE_DIRECTORY_ENTRY::size()
		   > inpBuffer.size())
		{
			return 1;
		}
		
//		std::cout << std::hex << pad << "Characteristics: " << header.Characteristics << std::endl;
//		std::cout << std::hex << pad << "TimeDateStamp: " << header.TimeDateStamp << std::endl;
//		std::cout << std::hex << pad << "MajorVersion: " << header.MajorVersion << std::endl;
//		std::cout << std::hex << pad << "MinorVersion: " << header.MinorVersion << std::endl;
//		std::cout << std::hex << pad << "NumberOfNamedEntries: " << header.NumberOfNamedEntries << std::endl;
//		std::cout << std::hex << pad << "NumberOfIdEntries: " << header.NumberOfIdEntries << std::endl;
			
		for (int i=0;i<header.NumberOfNamedEntries + header.NumberOfIdEntries;i++)
		{
			ResourceChild rc;
			inpBuffer >> rc.entry.irde.Name;
			inpBuffer >> rc.entry.irde.OffsetToData;
			
			unsigned int lastPos = inpBuffer.get();

			if (rc.entry.irde.Name & PELIB_IMAGE_RESOURCE_NAME_IS_STRING)
			{
				// Enough space to read string length?
				if ((rc.entry.irde.Name & ~PELIB_IMAGE_RESOURCE_NAME_IS_STRING) + 2 < inpBuffer.size())
				{
					inpBuffer.set(rc.entry.irde.Name & ~PELIB_IMAGE_RESOURCE_NAME_IS_STRING);
					word strlen;
					inpBuffer >> strlen;
					
					// Enough space to read string?
					if ((rc.entry.irde.Name & ~PELIB_IMAGE_RESOURCE_NAME_IS_STRING) + 2 * strlen < inpBuffer.size())
					{
						wchar_t c;
						for (word i=0;i<strlen;i++)
						{
							inpBuffer >> c;
							rc.entry.wstrName += c;
						}
					}
				}
				
//				std::wcout << rc.entry.wstrName << std::endl;
				
//				std::cout << strlen << std::endl;
				inpBuffer.set(lastPos);
			}
			
			if (rc.entry.irde.OffsetToData & PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY)
			{
				rc.child = new ResourceNode;
				rc.child->read(inpBuffer, rc.entry.irde.OffsetToData & ~PELIB_IMAGE_RESOURCE_DATA_IS_DIRECTORY, uiRva/*, pad + "  "*/);
			}
			else
			{
				rc.child = new ResourceLeaf;
				rc.child->read(inpBuffer, rc.entry.irde.OffsetToData, uiRva/*, pad + "  "*/);
			}
//			std::cout << std::hex << pad << "Entry " << i << "(Name): " << rc.entry.irde.Name << std::endl;
//			std::cout << std::hex << pad << "Entry " << i << "(Offset): " << rc.entry.irde.OffsetToData << std::endl;

			children.push_back(rc);
			inpBuffer.set(lastPos);
		}
		
		return 0;
	}
	
	/**
	* Returns the number of children of the current node. Note that this number is the number
	* of defined children, not the value from the header.
	* @return Number of node's children.
	**/
	unsigned int ResourceNode::getNumberOfChildren() const
	{
		return static_cast<unsigned int>(children.size());
	}
	
	/**
	* Adds another child to the current node.
	**/
	void ResourceNode::addChild()
	{
		ResourceChild c;
		c.child = 0;
		children.push_back(c);
	}
		  
	/**
	* Returns a node's child.
	* @param uiIndex Index of the child.
	* @return The child identified by uiIndex. This child can be either a ResourceNode or a ResourceLeaf.
	**/
	ResourceElement* ResourceNode::getChild(unsigned int uiIndex)
	{
		return children[uiIndex].child;
	}
	
	/**
	* Removes a child from the current node.
	* @param uiIndex Index of the child.
	**/
	void ResourceNode::removeChild(unsigned int uiIndex)
	{
		children.erase(children.begin() + uiIndex);
	}
		  
	/**
	* Returns the name of a child.
	* @param uiIndex Index of the child.
	* @return Either the name of the specified child or an empty string.
	**/
	std::string ResourceNode::getChildName(unsigned int uiIndex) const
	{
		return children[uiIndex].entry.wstrName;
	}
	
	/**
	* Returns the Name value of a child.
	* @param uiIndex Index of the child.
	* @return Name value of a child.
	**/
	dword ResourceNode::getOffsetToChildName(unsigned int uiIndex) const
	{
		return children[uiIndex].entry.irde.Name;
	}
	
	/**
	* Returns the OffsetToData value of a child.
	* @param uiIndex Index of the child.
	* @return OffsetToData value of a child.
	**/
	dword ResourceNode::getOffsetToChildData(unsigned int uiIndex) const
	{
		return children[uiIndex].entry.irde.OffsetToData;
	}
	
		  
	/**
	* Sets the name of a child.
	* @param uiIndex Index of the child.
	* @param strNewName New name of the resource.
	**/
	void ResourceNode::setChildName(unsigned int uiIndex, const std::string& strNewName)
	{
		children[uiIndex].entry.wstrName = strNewName;
	}
	
	/**
	* Sets the Name value of a child.
	* @param uiIndex Index of the child.
	* @param dwNewOffset New Name value of the resource.
	**/
	void ResourceNode::setOffsetToChildName(unsigned int uiIndex, dword dwNewOffset)
	{
		children[uiIndex].entry.irde.Name = dwNewOffset;
	}
	
	/**
	* Sets the OffsetToData value of a child.
	* @param uiIndex Index of the child.
	* @param dwNewOffset New OffsetToData value of the resource.
	**/
	void ResourceNode::setOffsetToChildData(unsigned int uiIndex, dword dwNewOffset)
	{
		children[uiIndex].entry.irde.OffsetToData = dwNewOffset;
	}
		  
	/**
	* Returns the Characteristics value of the node.
	* @return Characteristics value of the node.
	**/
	dword ResourceNode::getCharacteristics() const
	{
		return header.Characteristics;
	}
	
	/**
	* Returns the TimeDateStamp value of the node.
	* @return TimeDateStamp value of the node.
	**/
	dword ResourceNode::getTimeDateStamp() const
	{
		return header.TimeDateStamp;
	}
	
	/**
	* Returns the MajorVersion value of the node.
	* @return MajorVersion value of the node.
	**/
	word ResourceNode::getMajorVersion() const
	{
		return header.MajorVersion;
	}
	
	/**
	* Returns the MinorVersion value of the node.
	* @return MinorVersion value of the node.
	**/
	word ResourceNode::getMinorVersion() const
	{
		return header.MinorVersion;
	}
	
	/**
	* Returns the NumberOfNamedEntries value of the node.
	* @return NumberOfNamedEntries value of the node.
	**/
	word ResourceNode::getNumberOfNamedEntries() const
	{
		return header.NumberOfNamedEntries;
	}
	
	/**
	* Returns the NumberOfIdEntries value of the node.
	* @return NumberOfIdEntries value of the node.
	**/
	word ResourceNode::getNumberOfIdEntries() const
	{
		return header.NumberOfIdEntries;
	}
		  
	/**
	* Sets the Characteristics value of the node.
	* @param value New Characteristics value of the node.
	**/
	void ResourceNode::setCharacteristics(dword value)
	{
		header.Characteristics = value;
	}
	
	/**
	* Sets the TimeDateStamp value of the node.
	* @param value New TimeDateStamp value of the node.
	**/
	void ResourceNode::setTimeDateStamp(dword value)
	{
		header.TimeDateStamp = value;
	}
	
	/**
	* Sets the MajorVersion value of the node.
	* @param value New MajorVersion value of the node.
	**/
	void ResourceNode::setMajorVersion(word value)
	{
		header.MajorVersion = value;
	}
	
	/**
	* Sets the MinorVersion value of the node.
	* @param value New MinorVersion value of the node.
	**/
	void ResourceNode::setMinorVersion(word value)
	{
		header.MinorVersion = value;
	}
	
	/**
	* Sets the NumberOfNamedEntries value of the node.
	* @param value New NumberOfNamedEntries value of the node.
	**/
	void ResourceNode::setNumberOfNamedEntries(word value)
	{
		header.NumberOfNamedEntries = value;
	}
	
	/**
	* Sets the NumberOfIdEntries value of the node.
	* @param value New NumberOfIdEntries value of the node.
	**/
	void ResourceNode::setNumberOfIdEntries(word value)
	{
		header.NumberOfIdEntries = value;
	}
	
		  
/*	/// Returns the size of a resource node.
	unsigned int ResourceNode::size() const
	{
		if (children.size())
		{
			std::cout << std::accumulate(children.begin(), children.end(), 0, accumulate<ResourceChild>) << std::endl;
			return PELIB_IMAGE_RESOURCE_DIRECTORY::size()
			         + std::accumulate(children.begin(), children.end(), 0, accumulate<ResourceChild>);
		}
		else
		{
			return 0;
		}
	}
*/	
// -------------------------------------------------- ResourceDirectory -------------------------------------------
	
	/**
	* Returns the root node of the resource directory.
	* @return Root node of the resource directory.
	**/
	ResourceNode* ResourceDirectory::getRoot()
	{
		return &m_rnRoot;
	}

	/**
	* Correctly sorts the resource nodes of the resource tree. This function should be called
	* before calling rebuild.
	**/
	void ResourceDirectory::makeValid()
	{
		m_rnRoot.makeValid();
	}

	/**
	* Reads the resource directory from a file.
	* @param strFilename Name of the file.
	* @param uiOffset File offset of the resource directory.
	* @param uiSize Raw size of the resource directory.
	* @param uiResDirRva RVA of the beginning of the resource directory.
	**/
	int ResourceDirectory::read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize, unsigned int uiResDirRva)
	{
		if (!uiSize || !uiOffset)
		{
			return 1;
		}
		
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);
		
		if (!ifFile)
		{
//			throw Exceptions::CannotOpenFile(ResourceDirectoryId, __LINE__);
			return 1;
		}
		
		if (fileSize(ifFile) < uiOffset + uiSize)
		{
//			throw Exceptions::InvalidFormat(ResourceDirectoryId, __LINE__);
			return 1;
		}

		ifFile.seekg(uiOffset, std::ios::beg);
		
		PELIB_IMAGE_RESOURCE_DIRECTORY irdCurrRoot;
		
		std::vector<byte> vResourceDirectory(uiSize);
		ifFile.read(reinterpret_cast<char*>(&vResourceDirectory[0]), uiSize);

		InputBuffer inpBuffer(vResourceDirectory);
		
//		ResourceNode currNode;
		return m_rnRoot.read(inpBuffer, 0, uiResDirRva/*, ""*/);
//		std::swap(currNode, m_rnRoot);
	}

	/**
	* Rebuilds the resource directory.
	* @param vBuffer Buffer the source directory will be written to.
	* @param uiRva RVA of the resource directory.
	**/
	void ResourceDirectory::rebuild(std::vector<byte>& vBuffer, unsigned int uiRva) const
	{
		OutputBuffer obBuffer(vBuffer);
		unsigned int offs = 0;
//		std::cout << "Root: " << m_rnRoot.children.size() << std::endl;
		m_rnRoot.rebuild(obBuffer, offs, uiRva, "");
	}
	
	/**
	* Returns the size of the entire rebuilt resource directory. That's the size of the entire
	* structure as it's written back to a file.
	**/
/*	unsigned int ResourceDirectory::size() const
	{
		return m_rnRoot.size();
	}
*/	
	/**
	* Writes the current resource directory back into a file.
	* @param strFilename Name of the output file.
	* @param uiOffset File offset where the resource directory will be written to.
	* @param uiRva RVA of the file offset.
	**/
	int ResourceDirectory::write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}
		
		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(uiOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer, uiRva);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), static_cast<unsigned int>(vBuffer.size()));

		ofFile.close();
		
		return 0;
	}
	
	/**
	* Adds another resource type. The new resource type is identified by the ID dwResTypeId.
	* @param dwResTypeId ID which identifies the resource type.
	**/
	int ResourceDirectory::addResourceType(dword dwResTypeId)
	{
		std::vector<ResourceChild>::iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(&ResourceChild::equalId), dwResTypeId));
		if (Iter != m_rnRoot.children.end())
		{
			return 1;
			// throw Exceptions::EntryAlreadyExists(ResourceDirectoryId, __LINE__);
		}
		
		ResourceChild rcCurr;
		rcCurr.child = new ResourceNode;
		rcCurr.entry.irde.Name = dwResTypeId;
		m_rnRoot.children.push_back(rcCurr);
		
		return 0;
	}
	
	/**
	* Adds another resource type. The new resource type is identified by the name strResTypeName.
	* @param strResTypeName Name which identifies the resource type.
	**/
	int ResourceDirectory::addResourceType(const std::string& strResTypeName)
	{
		std::vector<ResourceChild>::iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(&ResourceChild::equalName), strResTypeName));
		if (Iter != m_rnRoot.children.end())
		{
			return 1;
//			throw Exceptions::EntryAlreadyExists(ResourceDirectoryId, __LINE__);
		}
		
		ResourceChild rcCurr;
		rcCurr.entry.wstrName = strResTypeName;
		rcCurr.child = new ResourceNode;
		m_rnRoot.children.push_back(rcCurr);
		
		return 0;
	}
	
	/**
	* Removes the resource type identified by the ID dwResTypeId.
	* @param dwResTypeId ID which identifies the resource type.
	**/
	int ResourceDirectory::removeResourceType(dword dwResTypeId)
	{
		std::vector<ResourceChild>::iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(&ResourceChild::equalId), dwResTypeId));
		if (Iter == m_rnRoot.children.end())
		{
			return 1;
//			throw Exceptions::ResourceTypeDoesNotExist(ResourceDirectoryId, __LINE__);
		}
		
		bool isNamed = false;
		if (Iter->isNamedResource()) isNamed = true;

		m_rnRoot.children.erase(Iter);
		
		if (isNamed) m_rnRoot.header.NumberOfNamedEntries = static_cast<PeLib::word>(m_rnRoot.children.size());
		else m_rnRoot.header.NumberOfIdEntries = static_cast<PeLib::word>(m_rnRoot.children.size());
		
		return 0;
	}
	
	/**
	* Removes the resource type identified by the name strResTypeName.
	* @param strResTypeName Name which identifies the resource type.
	**/
	int ResourceDirectory::removeResourceType(const std::string& strResTypeName)
	{
		std::vector<ResourceChild>::iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(&ResourceChild::equalName), strResTypeName));
		if (Iter == m_rnRoot.children.end())
		{
			return 1;
		//	throw Exceptions::ResourceTypeDoesNotExist(ResourceDirectoryId, __LINE__);
		}
		
		bool isNamed = false;
		if (Iter->isNamedResource()) isNamed = true;
		
		m_rnRoot.children.erase(Iter);
		
		if (isNamed) m_rnRoot.header.NumberOfNamedEntries = static_cast<PeLib::word>(m_rnRoot.children.size());
		else m_rnRoot.header.NumberOfIdEntries = static_cast<PeLib::word>(m_rnRoot.children.size());
		
		return 0;
	}

	/**
	* Removes the resource type identified by the index uiIndex.
	* @param uiIndex Index which identifies the resource type.
	**/
	int ResourceDirectory::removeResourceTypeByIndex(unsigned int uiIndex)
	{
		bool isNamed = false;
		if (m_rnRoot.children[uiIndex].isNamedResource()) isNamed = true;
		
		m_rnRoot.children.erase(m_rnRoot.children.begin() + uiIndex);
		
		if (isNamed) m_rnRoot.header.NumberOfNamedEntries = static_cast<PeLib::word>(m_rnRoot.children.size());
		else m_rnRoot.header.NumberOfIdEntries = static_cast<PeLib::word>(m_rnRoot.children.size());
		
		return 0;
	}
		  
	/**
	* Adds another resource to the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param dwResTypeId ID of the resource type.
	* @param dwResId ID of the resource.
	**/
	int ResourceDirectory::addResource(dword dwResTypeId, dword dwResId)
	{
		ResourceChild rcCurr;
		rcCurr.entry.irde.Name = dwResId;
		return addResourceT(dwResTypeId, dwResId, rcCurr);
	}
	
	/**
	* Adds another resource to the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param dwResTypeId ID of the resource type.
	* @param strResName Name of the resource.
	**/
	int ResourceDirectory::addResource(dword dwResTypeId, const std::string& strResName)
	{
		ResourceChild rcCurr;
		rcCurr.entry.wstrName = strResName;
		return addResourceT(dwResTypeId, strResName, rcCurr);
	}
	
	/**
	* Adds another resource to the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param strResTypeName Name of the resource type.
	* @param dwResId ID of the resource.
	**/
	int ResourceDirectory::addResource(const std::string& strResTypeName, dword dwResId)
	{
		ResourceChild rcCurr;
		rcCurr.entry.irde.Name = dwResId;
		return addResourceT(strResTypeName, dwResId, rcCurr);
	}

	/**
	* Adds another resource to the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param strResTypeName Name of the resource type.
	* @param strResName Name of the resource.
	**/
	int ResourceDirectory::addResource(const std::string& strResTypeName, const std::string& strResName)
	{
		ResourceChild rcCurr;
		rcCurr.entry.wstrName = strResName;
		return addResourceT(strResTypeName, strResName, rcCurr);
	}

	/**
	* Removes a resource from the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param dwResTypeIndex ID of the resource type.
	* @param dwResId ID of the resource.
	**/
	int ResourceDirectory::removeResource(dword dwResTypeIndex, dword dwResId)
	{
		return removeResourceT(dwResTypeIndex, dwResId);
	}
	
	/**
	* Removes a resource from the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param dwResTypeIndex ID of the resource type.
	* @param strResName Name of the resource.
	**/
	int ResourceDirectory::removeResource(dword dwResTypeIndex, const std::string& strResName)
	{
		return removeResourceT(dwResTypeIndex, strResName);
	}
	
	/**
	* Removes a resource from the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param strResTypeName Name of the resource type.
	* @param dwResId ID of the resource.
	**/
	int ResourceDirectory::removeResource(const std::string& strResTypeName, dword dwResId)
	{
		return removeResourceT(strResTypeName, dwResId);
	}
	
	/**
	* Removes a resource from the resource tree. The first parameter identifies the resource type
	* of the new resource, the second parameter identifies the resource itself.
	* @param strResTypeName Name of the resource type.
	* @param strResName Name of the resource.
	**/
	int ResourceDirectory::removeResource(const std::string& strResTypeName, const std::string& strResName)
	{
		return removeResourceT(strResTypeName, strResName);
	}
		  
	/**
	* Returns the number of resource types.
	**/
	unsigned int ResourceDirectory::getNumberOfResourceTypes() const
	{
		return static_cast<unsigned int>(m_rnRoot.children.size());
	}

	/**
	* Returns the ID of a resource type which was specified through an index.
	* The valid range of the parameter uiIndex is 0...getNumberOfResourceTypes() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiIndex Index which identifies a resource type.
	* @return The ID of the specified resource type.
	**/
	dword ResourceDirectory::getResourceTypeIdByIndex(unsigned int uiIndex) const
	{
		return m_rnRoot.children[uiIndex].entry.irde.Name;
	}
	
	/**
	* Returns the name of a resource type which was specified through an index.
	* The valid range of the parameter uiIndex is 0...getNumberOfResourceTypes() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiIndex Index which identifies a resource type.
	* @return The name of the specified resource type.
	**/
	std::string ResourceDirectory::getResourceTypeNameByIndex(unsigned int uiIndex) const
	{
		return m_rnRoot.children[uiIndex].entry.wstrName;
	}

	/**
	* Converts the ID of a resource type to an index.
	* @param dwResTypeId ID of the resource type.
	* @return Index of that resource type.
	**/
	int ResourceDirectory::resourceTypeIdToIndex(dword dwResTypeId) const
	{
		std::vector<ResourceChild>::const_iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(&ResourceChild::equalId), dwResTypeId));
		if (Iter == m_rnRoot.children.end()) return -1;
		return static_cast<unsigned int>(std::distance(m_rnRoot.children.begin(), Iter));
	}
	
	/**
	* Converts the name of a resource type to an index.
	* @param strResTypeName ID of the resource type.
	* @return Index of that resource type.
	**/
	int ResourceDirectory::resourceTypeNameToIndex(const std::string& strResTypeName) const
	{
		std::vector<ResourceChild>::const_iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(&ResourceChild::equalName), strResTypeName));
		if (Iter == m_rnRoot.children.end()) return -1;
		return static_cast<unsigned int>(std::distance(m_rnRoot.children.begin(), Iter));
	}
	
	/**
	* Returns the number of resources of a specific resource type.
	* @param dwId ID of the resource type.
	* @return Number of resources of resource type dwId.
	**/
	unsigned int ResourceDirectory::getNumberOfResources(dword dwId) const
	{
//		std::vector<ResourceChild>::const_iterator IterD = m_rnRoot.children.begin();
//		std::cout << dwId << std::endl;
//		while (IterD != m_rnRoot.children.end())
//		{
//			std::cout << IterD->entry.irde.Name << std::endl;
//			++IterD;
//		}
		
		std::vector<ResourceChild>::const_iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(&ResourceChild::equalId), dwId));
		if (Iter == m_rnRoot.children.end())
		{
			return 0xFFFFFFFF;
		}
		else
		{
			ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
			return static_cast<unsigned int>(currNode->children.size());
		}
	}

	/**
	* Returns the number of resources of a specific resource type.
	* @param strResTypeName Name of the resource type.
	* @return Number of resources of resource type strResTypeName.
	**/
	unsigned int ResourceDirectory::getNumberOfResources(const std::string& strResTypeName) const
	{
		std::vector<ResourceChild>::const_iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(&ResourceChild::equalName), strResTypeName));
		if (Iter == m_rnRoot.children.end())
		{
			return 0xFFFFFFFF;
		}
		else
		{
			ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
			return static_cast<unsigned int>(currNode->children.size());
		}
	}

	/**
	* Returns the number of resources of a resource type which was specified through an index.
	* The valid range of the parameter uiIndex is 0...getNumberOfResourceTypes() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiIndex Index which identifies a resource type.
	* @return The number of resources of the specified resource type.
	**/
	unsigned int ResourceDirectory::getNumberOfResourcesByIndex(unsigned int uiIndex) const
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiIndex].child);
		return static_cast<unsigned int>(currNode->children.size());
	}
	
	/**
	* Gets the resource data of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceData(dword dwResTypeId, dword dwResId, std::vector<byte>& data) const
	{
		getResourceDataT(dwResTypeId, dwResId, data);
	}
	
	/**
	* Gets the resource data of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceData(dword dwResTypeId, const std::string& strResName, std::vector<byte>& data) const
	{
		getResourceDataT(dwResTypeId, strResName, data);
	}
	
	/**
	* Gets the resource data of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceData(const std::string& strResTypeName, dword dwResId, std::vector<byte>& data) const
	{
		getResourceDataT(strResTypeName, dwResId, data);
	}
	
	/**
	* Gets the resource data of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceData(const std::string& strResTypeName, const std::string& strResName, std::vector<byte>& data) const
	{
		getResourceDataT(strResTypeName, strResName, data);
	}
	
	/**
	* Gets the resource data of a specific resource by index.
	* The valid range of the parameter uiResTypeIndex is 0...getNumberOfResourceTypes() - 1.
	* The valid range of the parameter uiResIndex is 0...getNumberOfResources() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @param data Vector where the data is stored.
	**/
	void ResourceDirectory::getResourceDataByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::vector<byte>& data) const
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		currNode = static_cast<ResourceNode*>(currNode->children[uiResIndex].child);
		ResourceLeaf* currLeaf = static_cast<ResourceLeaf*>(currNode->children[0].child);
		
		data.assign(currLeaf->m_data.begin(), currLeaf->m_data.end());
	}
		  
	/**
	* Sets the resource data of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceData(dword dwResTypeId, dword dwResId, std::vector<byte>& data)
	{
		setResourceDataT(dwResTypeId, dwResId, data);
	}
	
	/**
	* Sets the resource data of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceData(dword dwResTypeId, const std::string& strResName, std::vector<byte>& data)
	{
		setResourceDataT(dwResTypeId, strResName, data);
	}
	
	/**
	* Sets the resource data of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceData(const std::string& strResTypeName, dword dwResId, std::vector<byte>& data)
	{
		setResourceDataT(strResTypeName, dwResId, data);
	}
	
	/**
	* Sets the resource data of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceData(const std::string& strResTypeName, const std::string& strResName, std::vector<byte>& data)
	{
		setResourceDataT(strResTypeName, strResName, data);
	}
	
	/**
	* Sets the resource data of a specific resource by index.
	* The valid range of the parameter uiResTypeIndex is 0...getNumberOfResourceTypes() - 1.
	* The valid range of the parameter uiResIndex is 0...getNumberOfResources() - 1.
	* Leaving the invalid range leads to undefined behaviour.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @param data The new resource data.
	**/
	void ResourceDirectory::setResourceDataByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::vector<byte>& data)
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		currNode = static_cast<ResourceNode*>(currNode->children[uiResIndex].child);
		ResourceLeaf* currLeaf = static_cast<ResourceLeaf*>(currNode->children[0].child);
		currLeaf->m_data.assign(data.begin(), data.end());
	}
		  
	/**
	* Gets the ID of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @return ID of the specified resource.
	**/
	dword ResourceDirectory::getResourceId(dword dwResTypeId, const std::string& strResName) const
	{
		return getResourceIdT(dwResTypeId, strResName);
	}
	
	/**
	* Gets the ID of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @return ID of the specified resource.
	**/
	dword ResourceDirectory::getResourceId(const std::string& strResTypeName, const std::string& strResName) const
	{
		return getResourceIdT(strResTypeName, strResName);
	}
	
	/**
	* Gets the ID of a specific resource by index.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @return ID of the specified resource.
	**/
	dword ResourceDirectory::getResourceIdByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex) const
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		return currNode->children[uiResIndex].entry.irde.Name;
	}

	/**
	* Sets the ID of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param dwNewResId New ID of the resource.
	**/
	void ResourceDirectory::setResourceId(dword dwResTypeId, dword dwResId, dword dwNewResId)
	{
		setResourceIdT(dwResTypeId, dwResId, dwNewResId);
	}
	
	/**
	* Sets the ID of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param dwNewResId New ID of the resource.
	**/
	void ResourceDirectory::setResourceId(dword dwResTypeId, const std::string& strResName, dword dwNewResId)
	{
		setResourceIdT(dwResTypeId, strResName, dwNewResId);
	}
	
	/**
	* Sets the ID of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param dwNewResId New ID of the resource.
	**/
	void ResourceDirectory::setResourceId(const std::string& strResTypeName, dword dwResId, dword dwNewResId)
	{
		setResourceIdT(strResTypeName, dwResId, dwNewResId);
	}
	
	/**
	* Sets the ID of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param dwNewResId New ID of the resource.
	**/
	void ResourceDirectory::setResourceId(const std::string& strResTypeName, const std::string& strResName, dword dwNewResId)
	{
		setResourceIdT(strResTypeName, strResName, dwNewResId);
	}
	
	/**
	* Sets the ID of a specific resource by index.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @param dwNewResId New ID of the specified resource.
	**/
	void ResourceDirectory::setResourceIdByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, dword dwNewResId)
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		currNode->children[uiResIndex].entry.irde.Name = dwNewResId;
	}

	/**
	* Gets the Name of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @return Name of the specified resource.
	**/
	std::string ResourceDirectory::getResourceName(dword dwResTypeId, dword dwResId) const
	{
		return getResourceNameT(dwResTypeId, dwResId);
	}
	
	/**
	* Gets the Name of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @return Name of the specified resource.
	**/
	std::string ResourceDirectory::getResourceName(const std::string& strResTypeName, dword dwResId) const
	{
		return getResourceNameT(strResTypeName, dwResId);
	}
	
	/**
	* Gets the name of a specific resource by index.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @return Name of the specified resource.
	**/
	std::string ResourceDirectory::getResourceNameByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex) const
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		return currNode->children[uiResIndex].entry.wstrName;
	}

	/**
	* Sets the name of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceName(dword dwResTypeId, dword dwResId, const std::string& strNewResName)
	{
		setResourceNameT(dwResTypeId, dwResId, strNewResName);
	}
	
	/**
	* Sets the name of a specific resource.
	* @param dwResTypeId Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceName(dword dwResTypeId, const std::string& strResName, const std::string& strNewResName)
	{
		setResourceNameT(dwResTypeId, strResName, strNewResName);
	}
	
	/**
	* Sets the name of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param dwResId Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceName(const std::string& strResTypeName, dword dwResId, const std::string& strNewResName)
	{
		setResourceNameT(strResTypeName, dwResId, strNewResName);
	}
	
	/**
	* Sets the name of a specific resource.
	* @param strResTypeName Identifies the resource type of the resource.
	* @param strResName Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceName(const std::string& strResTypeName, const std::string& strResName, const std::string& strNewResName)
	{
		setResourceNameT(strResTypeName, strResName, strNewResName);
	}
		  
	/**
	* Sets the name of a specific resource by index.
	* @param uiResTypeIndex Identifies the resource type of the resource.
	* @param uiResIndex Identifies the resource.
	* @param strNewResName New name of the specified resource.
	**/
	void ResourceDirectory::setResourceNameByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, const std::string& strNewResName)
	{
		ResourceNode* currNode = static_cast<ResourceNode*>(m_rnRoot.children[uiResTypeIndex].child);
		currNode->children[uiResIndex].entry.wstrName = strNewResName;
	}
	
}

```

`deps/PeLib/ResourceDirectory.h`:

```h
/*
* ResourceDirectory.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef RESOURCEDIRECTORY_H
#define RESOURCEDIRECTORY_H

#include "PeLibInc.h"

namespace PeLib
{
	class ResourceElement;
	
	/// The class ResourceChild is used to store information about a resource node.
	class ResourceChild
	{
		friend class ResourceElement;
		friend class ResourceDirectory;
		friend class ResourceNode;
		friend class ResourceLeaf;
		
		/// Stores name and offset of a resource node.
		PELIB_IMG_RES_DIR_ENTRY entry;
		/// A pointer to one of the node's child nodes.
		ResourceElement* child;
		
		public:
		  /// Function which compares a resource ID to the node's resource ID.
		  bool equalId(dword wId) const; // EXPORT
		  /// Function which compares a string to the node's resource name.
		  bool equalName(std::string strName) const; // EXPORT
		  /// Predicate that determines if a child is identified by name or by ID.
		  bool isNamedResource() const; // EXPORT
		  /// Used for sorting a node's children.
		  bool operator<(const ResourceChild& rc) const; // EXPORT
		  /// Returns the size of a resource child.
//		unsigned int size() const;

		  /// Standard constructor. Does absolutely nothing.
		  ResourceChild();
		  /// Makes a deep copy of a ResourceChild object.
		  ResourceChild(const ResourceChild& rhs);
		  /// Makes a deep copy of a ResourceChild object.
		  ResourceChild& operator=(const ResourceChild& rhs);
		  /// Deletes a ResourceChild object.
		  ~ResourceChild();
	};
	
	/// Base class for ResourceNode and ResourceLeaf, the elements of the resource tree.
	/// \todo write
	class ResourceElement
	{
		friend class ResourceChild;
		friend class ResourceNode;
		friend class ResourceLeaf;
		
		protected:
		  /// Stores RVA of the resource element in the file.
		  unsigned int uiElementRva;
		
		  /// Reads the next resource element from the InputBuffer.
		  virtual int read(InputBuffer&, unsigned int, unsigned int/*, const std::string&*/) = 0;
		  /// Writes the next resource element into the OutputBuffer.
		  virtual void rebuild(OutputBuffer&, unsigned int&, unsigned int, const std::string&) const = 0;
		  
		public:
		  /// Returns the RVA of the element in the file.
		  unsigned int getElementRva() const; // EXPORT
		  /// Indicates if the resource element is a leaf or a node.
		  virtual bool isLeaf() const = 0; // EXPORT
		  /// Corrects erroneous valeus in the ResourceElement.
		  virtual void makeValid() = 0; // EXPORT
		  /// Returns the size of a resource element.
//		  virtual unsigned int size() const = 0;
		  /// Necessary virtual destructor.
		  virtual ~ResourceElement() {}
	};
	
	/// ResourceLeafs represent the leafs of the resource tree: The actual resources.
	class ResourceLeaf : public ResourceElement
	{
		friend class ResourceChild;
		friend class ResourceDirectory;
		template<typename T> friend struct fixNumberOfEntries;
		
		private:
		  /// The resource data.
		  std::vector<byte> m_data;
		  /// PeLib equivalent of the Win32 structure IMAGE_RESOURCE_DATA_ENTRY
		  PELIB_IMAGE_RESOURCE_DATA_ENTRY entry;
		  
		protected:
		  int read(InputBuffer& inpBuffer, unsigned int uiOffset, unsigned int rva/*, const std::string&*/);
		  /// Writes the next resource leaf into the OutputBuffer.
		  void rebuild(OutputBuffer&, unsigned int& uiOffset, unsigned int uiRva, const std::string&) const;
		
		public:
		  /// Indicates if the resource element is a leaf or a node.
		  bool isLeaf() const; // EXPORT
		  /// Corrects erroneous valeus in the ResourceLeaf.
		  void makeValid(); // EXPORT
		  /// Reads the next resource leaf from the InputBuffer.
		  /// Returns the size of a resource lead.
//		  unsigned int size() const;

		  /// Returns the resource data of this resource leaf.
		  std::vector<byte> getData() const; // EXPORT
		  /// Sets the resource data of this resource leaf.
		  void setData(const std::vector<byte>& vData); // EXPORT

		  /// Returns the OffsetToData value of this resource leaf.
		  dword getOffsetToData() const; // EXPORT
		  /// Returns the Size value of this resource leaf.
		  dword getSize() const; // EXPORT
		  /// Returns the CodePage value of this resource leaf.
		  dword getCodePage() const; // EXPORT
		  /// Returns the Reserved value of this resource leaf.
		  dword getReserved() const; // EXPORT
		  
		  /// Sets the OffsetToData value of this resource leaf.
		  void setOffsetToData(dword dwValue); // EXPORT
		  /// Sets the Size value of this resource leaf.
		  void setSize(dword dwValue); // EXPORT
		  /// Sets the CodePage value of this resource leaf.
		  void setCodePage(dword dwValue); // EXPORT
		  /// Sets the Reserved value of this resource leaf.
		  void setReserved(dword dwValue); // EXPORT
	};
	
	/// ResourceNodes represent the nodes in the resource tree.
	class ResourceNode : public ResourceElement
	{
		friend class ResourceChild;
		friend class ResourceDirectory;
		template<typename T> friend struct fixNumberOfEntries;
		
		/// The node's children.
		std::vector<ResourceChild> children;
		/// The node's header. Equivalent to IMAGE_RESOURCE_DIRECTORY from the Win32 API.
		PELIB_IMAGE_RESOURCE_DIRECTORY header;
		
		protected:
		  /// Reads the next resource node.
		  int read(InputBuffer& inpBuffer, unsigned int uiOffset, unsigned int rva/*, const std::string&*/);
		  /// Writes the next resource node into the OutputBuffer.
		  void rebuild(OutputBuffer&, unsigned int& uiOffset, unsigned int uiRva, const std::string&) const;
		  
		public:
		  /// Indicates if the resource element is a leaf or a node.
		  bool isLeaf() const; // EXPORT
		  /// Corrects erroneous valeus in the ResourceNode.
		  void makeValid(); // EXPORT
		  
		  /// Returns the node's number of children.
		  unsigned int getNumberOfChildren() const; // EXPORT
		  /// Adds another child to node.
		  void addChild(); // EXPORT
		  /// Returns a node's child.
		  ResourceElement* getChild(unsigned int uiIndex); // EXPORT
		  /// Removes a node's child.
		  void removeChild(unsigned int uiIndex); // EXPORT
		  
		  /// Returns the name of one of the node's children.
		  std::string getChildName(unsigned int uiIndex) const; // EXPORT
		  /// Returns the Name value of one of the node's children.
		  dword getOffsetToChildName(unsigned int uiIndex) const; // EXPORT
		  /// Returns the OffsetToData value of one of the node's children.
		  dword getOffsetToChildData(unsigned int uiIndex) const; // EXPORT
		  
		  /// Sets the name of one of the node's children.
		  void setChildName(unsigned int uiIndex, const std::string& strNewName); // EXPORT
		  /// Sets the Name value of one of the node's children.
		  void setOffsetToChildName(unsigned int uiIndex, dword dwNewOffset); // EXPORT
		  /// Sets the OffsetToData value of one of the node's children.
		  void setOffsetToChildData(unsigned int uiIndex, dword dwNewOffset); // EXPORT
		  
		  /// Returns the node's Characteristics value.
		  dword getCharacteristics() const; // EXPORT
		  /// Returns the node's TimeDateStamp value.
		  dword getTimeDateStamp() const; // EXPORT
		  /// Returns the node's MajorVersion value.
		  word getMajorVersion() const; // EXPORT
		  /// Returns the node's MinorVersion value.
		  word getMinorVersion() const; // EXPORT
		  /// Returns the node's NumberOfNamedEntries value.
		  word getNumberOfNamedEntries() const; // EXPORT
		  /// Returns the node's NumberOfIdEntries value.
		  word getNumberOfIdEntries() const; // EXPORT
		  
		  /// Sets the node's Characteristics value.
		  void setCharacteristics(dword value); // EXPORT
		  /// Sets the node's TimeDateStamp value.
		  void setTimeDateStamp(dword value); // EXPORT
		  /// Sets the node's MajorVersion value.
		  void setMajorVersion(word value); // EXPORT
		  /// Sets the node's MinorVersion value.
		  void setMinorVersion(word value); // EXPORT
		  /// Sets the node's NumberOfNamedEntries value.
		  void setNumberOfNamedEntries(word value); // EXPORT
		  /// Sets the node's NumberOfIdEntries value.
		  void setNumberOfIdEntries(word value); // EXPORT
		  
		  /// Returns the size of a resource node.
//		unsigned int size() const;
	};

	/// Auxiliary functor which is used to search through the resource tree.
	/**
	* Traits class for the template functions of ResourceDirectory.
	* It's used to find out which function to use when searching for resource nodes or resource leafs
	* in a node's children vector.
	**/
	template<typename T>
	struct ResComparer
	{
		/// Pointer to a member function of ResourceChild
		typedef bool(ResourceChild::*CompFunc)(T) const;
		 
		/// Return 0 for all unspecialized versions of ResComparer.
		static CompFunc comp();
	};

	/// Auxiliary functor which is used to search through the resource tree.
	/**
	* ResComparer<dword> is used when a resource element is searched for by ID.
	**/
	template<>
	struct ResComparer<dword>
	{
		/// Pointer to a member function of ResourceChild
		typedef bool(ResourceChild::*CompFunc)(dword) const;
		 
		/// Return the address of the ResourceChild member function that compares the ids of resource elements.
		static CompFunc comp()
		{
			return &ResourceChild::equalId;
		}
	};

	/// Auxiliary functor which is used to search through the resource tree.
	/**
	* This specializd version of ResComparer is used when a resource element is searched for by name.
	**/
	template<>
	struct ResComparer<std::string>
	{
		/// Pointer to a member function of ResourceChild
		typedef bool(ResourceChild::*CompFunc)(std::string) const;
		 
		/// Return the address of the ResourceChild member function that compares the names of resource elements.
		static CompFunc comp()
		{
			return &ResourceChild::equalName;
		}
	};

	/// Unspecialized function that's used as base template for the specialized versions below.
	template<typename T>
	struct fixNumberOfEntries
	{
		/// Fixes a resource node's header.
		static void fix(ResourceNode*);
	};
		  
	/// Fixes NumberOfIdEntries value of a node.
	template<>
	struct fixNumberOfEntries<dword>
	{
		/// Fixes a resource node's NumberOfIdEntries value.
		static void fix(ResourceNode* node)
		{
			node->header.NumberOfIdEntries = node->children.size();
			for (auto c : node->children)
				if (c.isNamedResource())
					node->header.NumberOfIdEntries--;
		}
	};

	/// Fixes NumberOfNamedEntries value of a node.
	template<>
	struct fixNumberOfEntries<std::string>
	{
		/// Fixes a resource node's NumberOfNamedEntries value.
		static void fix(ResourceNode* node)
		{
			node->header.NumberOfNamedEntries = 0;
			for (auto c : node->children)
				if (c.isNamedResource())
					node->header.NumberOfNamedEntries++;
		}
	};

	
	/// Class that represents the resource directory of a PE file.	  
	/**
	* The class ResourceDirectory represents the resource directory of a PE file. This class is fundamentally
	* different from the other classes of the PeLib library due to the structure of the ResourceDirectory.
	* For once, it's possible to manipulate the ResourceDirectory through a set of "high level" functions and
	* and through a set of "low level" functions. The "high level" functions are the functions inside the
	* ResourceDirectory class with the exception of getRoot.<br><br>
	* getRoot on the other hand is the first "low level" function. Use it to retrieve the root node of the
	* resource tree. Then you can traverse through the tree and manipulate individual nodes and leafs
	* directly using the functions provided by the classes ResourceNode and ResourceLeaf.<br><br>
	* There's another difference between the ResourceDirectory class and the other PeLib classes, which is
	* once again caused by the special structure of the PE resource directory. The nodes of the resource
	* tree must be in a certain order. Manipulating the resource tree does not directly sort the nodes
	* correctly as this would cause more trouble than it fixes. That means it's your responsibility to 
	* fix the resource tree after manipulating it. PeLib makes the job easy for you, just call the
	* ResourceDirectory::makeValid function.<br><br>
	* You might also wonder why there's no size() function in this class. I did not forget it. It's just
	* that it's impossible to calculate the size of the resource directory without rebuilding it. So why
	* should PeLib do this if you can do it just as easily by calling rebuild() and then checking the length
	* of the returned vector.<br><br>
	* There are also different ways to serialize (rebuild) the resource tree as it's not a fixed structure
	* that can easily be minimized like most other PE directories.<br><br>
	* This means it's entirely possible that the resource tree you read from a file differs from the one
	* PeLib creates. This might cause a minor issue. The original resource tree might be smaller (due to
	* different padding) so it's crucial that you check if there's enough space in the original resource
	* directory before you write the rebuilt resource directory back to the file.
	**/
	class ResourceDirectory
	{
		private:
		  /// The root node of the resource directory.
		  ResourceNode m_rnRoot;

		  // Prepare for some crazy syntax below to make Digital Mars happy.
		  
		  /// Retrieves an iterator to a specified resource child.
		  template<typename S, typename T>
		  std::vector<ResourceChild>::const_iterator locateResourceT(S restypeid, T resid) const;
		  
		  /// Retrieves an iterator to a specified resource child.
		  template<typename S, typename T>
		  std::vector<ResourceChild>::iterator locateResourceT(S restypeid, T resid);
		  
		  /// Adds a new resource.
		  template<typename S, typename T>
		  int addResourceT(S restypeid, T resid, ResourceChild& rc);
		  
		  /// Removes new resource.
		  template<typename S, typename T>
		  int removeResourceT(S restypeid, T resid);
		  
		  /// Returns the data of a resource.
		  template<typename S, typename T>
		  int getResourceDataT(S restypeid, T resid, std::vector<byte>& data) const;
		  
		  /// Sets the data of a resource.
		  template<typename S, typename T>
		  int setResourceDataT(S restypeid, T resid, std::vector<byte>& data);
		  
		  /// Returns the ID of a resource.
		  template<typename S, typename T>
		  dword getResourceIdT(S restypeid, T resid) const;
		  
		  /// Sets the ID of a resource.
		  template<typename S, typename T>
		  int setResourceIdT(S restypeid, T resid, dword dwNewResId);
		  
		  /// Returns the name of a resource.
		  template<typename S, typename T>
		  std::string getResourceNameT(S restypeid, T resid) const;
		  
		  /// Sets the name of a resource.
		  template<typename S, typename T>
		  int setResourceNameT(S restypeid, T resid, std::string strNewResName);
		  
		public:
		  ResourceNode* getRoot();
		  /// Corrects a erroneous resource directory.
		  void makeValid();
		  /// Reads the resource directory from a file.
		  int read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize, unsigned int uiResDirRva);
		  /// Rebuilds the resource directory.
		  void rebuild(std::vector<byte>& vBuffer, unsigned int uiRva) const;
		  /// Returns the size of the rebuilt resource directory.
//		  unsigned int size() const;
		  /// Writes the resource directory to a file.
		  int write(const std::string& strFilename, unsigned int uiOffset, unsigned int uiRva) const;

		  /// Adds a new resource type.
		  int addResourceType(dword dwResTypeId);
		  /// Adds a new resource type.
		  int addResourceType(const std::string& strResTypeName);
		  
		  /// Removes a resource type and all of it's resources.
		  int removeResourceType(dword dwResTypeId);
		  /// Removes a resource type and all of it's resources.
		  int removeResourceType(const std::string& strResTypeName);
		  
		  /// Removes a resource type and all of it's resources.
		  int removeResourceTypeByIndex(unsigned int uiIndex);
		  
		  /// Adds a new resource.
		  int addResource(dword dwResTypeId, dword dwResId);
		  /// Adds a new resource.
		  int addResource(dword dwResTypeId, const std::string& strResName);
		  /// Adds a new resource.
		  int addResource(const std::string& strResTypeName, dword dwResId);
		  /// Adds a new resource.
		  int addResource(const std::string& strResTypeName, const std::string& strResName);

		  /// Removes a resource.
		  int removeResource(dword dwResTypeId, dword dwResId);
		  /// Removes a resource.
		  int removeResource(dword dwResTypeId, const std::string& strResName);
		  /// Removes a resource.
		  int removeResource(const std::string& strResTypeName, dword dwResId);
		  /// Removes a resource.
		  int removeResource(const std::string& strResTypeName, const std::string& strResName);

		  /// Returns the number of resource types.
		  unsigned int getNumberOfResourceTypes() const;
		  
		  /// Returns the ID of a resource type.
		  dword getResourceTypeIdByIndex(unsigned int uiIndex) const;
		  /// Returns the name of a resource type.
		  std::string getResourceTypeNameByIndex(unsigned int uiIndex) const;
		  
		  /// Converts a resource type ID to an index.
		  int resourceTypeIdToIndex(dword dwResTypeId) const;
		  /// Converts a resource type name to an index.
		  int resourceTypeNameToIndex(const std::string& strResTypeName) const;
		  
		  /// Returns the number of resources of a certain resource type.
		  unsigned int getNumberOfResources(dword dwId) const;
		  /// Returns the number of resources of a certain resource type.
		  unsigned int getNumberOfResources(const std::string& strResTypeName) const;
		  
		  /// Returns the number of resources of a certain resource type.
		  unsigned int getNumberOfResourcesByIndex(unsigned int uiIndex) const;
		  
		  /// Returns the data of a certain resource.
		  void getResourceData(dword dwResTypeId, dword dwResId, std::vector<byte>& data) const;
		  /// Returns the data of a certain resource.
		  void getResourceData(dword dwResTypeId, const std::string& strResName, std::vector<byte>& data) const;
		  /// Returns the data of a certain resource.
		  void getResourceData(const std::string& strResTypeName, dword dwResId, std::vector<byte>& data) const;
		  /// Returns the data of a certain resource.
		  void getResourceData(const std::string& strResTypeName, const std::string& strResName, std::vector<byte>& data) const;
		  
		  /// Returns the data of a certain resource.
		  void getResourceDataByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::vector<byte>& data) const;
		  
		  /// Sets the data of a certain resource.
		  void setResourceData(dword dwResTypeId, dword dwResId, std::vector<byte>& data);
		  /// Sets the data of a certain resource.
		  void setResourceData(dword dwResTypeId, const std::string& strResName, std::vector<byte>& data);
		  /// Sets the data of a certain resource.
		  void setResourceData(const std::string& strResTypeName, dword dwResId, std::vector<byte>& data);
		  /// Sets the data of a certain resource.
		  void setResourceData(const std::string& strResTypeName, const std::string& strResName, std::vector<byte>& data);
		  
		  /// Sets the data of a certain resource.
		  void setResourceDataByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, std::vector<byte>& data);

		  /// Returns the ID of a certain resource.
		  dword getResourceId(dword dwResTypeId, const std::string& strResName) const;
		  /// Returns the ID of a certain resource.
		  dword getResourceId(const std::string& strResTypeName, const std::string& strResName) const;
		  
		  /// Returns the ID of a certain resource.
		  dword getResourceIdByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex) const;
		  
		  /// Sets the ID of a certain resource.
		  void setResourceId(dword dwResTypeId, dword dwResId, dword dwNewResId);
		  /// Sets the ID of a certain resource.
		  void setResourceId(dword dwResTypeId, const std::string& strResName, dword dwNewResId);
		  /// Sets the ID of a certain resource.
		  void setResourceId(const std::string& strResTypeName, dword dwResId, dword dwNewResId);
		  /// Sets the ID of a certain resource.
		  void setResourceId(const std::string& strResTypeName, const std::string& strResName, dword dwNewResId);
		  
		  /// Sets the ID of a certain resource.
		  void setResourceIdByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, dword dwNewResId);
		  
		  /// Returns the name of a certain resource.
		  std::string getResourceName(dword dwResTypeId, dword dwResId) const;
		  /// Returns the name of a certain resource.
		  std::string getResourceName(const std::string& strResTypeName, dword dwResId) const;
		  
		  /// Returns the name of a certain resource.
		  std::string getResourceNameByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex) const;
		  
		  /// Sets the name of a certain resource.
		  void setResourceName(dword dwResTypeId, dword dwResId, const std::string& strNewResName);
		  /// Sets the name of a certain resource.
		  void setResourceName(dword dwResTypeId, const std::string& strResName, const std::string& strNewResName);
		  /// Sets the name of a certain resource.
		  void setResourceName(const std::string& strResTypeName, dword dwResId, const std::string& strNewResName);
		  /// Sets the name of a certain resource.
		  void setResourceName(const std::string& strResTypeName, const std::string& strResName, const std::string& strNewResName);
		  
		  /// Sets the name of a certain resource.
		  void setResourceNameByIndex(unsigned int uiResTypeIndex, unsigned int uiResIndex, const std::string& strNewResName);
	};
	
	/**
	* Looks through the entire resource tree and returns a const_iterator to the resource specified
	* by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @return A const_iterator to the specified resource.
	**/
	template<typename S, typename T>
	std::vector<ResourceChild>::const_iterator ResourceDirectory::locateResourceT(S restypeid, T resid) const
	{
		typedef bool(ResourceChild::*CompFunc1)(S) const;
		typedef bool(ResourceChild::*CompFunc2)(T) const;
		
		CompFunc1 comp1 = ResComparer<S>::comp();
		CompFunc2 comp2 = ResComparer<T>::comp();

		std::vector<ResourceChild>::const_iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(comp1), restypeid));
		if (Iter == m_rnRoot.children.end())
		{
			return Iter;
		}
		
		ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
		std::vector<ResourceChild>::const_iterator ResIter = std::find_if(currNode->children.begin(), currNode->children.end(), std::bind2nd(std::mem_fun_ref(comp2), resid));
		if (ResIter == currNode->children.end())
		{
			return ResIter;
		}
			
		return ResIter;
	}
	
	/**
	* Looks through the entire resource tree and returns an iterator to the resource specified
	* by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @return An iterator to the specified resource.
	**/
	template<typename S, typename T>
	std::vector<ResourceChild>::iterator ResourceDirectory::locateResourceT(S restypeid, T resid)
	{
		typedef bool(ResourceChild::*CompFunc1)(S) const;
		typedef bool(ResourceChild::*CompFunc2)(T) const;
		
		CompFunc1 comp1 = ResComparer<S>::comp();
		CompFunc2 comp2 = ResComparer<T>::comp();

		std::vector<ResourceChild>::iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(comp1), restypeid));
		if (Iter == m_rnRoot.children.end())
		{
			return Iter;
		}
		
		ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
		std::vector<ResourceChild>::iterator ResIter = std::find_if(currNode->children.begin(), currNode->children.end(), std::bind2nd(std::mem_fun_ref(comp2), resid));
		if (ResIter == currNode->children.end())
		{
			return ResIter;
		}
			
		return ResIter;
	}
	
	/**
	* Adds a new resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param rc ResourceChild that will be added.
	**/
	template<typename S, typename T>
	int ResourceDirectory::addResourceT(S restypeid, T resid, ResourceChild& rc)
	{
		typedef bool(ResourceChild::*CompFunc1)(S) const;
		typedef bool(ResourceChild::*CompFunc2)(T) const;
		
		CompFunc1 comp1 = ResComparer<S>::comp();
		CompFunc2 comp2 = ResComparer<T>::comp();

		std::vector<ResourceChild>::iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(comp1), restypeid));
		if (Iter == m_rnRoot.children.end())
		{
			return 1;
			// throw Exceptions::ResourceTypeDoesNotExist(ResourceDirectoryId, __LINE__);
		}
		
		ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
		std::vector<ResourceChild>::iterator ResIter = std::find_if(currNode->children.begin(), currNode->children.end(), std::bind2nd(std::mem_fun_ref(comp2), resid));
		if (ResIter != currNode->children.end())
		{
			return 1;
//			throw Exceptions::EntryAlreadyExists(ResourceDirectoryId, __LINE__);
		}
				
		rc.child = new ResourceNode;
		ResourceChild rlnew;
		rlnew.child = new ResourceLeaf;
		ResourceNode* currNode2 = static_cast<ResourceNode*>(rc.child);
		currNode2->children.push_back(rlnew);
		currNode->children.push_back(rc);
		
		fixNumberOfEntries<T>::fix(currNode);
		fixNumberOfEntries<T>::fix(currNode2);
		
		return 0;
	}
	
	/**
	* Removes a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	**/
	template<typename S, typename T>
	int ResourceDirectory::removeResourceT(S restypeid, T resid)
	{
		typedef bool(ResourceChild::*CompFunc1)(S) const;
		typedef bool(ResourceChild::*CompFunc2)(T) const;
		
		CompFunc1 comp1 = ResComparer<S>::comp();
		CompFunc2 comp2 = ResComparer<T>::comp();
		
		std::vector<ResourceChild>::iterator Iter = std::find_if(m_rnRoot.children.begin(), m_rnRoot.children.end(), std::bind2nd(std::mem_fun_ref(comp1), restypeid));
		if (Iter == m_rnRoot.children.end())
		{
			return 1;
			//throw Exceptions::ResourceTypeDoesNotExist(ResourceDirectoryId, __LINE__);
		}
		
		ResourceNode* currNode = static_cast<ResourceNode*>(Iter->child);
		std::vector<ResourceChild>::iterator ResIter = std::find_if(currNode->children.begin(), currNode->children.end(), std::bind2nd(std::mem_fun_ref(comp2), resid));
		if (ResIter == currNode->children.end())
		{
			return 1;
			// throw Exceptions::InvalidName(ResourceDirectoryId, __LINE__);
		}
			
		currNode->children.erase(ResIter);
		
		fixNumberOfEntries<T>::fix(currNode);
		
		return 0;
	}
	
	/**
	* Returns the data of a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param data The data of the resource will be written into this vector.
	**/
	template<typename S, typename T>
	int ResourceDirectory::getResourceDataT(S restypeid, T resid, std::vector<byte>& data) const
	{
		std::vector<ResourceChild>::const_iterator ResIter = locateResourceT(restypeid, resid);
		ResourceNode* currNode = static_cast<ResourceNode*>(ResIter->child);
		ResourceLeaf* currLeaf = static_cast<ResourceLeaf*>(currNode->children[0].child);
		data.assign(currLeaf->m_data.begin(), currLeaf->m_data.end());
		
		return 0;
	}
	
	/**
	* Sets the data of a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param data The new data of the resource is taken from this vector.
	**/
	template<typename S, typename T>
	int ResourceDirectory::setResourceDataT(S restypeid, T resid, std::vector<byte>& data)
	{
		std::vector<ResourceChild>::iterator ResIter = locateResourceT(restypeid, resid);
		ResourceNode* currNode = static_cast<ResourceNode*>(ResIter->child);
		ResourceLeaf* currLeaf = static_cast<ResourceLeaf*>(currNode->children[0].child);
		currLeaf->m_data.assign(data.begin(), data.end());
		
		return 0;
	}
	
	/**
	* Returns the id of a resource, resource type and ID are specified by the parameters.
	* Note: Calling this function with resid == the ID of the resource makes no sense at all.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @return The ID of the specified resource.
	**/
	template<typename S, typename T>
	dword ResourceDirectory::getResourceIdT(S restypeid, T resid) const
	{
		std::vector<ResourceChild>::const_iterator ResIter = locateResourceT(restypeid, resid);
		return ResIter->entry.irde.Name;
	}
	
	/**
	* Sets the id of a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param dwNewResId New ID of the resource.
	**/
	template<typename S, typename T>
	int ResourceDirectory::setResourceIdT(S restypeid, T resid, dword dwNewResId)
	{
		std::vector<ResourceChild>::iterator ResIter = locateResourceT(restypeid, resid);
		ResIter->entry.irde.Name = dwNewResId;
		return 0;
	}
		  
	/**
	* Returns the name of a resource, resource type and ID are specified by the parameters.
	* Note: Calling this function with resid == the name of the resource makes no sense at all.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @return The name of the specified resource.
	**/
	template<typename S, typename T>
	std::string ResourceDirectory::getResourceNameT(S restypeid, T resid) const
	{
		std::vector<ResourceChild>::const_iterator ResIter = locateResourceT(restypeid, resid);
		return ResIter->entry.wstrName;
	}
		  
	/**
	* Sets the name of a resource, resource type and ID are specified by the parameters.
	* @param restypeid Identifier of the resource type (either ID or name).
	* @param resid Identifier of the resource (either ID or name).
	* @param strNewResName The new name of the resource.
	**/
	template<typename S, typename T>
	int ResourceDirectory::setResourceNameT(S restypeid, T resid, std::string strNewResName)
	{
		std::vector<ResourceChild>::iterator ResIter = locateResourceT(restypeid, resid);
		ResIter->entry.wstrName = strNewResName;
		
		return 0;
	}
}

#endif

```

`deps/PeLib/TlsDirectory.h`:

```h
/*
* TlsDirectory.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef TLSDIRECTORY_H
#define TLSDIRECTORY_H

namespace PeLib
{
	/// Class that handles the TLS directory.
	/**
	* This class handles the TLS (Thread Local Storage) directory.
	**/
	template<int bits>
	class TlsDirectory
	{
		private:
		  PELIB_IMAGE_TLS_DIRECTORY<bits> m_tls; ///< Structure that holds all information about the directory.

		  void read(InputBuffer& inputbuffer);

		public:
		  /// Reads a file's TLS directory.
		  int read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize); // EXPORT
		  int read(unsigned char* buffer, unsigned int buffersize); // EXPORT
		  /// Rebuilds the TLS directory.
		  void rebuild(std::vector<byte>& vBuffer) const; // EXPORT
		  /// Returns the size of the TLS Directory.
		  unsigned int size() const; // EXPORT
		  /// Writes the TLS directory to a file.
		  int write(const std::string& strFilename, unsigned int dwOffset) const; // EXPORT

		  /// Returns the StartAddressOfRawData value of the TLS header.
		  dword getStartAddressOfRawData() const; // EXPORT
		  /// Returns the EndAddressOfRawData value of the TLS header.
		  dword getEndAddressOfRawData() const; // EXPORT
		  /// Returns the AddressOfIndex value of the TLS header.
		  dword getAddressOfIndex() const; // EXPORT
		  /// Returns the AddressOfCallBacks value of the TLS header.
		  dword getAddressOfCallBacks() const; // EXPORT
		  /// Returns the SizeOfZeroFill value of the TLS header.
		  dword getSizeOfZeroFill() const; // EXPORT
		  /// Returns the Characteristics value of the TLS header.
		  dword getCharacteristics() const; // EXPORT
		  
		  /// Sets the StartAddressOfRawData value of the TLS header.
		  void setStartAddressOfRawData(dword dwValue); // EXPORT
		  /// Sets the EndAddressOfRawData value of the TLS header.
		  void setEndAddressOfRawData(dword dwValue); // EXPORT
		  /// Sets the AddressOfIndex value of the TLS header.
		  void setAddressOfIndex(dword dwValue); // EXPORT
		  /// Sets the AddressOfCallBacks value of the TLS header.
		  void setAddressOfCallBacks(dword dwValue); // EXPORT
		  /// Sets the SizeOfZeroFill value of the TLS header.
		  void setSizeOfZeroFill(dword dwValue); // EXPORT
		  /// Sets the Characteristics value of the TLS header.
		  void setCharacteristics(dword dwValue); // EXPORT
	};
	
	template<int bits>
	void TlsDirectory<bits>::read(InputBuffer& inputBuffer)
	{
		PELIB_IMAGE_TLS_DIRECTORY<bits> itdCurr;
		
		inputBuffer >> itdCurr.StartAddressOfRawData;
		inputBuffer >> itdCurr.EndAddressOfRawData;
		inputBuffer >> itdCurr.AddressOfIndex;
		inputBuffer >> itdCurr.AddressOfCallBacks;
		inputBuffer >> itdCurr.SizeOfZeroFill;
		inputBuffer >> itdCurr.Characteristics;
		
		std::swap(itdCurr, m_tls);
	}
	
	template<int bits>
	int TlsDirectory<bits>::read(unsigned char* buffer, unsigned int buffersize)
	{
		if (buffersize < PELIB_IMAGE_TLS_DIRECTORY<bits>::size())
		{
			return ERROR_INVALID_FILE;
		}

		std::vector<byte> vTlsDirectory(buffer, buffer + buffersize);
		
		InputBuffer ibBuffer(vTlsDirectory);
		read(ibBuffer);
		return NO_ERROR;
	}
	
	/**
	* Reads a file's TLS directory.
	* @param strFilename Name of the file.
	* @param uiOffset File offset of the TLS directory.
	* @param uiSize Size of the TLS directory.
	**/
	template<int bits>
	int TlsDirectory<bits>::read(const std::string& strFilename, unsigned int uiOffset, unsigned int uiSize)
	{
		std::ifstream ifFile(strFilename.c_str(), std::ios::binary);
		unsigned int ulFileSize = fileSize(ifFile);

		if (!ifFile)
		{
			return ERROR_OPENING_FILE;
		}
		
		if (ulFileSize < uiOffset + uiSize)
		{
			return ERROR_INVALID_FILE;
		}

		ifFile.seekg(uiOffset, std::ios::beg);

		std::vector<byte> vTlsDirectory(uiSize);
		ifFile.read(reinterpret_cast<char*>(&vTlsDirectory[0]), uiSize);
		
		InputBuffer ibBuffer(vTlsDirectory);
		read(ibBuffer);
		return NO_ERROR;
	}
	
	/**
	* Rebuilds the current TLS Directory.
	* @param vBuffer Buffer where the TLS directory will be written to.
	**/
	template<int bits>
	void TlsDirectory<bits>::rebuild(std::vector<byte>& vBuffer) const
	{
		OutputBuffer obBuffer(vBuffer);
		
		obBuffer << m_tls.StartAddressOfRawData;
		obBuffer << m_tls.EndAddressOfRawData;
		obBuffer << m_tls.AddressOfIndex;
		obBuffer << m_tls.AddressOfCallBacks;
		obBuffer << m_tls.SizeOfZeroFill;
		obBuffer << m_tls.Characteristics;
	}

	/**
	* Returns the size of the TLS directory. Due to the static nature of this structure the return value
	* will always be 24.
	* @return Size in bytes.
	**/
	template<int bits>
	unsigned int TlsDirectory<bits>::size() const
	{
		return PELIB_IMAGE_TLS_DIRECTORY<bits>::size();
	}

	/**
	* @param strFilename Name of the file.
	* @param dwOffset File offset the TLS Directory will be written to.
	**/
	template<int bits>
	int TlsDirectory<bits>::write(const std::string& strFilename, unsigned int dwOffset) const
	{
		std::fstream ofFile(strFilename.c_str(), std::ios_base::in);
		
		if (!ofFile)
		{
			ofFile.clear();
			ofFile.open(strFilename.c_str(), std::ios_base::out | std::ios_base::binary);
		}
		else
		{
			ofFile.close();
			ofFile.open(strFilename.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		if (!ofFile)
		{
			return ERROR_OPENING_FILE;
		}

		ofFile.seekp(dwOffset, std::ios::beg);

		std::vector<unsigned char> vBuffer;
		rebuild(vBuffer);

		ofFile.write(reinterpret_cast<const char*>(&vBuffer[0]), vBuffer.size());

		ofFile.close();
		
		return NO_ERROR;
	}

	/**
	* @return The StartAddressOfRawData value of the TLS directory.
	**/
	template<int bits>
	dword TlsDirectory<bits>::getStartAddressOfRawData() const
	{
		return m_tls.StartAddressOfRawData;
	}
	
	/**
	* @return The EndAddressOfRawData value of the TLS directory.
	**/
	template<int bits>
	dword TlsDirectory<bits>::getEndAddressOfRawData() const
	{
		return m_tls.EndAddressOfRawData;
	}
	
	/**
	* @return The AddressOfIndex value of the TLS directory.
	**/
	template<int bits>
	dword TlsDirectory<bits>::getAddressOfIndex() const
	{
		return m_tls.AddressOfIndex;
	}
	
	/**
	* @return The AddressOfCallBacks value of the TLS directory.
	**/
	template<int bits>
	dword TlsDirectory<bits>::getAddressOfCallBacks() const
	{
		return m_tls.AddressOfCallBacks;
	}
	
	/**
	* @return The SizeOfZeroFill value of the TLS directory.
	**/
	template<int bits>
	dword TlsDirectory<bits>::getSizeOfZeroFill() const
	{
		return m_tls.SizeOfZeroFill;
	}
	
	/**
	* @return The Characteristics value of the TLS directory.
	**/
	template<int bits>
	dword TlsDirectory<bits>::getCharacteristics() const
	{
		return m_tls.Characteristics;
	}

	/**
	* @param dwValue The new StartAddressOfRawData value of the TLS directory.
	**/
	template<int bits>
	void TlsDirectory<bits>::setStartAddressOfRawData(dword dwValue)
	{
		m_tls.StartAddressOfRawData = dwValue;
	}
	
	/**
	* @param dwValue The new EndAddressOfRawData value of the TLS directory.
	**/
	template<int bits>
	void TlsDirectory<bits>::setEndAddressOfRawData(dword dwValue)
	{
		m_tls.EndAddressOfRawData = dwValue;
	}
	
	/**
	* @param dwValue The new AddressOfIndex value of the TLS directory.
	**/
	template<int bits>
	void TlsDirectory<bits>::setAddressOfIndex(dword dwValue)
	{
		m_tls.AddressOfIndex = dwValue;
	}
	
	/**
	* @param dwValue The new AddressOfCallBacks value of the TLS directory.
	**/
	template<int bits>
	void TlsDirectory<bits>::setAddressOfCallBacks(dword dwValue)
	{
		m_tls.AddressOfCallBacks = dwValue;
	}
	
	/**
	* @param dwValue The new SizeOfZeroFill value of the TLS directory.
	**/
	template<int bits>
	void TlsDirectory<bits>::setSizeOfZeroFill(dword dwValue)
	{
		m_tls.SizeOfZeroFill = dwValue;
	}
	
	/**
	* @param dwValue The new Characteristics value of the TLS directory.
	**/
	template<int bits>
	void TlsDirectory<bits>::setCharacteristics(dword dwValue)
	{
		m_tls.Characteristics = dwValue;
	}
	
}
#endif

```

`deps/PeLib/buffer/InputBuffer.cpp`:

```cpp
/*
* InputBuffer.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "InputBuffer.h"

namespace PeLib
{
	unsigned long InputBuffer::get()
	{
		return ulIndex;
	}

	InputBuffer::InputBuffer(std::vector<unsigned char>& vBuffer) : m_vBuffer(vBuffer), ulIndex(0)
	{
	}

	const unsigned char* InputBuffer::data() const
	{
		return &m_vBuffer[0];
	}

	unsigned long InputBuffer::size()
	{
		return static_cast<unsigned long>(m_vBuffer.size());
	}

	void InputBuffer::read(char* lpBuffer, unsigned long ulSize)
	{
		std::copy(&m_vBuffer[ulIndex], &m_vBuffer[ulIndex + ulSize], lpBuffer);
		ulIndex += ulSize;
	}

	void InputBuffer::reset()
	{
		m_vBuffer.clear();
	}

	void InputBuffer::set(unsigned long ulIndex)
	{
		this->ulIndex = ulIndex;
	}

	void InputBuffer::setBuffer(std::vector<unsigned char>& vBuffer)
	{
		m_vBuffer = vBuffer;
		ulIndex = 0;
	}
}


```

`deps/PeLib/buffer/InputBuffer.h`:

```h
/*
* InputBuffer.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef INPUTBUFFER_H
#define INPUTBUFFER_H

#include <vector>
#include <iterator>
#include <cassert>

namespace PeLib
{
	class InputBuffer
	{
		private:
		  std::vector<unsigned char>& m_vBuffer;
		  unsigned long ulIndex;
		  
		public:
		  InputBuffer(std::vector<unsigned char>& vBuffer);
		  
		  const unsigned char* data() const;
		  unsigned long size();

		  template<typename T>
		  InputBuffer& operator>>(T& value)
		  {
			assert(ulIndex + sizeof(value) <= m_vBuffer.size());
			value = *(T*)(&m_vBuffer[ulIndex]);//reinterpret_cast<T*>(&m_vBuffer[ulIndex]);
			ulIndex += sizeof(T);
			return *this;
		  }

		  void read(char* lpBuffer, unsigned long ulSize);
		  void reset();
		  void set(unsigned long ulIndex);
		  unsigned long get();
		  void setBuffer(std::vector<unsigned char>& vBuffer);
//		  void updateData(unsigned long ulIndex,
	};
}

#endif

```

`deps/PeLib/buffer/OutputBuffer.cpp`:

```cpp
/*
* OutputBuffer.cpp - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#include "OutputBuffer.h"

namespace PeLib
{
	OutputBuffer::OutputBuffer(std::vector<unsigned char>& vBuffer) : m_vBuffer(vBuffer)
	{
		m_vBuffer.clear();
	}

	const unsigned char* OutputBuffer::data() const
	{
		return &m_vBuffer[0];
	}

	unsigned long OutputBuffer::size()
	{
		return static_cast<unsigned long>(m_vBuffer.size());
	}

	void OutputBuffer::add(const char* lpBuffer, unsigned long ulSize)
	{
		std::copy(lpBuffer, lpBuffer + ulSize, std::back_inserter(m_vBuffer));
	}

	void OutputBuffer::reset()
	{
		m_vBuffer.clear();
	}
}

```

`deps/PeLib/buffer/OutputBuffer.h`:

```h
/*
* OutputBuffer.h - Part of the PeLib library.
*
* Copyright (c) 2004 - 2005 Sebastian Porst (webmaster@the-interweb.com)
* All rights reserved.
*
* This software is licensed under the zlib/libpng License.
* For more details see http://www.opensource.org/licenses/zlib-license.php
* or the license information file (license.htm) in the root directory 
* of PeLib.
*/

#ifndef OUTPUTBUFFER_H
#define OUTPUTBUFFER_H

#include <vector>
#include <iterator>

namespace PeLib
{
	class OutputBuffer
	{
		private:
		  std::vector<unsigned char>& m_vBuffer;
		  
		public:
		  OutputBuffer(std::vector<unsigned char>& vBuffer);
		  const unsigned char* data() const;
		  unsigned long size();

		  template<typename T>
		  OutputBuffer& operator<<(const T& value)
		  {
			const unsigned char* p = reinterpret_cast<const unsigned char*>(&value);
			std::copy(p, p + sizeof(value), std::back_inserter(m_vBuffer));
			return *this;
		  }
		  void add(const char* lpBuffer, unsigned long ulSize);
		  void reset();
		  void resize(unsigned int uiSize);
		  void set(unsigned int uiPosition);

		  template<typename T>
		  void update(unsigned long ulIndex, const T& value)
		  {
			*(T*)(&m_vBuffer[ulIndex]) = value;
		  }
	};
}

#endif

```

`deps/PeLib/license.htm`:

```htm
<html>
<body>
<h1>The zlib/libpng License</h1>

<tt>

<p>Copyright (c) 2004 - Sebastian Porst</p>

  <p>This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.</p>

  <p>Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:</p>

<blockquote>

  <p>1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.</p>

  <p>2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.</p>

  <p>3. This notice may not be removed or altered from any source
 distribution.</p>

</blockquote>

</tt>

</body>
</html>
```

`license.txt`:

```txt
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

`samples/README.MD`:

```MD
# Reloc Packer Samples

This repository contains multiple different samples which can be used to test detection of the RelocBonus relocations-based packer. They are safe hello world applications, not harmful or malware.

**These samples are meant to run on Windows 7**. If you want to run on Windows 8 or 10, you must properly configure some execution policies. Here is a `.reg` template. You must replace `NAME_OF_EXE` with the name of the executable (file name is fine, do not use full path) you want to configure, and you must do this for each sample you use.

```
 [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\NAME_OF_EXE]
 "MitigationAuditOptions"=hex:00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
 "MitigationOptions"=hex:00,01,22,00,00,00,00,00,00,00,00,00,00,00,00,00
```

# Normal Samples

Samples prefixed with `normal-` are not packed using relocations. Before describing these samples, let me define a term:

`fixup` - The act of overwriting `ImageBase` of the in-memory the PE Header to match the base address of the executable in memory, which can be used as an evasion for runtime detection.

All of normal samples are "hello world" applications, with a few differences:

- `normal-nofixup.exe` has no unique behavior
- `normal-runtimefixup` does fixup inside of `EntryPoint` function

# Reloc Samples

These samples are variations of the normal samples that have been packed using RelocBonus. They **should** trigger detection.

`reloc-nofixup.exe` is the simplest sample with no fixup. Created with
```
reloc.exe --section=.text --section=.data normal-nofixup.exe reloc-nofixup.exe
```


`reloc-runtimefixup.exe` has fixup, but only inside of `EntryPoint`. Created with
```
reloc.exe --section=.text --section=.data normal-runtimefixup.exe reloc-runtimefixup.exe
```


`reloc-deltafixup.exe` has fixup, done by the Windows Loader during the relocations stage. This will almost certainly evade any post-reloc checks, but **it requires memory write-protection to be off**. This will certainly never be the case, though there is a trick to decrease section align and map a RW section on the same page as the header (Corkami figured this out, not me), causing a writeable header. This sample does not use that trick. Even though this sample really shouldn't run, you can catch the access violation in a debugger, change the page protection, and execute again to see the attack actually work. Created with 
```
reloc.exe --section=.text --section=.data normal-nofixup.exe reloc-deltafixup.exe --fixupBase
```
```

`src/reloc/ASLRPreselectionStub.h`:

```h
#pragma once
#include <iostream>

#include "LdrDefs.h"
#include "ShellcodeMacros.h"

void preselectionStub();
void preselectionFunc();
void preselectionFunc_end();

bool prepareStub(void* entryOffset, void* &stub, size_t &len, std::ostream &infoStream, std::ostream &errorStream)
{
	if (&preselectionStub > &preselectionFunc)
	{
		errorStream << "\t\tprepareStub: preselectionStub() must come before preselectionFunc()" << std::endl;
		return false;
	}

	if (&preselectionFunc > &preselectionFunc_end)
	{
		errorStream << "\t\tprepareStub: preselectionFunc() must come before preselectionFunc_end()" << std::endl;
		return false;
	}

	stub = &preselectionStub;
	len = (size_t)&preselectionFunc_end - (size_t)&preselectionStub;

	infoStream << "\t\tprepareStub: preparing stub at 0x" << std::hex << stub << " (len " << std::dec << len << ")" << std::endl;

	DWORD oldprotect;
	VirtualProtect(&preselectionStub, len, PAGE_EXECUTE_READWRITE, &oldprotect);

	const uint32_t entryOffsetMarker = 0xDEADB33F;
	for (auto ptr = (size_t)&preselectionStub; ptr < (size_t)&preselectionFunc_end; ptr++)
	{
		if (memcmp((void*)ptr, &entryOffsetMarker, 4) == 0)
		{
			memcpy((void*)ptr, &entryOffset, sizeof(void*));
			infoStream << "\t\tprepareStub: configured entry point at 0x" << std::hex << ptr << std::endl;
		}
	}

	VirtualProtect(&preselectionStub, len, oldprotect, &oldprotect);

	return true;
}


// this code absolutely needs to be compiled with all of these options,
// which sometimes don't take effect. so if you're having issues, make sure they
// are off in the project settings.
#pragma runtime_checks("scu", off)
#pragma optimize("", off)
#pragma strict_gs_check(push, off)
#pragma check_stack(off)

__declspec(naked) void preselectionStub()
{
	/*
		This function, along with preselectionFunc, get injected into the PE.
		The responsibility of this function is to preserve everything and call into preselectionFunc.
		That function will carry out the ASLR preselection attack. The assumption is that,
		if it fails, it will end our life with ExitProcess(). However, if the failing is during function resolution,
		it will int3 breakpoint.

		If it does not breakpoint and successfully returns, the assumption is the preselection was successfull.
		This means our base address is 0x00010000, and we will assume that when jumping to the original entry point.

		Marker in both funcs:
			0xDEADB33F   offset for original entry point
			0xBADB33F5   not a marker, but a magic value used as an exit code to communicate between processes
			0x00010000   if we ever want to preselect a different base, we much change all occurances of this (and make many changes to the pe recompiler)
	*/

	__asm
	{
		//PUSHAD
		//PUSHFD

		CALL preselectionFunc

		//POPFD
		//POPAD

		MOV EAX, 0x00010000
		ADD EAX, 0xDEADB33F
		JMP EAX

	}
}


void preselectionFunc()
{
	// grab loader list
	PPEB_LDR_DATA LoaderData;
	__asm
	{
		MOV EAX, DWORD PTR FS : [30h]
		MOV EAX, DWORD PTR DS : [EAX + 12]
		MOV LoaderData, EAX
	}

	// get modules
	LDR_GET_MODULE(kernel32Handle, 12, 'k', '2');

	// get functions
	// TODO could actually really simplify this by first locating GetModuleHandle and GetProcAddress
	// and using them to locate the rest of the functions.. but I got carried away working macro magic
	//
	// but hey guess what this actually makes reversing much harder so let's call it a feature!
	LDR_GET_PROC(f_GetModuleHandle,      kernel32Handle, HMODULE(__stdcall *)(PUCHAR), LDR_STR_SIG('G', 'e', 't', 'M', 'o', 'd', 'u', 'l', 'e', 'H', 'a', 'n', 'd', 'l', 'e', 'A'));
	LDR_GET_PROC(f_CreateMutexA,         kernel32Handle, HANDLE(__stdcall *)(PVOID, BOOL, LPCSTR), LDR_STR_SIG('C', 'r', 'e', 'a', 't', 'e', 'M', 'u', 't', 'e', 'x', 'A'));
	LDR_GET_PROC(f_GetLastError,         kernel32Handle, DWORD(__stdcall *)(), LDR_STR_SIG('G', 'e', 't', 'L', 'a', 's', 't', 'E', 'r', 'r', 'o', 'r'));
	LDR_GET_PROC(f_CloseHandle,          kernel32Handle, BOOL(__stdcall *)(HANDLE), LDR_STR_SIG('C', 'l', 'o', 's', 'e', 'H', 'a', 'n', 'd', 'l', 'e'));
	LDR_GET_PROC(f_GetCurrentProcessId,  kernel32Handle, DWORD(__stdcall *)(), LDR_STR_SIG('G', 'e', 't', 'C', 'u', 'r', 'r', 'e', 'n', 't', 'P', 'r', 'o', 'c', 'e', 's', 's', 'I', 'd'));
	LDR_GET_PROC(f_GetModuleFileNameW,   kernel32Handle, DWORD(__stdcall *)(HMODULE, LPWSTR, DWORD), LDR_STR_SIG('G', 'e', 't', 'M', 'o', 'd', 'u', 'l', 'e', 'F', 'i', 'l', 'e', 'N', 'a', 'm', 'e', 'W'));
	LDR_GET_PROC(f_CreateProcessW,       kernel32Handle, BOOL(__stdcall *)(LPCWSTR, LPWSTR, PVOID, PVOID, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION), LDR_STR_SIG('C', 'r', 'e', 'a', 't', 'e', 'P', 'r', 'o', 'c', 'e', 's', 's', 'W'));
	LDR_GET_PROC(f_WaitForSingleObject,  kernel32Handle, DWORD(__stdcall *)(HANDLE, DWORD), LDR_STR_SIG('W', 'a', 'i', 't', 'F', 'o', 'r', 'S', 'i', 'n', 'g', 'l', 'e', 'O', 'b', 'j', 'e', 'c', 't'));
	LDR_GET_PROC(f_GetExitCodeProcess,   kernel32Handle, BOOL(__stdcall *)(HANDLE, LPDWORD), LDR_STR_SIG('G', 'e', 't', 'E', 'x', 'i', 't', 'C', 'o', 'd', 'e', 'P', 'r', 'o', 'c', 'e', 's', 's'));
	LDR_GET_PROC(f_CreateFileW,          kernel32Handle, HANDLE(__stdcall *)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE), LDR_STR_SIG('C', 'r', 'e', 'a', 't', 'e', 'F', 'i', 'l', 'e', 'W'));
	LDR_GET_PROC(f_CreateFileMappingW,   kernel32Handle, HANDLE(__stdcall *)(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR), LDR_STR_SIG('C', 'r', 'e', 'a', 't', 'e', 'F', 'i', 'l', 'e', 'M', 'a', 'p', 'p', 'i', 'n', 'g', 'W'));
	LDR_GET_PROC(f_MapViewOfFileEx,      kernel32Handle, LPVOID(__stdcall *)(HANDLE, DWORD, DWORD, DWORD, SIZE_T, LPVOID), LDR_STR_SIG('M', 'a', 'p', 'V', 'i', 'e', 'w', 'O', 'f', 'F', 'i', 'l', 'e', 'E', 'x'));
	LDR_GET_PROC(f_UnmapViewOfFile,      kernel32Handle, BOOL(__stdcall *)(LPCVOID), LDR_STR_SIG('U', 'n', 'm', 'a', 'p', 'V', 'i', 'e', 'w', 'O', 'f', 'F', 'i', 'l', 'e'));
	LDR_GET_PROC(f_CopyFileW,            kernel32Handle, BOOL(__stdcall *)(LPCWSTR, LPCWSTR, BOOL), LDR_STR_SIG('C', 'o', 'p', 'y', 'F', 'i', 'l', 'e', 'W'));
	LDR_GET_PROC(f_DeleteFileW,          kernel32Handle, BOOL(__stdcall *)(LPCWSTR), LDR_STR_SIG('D', 'e', 'l', 'e', 't', 'e', 'F', 'i', 'l', 'e', 'W'));
	LDR_GET_PROC(f_lstrcatW,             kernel32Handle, LPWSTR(__stdcall *)(LPWSTR, LPCWSTR), LDR_STR_SIG('l', 's', 't', 'r', 'c', 'a', 't', 'W'));
	LDR_GET_PROC(f_ExitProcess,          kernel32Handle, VOID(__stdcall *)(DWORD), LDR_STR_SIG('E', 'x', 'i', 't', 'P', 'r', 'o', 'c', 'e', 's', 's'));

	// define strings
	DEFINE_STR(const char*, mutexName, 'r', 'e', 'l', 'o', 'c', '_', 'p', 'a', 'c', 'k', '_', 'm', 'u', 't');
	DEFINE_STR(const wchar_t*, copySuffix, '2', 0x00, '.', 0x00, 'e', 0x00, 'x', 0x00, 'e', 0x00);


	// do preselection
	auto base = f_GetModuleHandle(NULL);
	auto mutex = f_CreateMutexA(NULL, FALSE, mutexName);
	auto mutexErr = f_GetLastError();
	//printf("%06d: 0x%0p - ASLR Preselection ", f_GetCurrentProcessId(), base);
	if (base == (HMODULE)0x00010000)
	{
		// we have the correct base and it doesn't matter who we are, we're done
		//printf("SUCCESS\n");
		f_CloseHandle(mutex);
		return;
	}
	else if (mutexErr == ERROR_ALREADY_EXISTS)
	{
		// we don't have the correct base and we're not the original process, return
		//printf("FAILURE\n");
		f_CloseHandle(mutex);
		f_ExitProcess(0xBADB33F5);
	}
	else
	{
		// we don't have the correct base and we're the original process, begin ASLR Preselection
		//printf("STARTING\n");
		wchar_t filePath[MAX_PATH * 2];
		wchar_t destFilePath[MAX_PATH * 2];
		f_GetModuleFileNameW(NULL, filePath, sizeof(filePath));
		f_GetModuleFileNameW(NULL, destFilePath, sizeof(destFilePath));
		f_lstrcatW(destFilePath, copySuffix);
		if (f_CopyFileW(filePath, destFilePath, FALSE) == TRUE)
		{
			for (size_t i = 0; true; i++)
			{
				// launch the process
				STARTUPINFOW info;
				ZERO_MEM(&info, sizeof(info));
				info.cb = sizeof(info);

				PROCESS_INFORMATION processInfo;
				if (f_CreateProcessW(destFilePath, NULL, NULL, NULL, TRUE, 0, NULL, NULL, &info, &processInfo))
				{
					DWORD code;
					f_WaitForSingleObject(processInfo.hProcess, INFINITE);
					f_GetExitCodeProcess(processInfo.hProcess, &code);
					f_CloseHandle(processInfo.hProcess);
					f_CloseHandle(processInfo.hThread);

					if (code != 0xBADB33F5) // if we haven't thrown this code, it was a successfull execution
					{
						//printf("ASLR Preselection completed in %d tries", i);
						f_DeleteFileW(destFilePath);
						break;
					}
				}

				// trigger flush of the previous base
				auto fileHandle = f_CreateFileW(destFilePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
				if (fileHandle == INVALID_HANDLE_VALUE)
					continue;
				auto mapping = f_CreateFileMappingW(fileHandle, NULL, PAGE_READONLY, 0, 0, NULL);
				if (!mapping)
				{
					f_CloseHandle(fileHandle);
					continue;
				}
				auto mapView = f_MapViewOfFileEx(mapping, FILE_MAP_READ, 0, 0, 0, (LPVOID)0x00010000);
				if (mapView)
					f_UnmapViewOfFile(mapView);
				f_CloseHandle(mapping);
				f_CloseHandle(fileHandle);
			}
		}

		f_CloseHandle(mutex);
	}

	f_ExitProcess(0);
}

void preselectionFunc_end() {}

#pragma check_stack()
#pragma strict_gs_check(pop)
#pragma optimize("", on)
#pragma runtime_checks("scu", restore)
```

`src/reloc/LdrDefs.h`:

```h
#pragma once

#include <Windows.h>

typedef struct _PEB_LDR_DATA
{
	ULONG      Length;
	BOOL       Initialized;
	PVOID      SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LSA_UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRNIG, UNICODE_STRING, *PUNICODE_STRING;

typedef struct _LDR_MODULE
{
	LIST_ENTRY      InLoadOrderModuleList;
	LIST_ENTRY      InMemoryOrderModuleList;
	LIST_ENTRY      InInitializationOrderModuleList;
	PVOID           BaseAddress;
	PVOID           EntryPoint;
	ULONG           SizeOfImage;
	UNICODE_STRING  FullDllName;
	UNICODE_STRING  BaseDllName;
	ULONG           Flags;
	SHORT           LoadCount;
	SHORT           TlsIndex;
	LIST_ENTRY      HashTableEntry;
	ULONG           TimeDateStamp;
} LDR_MODULE, *PLDR_MODULE;

```

`src/reloc/PeLibInclude.h`:

```h
#pragma once
#include "..\PeLib\PeLibInc.h"
#include "..\PeLib\PeLib.h"
#include "..\PeLib\ExportDirectory.h"

/*#pragma warning(disable: 4099)
#ifdef _DEBUG
#ifdef _WIN64
#pragma comment(lib, "..\\PeLib\\PeLib64d.lib")
#else
#pragma comment(lib, "..\\PeLib\\PeLib32d.lib")
#endif
#else
#ifdef _WIN64
#pragma comment(lib, "..\\PeLib\\PeLib64.lib")
#else
#pragma comment(lib, "..\\PeLib\\PeLib32.lib")
#endif
#endif*/
```

`src/reloc/PeRecompiler.cpp`:

```cpp
#include "PeLibInclude.h" 

#include "PeRecompiler.h"
#include "VectorUtils.h"
#include "RewriteBlock.h"
#include "ASLRPreselectionStub.h"

#include <algorithm>
#include <functional>

#include <Windows.h>


const uint32_t TRICKY_BASE_ADDRESS = 0xFFFF0000;
const uint32_t ACTUALIZED_BASE_ADDRESS = 0x00010000;

PeSectionContents::PeSectionContents(uint32_t index, std::shared_ptr<PeLib::PeFile32> &_header, std::ifstream &file)
{
	auto& peHeader = _header->peHeader();
	this->index = index;
	this->RVA = peHeader.getVirtualAddress(index);
	this->size = peHeader.getSizeOfRawData(index);
	this->rawPointer = peHeader.getPointerToRawData(index);
	this->virtualSize = peHeader.getVirtualSize(index);
	this->name = peHeader.getSectionName(index);

	char* block = new char[this->size];
	file.seekg(this->rawPointer, std::ios::beg);
	file.read(block, this->size);

	this->data = std::vector<uint8_t>(block, block + this->size);
	delete[] block;
}

void PeSectionContents::print(std::ostream &stream)
{
	auto writePadHex = [&stream](uint32_t val) -> void
	{
		stream << "0x" << std::hex << std::left << std::setfill('0') << std::setw(8) << val << "  ";
	};

	stream << "\t";
	stream << std::left << std::setfill(' ') << std::setw(10) << this->name;
	writePadHex(this->virtualSize);
	writePadHex(this->size);
	writePadHex(this->RVA);
	writePadHex(this->rawPointer);
	stream << std::endl;
}


template <class RWBLOCK, typename... ARGS>
void PeRecompiler::addRewriteBlock(ARGS... args)
{
	auto block = std::shared_ptr<RewriteBlock>(new RWBLOCK(args...));
	this->rewriteBlocks.push_back(block);

	if (this->multiPass)
	{
		auto count = 0;
		auto newptr = block;
		while (true)
		{
			newptr = newptr->getNextMultiPassBlock(count++);
			if (newptr.get() != nullptr)
				this->rewriteBlocks.push_back(newptr);
			else
				break;
		}
	}
}


PeRecompiler::PeRecompiler(
	std::ostream &_infoStream, std::ostream &_errorStream,
	const std::string &_inputFileName, const std::string &_outputFileName
)
	: infoStream(_infoStream), errorStream(_errorStream),
	inputFileName(_inputFileName), outputFileName(_outputFileName),
	multiPass(false), shouldUseWin10Attack(false)
{
	this->infoStream << std::hex;
	this->errorStream << std::hex;
}


void PeRecompiler::useWindows10Attack(bool win10)
{
	this->shouldUseWin10Attack = win10;
}

void PeRecompiler::doMultiPass(bool multi)
{
	this->multiPass = multi;
}

bool PeRecompiler::loadInputFile()
{
	auto peFile = std::make_shared<PeLib::PeFile32>(this->inputFileName);
	if (peFile->readMzHeader() != NO_ERROR)
	{
		this->errorStream << "Failed to read MzHeader: " << this->inputFileName << std::endl;
		return false;
	}

	if (peFile->readPeHeader() != NO_ERROR)
	{
		this->errorStream << "Failed to read PeHeader: " << this->inputFileName << std::endl;
		return false;
	}

	this->peFile = peFile;
	this->infoStream << "Successfully loaded PE File: " << this->inputFileName << std::endl;
	return true;
}

bool PeRecompiler::loadInputSections()
{
	if (!this->peFile)
		return false;

	std::ifstream file(this->inputFileName.c_str(), std::ios::in | std::ios::binary | std::ios::ate);
	if (!file.is_open())
	{
		this->errorStream << "Failed to open original file for section reading: " << this->inputFileName << std::endl;
		return false;
	}

	auto& peHeader = this->peFile->peHeader();
	this->infoStream << "Loading sections" << std::endl;
	this->infoStream << "\t";
	this->infoStream << std::left << std::setfill(' ') << std::setw(10) << "Name";
	this->infoStream << std::hex << std::left << std::setw(12) << "VirtSize";
	this->infoStream << std::hex << std::left << std::setw(12) << "RawSize";
	this->infoStream << std::hex << std::left << std::setw(12) << "VirtAddr";
	this->infoStream << std::hex << std::left << std::setw(12) << "RawAddr";
	this->infoStream << std::endl;

	for (unsigned int sec = 0; sec < peHeader.getNumberOfSections(); sec++)
	{
		auto sc = std::make_shared<PeSectionContents>(sec, this->peFile, file);
		sc->print(this->infoStream);
		this->sectionContents.push_back(sc);
	}

	file.close();

	/* 
	TODO:
		when allocSection() has been properly finished and is able to serve
		a new relocations section during building, we can remove the following
		two checks; the first is done later as well, and the second won't be
		needed once section alloc is properly working.
	*/
	auto relocSec = this->getSectionByRVA(peHeader.getIddBaseRelocRva(), 4);
	if (!relocSec)
	{
		this->errorStream << "Failed to locate reloc section!" << std::endl;
		return false;
	}
	if (relocSec->index != (peHeader.getNumberOfSections() - 1))
	{
		this->errorStream << "Reloc section '" << relocSec->name << "' is not final section; currently unsupported" << std::endl;
		return false;
	}

	return true;
}

bool PeRecompiler::performOnDiskRelocations()
{
	if (!this->peFile)
		return false;

	/* first, make sure everything is as it must be */
	if (!this->sectionContents.size())
	{
		this->errorStream << "Section contents must be loaded before doing any relocations!" << std::endl;
		return false;
	}

	auto& peHeader = this->peFile->peHeader();

	uint32_t characteristics = peHeader.getDllCharacteristics();
	uint32_t requestedBase = peHeader.getImageBase();

	if ((characteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) != IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)
	{
		this->errorStream << "Binary must have ASLR enabled to perform on-disk relocations!" << std::endl;
		return false;
	}

	if (this->peFile->readRelocationsDirectory())
	{
		this->errorStream << "Failed to read reloc directory!" << std::endl;
		return false;
	}

	this->infoStream << "Preparing header for obfuscation" << std::endl;

	/*
		now, our first step is to remove the ASLR flag and request a base of TRICKY_BASE_ADDRESS.
		this actually causes us to load at ACTUALIZED_BASE_ADDRESS, though, so we will relocate to there.
	*/
	if (!this->shouldUseWin10Attack)
	{
		auto newCharacteristics = (characteristics & ~IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE);
		peHeader.setDllCharacteristics(newCharacteristics);
		this->infoStream << "\tStripped IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE flag" << std::endl;
		this->infoStream << "\t\tOld Characteristics: 0x" << characteristics << std::endl;
		this->infoStream << "\t\tNew Characteristics: 0x" << newCharacteristics << std::endl;
	}
	else if (characteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE)
	{
		this->infoStream << "\t[Win10 Attack] Leaving IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE set" << std::endl;
	}
	else
	{
		auto newCharacteristics = (characteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE);
		peHeader.setDllCharacteristics(newCharacteristics);
		this->infoStream << "\t[Win10 Attack] Added IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE flag" << std::endl;
		this->infoStream << "\t\tOld Characteristics: 0x" << characteristics << std::endl;
		this->infoStream << "\t\tNew Characteristics: 0x" << newCharacteristics << std::endl;
	}


	if (!this->shouldUseWin10Attack)
	{
		peHeader.setImageBase(TRICKY_BASE_ADDRESS);
		this->infoStream << "\tChanged ImageBase to 0x" << TRICKY_BASE_ADDRESS << " (was 0x" << requestedBase << ")" << std::endl;
	}
	else
	{
		this->infoStream << "\t[Win10 Attack] Leaving ImageBase as 0x" << requestedBase << std::endl;
	}



	/* now let's relocate everything to 0x00010000 */
	uint32_t numberOfRelocsPerformed = 0;
	auto& reloc = this->peFile->relocDir();
	const int32_t relocDelta = ACTUALIZED_BASE_ADDRESS - requestedBase;
	for (unsigned int rel = 0; rel < reloc.calcNumberOfRelocations(); rel++)
	{
		uint32_t relocBlockRVA = reloc.getVirtualAddress(rel);
		uint32_t relocBlockSize = reloc.getSizeOfBlock(rel);
		auto sc = this->getSectionByRVA(relocBlockRVA, 4);
		if (!sc)
		{
			this->errorStream << "Reloc has no matching section! RVA: 0x" << relocBlockRVA << std::endl;
			return false;
		}

		auto relocBlockCount = reloc.calcNumberOfRelocationData(rel);
		for (unsigned int relEntry = 0; relEntry < relocBlockCount; relEntry++)
		{
			uint16_t entry = reloc.getRelocationData(rel, relEntry);
			uint16_t entryType = (entry >> 12);
			uint32_t entryAddress = relocBlockRVA + (entry & 0x0FFF);

			uint32_t si = entryAddress - sc->RVA;
			if (entryType & IMAGE_REL_BASED_HIGHLOW)
			{
				uint32_t original;
				if (!getData(sc->data, si, original))
				{
					this->errorStream << "Failed to read original value to reloc!" << std::endl;
					return false;
				}
				putData(sc->data, si, original + relocDelta);
			}
			else if (entryType)
			{
				this->errorStream << "Unknown reloc type: 0x" << entryType << std::endl;
				return false;
			}

			numberOfRelocsPerformed++;
		}
	}

	this->infoStream << "\tParsed original reloc table and applied " << std::dec << numberOfRelocsPerformed << std::hex << " relocations" << std::endl;
	this->infoStream << "\t\tDelta of 0x" << relocDelta << " applied, as binary will load at 0x" << ACTUALIZED_BASE_ADDRESS << std::endl;

	/* we also need to clear out the original reloc table */
	while (reloc.calcNumberOfRelocations())
		reloc.removeRelocation(0);

	this->infoStream << "\tCleared original reloc table" << std::endl;

	return true;
}

bool PeRecompiler::rewriteHeader()
{
	if (!this->doRewriteReadyCheck())
		return false;

	if (!this->shouldUseWin10Attack)
	{
		this->addRewriteBlock<EntryPointRewriteBlock>(this->peFile);
		this->infoStream << "Rewrote header entrypoint" << std::endl;
	}
	else
	{
		this->infoStream << "[Win10 Attack] Skipping header entrypoint rewrite" << std::endl;
	}
	return true;
}

bool PeRecompiler::fixupBase()
{
	if (!this->doRewriteReadyCheck())
		return false;

	this->addRewriteBlock<BaseAddressRewriteBlock>(this->peFile);
	this->infoStream << "Added fixup rewrite for ImageBase; will match actual base in memory" << std::endl;

	return true;
}

bool PeRecompiler::rewriteSection(const std::string &name)
{
	if (!this->doRewriteReadyCheck())
		return false;

	for (auto isec = this->sectionContents.begin(); isec != this->sectionContents.end(); isec++)
	{
		auto& sec = *isec;
		if (sec->name.compare(name) == 0)
		{
			this->addRewriteBlock<PeSectionRewriteBlock>(sec);
			this->infoStream << "\tRewrote " << name << " section at RVA: 0x" << sec->RVA << std::endl;
			return true;
		}
	}

	this->infoStream << "\tSeemingly no section named " << name << " to rewrite" << std::endl;
	return true;
}

bool PeRecompiler::rewriteImports()
{
	if (!this->doRewriteReadyCheck())
		return false;

	if (this->shouldUseWin10Attack)
	{
		this->infoStream << "[Win10 Attack] Skipping import obfuscation" << std::endl;
		return true;
	}


	auto& peHeader = this->peFile->peHeader();
	this->infoStream << "Obfuscating imports" << std::endl;

	/* rewrite Import Address Table */
	uint32_t iatRVA = peHeader.getIddIatRva();
	uint32_t iatSize = peHeader.getIddIatSize();
	if (!this->rewriteSubsectionByRVA(iatRVA, iatSize))
		this->infoStream << "\tSeemingly no Import Address Table to rewrite" << std::endl;
	else
		this->infoStream << "\tRewrote Import Address Table from RVA 0x" << iatRVA << " to 0x" << (iatRVA + iatSize) << std::endl;

	/* rewrite Import Directory Table */
	uint32_t importRVA = peHeader.getIddImportRva();
	uint32_t importSize = peHeader.getIddImportSize();
	if (!this->rewriteSubsectionByRVA(importRVA, importSize))
		this->infoStream << "\tSeemingly no Import Table to rewrite" << std::endl;
	else
		this->infoStream << "\tRewrote Import Table from RVA 0x" << importRVA << " to 0x" << (importRVA + importSize) << std::endl;

	/* rewrite Import Hints/Names & Dll Names Table */
	auto iatSec = getSectionByRVA(iatRVA, iatSize);
	if (iatSec)
	{
		uint32_t iatOffset = iatRVA - iatSec->RVA;

		uint32_t lowestNameRVA = 0xFFFFFFFF;
		uint32_t highestNameRVA = 0;
		for (uint32_t imp = iatOffset; imp < iatOffset + iatSize; imp += 4)
		{
			uint32_t temp;
			if (!getData(iatSec->data, imp, temp))
				break;
			if (temp == 0) continue;
			else if (temp < lowestNameRVA) lowestNameRVA = temp;
			else if (temp > highestNameRVA) highestNameRVA = temp;
		}

		if (!this->rewriteSubsectionByRVA(lowestNameRVA, highestNameRVA - lowestNameRVA))
			this->infoStream << "\tSeemingly no Import Hints/Names & Dll Names Table to rewrite" << std::endl;
		else
			this->infoStream << "\tRewrote Import Hints/Names & Dll Names Table from RVA 0x" << lowestNameRVA << " to 0x" << highestNameRVA << std::endl;
	}

	return true;
}

bool PeRecompiler::rewriteMatches(const std::string &needle)
{
	if (!this->doRewriteReadyCheck())
		return false;

	this->infoStream << "\tObfuscating all instances of string: " << needle << std::endl;
	std::boyer_moore_horspool_searcher<std::string::const_iterator> searcher(needle.cbegin(), needle.cend());
	for (auto isec = this->sectionContents.begin(); isec != this->sectionContents.end(); isec++)
	{
		auto& sec = *isec;
		auto schunk = std::string(sec->data.begin(), sec->data.end());
		auto res = schunk.cbegin();
		while (true)
		{
			res = std::search(res, schunk.cend(), searcher);
			if (res == schunk.cend())
				break;
			auto index = (res - schunk.cbegin()) * sizeof(std::string::value_type);

			this->infoStream << "\t\tMatch in " << sec->name << " at offset 0x" << std::hex << index << std::endl;
			this->addRewriteBlock<PeSectionRewriteBlock>(sec, index, needle.length() + 1);
			res++;
		}
	}

	return true;
}


bool PeRecompiler::writeOutputFile()
{
	if (!this->peFile)
		return false;

	if (!this->sectionContents.size())
	{
		this->errorStream << "Section contents must be loaded before writing output!" << std::endl;
		return false;
	}

	this->infoStream << "Generating output file" << std::endl;

	auto& reloc = this->peFile->relocDir();
	auto& peHeader = this->peFile->peHeader();
	auto& mzHeader = this->peFile->mzHeader();

	/*
		first, we need to actually DO THE REWRITES that we have queued up.
		we will modify the contents buffers we have in rewriteBlocks and
		keep a ledger of those so we can generate a reloc table later.

		in order to support overlapping relocs, we must record blocks in the
		reverse order that we decrement them, as relocations are processed
		in a linear fashion. this is done using .push_front().

		this will work as long as each entry in rewriteBlocks contains _no overlap_,
		as the reversal happens between entries in rewriteBlocks, not between relocations
		in each entry.
	*/
	struct PackedBlock
	{
		PackedBlock(unsigned int _beginRVA) : beginRVA(_beginRVA), offsets() {}
		unsigned int beginRVA;
		std::vector<unsigned short> offsets;
	};
	std::list<PackedBlock> packedBlocks;

	const uint32_t requestedBase = peHeader.getImageBase();
	const uint32_t packDelta = (ACTUALIZED_BASE_ADDRESS - requestedBase);
	const uint32_t dataSize = 4;
	const uint32_t chunkSize = 1024 * dataSize;
	for (auto iblock = this->rewriteBlocks.begin(); iblock != this->rewriteBlocks.end(); iblock++)
	{
		auto& block = *iblock;
		if (!block)
			continue;

		uint32_t rva, offset;
		if (!block->getFirstEntryLoc(dataSize, rva, offset))
			continue;
		packedBlocks.push_front(PackedBlock(rva));

		do
		{
			if (!block->decrementEntry(offset, packDelta))
				break;

			auto packedBlock = packedBlocks.begin();
			auto rvaOffset = static_cast<uint16_t>((rva - packedBlock->beginRVA));
			if (rvaOffset >= chunkSize)
			{
				rvaOffset = 0;
				packedBlocks.push_front(PackedBlock(rva));
				packedBlock = packedBlocks.begin();
			}

			packedBlock->offsets.push_back(rvaOffset);
		}
		while (block->getNextEntryLoc(dataSize, offset, rva, offset));
	}

	/* now that that's done, we actually need to generate a reloc table... */
	if (packedBlocks.size())
	{
		this->infoStream << "\tApplied all rewrites to actual file contents" << std::endl;

		if (reloc.calcNumberOfRelocations())
		{
			this->errorStream << "No relocation table should exist if rewrites are present!" << std::endl;
			return false;
		}

		/* generate a new reloc entry for each packed block */
		for (auto ipb = packedBlocks.begin(); ipb != packedBlocks.end(); ipb++)
		{
			auto& packedBlock = *ipb;

			unsigned int rel = reloc.calcNumberOfRelocations();
			reloc.addRelocation();

			for (auto offset = packedBlock.offsets.begin(); offset != packedBlock.offsets.end(); offset++)
				reloc.addRelocationData(rel, (IMAGE_REL_BASED_HIGHLOW << 12) | (*offset & 0x0FFF));

			/*
				calculate the header values and write them.
				size needs +8 to include headr itself.
				number of entries should be even to align entire table on 4-byte boundary.
			*/
			uint32_t relocSize = (packedBlock.offsets.size() * sizeof(uint16_t)) + 8;
			if (packedBlock.offsets.size() % 2 == 1)
			{
				reloc.addRelocationData(rel, 0);
				relocSize += sizeof(uint16_t);
			}
			reloc.setVirtualAddress(rel, packedBlock.beginRVA);
			reloc.setSizeOfBlock(rel, relocSize);
		}

		this->infoStream << "\tGenerated reloc table for rewrites with " << std::dec << packedBlocks.size() << std::hex << " entries" << std::endl;
	}


	/*
		embed the new reloc table in place of the old one.
		make sure the raw data is aligned on a 512-byte boundary for filesystem mapping.
	*/
	auto relocSec = this->getSectionByRVA(peHeader.getIddBaseRelocRva(), 4);
	if (!relocSec)
	{
		this->errorStream << "Failed to locate reloc section!" << std::endl;
		return false;
	}

	relocSec->data.clear();
	reloc.rebuild(relocSec->data);
	peHeader.setVirtualSize(relocSec->index, relocSec->data.size());
	peHeader.setIddBaseRelocSize(relocSec->data.size());
	while (relocSec->data.size() % 512)
		relocSec->data.push_back(0x00);
	peHeader.setSizeOfRawData(relocSec->index, relocSec->data.size());

	this->infoStream << "\tUpdated PE header with new reloc meta-data" << std::endl;

	/* validate the binary since we changed some sections */
	peHeader.makeValid(mzHeader.getAddressOfPeHeader());
	this->infoStream << "\tValidated new PE header" << std::endl;

	/* inject preselection shellcode, if needed */
	if (this->shouldUseWin10Attack)
	{
		this->infoStream << "\t[Win10 Attack] Injecting ASLR preselection stub" << std::endl;

		/* prepare the stub */
		void* originalEntrypoint = (void*)peHeader.getAddressOfEntryPoint();

		void* stub;
		size_t stubLen;
		if (!prepareStub(originalEntrypoint, stub, stubLen, this->infoStream, this->errorStream))
		{
			this->errorStream << "Failed to inject ASLR preselection stub!" << std::endl;
			return false;
		}

		/* inject a section to hold the stub */
		auto access = PeLib::PELIB_IMAGE_SCN_MEM_EXECUTE | PeLib::PELIB_IMAGE_SCN_MEM_WRITE |
						PeLib::PELIB_IMAGE_SCN_MEM_READ | PeLib::PELIB_IMAGE_SCN_CNT_INITIALIZED_DATA |
						PeLib::PELIB_IMAGE_SCN_CNT_CODE;
		auto sc = this->allocSection(".presel", stubLen, access);

		peHeader.addSection(".presel", stubLen);

		/* point the entrypoint at the stub */
		auto offsetOfNewSection = peHeader.rvaToOffset(sc->RVA);
		this->infoStream << "\t\tOriginal EP: 0x" << std::hex << originalEntrypoint << std::endl;
		this->infoStream << "\t\tStub Section RVA: 0x" << std::hex << sc->RVA << std::endl;
		this->infoStream << "\t\tStub Section Offset: 0x" << std::hex << offsetOfNewSection << std::endl;
		peHeader.setAddressOfEntryPoint(sc->RVA);
		this->infoStream << "\t\tEP updated to RVA" << std::endl;

		/* write the stub to the section */
		pushBytes((const char*)stub, stubLen, sc->data);
	}
	
	/* write original MZ and PE headers to new binary */
	mzHeader.write(this->outputFileName, 0);
	this->infoStream << "\tWrote MZ Header to output file" << std::endl;

    peHeader.write(this->outputFileName, mzHeader.getAddressOfPeHeader());
	this->infoStream << "\tWrote PE Header to output file" << std::endl;
        
	/* write section meta-data and contents to new binary */
    peHeader.writeSections(this->outputFileName);
	this->infoStream << "\tWrote PE Section meta-data to output file" << std::endl;

	for (auto isec = this->sectionContents.begin(); isec != this->sectionContents.end(); isec++)
	{
		auto& sec = *isec;
		if (sec->size)
			peHeader.writeSectionData(this->outputFileName, sec->index, sec->data);
	}
	this->infoStream << "\tWrote PE Section Contents to output file" << std::endl;

	return true;
}


bool PeRecompiler::doRewriteReadyCheck()
{
	if (!this->peFile)
		return false;

	if (!this->sectionContents.size())
	{
		this->errorStream << "Section contents must be loaded before doing rewrites!" << std::endl;
		return false;
	}

	if (this->peFile->relocDir().calcNumberOfRelocations() || this->peFile->peHeader().getImageBase() != TRICKY_BASE_ADDRESS)
	{
		if (!this->shouldUseWin10Attack)
		{
			this->errorStream << "On-disk relocations must be performed before doing rewrites!" << std::endl;
			return false;
		}
	}

	return true;
}

std::shared_ptr<PeSectionContents> PeRecompiler::getSectionByRVA(uint32_t RVA, uint32_t size)
{
	if (!RVA || !size)
		return nullptr;

	for (auto isec = this->sectionContents.begin(); isec != this->sectionContents.end(); isec++)
	{
		auto& sec = *isec;
		if (RVA < sec->RVA || RVA >= (sec->RVA + sec->size) || (RVA + size) > (sec->RVA + sec->size))
			continue;
		return sec;
	}
	return nullptr;
}

std::shared_ptr<PeSectionContents> PeRecompiler::allocSection(const std::string& name, uint32_t size, uint32_t access)
{
	auto& peHeader = this->peFile->peHeader();
	auto& mzHeader = this->peFile->mzHeader();

	/*
		if possible, find an unused section to reuse.

		this works in theory, but needs to be properly tested
		and, as such, is disabled. my major concern right now
		is that we may re-use a section that is marked as discardable,
		which is typically a property of .reloc, which is also the only
		section which would currently be a reuse candidate. (fancy pooling
		just being an abstraction for future, even though there's only one)

		I am concerned about this because discardable sections may not have space
		alloted for them in the in-memory mapping, so reusing them for things
		which must not be discarded, such as injected stubs, can be
		problematic. This isn't always the case. For instance, if the section is
		the final section in the binary, there shouldn't be an issue. Might also
		be able to mess with VA's and such for other cases.

		In short, this is here because I want it to work, but it currently
		needs more testing and consideration. You might say "wait, the code
		is right here, what do you mean this is disabled?" And the answer is
		that we never add anything to this->sectionPool, so the loop won't run.
	*/
	std::shared_ptr<PeSectionContents> newSec = nullptr;
	auto finalSecIndex = peHeader.getNumberOfSections() - 1;
	for (auto& sec : this->sectionPool)
	{
		if (sec->size > size || sec->index == finalSecIndex)
		{
			this->infoStream << "\t\tRepurposed Section " << sec->name << " as " << name << std::endl;
			newSec = sec;
			peHeader.setSectionName(sec->index, name);
			peHeader.setVirtualSize(sec->index, size);
			peHeader.setSizeOfRawData(sec->index, size);
			this->sectionPool.remove(sec);
			break;
		}
	}

	/* if reuse failed, alloc a new section */
	if (!newSec)
	{
		/* allocate it */
		peHeader.addSection(name, size);
		this->infoStream << "\t\tInjected Section " << name << std::endl;

		/* re-validate the binary since we added a section */
		peHeader.makeValid(mzHeader.getAddressOfPeHeader());

		/* track the section */
		newSec = std::make_shared<PeSectionContents>();
		newSec->index = peHeader.getNumberOfSections() - 1;
		this->sectionContents.push_back(newSec);
	}

	/* set up proper section access */
	peHeader.setCharacteristics(newSec->index, access);

	/* prepare the section contents */
	newSec->RVA = peHeader.getVirtualAddress(newSec->index);
	newSec->size = peHeader.getSizeOfRawData(newSec->index);
	newSec->rawPointer = peHeader.getPointerToRawData(newSec->index);
	newSec->virtualSize = peHeader.getVirtualSize(newSec->index);
	newSec->name = peHeader.getSectionName(newSec->index);

	/* display some info and nope out */
	this->infoStream << "\t\t\tVirtual Size: 0x" << newSec->virtualSize << std::endl;
	this->infoStream << "\t\t\tRVA: 0x" << newSec->RVA << std::endl;
	this->infoStream << "\t\t\tRaw Size: 0x" << newSec->size << std::endl;
	this->infoStream << "\t\t\tRaw Pointer: 0x" << newSec->rawPointer << std::endl;

	return newSec;
}

bool PeRecompiler::rewriteSubsectionByRVA(uint32_t RVA, uint32_t size)
{
	auto sec = getSectionByRVA(RVA, size);
	if (!sec)
		return false;
	this->addRewriteBlock<PeSectionRewriteBlock>(sec, RVA - sec->RVA, size);
	return true;
}
```

`src/reloc/PeRecompiler.h`:

```h
#pragma once
#include <memory>
#include <string>
#include <vector>
#include <list>
#include <iostream>
#include <iomanip>
#include <stdint.h>

class RewriteBlock;
namespace PeLib { class PeFile32; };

class PeSectionContents
{
public:
	std::string name;
	std::vector<uint8_t> data;
	uint32_t index, RVA, size, virtualSize, rawPointer;

	PeSectionContents() {}
	PeSectionContents(uint32_t index, std::shared_ptr<PeLib::PeFile32> &_header, std::ifstream &file);

	void print(std::ostream &stream);
};

class PeRecompiler
{
public:
	PeRecompiler(
		std::ostream &_infoStream, std::ostream &_errorStream,
		const std::string &_inputFileName, const std::string &_outputFileName
	);
	~PeRecompiler() {}

	void useWindows10Attack(bool win10);
	void doMultiPass(bool multi);

	bool loadInputFile();
	bool loadInputSections();

	bool performOnDiskRelocations();

	bool rewriteHeader();
	bool fixupBase();
	bool rewriteSection(const std::string &name);
	bool rewriteImports();

	bool rewriteMatches(const std::string &needle);

	bool writeOutputFile();

private:
	bool multiPass;
	bool shouldUseWin10Attack;
	std::ostream &infoStream, &errorStream;
	std::string inputFileName, outputFileName;
	std::shared_ptr<PeLib::PeFile32> peFile;
	
	std::list<std::shared_ptr<PeSectionContents>> sectionPool;
	std::vector<std::shared_ptr<PeSectionContents>> sectionContents;
	std::vector<std::shared_ptr<RewriteBlock>> rewriteBlocks;

	bool doRewriteReadyCheck();
	std::shared_ptr<PeSectionContents> getSectionByRVA(uint32_t RVA, uint32_t size);
	std::shared_ptr<PeSectionContents> allocSection(const std::string& name, uint32_t size, uint32_t access);
	bool rewriteSubsectionByRVA(uint32_t RVA, uint32_t size);
	

	template <class RWBLOCK, typename... ARGS>
	void addRewriteBlock(ARGS... args);
};
```

`src/reloc/RewriteBlock.cpp`:

```cpp
#include "PeLibInclude.h"

#include "RewriteBlock.h"
#include "PeRecompiler.h"
#include "VectorUtils.h"


EntryPointRewriteBlock::EntryPointRewriteBlock(std::shared_ptr<PeLib::PeFile32> _header)
	: header(_header) { }

bool EntryPointRewriteBlock::getFirstEntryLoc(uint32_t size, uint32_t &firstEntryRVA, uint32_t &firstEntryOffset) const
{
	if (size > sizeof(this->header->peHeader().getAddressOfEntryPoint()))
		return false;

	// 0x18 is sizeof(Signature) + sizeof(IMAGE_FILE_HEADER), 0x10 is the offset of AddressOfEntryPoint into IMAGE_OPTIONAL_HEADER
	firstEntryRVA = this->header->mzHeader().getAddressOfPeHeader() + 0x18 + 0x10;
	firstEntryOffset = 0;
	return true;
}

bool EntryPointRewriteBlock::getNextEntryLoc(uint32_t size, uint32_t lastEntryOffset, uint32_t &nextEntryRVA, uint32_t &nextEntryOffset) const
{
	return false;
}

bool EntryPointRewriteBlock::decrementEntry(uint32_t offset, uint32_t value)
{
	uint32_t original = this->header->peHeader().getAddressOfEntryPoint();
	this->header->peHeader().setAddressOfEntryPoint(static_cast<PeLib::dword>(original - value));
	return true;
}



BaseAddressRewriteBlock::BaseAddressRewriteBlock(std::shared_ptr<PeLib::PeFile32> _header)
	: header(_header) { }

bool BaseAddressRewriteBlock::getFirstEntryLoc(uint32_t size, uint32_t &firstEntryRVA, uint32_t &firstEntryOffset) const
{
	if (size > sizeof(this->header->peHeader().getImageBase()))
		return false;

	// 0x18 is sizeof(Signature) + sizeof(IMAGE_FILE_HEADER), 0x1C is the offset of BaseAddress into IMAGE_OPTIONAL_HEADER
	firstEntryRVA = this->header->mzHeader().getAddressOfPeHeader() + 0x18 + 0x1C;
	firstEntryOffset = 0;
	return true;
}

bool BaseAddressRewriteBlock::getNextEntryLoc(uint32_t size, uint32_t lastEntryOffset, uint32_t &nextEntryRVA, uint32_t &nextEntryOffset) const
{
	return false;
}

bool BaseAddressRewriteBlock::decrementEntry(uint32_t offset, uint32_t value)
{
	// we don't actually rewrite this before hand, so nothing to do here
	return true;
}



PeSectionRewriteBlock::PeSectionRewriteBlock(std::shared_ptr<PeSectionContents> _sec)
	: sec(_sec), startOffset(0), endOffset(_sec->size) { }
PeSectionRewriteBlock::PeSectionRewriteBlock(std::shared_ptr<PeSectionContents> _sec, uint32_t _startOffset, uint32_t _subSize)
	: sec(_sec), startOffset(_startOffset), endOffset(_startOffset + _subSize)
{
	if (this->endOffset > this->sec->size)
		this->endOffset = this->sec->size;
}

bool PeSectionRewriteBlock::getFirstEntryLoc(uint32_t size, uint32_t &firstEntryRVA, uint32_t &firstEntryOffset) const
{
	if (this->startOffset + size > this->endOffset)
		return false;
	return this->getNextEntryLoc(0, this->startOffset, firstEntryRVA, firstEntryOffset);
}

bool PeSectionRewriteBlock::getNextEntryLoc(uint32_t size, uint32_t lastEntryOffset, uint32_t &nextEntryRVA, uint32_t &nextEntryOffset) const
{
	if (lastEntryOffset + size >= this->endOffset)
		return false;

	nextEntryOffset = lastEntryOffset + size;
	nextEntryRVA = this->sec->RVA + nextEntryOffset;
	return true;
}

bool PeSectionRewriteBlock::decrementEntry(uint32_t offset, uint32_t value)
{
	uint32_t original;
	if (!getData(this->sec->data, offset, original)) return false;
	if (!putData(this->sec->data, offset, (original - value) )) return false;
	return true;
}

std::shared_ptr<RewriteBlock> PeSectionRewriteBlock::getNextMultiPassBlock(uint32_t num)
{
	// each PeSectionRewriteBlock should have only one sibling block for multi-pass,
	// offset by 2 bytes. additionally, we shouldn't multipass something which doesn't
	// have enough bytes.
	// 
	// there's one exception: on pass #2 (index == 1), if possible, we BACKTRACK a total
	// of 4 bytes (2 to get us to original spot, 2 to get us 2 bytes before original spot) so
	// we don't miss the first 2 bytes of the data, since they'll be missed due to endianness.
	// this is mostly useful for strings and crap. This backtrack block will only be 4 bytes long,
	// as we only want to hit the first entry.

	if (num >= 1)
	{
		if (num == 1 && this->startOffset >= 4)  // backtrack for first 2 bytes
			return std::shared_ptr<RewriteBlock>(new PeSectionRewriteBlock(this->sec, this->startOffset - 4, 4));
		return nullptr; // no more blocks to be made
	}
	if (this->endOffset - this->startOffset <= 6) // make sure we have room
		return nullptr;

	// first block
	auto _startOffset = this->startOffset + 2;
	return std::shared_ptr<RewriteBlock>(new PeSectionRewriteBlock(this->sec, _startOffset, this->endOffset - _startOffset));
}
```

`src/reloc/RewriteBlock.h`:

```h
#pragma once

#include <stdint.h>
#include <memory>
namespace PeLib { class PeFile32; };

class PeSectionContents;

class RewriteBlock // defines a block that we will rewrite (encrypt) on disk
{
public:
	virtual bool getFirstEntryLoc(uint32_t size, uint32_t &firstEntryRVA, uint32_t &firstEntryOffset) const = 0;
	virtual bool getNextEntryLoc(uint32_t size, uint32_t lastEntryOffset, uint32_t &nextEntryRVA, uint32_t &nextEntryOffset) const = 0;
	virtual bool decrementEntry(uint32_t offset, uint32_t value) = 0;
	virtual std::shared_ptr<RewriteBlock> getNextMultiPassBlock(uint32_t num) { return nullptr;  }
};

class EntryPointRewriteBlock : public RewriteBlock
{
public:
	EntryPointRewriteBlock(std::shared_ptr<PeLib::PeFile32> _header);

	virtual bool getFirstEntryLoc(uint32_t size, uint32_t &firstEntryRVA, uint32_t &firstEntryOffset) const;
	virtual bool getNextEntryLoc(uint32_t size, uint32_t lastEntryOffset, uint32_t &nextEntryRVA, uint32_t &nextEntryOffset) const;
	virtual bool decrementEntry(uint32_t offset, uint32_t value);

private:
	std::shared_ptr<PeLib::PeFile32> header;
};

class BaseAddressRewriteBlock : public RewriteBlock
{
public:
	BaseAddressRewriteBlock(std::shared_ptr<PeLib::PeFile32> _header);

	virtual bool getFirstEntryLoc(uint32_t size, uint32_t &firstEntryRVA, uint32_t &firstEntryOffset) const;
	virtual bool getNextEntryLoc(uint32_t size, uint32_t lastEntryOffset, uint32_t &nextEntryRVA, uint32_t &nextEntryOffset) const;
	virtual bool decrementEntry(uint32_t offset, uint32_t value);

private:
	std::shared_ptr<PeLib::PeFile32> header;
};

class PeSectionRewriteBlock : public RewriteBlock
{
public:
	PeSectionRewriteBlock(std::shared_ptr<PeSectionContents> _sec);
	PeSectionRewriteBlock(std::shared_ptr<PeSectionContents> _sec, uint32_t _startOffset, uint32_t _subSize);

	virtual bool getFirstEntryLoc(uint32_t size, uint32_t &firstEntryRVA, uint32_t &firstEntryOffset) const;
	virtual bool getNextEntryLoc(uint32_t size, uint32_t lastEntryOffset, uint32_t &nextEntryRVA, uint32_t &nextEntryOffset) const;
	virtual bool decrementEntry(uint32_t offset, uint32_t value);

	virtual std::shared_ptr<RewriteBlock> getNextMultiPassBlock(uint32_t num);

private:
	uint32_t startOffset, endOffset;
	std::shared_ptr<PeSectionContents> sec;
};
```

`src/reloc/ShellcodeMacros.h`:

```h
#pragma once

// HELPERS FOR VARIADIC MACROS
#define EXPAND( x ) x
#define __ARG_N( \
      _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
     _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
     _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
     _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
     _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
     _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
     _61,_62,_63,N,...) N
#define __RSEQ_N() \
     63,62,61,60,                   \
     59,58,57,56,55,54,53,52,51,50, \
     49,48,47,46,45,44,43,42,41,40, \
     39,38,37,36,35,34,33,32,31,30, \
     29,28,27,26,25,24,23,22,21,20, \
     19,18,17,16,15,14,13,12,11,10, \
     9,8,7,6,5,4,3,2,1,0
#define __NARG_I_(...) EXPAND(__ARG_N(__VA_ARGS__))
#define __NARG__(...) __NARG_I_(__VA_ARGS__,__RSEQ_N())
#define __NARG_PLUS_TWO__(...) __NARG__(0, 0, __VA_ARGS__)

#define _VFUNC_(name, n) name##n
#define _VFUNC(name, n) _VFUNC_(name, n)
#define VFUNC(func, ...) EXPAND(_VFUNC(func, __NARG__(__VA_ARGS__)) (__VA_ARGS__))

// GetModuleHandle as a macro
#define LOWER(c) ((((char)c) <= 0x5A && ((char)c) >= 0x41) ? ((char)c) + 0x20 : ((char)c))
#define LDR_GET_MODULE(varName, len, firstChar, lastCharBeforeExt) \
	PVOID varName = NULL; \
	auto module##varName = (PLDR_MODULE)LoaderData->InLoadOrderModuleList.Flink; \
	do { \
		auto checkLen = module##varName->FullDllName.Length / 2; \
		/*wprintf(L"Mod (len %d): %s\n", checkLen, module##varName->FullDllName.Buffer);*/ \
		if (checkLen > len) { \
			if (LOWER(module##varName->FullDllName.Buffer[checkLen - len - 1]) == '\\' && \
				LOWER(module##varName->FullDllName.Buffer[checkLen - len]) == firstChar && \
				LOWER(module##varName->FullDllName.Buffer[checkLen - 5]) == lastCharBeforeExt) { \
					varName = module##varName->BaseAddress; \
					break; \
			} \
		} \
		module##varName = (PLDR_MODULE)module##varName->InLoadOrderModuleList.Flink; \
	} while ((PVOID)module##varName != &LoaderData->InLoadOrderModuleList && module##varName->BaseAddress); \
	if (varName == NULL) /*return 0xBADB33F5;*/ {__asm int 3} \
	//printf("%s at 0x%p\n", #varName, varName);

// GetProcAddress as a macro
#define LDR_STR_SIG1(c1) ((int)c1 * (1 << (1 % 16)))
#define LDR_STR_SIG2(c1, c2) (LDR_STR_SIG1(c1) + (int)c2 * (1 << (2 % 16)))
#define LDR_STR_SIG3(c1, c2, c3) (LDR_STR_SIG2(c1, c2) + (int)c3 * (1 << (3 % 16)))
#define LDR_STR_SIG4(c1, c2, c3, c4) (LDR_STR_SIG3(c1, c2, c3) + (int)c4 * (1 << (4 % 16)))
#define LDR_STR_SIG5(c1, c2, c3, c4, c5) (LDR_STR_SIG4(c1, c2, c3, c4) + (int)c5 * (1 << (5 % 16)))
#define LDR_STR_SIG6(c1, c2, c3, c4, c5, c6) (LDR_STR_SIG5(c1, c2, c3, c4, c5) + (int)c6 * (1 << (6 % 16)))
#define LDR_STR_SIG7(c1, c2, c3, c4, c5, c6, c7) (LDR_STR_SIG6(c1, c2, c3, c4, c5, c6) + (int)c7 * (1 << (7 % 16)))
#define LDR_STR_SIG8(c1, c2, c3, c4, c5, c6, c7, c8) (LDR_STR_SIG7(c1, c2, c3, c4, c5, c6, c7) + (int)c8 * (1 << (8 % 16)))
#define LDR_STR_SIG9(c1, c2, c3, c4, c5, c6, c7, c8, c9) (LDR_STR_SIG8(c1, c2, c3, c4, c5, c6, c7, c8) + (int)c9 * (1 << (9 % 16)))
#define LDR_STR_SIG10(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10) (LDR_STR_SIG9(c1, c2, c3, c4, c5, c6, c7, c8, c9) + (int)c10 * (1 << (10 % 16)))
#define LDR_STR_SIG11(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11) (LDR_STR_SIG10(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10) + (int)c11 * (1 << (11 % 16)))
#define LDR_STR_SIG12(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12) (LDR_STR_SIG11(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11) + (int)c12 * (1 << (12 % 16)))
#define LDR_STR_SIG13(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13) (LDR_STR_SIG12(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12) + (int)c13 * (1 << (13 % 16)))
#define LDR_STR_SIG14(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14) (LDR_STR_SIG13(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13) + (int)c14 * (1 << (14 % 16)))
#define LDR_STR_SIG15(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15) (LDR_STR_SIG14(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14) + (int)c15 * (1 << (15 % 16)))
#define LDR_STR_SIG16(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16) (LDR_STR_SIG15(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15) + (int)c16 * (1 << (16 % 16)))
#define LDR_STR_SIG17(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17) (LDR_STR_SIG16(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16) + (int)c17 * (1 << (17 % 16)))
#define LDR_STR_SIG18(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18) (LDR_STR_SIG17(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17) + (int)c18 * (1 << (18 % 16)))
#define LDR_STR_SIG19(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19) (LDR_STR_SIG18(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18) + (int)c19 * (1 << (19 % 16)))
#define LDR_STR_SIG20(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20) (LDR_STR_SIG19(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19) + (int)c20 * (1 << (20 % 16)))
#define LDR_STR_SIG21(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21) (LDR_STR_SIG20(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20) + (int)c21 * (1 << (21 % 16)))
#define LDR_STR_SIG22(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22) (LDR_STR_SIG21(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21) + (int)c22 * (1 << (22 % 16)))
#define LDR_STR_SIG23(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23) (LDR_STR_SIG22(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22) + (int)c23 * (1 << (23 % 16)))
#define LDR_STR_SIG24(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24) (LDR_STR_SIG23(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23) + (int)c24 * (1 << (24 % 16)))
#define LDR_STR_SIG25(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25) (LDR_STR_SIG24(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24) + (int)c25 * (1 << (25 % 16)))
#define LDR_STR_SIG26(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26) (LDR_STR_SIG25(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25) + (int)c26 * (1 << (26 % 16)))
#define LDR_STR_SIG27(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27) (LDR_STR_SIG26(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26) + (int)c27 * (1 << (27 % 16)))
#define LDR_STR_SIG28(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28) (LDR_STR_SIG27(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27) + (int)c28 * (1 << (28 % 16)))
#define LDR_STR_SIG29(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28, c29) (LDR_STR_SIG28(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21, c22, c23, c24, c25, c26, c27, c28) + (int)c29 * (1 << (29 % 16)))
#define LDR_STR_SIG(...) __NARG__(__VA_ARGS__), VFUNC(LDR_STR_SIG, __VA_ARGS__)

#define LDR_GET_PROC_INTERNAL(varName, module, typeCast, len, sig) \
	auto varName = (typeCast)NULL; \
	auto base##varName = (HINSTANCE)module; \
	auto dosHeader##varName = (PIMAGE_DOS_HEADER)base##varName; \
	auto ntHeader##varName = (PIMAGE_NT_HEADERS)((LONG)dosHeader##varName + dosHeader##varName->e_lfanew); \
	auto exportOffset##varName = ntHeader##varName->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; \
	auto exportSize##varName = ntHeader##varName->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size; \
	auto exportDir##varName = (PIMAGE_EXPORT_DIRECTORY)((DWORD)base##varName + exportOffset##varName); \
	auto functionArray##varName = (PDWORD)((LPBYTE)base##varName + exportDir##varName->AddressOfFunctions); \
	auto functionNameArray##varName = (PDWORD)((LPBYTE)base##varName + exportDir##varName->AddressOfNames); \
	auto ordinal##varName = (PWORD)((LPBYTE)base##varName + exportDir##varName->AddressOfNameOrdinals); \
	for (DWORD i = 0; i < exportDir##varName->NumberOfFunctions; i++) { \
		if (functionNameArray##varName[i] == NULL) continue; \
		auto funcName = (char*)base##varName+functionNameArray##varName[i]; \
		int nameLen = 0; \
		int nameSig = 0; \
		for (; funcName[nameLen] != '\x00'; nameLen++) \
			nameSig += (int)funcName[nameLen] * (1 << ((nameLen + 1) % 16)); \
		/*printf("Func (len %02d, sig %08d): %s\n", nameLen, nameSig, funcName);*/ \
		if (nameLen == len && nameSig == sig) { \
			varName = (typeCast)((LPBYTE)base##varName+functionArray##varName[ordinal##varName[i]]); \
			/*printf("%s %08d - %s %08d\n", #varName, sig, funcName, nameSig);*/ \
			break; \
		} \
	} \
	if (varName == NULL) /*return 0xBADB33F5;*/ {__asm int 3} \
	//printf("%s at 0x%p\n", #varName, varName);

#define LDR_GET_PROC(...) EXPAND(LDR_GET_PROC_INTERNAL(__VA_ARGS__))

// String definitions in inline assembly as a macro
#define EMIT1(c1) __asm _emit c1
#define EMIT2(c1, c2) EMIT1(c1)  __asm _emit c2
#define EMIT3(c1, c2, c3) EMIT2(c1, c2)  __asm _emit c3
#define EMIT4(c1, c2, c3, c4) EMIT3(c1, c2, c3)  __asm _emit c4
#define EMIT5(c1, c2, c3, c4, c5) EMIT4(c1, c2, c3, c4)  __asm _emit c5
#define EMIT6(c1, c2, c3, c4, c5, c6) EMIT5(c1, c2, c3, c4, c5)  __asm _emit c6
#define EMIT7(c1, c2, c3, c4, c5, c6, c7) EMIT6(c1, c2, c3, c4, c5, c6)  __asm _emit c7
#define EMIT8(c1, c2, c3, c4, c5, c6, c7, c8) EMIT7(c1, c2, c3, c4, c5, c6, c7)  __asm _emit c8
#define EMIT9(c1, c2, c3, c4, c5, c6, c7, c8, c9) EMIT8(c1, c2, c3, c4, c5, c6, c7, c8)  __asm _emit c9
#define EMIT10(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10) EMIT9(c1, c2, c3, c4, c5, c6, c7, c8, c9)  __asm _emit c10
#define EMIT11(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11) EMIT10(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10)  __asm _emit c11
#define EMIT12(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12) EMIT11(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11)  __asm _emit c12
#define EMIT13(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13) EMIT12(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12)  __asm _emit c13
#define EMIT14(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14) EMIT13(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)  __asm _emit c14
#define EMIT15(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15) EMIT14(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14)  __asm _emit c15
#define EMIT16(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16) EMIT15(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15)  __asm _emit c16
#define EMIT17(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17) EMIT16(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16)  __asm _emit c17
#define EMIT18(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18) EMIT17(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17)  __asm _emit c18
#define EMIT19(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19) EMIT18(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18)  __asm _emit c19
#define EMIT20(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20) EMIT19(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19)  __asm _emit c20
#define EMIT21(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20, c21) EMIT20(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, c20)  __asm _emit c21

#define DEFINE_STR(type, varName, ...) \
	type varName = NULL; \
	__asm _emit 0xE8 __asm _emit 00 __asm _emit 00 __asm _emit 00 __asm  _emit 00 /* CALL <next instruction> */ \
	__asm POP EAX \
	__asm ADD EAX, 0x06 \
	__asm _emit 0xEB __asm _emit __NARG_PLUS_TWO__(__VA_ARGS__)                  /* jmp over string */ \
	VFUNC(EMIT, __VA_ARGS__)                                                     /* emit string */ \
	__asm _emit '\0' __asm _emit '\0'                                            /* emit nullterm */ \
	__asm MOV varName, EAX

#define ZERO_MEM(ptr, size) \
	for (size_t zerosize = 0; zerosize < size; zerosize++) { \
		((char*)ptr)[zerosize] = 0x00; \
	}

```

`src/reloc/VectorUtils.h`:

```h
#include <vector>

template<typename TI>
void pushBytes(const char* data, const size_t size, std::vector<TI> &dest)
{
	for (size_t i = 0; i < size; i++)
		dest.push_back(data[i]);
}

template<typename T, typename TI>
bool getData(const std::vector<TI> &input, unsigned int offset, T& output)
{
	unsigned int size = sizeof(T);
	if (offset + size >= input.size())
		return false;
	
	char* data = new char[size];
	for (unsigned int i = 0; i < size; i++)
		data[i] = input[offset + i];

	output = *(T*)&data[0];
	delete [] data;
	return true;
}

template<typename T, typename TI>
bool putData(std::vector<TI> &destination, unsigned int offset, const T& input)
{
	unsigned int size = sizeof(T);
	if (offset + size >= destination.size())
		return false;

	auto data = (const char*)&input;
	for (unsigned int i = 0; i < size; i++)
		destination[offset + i] = data[i];
	return true;
}
```

`src/reloc/main.cpp`:

```cpp
#include "PeRecompiler.h"
#include <Windows.h>

#include <map>
#include <vector>
#include <string>


/*
	useful refs
	http://reverseengineerlog.blogspot.com/2017/03/activating-windows-loader-debug-messages.html
	https://msdn.microsoft.com/en-us/library/ms809762.aspx
	http://images2015.cnblogs.com/blog/268182/201509/268182-20150906154155451-80554465.jpg (i'm gonna print this for my wall)
*/

// BUG: sometimes windows 10 won't map at 0x10000 at all, causing the preselection loop to go forever;
//      need to update code to use a base address which it knows will get hit
// BUG: for some reason binary won't run unless we rewrite at least 1 section, probably a bug in building
// BUG: sometimes multipass has issues, need to figure out what causes them
// IMPROVEMENT: need to add "dodging" so obfuscation can work 'around' certain data/structures which are
//              needed by loader before relocations without sacrificing obfuscation of an entire section

bool startsWith(const std::string& s, const std::string& prefix)
{
	return (s.size() >= prefix.size() && s.compare(0, prefix.size(), prefix) == 0);
}

auto split(const std::string& s, char delim, size_t max=-1)
{
	auto start = 0;
	std::vector<std::string> res;
	while (start != std::string::npos && (max == -1 || res.size() < (max - 1)))
	{
		auto pos = s.find(delim);
		auto sub = (pos == std::string::npos) ? s.substr(start) : s.substr(start, pos - start);
		res.push_back(sub);
		start = (pos == std::string::npos) ? pos : ++pos;
	}
	if (start != std::string::npos)
		res.push_back(s.substr(start));
	return res;
}

typedef std::map<std::string, std::vector<std::string>> CommandLine;
auto parseCommandLine(int argc, char* argv[])
{
	std::vector<std::string> args;
	for (int i = 0; i < argc; i++)
		args.push_back(argv[i]);

	CommandLine cl;
	for (auto arg : args)
	{
		auto isSwitch = startsWith(arg, "--");
		if (isSwitch)
		{
			auto parts = split(arg, '=', 2);
			auto key = (parts.size() == 2) ? parts[0] : arg;
			cl[key] = cl[key]; // trick to automatically new() upon first discovery
			if (parts.size() == 2)
				cl[key].push_back(parts[1]);
		}
		else
			cl[""].push_back(arg);
	}
	
	return cl;
}

const char* usageString =
"Usage: reloc.exe [--section=<name> | --multipass | --win10 | --noImports | --rewriteHeader | --stringMatch=<text>] input.exe output.exe\n" \
"    --section=<name>       Rewrite section with <name>\n" \
"    --win10                Use runtime ASLR Preselection attack, required for targets running Windows 10\n" \
"    --noImports            Don't rewrite import names or pointers\n" \
"    --multipass            Go over data multiple times with an offset; this increases obfuscation potency and output size\n" \
"    --rewriteHeader        Rewrite entrypoint; incompatible with --win10 and header must be writable\n" \
"    --fixupBase            Relocate ImageBase in PE header to match actual base; header must be writeable\n" \
"    --stringMatch=<text>   Relocate all occurrences of the string <text>; disables obfuscation of whole sections\n" \
"\n" \
"Notes:\n" \
"    - If no sections are specified, .text, .data, and .rsrc will be used\n" \
"    - Using --win10 will remove .rsrc from the default section list, as win10 doesn't like obfuscated resources\n" \
"    - Using --win10 will set --noImports, as the attack is incompatible with import obfuscation\n" \
"    - Options which say \"header must be writeable\" are effectively useless in the real world, but exist for debugging/experimentation purposes.\n"\
"\n"\
"Example 1 - Standard:\n" \
"    reloc.exe malware.exe obfuscated_malware.exe\n" \
"Example 2 - Standard Win10:\n" \
"    reloc.exe --win10 malware.exe obfuscated_malware.exe\n" \
"Example 3 - Custom Sections:\n" \
"    reloc.exe --section=CODE --section=DATA --section=BSS malware.exe obfuscated_malware.exe\n" \
"Example 4 - Obfuscate Strings:\n" \
"    reloc.exe --stringMatch=\"hello world\" malware.exe obfuscated_malware.exe\n" \
"Example 5 - Obfuscate Strings (Multi-Pass):\n" \
"    reloc.exe --multipass --stringMatch=\"hello world\" malware.exe obfuscated_malware.exe\n" \
"\n" \
"If the output executable crashes or fails to start:\n" \
"    - Obfuscating .rdata can cause issues with certain parts of the PE which may be needed pre-reloc\n" \
"    - Obfuscating .rsrc can sometimes cause issues, still trying to figure out why\n" \
"    - Obfuscating a binary where .reloc isn't the final section will cause section overlap, this needs to be fixed\n" \
"If none of these fix the error, you may be seeing a new bug.\n";

int main(int argc, char* argv[])
{
	auto cl = parseCommandLine(argc, argv);

	auto args = cl[""];
	if (args.size() != 3)
	{
		std::cout << usageString << std::endl;
		return ERROR_INVALID_PARAMETER;
	}

	auto win10 = (cl.find("--win10") != cl.end());
	auto noImports = (cl.find("--noImports") != cl.end()) || win10;
	auto rewriteHeader = (cl.find("--rewriteHeader") != cl.end());
	auto fixupBase = (cl.find("--fixupBase") != cl.end());
	auto multi = (cl.find("--multipass") != cl.end());

	auto sections = cl["--section"];
	auto stringMatchList = cl["--stringMatch"];

	if (!stringMatchList.size())
	{
		if (sections.size() == 0)
		{
			sections.push_back(".text");
			sections.push_back(".data");
			if (!win10)
				sections.push_back(".rsrc");
		}
	}
	else if (sections.size())
	{
		std::cout << "Disabling obfuscation of whole sections due to --stringMatch" << std::endl;
		sections.clear();
	}

	PeRecompiler compiler(std::cout, std::cerr, args[1], args[2]);
	do
	{
		compiler.useWindows10Attack(win10);
		compiler.doMultiPass(multi);

		/* load everything up */
		if (!compiler.loadInputFile()) break;
		if (!compiler.loadInputSections()) break;

		/* statically relocate the file to prepare for rewriting */
		if (!compiler.performOnDiskRelocations()) break;

		/* if headr is writeable, we can re-write parts of the header (such as EntryPoint) */
		if (rewriteHeader) if (!compiler.rewriteHeader()) break;

		/* if header is writeable, we can make BaseAddress look normal in memory */
		if (fixupBase) if (!compiler.fixupBase()) break;

		/* rewrite some sections */
		if (sections.size())
			std::cout << "Obfuscating sections" << std::endl;
		bool failed = false;
		for (auto sec : sections)
		{
			if (!compiler.rewriteSection(sec))
			{
				failed = true;
				break;
			}
		}
		if (failed) break;

		/* rewrite string matches */
		if (stringMatchList.size())
			std::cout << "Obfuscating string matches" << std::endl;
		failed = false;
		for (auto str : stringMatchList)
		{
			if (!compiler.rewriteMatches(str))
			{
				failed = true;
				break;
			}
		}
		if (failed) break;

		/* rewrite import tables */
		if (!noImports) if (!compiler.rewriteImports()) break;

		/* write out the new binary */
		if (!compiler.writeOutputFile()) break;

		std::cout << "Packing succeeded!" << std::endl;
		return 0;
	} while(0);
	
	std::cout << "Packing failed!" << std::endl;
	return 1;
}


```

`src/reloc/reloc.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B1628253-F5E4-427C-8EB9-C0D67742F6D9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>reloc</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.15063.0</WindowsTargetPlatformVersion>
    <ProjectName>reloc</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\BuildTemp\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir)\deps\PeLib\;$(SolutionDir)\src\chrome\;$(SolutionDir)\deps\luajit-2.0\src\;$(SolutionDir)\src\XenoLua\;C:\Program Files (x86)\Microsoft DirectX SDK (August 2009)\Include;C:\Program Files (x86)\Visual Leak Detector\include;C:\Program Files (x86)\Microsoft Research\Detours Express 3.0\src;$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)\deps\PeLib\;$(SolutionDir)\deps\luajit-2.0\src\;$(OutDir)\;C:\Program Files (x86)\Microsoft Research\Detours Express 3.0\lib.X86;C:\Program Files (x86)\Microsoft DirectX SDK (August 2009)\Lib\x86;C:\Program Files (x86)\Visual Leak Detector\lib\Win32;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)\bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\BuildTemp\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir)\deps\PeLib\;C:\Program Files (x86)\Microsoft DirectX SDK (August 2009)\Include;C:\Program Files (x86)\Visual Leak Detector\include;C:\Program Files (x86)\Microsoft Research\Detours Express 3.0\src;$(IncludePath)</IncludePath>
    <LibraryPath>$(SolutionDir)\deps\PeLib\;$(OutDir)\;C:\Program Files (x86)\Microsoft Research\Detours Express 3.0\lib.X86;C:\Program Files (x86)\Microsoft DirectX SDK (August 2009)\Lib\x86;C:\Program Files (x86)\Visual Leak Detector\lib\Win32;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>PeLib32d.lib;DbgHelp.lib;winmm.lib;Iphlpapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>PeLib32.lib;DbgHelp.lib;winmm.lib;Iphlpapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="PeRecompiler.cpp" />
    <ClCompile Include="RewriteBlock.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ASLRPreselectionStub.h" />
    <ClInclude Include="LdrDefs.h" />
    <ClInclude Include="PeLibInclude.h" />
    <ClInclude Include="PeRecompiler.h" />
    <ClInclude Include="RewriteBlock.h" />
    <ClInclude Include="ShellcodeMacros.h" />
    <ClInclude Include="VectorUtils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/reloc/reloc.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4868cbe4-7467-4a47-b0ff-a361e85c9188}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{014fc30d-f552-47c9-9ec5-3f28d0b76cfe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\ASLR Preselection Shellcode">
      <UniqueIdentifier>{4bd6785c-f129-4b65-9519-1d53eda3f7c1}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="RewriteBlock.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PeRecompiler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="PeLibInclude.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RewriteBlock.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VectorUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PeRecompiler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ASLRPreselectionStub.h">
      <Filter>Header Files\ASLR Preselection Shellcode</Filter>
    </ClInclude>
    <ClInclude Include="LdrDefs.h">
      <Filter>Header Files\ASLR Preselection Shellcode</Filter>
    </ClInclude>
    <ClInclude Include="ShellcodeMacros.h">
      <Filter>Header Files\ASLR Preselection Shellcode</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```