Project Path: arc_gmh5225_wda_monitor_trick_oniuuw2h

Source Tree:

```txt
arc_gmh5225_wda_monitor_trick_oniuuw2h
├── README.md
├── demo.jpg
├── wda_monitor
│   ├── d3d9_x.h
│   ├── wda_monitor.cpp
│   ├── wda_monitor.vcxproj
│   └── win_utils.h
└── wda_monitor.sln

```

`README.md`:

```md
![img](demo.jpg)

[video](https://www.youtube.com/watch?v=Y6htthx_kCk)

abusing the WDA_MONITOR :)

```

`wda_monitor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29613.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wda_monitor", "wda_monitor\wda_monitor.vcxproj", "{F8CD68DB-5BF7-4921-AB55-5550284140A9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F8CD68DB-5BF7-4921-AB55-5550284140A9}.Release|x64.ActiveCfg = Release|x64
		{F8CD68DB-5BF7-4921-AB55-5550284140A9}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F33EEEA2-05DC-453A-8869-22D590C09548}
	EndGlobalSection
EndGlobal

```

`wda_monitor/d3d9_x.h`:

```h
#pragma once

// https://doxygen.reactos.org/de/d57/dll_2directx_2wine_2d3dx9__36_2math_8c_source.html

inline D3DVECTOR* D3DXVec3Add( D3DVECTOR *pOut, CONST D3DVECTOR *pV1, CONST D3DVECTOR *pV2 )
{
	pOut->x = pV1->x + pV2->x;
	pOut->y = pV1->y + pV2->y;
	pOut->z = pV1->z + pV2->z;
	return pOut;
}

inline D3DVECTOR* D3DXVec3Subtract( D3DVECTOR *pOut, CONST D3DVECTOR *pV1, CONST D3DVECTOR *pV2 )
{
	pOut->x = pV1->x - pV2->x;
	pOut->y = pV1->y - pV2->y;
	pOut->z = pV1->z - pV2->z;
	return pOut;
}

inline FLOAT D3DXVec3Dot( CONST D3DVECTOR *pV1, CONST D3DVECTOR *pV2 )
{
	return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
}

inline D3DVECTOR* D3DXVec3Cross( D3DVECTOR *pOut, CONST D3DVECTOR *pV1, CONST D3DVECTOR *pV2 )
{
	D3DVECTOR v;
	v.x = pV1->y * pV2->z - pV1->z * pV2->y;
	v.y = pV1->z * pV2->x - pV1->x * pV2->z;
	v.z = pV1->x * pV2->y - pV1->y * pV2->x;
	*pOut = v;
	return pOut;
}

inline FLOAT D3DXVec3Length( CONST D3DVECTOR *pV )
{
	return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
}

inline D3DVECTOR* D3DXVec3Normalize( D3DVECTOR *pout, const D3DVECTOR *pv )
{
	FLOAT norm = D3DXVec3Length(pv);
	if ( norm == 0.0f )
	{
		pout->x = 0.0f;
		pout->y = 0.0f;
		pout->z = 0.0f;
	}
	else
	{
		pout->x = pv->x / norm;
		pout->y = pv->y / norm;
		pout->z = pv->z / norm;
	}
	return pout;
}

inline D3DMATRIX* D3DXMatrixIdentity( D3DMATRIX *pOut )
{
	pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =
	pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
	pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
	pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
	pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
	return pOut;
}

inline D3DMATRIX* WINAPI D3DXMatrixRotationY( D3DMATRIX *pout, FLOAT angle )
{
	D3DXMatrixIdentity(pout);
	pout->m[0][0] = cosf(angle);
	pout->m[2][2] = cosf(angle);
	pout->m[0][2] = -sinf(angle);
	pout->m[2][0] = sinf(angle);
	return pout;
}

inline D3DMATRIX* D3DXMatrixLookAtLH( D3DMATRIX *out, const D3DVECTOR *eye, const D3DVECTOR *at, const D3DVECTOR *up )
{
	D3DVECTOR right, upn, vec;
	D3DXVec3Subtract(&vec, at, eye);
	D3DXVec3Normalize(&vec, &vec);
	D3DXVec3Cross(&right, up, &vec);
	D3DXVec3Cross(&upn, &vec, &right);
	D3DXVec3Normalize(&right, &right);
	D3DXVec3Normalize(&upn, &upn);
	out->m[0][0] = right.x;
	out->m[1][0] = right.y;
	out->m[2][0] = right.z;
	out->m[3][0] = -D3DXVec3Dot(&right, eye);
	out->m[0][1] = upn.x;
	out->m[1][1] = upn.y;
	out->m[2][1] = upn.z;
	out->m[3][1] = -D3DXVec3Dot(&upn, eye);
	out->m[0][2] = vec.x;
	out->m[1][2] = vec.y;
	out->m[2][2] = vec.z;
	out->m[3][2] = -D3DXVec3Dot(&vec, eye);
	out->m[0][3] = 0.0f;
	out->m[1][3] = 0.0f;
	out->m[2][3] = 0.0f;
	out->m[3][3] = 1.0f;
	return out;
}

inline D3DMATRIX* D3DXMatrixPerspectiveFovLH( D3DMATRIX *pout, FLOAT fovy, FLOAT aspect, FLOAT zn, FLOAT zf )
{
	D3DXMatrixIdentity(pout);
	pout->m[0][0] = 1.0f / (aspect * tanf(fovy/2.0f));
	pout->m[1][1] = 1.0f / tanf(fovy/2.0f);
	pout->m[2][2] = zf / (zf - zn);
	pout->m[2][3] = 1.0f;
	pout->m[3][2] = (zf * zn) / (zn - zf);
	pout->m[3][3] = 0.0f;
	return pout;
}

```

`wda_monitor/wda_monitor.cpp`:

```cpp
#include <windows.h>
#include <winternl.h>
#include <process.h>
#include <tlhelp32.h>
#include <inttypes.h>

#include <d3d9.h>
#pragma comment (lib, "d3d9.lib")

#include <stdexcept>
#include <vector>
#include <algorithm>
#include <chrono>

#include "win_utils.h"
#include "d3d9_x.h"

//=======================================================================================

#define WND_CLASS TEXT("wda_monitor")
#define WND_SIZEX 600
#define WND_SIZEY 600

static void xCreateWindow();
static void xInitD3d();
static void xMainLoop();
static void xShutdown();
static LRESULT CALLBACK xWindowProc(_In_ HWND   hwnd, _In_ UINT   uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam);

static HWND Window = NULL;
static LPDIRECT3D9 D3d = NULL;
static LPDIRECT3DDEVICE9 D3dDevice = NULL;
static LPDIRECT3DVERTEXBUFFER9 TriBuf = NULL;

//=======================================================================================

/*
.text:00000001801B90F4                                                 ; int CWindowNode::RenderBlackShape(CWindowNode *__hidden this, struct CDrawingContext *, const struct CShape *)
.text:00000001801B90F4                                                 ?RenderBlackShape@CWindowNode@@AEAAJPEAVCDrawingContext@@AEBVCShape@@@Z proc near
.text:00000001801B90F4                                                                                         ; CODE XREF: CWindowNode::RenderContent(CDrawingContext *,bool *)+5F9A6↑p
.text:00000001801B90F4                                                                                         ; CWindowNode::RenderBlackContent(CDrawingContext *)+AC↑p
.text:00000001801B90F4                                                                                         ; DATA XREF: ...
.text:00000001801B90F4
.text:00000001801B90F4                                                 var_18          = dword ptr -18h
.text:00000001801B90F4                                                 arg_0           = qword ptr  8
.text:00000001801B90F4
.text:00000001801B90F4 48 89 5C 24 08                                                  mov     [rsp+arg_0], rbx
.text:00000001801B90F9 57                                                              push    rdi
.text:00000001801B90FA 48 83 EC 30                                                     sub     rsp, 30h
.text:00000001801B90FE 49 8B C0                                                        mov     rax, r8
.text:00000001801B9101 48 8B FA                                                        mov     rdi, rdx
.text:00000001801B9104 48 8B D0                                                        mov     rdx, rax        ; struct CShape *
.text:00000001801B9107 4C 8D 05 D2 FE 0F 00                                            lea     r8, stru_1802B8FE0 ; struct _D3DCOLORVALUE *
.text:00000001801B910E 48 8B CF                                                        mov     rcx, rdi        ; this
.text:00000001801B9111 E8 8E BF FA FF                                                  call    ?FillRectangularShapeWithColor@CDrawingContext@@QEAAJAEBVCShape@@AEBU_D3DCOLORVALUE@@@Z ; CDrawingContext::FillRectangularShapeWithColor(CShape const &,_D3DCOLORVALUE const &)
.text:00000001801B9116 8B D8                                                           mov     ebx, eax
.text:00000001801B9118 85 C0                                                           test    eax, eax
.text:00000001801B911A 78 09                                                           js      short loc_1801B9125
.text:00000001801B911C C6 87 D3 18 00 00 01                                            mov     byte ptr [rdi+18D3h], 1
.text:00000001801B9123 EB 15                                                           jmp     short loc_1801B913A
.text:00000001801B9125                                                 ; ---------------------------------------------------------------------------
.text:00000001801B9125
.text:00000001801B9125                                                 loc_1801B9125:                          ; CODE XREF: CWindowNode::RenderBlackShape(CDrawingContext *,CShape const &)+26↑j
.text:00000001801B9125 44 8B CB                                                        mov     r9d, ebx        ; int
.text:00000001801B9128 C7 44 24 20 29 0D 00 00                                         mov     [rsp+38h+var_18], 0D29h ; unsigned int
.text:00000001801B9130 45 33 C0                                                        xor     r8d, r8d        ; unsigned int
.text:00000001801B9133 33 D2                                                           xor     edx, edx        ; int *
.text:00000001801B9135 E8 FE 7F EA FF                                                  call    ?MilInstrumentationCheckHR_MaybeFailFast@@YAXKQEBJIJI@Z ; MilInstrumentationCheckHR_MaybeFailFast(ulong,long const * const,uint,long,uint)
.text:00000001801B913A
.text:00000001801B913A                                                 loc_1801B913A:                          ; CODE XREF: CWindowNode::RenderBlackShape(CDrawingContext *,CShape const &)+2F↑j
.text:00000001801B913A 8B C3                                                           mov     eax, ebx
.text:00000001801B913C 48 8B 5C 24 40                                                  mov     rbx, [rsp+38h+arg_0]
.text:00000001801B9141 48 83 C4 30                                                     add     rsp, 30h
.text:00000001801B9145 5F                                                              pop     rdi
.text:00000001801B9146 C3                                                              retn
.text:00000001801B9146                                                 ?RenderBlackShape@CWindowNode@@AEAAJPEAVCDrawingContext@@AEBVCShape@@@Z endp
*/

int main(int argc, const char* argv[])
{
	(void)argc;
	(void)argv;

	// Version 10.0.17763.973
	// MD5 ea6256b1c5bc75242cc92bbcfd842832 dwmcore.dll

	auto c1(xParseByteArray("48 89 5C 24 08 57 48 83 EC 30 49 8B C0 48 8B FA 48 8B D0 4C 8D 05 CC CC CC CC 48 8B CF E8 CC CC CC CC 8B D8 85 C0 78 09"));
	auto c2(xParseByteArray("48 89 5C 24 08 57 48 83 EC 30 49 8B C0 48 8B FA 48 8B D0 4C 8D 05 CC CC CC CC 48 8B CF B8 00 00 00 00 8B D8 85 C0 78 09"));

	xPatchProcess(L"dwm.exe", c1, c2, NULL, 0);

	xCreateWindow();
	xInitD3d();

	// make content invisible!
	XGUARD_WIN(SetWindowDisplayAffinity(Window, WDA_MONITOR));

	xMainLoop();
	xShutdown();

	return 0;
}

void xCreateWindow()
{
	printf("xCreateWindow\n");

	WNDCLASSEXW wc;
	ZeroMemory(&wc, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.lpszClassName = WND_CLASS;
	wc.lpfnWndProc = xWindowProc;
	XGUARD_WIN(RegisterClassEx(&wc));

	#if 1
		DWORD ExStyle = WS_EX_TOPMOST | WS_EX_TRANSPARENT | WS_EX_TOOLWINDOW;
		DWORD Style = WS_POPUP;
	#else
		DWORD ExStyle = 0;
		DWORD Style = WS_OVERLAPPEDWINDOW;
	#endif

	Window = CreateWindowEx(
		ExStyle, WND_CLASS, TEXT("hello"), Style,
		0, 0, WND_SIZEX, WND_SIZEY,
		0, 0, GetModuleHandle(NULL), 0
	);
	XGUARD_WIN(Window);

	# if 1
	SetWindowLong(Window, GWL_EXSTYLE, ExStyle | WS_EX_LAYERED);
	SetLayeredWindowAttributes(Window, RGB(0, 0, 0), 255, LWA_ALPHA | LWA_COLORKEY);
	#endif

	ShowWindow(Window, SW_SHOW);
	UpdateWindow(Window);
}

#define CUSTOMFVF (D3DFVF_XYZ | D3DFVF_DIFFUSE)
struct CUSTOMVERTEX
{
	FLOAT x, y, z;
	DWORD color;
};

void xInitD3d()
{
	printf("xInitD3d\n");

	D3d = Direct3DCreate9(D3D_SDK_VERSION);
	XGUARD(D3d);

	D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory(&d3dpp, sizeof(d3dpp));
	d3dpp.BackBufferWidth = WND_SIZEX;
	d3dpp.BackBufferHeight = WND_SIZEY;
	d3dpp.BackBufferFormat = D3DFMT_X8R8G8B8;
	d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow = Window;
	d3dpp.Windowed = TRUE;

	XGUARD_HR(D3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, Window, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &D3dDevice));

	D3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	D3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

	#if 0
	D3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	D3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	D3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
	D3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	#endif

	// tri

	CUSTOMVERTEX Vertices[] =
	{
		{  2.5f, -3.0f, 0.0f, D3DCOLOR_ARGB(0xff, 0, 0, 255), },
		{  0.0f,  3.0f, 0.0f, D3DCOLOR_ARGB(0xff, 0, 255, 0), },
		{ -2.5f, -3.0f, 0.0f, D3DCOLOR_ARGB(0xff, 255, 0, 0), },
	};

	XGUARD_HR(D3dDevice->CreateVertexBuffer(3*sizeof(CUSTOMVERTEX), 0, CUSTOMFVF, D3DPOOL_MANAGED, &TriBuf, NULL));

	VOID* TriMem = NULL;
	XGUARD_HR(TriBuf->Lock(0, 0, (void**)&TriMem, 0));
	memcpy(TriMem, Vertices, sizeof(Vertices));
	TriBuf->Unlock();

	XGUARD_HR(D3dDevice->SetFVF(CUSTOMFVF));
	XGUARD_HR(D3dDevice->SetStreamSource(0, TriBuf, 0, sizeof(CUSTOMVERTEX)));

	// cam

	D3DVECTOR CamPos = {0.0f, 0.0f, 10.0f};
	D3DVECTOR CamTarg = {0.0f, 0.0f, 0.0f};
	D3DVECTOR CamUp = {0.0f, 1.0f, 0.0f};

	D3DMATRIX View;
	D3DXMatrixLookAtLH(&View, &CamPos, &CamTarg, &CamUp);
	XGUARD_HR(D3dDevice->SetTransform(D3DTS_VIEW, &View));

	D3DMATRIX Proj;
	D3DXMatrixPerspectiveFovLH(&Proj, 45 * 0.01745f, (FLOAT)WND_SIZEX / (FLOAT)WND_SIZEY, 1.0f, 1000.0f);
	XGUARD_HR(D3dDevice->SetTransform(D3DTS_PROJECTION, &Proj));
}

void xMainLoop()
{
	printf("xMainLoop\n");

	UINT FrameId = 0;
	FLOAT Angle = 0;

	using clock = std::chrono::high_resolution_clock;
	clock::time_point t0, t1, t2;

	t0 = clock::now();

	for (;;)
	{
		t1 = clock::now();
		const double dt = std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count() * 1e-6; // micros -> sec
		t0 = t1;

		MSG msg;
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);

			if (msg.message == WM_QUIT)
			{
				return;
			}
		}

		D3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0xff, 0, 0, 0), 1.0f, 0);
		D3dDevice->BeginScene();

		D3DMATRIX World;
		D3DXMatrixRotationY(&World, Angle);
		XGUARD_HR(D3dDevice->SetTransform(D3DTS_WORLD, &World));
		Angle += 5.0f * dt;

		XGUARD_HR(D3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1));

		D3dDevice->EndScene();
		XGUARD_HR(D3dDevice->Present(NULL, NULL, NULL, NULL));

		FrameId++;

		t2 = clock::now();
		const double elapsed = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count() * 0.001; // micros -> millis
		const double rate = 1000 / 60.0;

		if (elapsed < rate)
		{
			Sleep((DWORD)(rate - elapsed));
		}
	}
}

LRESULT CALLBACK xWindowProc(_In_ HWND hwnd, _In_ UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_NCPAINT:
		case WM_ERASEBKGND:
		case WM_PRINT:
		case WM_PRINTCLIENT:
			return 0;

		case WM_NCHITTEST:
			return HTTRANSPARENT;

		case WM_KEYDOWN:
			if (wParam == VK_ESCAPE)
			{
				PostQuitMessage(0);
				return 0;
			}
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			return 0;
	}

	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void xShutdown()
{
	printf("xShutdown\n");

	TriBuf->Release();
	D3dDevice->Release();
	D3d->Release();

	DestroyWindow(Window);
	UnregisterClass(WND_CLASS, NULL);
}

```

`wda_monitor/wda_monitor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{F8CD68DB-5BF7-4921-AB55-5550284140A9}</ProjectGuid>
    <RootNamespace>wdamonitor</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <UseFullPaths>false</UseFullPaths>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="wda_monitor.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="d3d9_x.h" />
    <ClInclude Include="win_utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`wda_monitor/win_utils.h`:

```h
#pragma once

#define XFATAL_CODE(__code) xEpicFail(__FILE__, __LINE__, (__code))
#define XFATAL() XFATAL_CODE(0)

#define XGUARD_CODE(__cond, __code) xGuard((__cond), __FILE__, __LINE__, (__code))
#define XGUARD_WIN(__cond) XGUARD_CODE((__cond), GetLastError())
#define XGUARD(__cond) XGUARD_CODE((__cond), 0)

#define XGUARD_HR(__code) xGuard((__code), __FILE__, __LINE__)

inline void xEpicFail(const char* file, int line, int code)
{
	printf("EPIC FAIL -> FILE:%s LINE:%d CODE=(int)%d\n", file, line, (int)code); 
	throw std::runtime_error("EPIC FAIL");
}

inline void xGuard(bool cond, const char* file, int line, int code) { if (!cond) { xEpicFail(file, line, code); } }
inline void xGuard(HRESULT code, const char* file, int line) { if FAILED(code) { xEpicFail(file, line, code); } }

//=======================================================================================

inline bool xIsHandleValid(PVOID Handle) { return (Handle != nullptr && Handle != INVALID_HANDLE_VALUE); }

template<typename T, typename Traits>
class TScopedHandle
{
public:
	T Handle;

	inline TScopedHandle() : Handle(nullptr) {}
	inline explicit TScopedHandle(T h) : Handle(h) {}
	inline TScopedHandle(TScopedHandle& other) { Handle = other.Handle; other.Handle = nullptr; }

	inline ~TScopedHandle() { Close(); }
	inline void Close() { Traits::Close(Handle); }
	inline void Dismiss() { Handle = nullptr; }

	inline T& operator*() { return Handle; }
	inline T* operator&() { return &Handle; }

	inline const T& operator*() const { return Handle; }
	inline const T* operator&() const { return &Handle; }

	inline TScopedHandle& operator=(T h) { Close(); Handle = h; return *this; }
	inline TScopedHandle& operator=(TScopedHandle& other) { Close(); Handle = other.Handle; other.Handle = nullptr; return *this; }

	inline operator bool() const { return xIsHandleValid(Handle); }
};

struct HANDLE_traits {
	static void Close(HANDLE& Value) throw() { if (xIsHandleValid(Value)) { CloseHandle(Value); Value = nullptr; } }
};

typedef TScopedHandle<HANDLE, HANDLE_traits> XScopedHandle;

//=======================================================================================

VOID xAdjustPrivilege(LPCWSTR PrivilegeName, BOOL Enable)
{
	TOKEN_PRIVILEGES Privilege;
	ZeroMemory(&Privilege, sizeof(Privilege));
	Privilege.PrivilegeCount = 1;
	Privilege.Privileges[0].Attributes = (Enable ? SE_PRIVILEGE_ENABLED : 0);

	XGUARD_WIN(LookupPrivilegeValueW(nullptr, PrivilegeName, &Privilege.Privileges[0].Luid));

	XScopedHandle Token;
	XGUARD_WIN(OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &Token));

	XGUARD_WIN(AdjustTokenPrivileges(*Token, FALSE, &Privilege, sizeof(Privilege), nullptr, nullptr));
}

DWORD xGetPidByName(LPCWSTR name)
{
	DWORD Pid = 0;

	XScopedHandle Snapshot(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0));
	XGUARD_WIN(Snapshot);

	PROCESSENTRY32W Entry;
	ZeroMemory(&Entry, sizeof(Entry));
	Entry.dwSize = sizeof(Entry);
	XGUARD_WIN(Process32FirstW(Snapshot.Handle, &Entry));

	do
	{
		if (_wcsicmp(Entry.szExeFile, name) == 0)
		{
			Pid = Entry.th32ProcessID;
			break;
		}
	}
	while (Process32NextW(Snapshot.Handle, &Entry));

	return Pid;
}

static inline bool xCompareBytes(const uint8_t &a, const uint8_t &b)
{
	return (a == b || b == 0xCC); // use 0xCC (int3) as wildcard
}

PVOID xFindPattern(HANDLE Process, LPVOID ImageBase, const std::vector<uint8_t>& Pattern)
{
	PVOID Result = nullptr;

	uint8_t* Ptr = (uint8_t*)ImageBase;

	MEMORY_BASIC_INFORMATION MemInfo;
	ZeroMemory(&MemInfo, sizeof(MemInfo));

	std::vector<uint8_t> Buffer;
	std::vector<uint8_t>::iterator Iter;

	for (;;)
	{
		auto QuerySize = VirtualQueryEx(Process, Ptr, &MemInfo, sizeof(MemInfo));
		if (QuerySize != sizeof(MemInfo))
		{
			DWORD Err = GetLastError();
			XGUARD_CODE(ERROR_INVALID_PARAMETER == Err, Err);
			break;
		}

		const bool bExecutable = (
			(MemInfo.Protect & PAGE_EXECUTE) != 0 || 
			(MemInfo.Protect & PAGE_EXECUTE_READ) != 0 || 
			(MemInfo.Protect & PAGE_EXECUTE_READWRITE) != 0 || 
			(MemInfo.Protect & PAGE_EXECUTE_WRITECOPY) != 0);

		if (bExecutable && ((MemInfo.Protect & PAGE_GUARD) == 0) && ((MemInfo.Protect & PAGE_NOACCESS) == 0))
		{
			if (Buffer.size() < MemInfo.RegionSize)
			{
				Buffer.resize(MemInfo.RegionSize);
			}

			SIZE_T NumBytes = 0;
			XGUARD_WIN(ReadProcessMemory(Process, MemInfo.BaseAddress, &Buffer[0], MemInfo.RegionSize, &NumBytes));

			auto BufferEnd = Buffer.begin() + MemInfo.RegionSize;
			Iter = Buffer.begin();

			if ((Iter = std::search(Iter, BufferEnd, Pattern.begin(), Pattern.end(), xCompareBytes)) != BufferEnd)
			{
				Result = (uint8_t*)MemInfo.BaseAddress + (Iter - Buffer.begin());
				break;
			}
		}

		Ptr += MemInfo.RegionSize;
	}

	return Result;
}

void xProtectWriteMemory(HANDLE Process, const std::vector<uint8_t>& OrigBytes, const std::vector<uint8_t>& PatchBytes, PVOID Addr, SIZE_T Offset)
{
	printf("xPatchMemory Addr=%p Offset=%I64u\n", Addr, (UINT64)Offset);

	DWORD Prot = 0;
	XGUARD_WIN(VirtualProtectEx(Process, Addr, OrigBytes.size(), PAGE_EXECUTE_READWRITE, &Prot));

	SIZE_T IoSize = 0;
	XGUARD_WIN(WriteProcessMemory(Process, (PVOID)((UINT64)Addr + (UINT64)Offset), &PatchBytes[0], PatchBytes.size(), &IoSize));

	DWORD Prot2 = 0;
	XGUARD_WIN(VirtualProtectEx(Process, Addr, OrigBytes.size(), Prot, &Prot2));

	printf("xPatchMemory DONE\n");
}

PVOID xPatchProcess(LPCWSTR ProcName, const std::vector<uint8_t>& OrigBytes, const std::vector<uint8_t>& PatchBytes, PVOID PatchAddr, SIZE_T PatchOffset)
{
	printf("xPatchProcess Name=\"%S\"\n", ProcName);

	XGUARD(OrigBytes.size());
	XGUARD(PatchBytes.size());

	DWORD ProcId = 0;
	XScopedHandle Process;

	if (ProcName)
	{
		ProcId = xGetPidByName(ProcName);
		XGUARD_WIN(ProcId);

		xAdjustPrivilege(L"SeDebugPrivilege", TRUE);

		Process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcId);
		XGUARD_WIN(Process);
	}
	else
	{
		ProcId = GetCurrentProcessId();
		Process = GetCurrentProcess();
	}

	PVOID Result = nullptr;

	if (PatchAddr)
	{
		xProtectWriteMemory(*Process, OrigBytes, PatchBytes, PatchAddr, PatchOffset);
		Result = PatchAddr;
	}
	else
	{
		XScopedHandle Snap(CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcId));
		XGUARD_WIN(Snap);

		MODULEENTRY32 Entry;
		ZeroMemory(&Entry, sizeof(Entry));
		Entry.dwSize = sizeof(Entry);
		XGUARD_WIN(Module32First(*Snap, &Entry));

		do
		{
			if (Entry.th32ProcessID == ProcId)
			{
				PVOID Addr = xFindPattern(*Process, Entry.modBaseAddr, OrigBytes);
				if (Addr)
				{
					xProtectWriteMemory(*Process, OrigBytes, PatchBytes, Addr, PatchOffset);
					Result = Addr;
					break;
				}
			}
		} 
		while (Module32Next(*Snap, &Entry));
	}

	return Result;
}

//=======================================================================================

inline uint8_t xParseHex(uint8_t Val)
{
	if (Val >= '0' && Val <= '9') return (Val - '0');
	if (Val >= 'a' && Val <= 'f') return (Val - 'a') + 10;
	if (Val >= 'A' && Val <= 'F') return (Val - 'A') + 10;
	XFATAL();
	return 0;
}

inline uint8_t xParseByte(const char* Str)
{
	uint8_t hi = xParseHex((uint8_t)Str[0]);
	uint8_t lo = xParseHex((uint8_t)Str[1]);
	return ((hi << 4) | lo);
}

std::vector<uint8_t> xParseByteArray(LPCSTR Str)
{
	XGUARD(Str);

	const size_t Len = strlen(Str);
	XGUARD(Len);

	size_t SpaceCount = 0;
	for (size_t i = 0; i < Len; ++i)
	{
		if (Str[i] == ' ') SpaceCount++;
	}

	const size_t NumBytes = (SpaceCount + 1);
	XGUARD(Len == (NumBytes * 2 + SpaceCount));

	std::vector<uint8_t> Vec;
	Vec.resize(NumBytes);

	for (size_t i = 0; i < NumBytes; i++)
	{
		Vec[i] = xParseByte(Str);
		Str += 3;
	}

	return Vec;
}

```