Project Path: arc_Lakr233_vphone-cli_4km7luja

Source Tree:

```txt
arc_Lakr233_vphone-cli_4km7luja
├── AGENTS.md
├── CLAUDE.md
├── LICENSE
├── Makefile
├── Package.swift
├── README.md
├── requirements.txt
├── researchs
│   ├── binary_patches_kernelcache.md
│   ├── build_manifest.md
│   ├── erase_install_component_origins.md
│   ├── jailbreak_patches.md
│   ├── kernel_jb_remaining_patches.md
│   └── keyboard_event_pipeline.md
├── scripts
│   ├── cfw_install.sh
│   ├── cfw_install_jb.sh
│   ├── fw_manifest.py
│   ├── fw_patch.py
│   ├── fw_patch_jb.py
│   ├── fw_prepare.sh
│   ├── patchers
│   │   ├── __init__.py
│   │   ├── cfw.py
│   │   ├── iboot.py
│   │   ├── iboot_jb.py
│   │   ├── kernel.py
│   │   ├── kernel_jb.py
│   │   ├── txm.py
│   │   └── txm_jb.py
│   ├── patches
│   │   └── libirecovery-pcc-vm.patch
│   ├── ramdisk_build.py
│   ├── ramdisk_send.sh
│   ├── resources
│   │   ├── cfw_input.tar.zst
│   │   ├── cfw_jb_input.tar.zst
│   │   └── ramdisk_input.tar.zst
│   ├── setup_libimobiledevice.sh
│   ├── setup_venv.sh
│   ├── setup_venv_linux.sh
│   └── vm_create.sh
└── sources
    ├── vphone-cli
    │   ├── VPhoneAppDelegate.swift
    │   ├── VPhoneCLI.swift
    │   ├── VPhoneError.swift
    │   ├── VPhoneHardwareModel.swift
    │   ├── VPhoneKeyHelper.swift
    │   ├── VPhoneMenuController.swift
    │   ├── VPhoneVM.swift
    │   ├── VPhoneVMView.swift
    │   ├── VPhoneWindowController.swift
    │   └── main.swift
    └── vphone.entitlements

```

`AGENTS.md`:

```md
# vphone-cli

Virtual iPhone boot tool using Apple's Virtualization.framework with PCC research VMs.

## Quick Reference

- **Build:** `make build`
- **Boot (GUI):** `make boot`
- **Boot (DFU):** `make boot_dfu`
- **All targets:** `make help`
- **Python venv:** `make setup_venv` (installs to `.venv/`, activate with `source .venv/bin/activate`)
- **Platform:** macOS 14+ (Sequoia), SIP/AMFI disabled
- **Language:** Swift 6.0 (SwiftPM), private APIs via [Dynamic](https://github.com/mhdhejazi/Dynamic)
- **Python deps:** `capstone`, `keystone-engine`, `pyimg4` (see `requirements.txt`)

## Workflow Rules

- Always read `/TODO.md` before starting any substantial work.
- Always update `/TODO.md` when plan, progress, assumptions, blockers, or open questions change.
- If blocked or waiting on user input, write the exact blocker and next action in `/TODO.md`.
- If not exists, continue existing work until complete. If exists, follow `/TODO.md` instructions.

## Project Overview

CLI tool that boots virtual iPhones (PV=3) via Apple's Virtualization.framework, targeting Private Cloud Compute (PCC) research VMs. Used for iOS security research — firmware patching, boot chain modification, and runtime instrumentation.

## Architecture

```
Makefile                          # Single entry point — run `make help`

sources/
├── vphone.entitlements               # Private API entitlements (5 keys)
└── vphone-cli/                       # Swift 6.0 executable (pure Swift, no ObjC)
    ├── main.swift                    # Entry point — NSApplication + AppDelegate
    ├── VPhoneAppDelegate.swift       # App lifecycle, SIGINT, VM start/stop
    ├── VPhoneCLI.swift               # ArgumentParser options (no execution logic)
    ├── VPhoneVM.swift                # @MainActor VM configuration and lifecycle
    ├── VPhoneHardwareModel.swift     # PV=3 hardware model via Dynamic
    ├── VPhoneVMView.swift            # Touch-enabled VZVirtualMachineView + helpers
    ├── VPhoneWindowController.swift  # @MainActor window management
    ├── VPhoneError.swift             # Error types
    └── MainActor+Isolated.swift      # MainActor.isolated helper

scripts/
├── patchers/                     # Python patcher package
│   ├── iboot.py                  # Dynamic iBoot patcher (iBSS/iBEC/LLB)
│   ├── iboot_jb.py               # JB extension iBoot patcher (nonce skip)
│   ├── kernel.py                 # Dynamic kernel patcher (25 patches)
│   ├── kernel_jb.py              # JB extension kernel patcher (~34 patches)
│   ├── txm.py                    # Dynamic TXM patcher
│   ├── txm_jb.py                 # JB extension TXM patcher (~13 patches)
│   └── cfw.py                    # CFW binary patcher (base + JB jetsam)
├── resources/                    # Resource archives
│   ├── cfw_input.tar.zst
│   ├── cfw_jb_input.tar.zst      # JB: procursus bootstrap + Sileo
│   └── ramdisk_input.tar.zst
├── fw_prepare.sh                 # Downloads IPSWs, merges cloudOS into iPhone
├── fw_manifest.py                # Generates hybrid BuildManifest.plist & Restore.plist
├── fw_patch.py                   # Patches 6 boot-chain components (41+ modifications)
├── fw_patch_jb.py                # Runs fw_patch + JB extension patches (iBSS/TXM/kernel)
├── ramdisk_build.py              # Builds SSH ramdisk with trustcache
├── ramdisk_send.sh               # Sends ramdisk to device via irecovery
├── cfw_install.sh                # Installs custom firmware to VM disk
├── cfw_install_jb.sh             # Wrapper: cfw_install with JB phases enabled
├── vm_create.sh                  # Creates VM directory (disk, SEP storage, ROMs)
├── setup_venv.sh                 # Creates Python venv with native keystone dylib
└── setup_libimobiledevice.sh     # Builds libimobiledevice toolchain from source

researchs/
├── jailbreak_patches.md          # JB vs base patch comparison table
└── ...                           # Component analysis and architecture docs
```

### Key Patterns

- **Private API access:** Private Virtualization.framework APIs are called via the [Dynamic](https://github.com/mhdhejazi/Dynamic) library (runtime method dispatch from pure Swift). No ObjC bridge needed.
- **App lifecycle:** Explicit `main.swift` creates `NSApplication` + `VPhoneAppDelegate`. CLI args parsed before the run loop starts. AppDelegate drives VM start, window, and shutdown.
- **Configuration:** CLI options parsed via `ArgumentParser`, converted to `VPhoneVM.Options` struct, then used to build `VZVirtualMachineConfiguration`.
- **Error handling:** `VPhoneError` enum with `CustomStringConvertible` for user-facing messages.
- **Window management:** `VPhoneWindowController` wraps `NSWindow` + `VZVirtualMachineView`. Window size derived from configurable screen dimensions and scale factor. Touch input translated from mouse events to multi-touch via `VPhoneVMView`.

---

## Firmware Assembly Pipeline

The firmware is a **PCC/iPhone hybrid** — PCC boot infrastructure wrapping iPhone iOS userland.

### Pipeline Stages

```
1. make fw_prepare          Download iPhone + cloudOS IPSWs, merge, generate hybrid plists
        ↓
2. make fw_patch            Patch 6 boot-chain components for signature bypass + debug
   OR  make fw_patch_jb     Base patches + JB extensions (iBSS nonce, TXM CS, kernel JB)
        ↓
3. make ramdisk_build       Build SSH ramdisk from SHSH blob, inject tools, sign with IM4M
        ↓
4. make vm_new              Create VM directory (sparse disk, SEP storage, copy ROMs)
        ↓
5. make boot_dfu            Boot VM in DFU mode
        ↓
6. make ramdisk_send        Load boot chain + ramdisk via irecovery
        ↓
7. make cfw_install         Mount Cryptex, patch userland, install base tools
   OR  make cfw_install_jb  Base CFW + JB phases (jetsam patch, procursus bootstrap)
```

### Component Origins

The firmware merges two Apple IPSWs:
- **iPhone IPSW:** `iPhone17,3_26.1_23B85_Restore.ipsw` (d47ap)
- **cloudOS IPSW:** PCC vresearch101ap IPSW (CDN hash URL)

`fw_prepare.sh` extracts both, then copies cloudOS boot chain into the
iPhone restore directory (`kernelcache.*`, `Firmware/{agx,all_flash,ane,dfu,pmp}/*`,
`Firmware/*.im4p`). The cloudOS extract is deleted after merge.

#### Boot Chain — from PCC (cloudOS / vresearch101ap)

| Component | File | Patched | Patch Purpose |
|-----------|------|---------|---------------|
| AVPBooter | `AVPBooter.vresearch1.bin` | Yes (1) | DGST signature validation bypass |
| LLB | `Firmware/all_flash/LLB.vresearch101.RELEASE.im4p` | Yes (6) | Serial + image4 bypass + boot-args + rootfs + panic |
| iBSS | `Firmware/dfu/iBSS.vresearch101.RELEASE.im4p` | Yes (2) | Serial labels + image4 callback bypass |
| iBEC | `Firmware/dfu/iBEC.vresearch101.RELEASE.im4p` | Yes (3) | Serial + image4 bypass + boot-args |
| SPTM | `Firmware/all_flash/sptm.vresearch1.release.im4p` | No | — |
| TXM | `Firmware/txm.iphoneos.research.im4p` | Yes (1) | Trustcache validation bypass |
| SEP Firmware | `Firmware/all_flash/sep-firmware.vresearch101.RELEASE.im4p` | No | — |
| DeviceTree | `Firmware/all_flash/DeviceTree.vphone600ap.im4p` | No | — |
| KernelCache | `kernelcache.release.vphone600` | Yes (25) | APFS, MAC, debugger, launch constraints, etc. |
| GPU/ANE/PMP | `Firmware/{agx,ane,pmp}/*` | No | — |

> TXM filename says "iphoneos" but is copied from cloudOS IPSW (`fw_prepare.sh` line 81).

#### OS / Filesystem — from iPhone (iPhone17,3)

| Component | Notes |
|-----------|-------|
| OS | iPhone OS image |
| SystemVolume | System partition |
| StaticTrustCache | Static trust cache |
| Ap,SystemVolumeCanonicalMetadata | System volume metadata |

> Cryptex1 components (SystemOS/AppOS DMGs) are **not** included in the BuildManifest.
> They are only needed by `cfw_install.sh` which reads paths from the original iPhone manifest separately.

### Build Identity

`fw_manifest.py` generates a **single** DFU erase-install identity (20 components).
The VM always boots via DFU restore, so only one identity is needed.

| Variant | Boot Chain | Ramdisk |
|---------|-----------|---------|
| `Darwin Cloud Customer Erase Install (IPSW)` | PCC RELEASE (LLB/iBSS/iBEC) + RESEARCH (iBoot/TXM) | PCC erase |

idevicerestore selects this identity by partial-matching `Info.Variant` against
`"Erase Install (IPSW)"` while excluding `"Research"`.

### Patched Components Summary

**Boot chain patches** (`fw_patch.py`) — all 6 targets from **PCC**:

| Component | Patches | Technique |
|-----------|---------|-----------|
| AVPBooter | 1 | `mov x0, #0` (DGST bypass) |
| iBSS | 2 | Dynamic via `patchers/iboot.py` (string anchors, instruction patterns) |
| iBEC | 3 | Dynamic via `patchers/iboot.py` (string anchors, instruction patterns) |
| LLB | 6 | Dynamic via `patchers/iboot.py` (string anchors, instruction patterns) |
| TXM | 1 | Dynamic via `patchers/txm.py` (trustcache hash lookup bypass) |
| KernelCache | 25 | Dynamic via `patchers/kernel.py` (string anchors, ADRP+ADD xrefs, BL frequency) |

**JB extension patches** (`fw_patch_jb.py`) — runs base patches first, then adds:

| Component | JB Patches | Technique |
|-----------|-----------|-----------|
| iBSS | +1 | `patchers/iboot_jb.py` (skip nonce generation) |
| TXM | +13 | `patchers/txm_jb.py` (CS validation bypass, get-task-allow, debugger ent, dev mode) |
| KernelCache | +34 | `patchers/kernel_jb.py` (trustcache, execve, sandbox, task/VM, kcall10) |

**CFW patches** (`patchers/cfw.py` / `cfw_install.sh`) — targets from **iPhone** Cryptex SystemOS:

| Binary | Technique | Purpose | Mode |
|--------|-----------|---------|------|
| seputil | String patch (`/%s.gl` → `/AA.gl`) | Gigalocker UUID fix | Base |
| launchd_cache_loader | NOP (disassembly-anchored) | Bypass cache validation | Base |
| mobileactivationd | Return true (disassembly-anchored) | Skip activation check | Base |
| launchd.plist | Plist injection | Add bash/dropbear/trollvnc daemons | Base |
| launchd | Branch (skip jetsam guard) + LC_LOAD_DYLIB injection | Prevent jetsam panic + load launchdhook.dylib | JB |

**JB install phases** (`cfw_install_jb.sh` → `cfw_install.sh` with `CFW_JB_MODE=1`):

| Phase | Action |
|-------|--------|
| JB-1 | Patch `/mnt1/sbin/launchd`: inject `launchdhook.dylib` LC_LOAD_DYLIB + jetsam guard bypass |
| JB-2 | Install procursus bootstrap to `/mnt5/<hash>/jb-vphone/procursus` |
| JB-3 | Deploy BaseBin hooks (`systemhook.dylib`, `launchdhook.dylib`, `libellekit.dylib`) to `/mnt1/cores/` |

### Boot Flow

**Base** (`fw_patch` + `cfw_install`):
```
AVPBooter (ROM, PCC)
  → LLB (PCC, patched)
    → iBSS (PCC, patched, DFU)
      → iBEC (PCC, patched, DFU)
        → SPTM + TXM (PCC, TXM patched)
          → KernelCache (PCC, 25 patches)
            → Ramdisk (PCC or iPhone, SSH-injected)
              → iOS userland (iPhone, CFW-patched)
```

**Jailbreak** (`fw_patch_jb` + `cfw_install_jb`):
```
AVPBooter (ROM, PCC)
  → LLB (PCC, patched)
    → iBSS (PCC, patched + nonce skip)
      → iBEC (PCC, patched, DFU)
        → SPTM + TXM (PCC, TXM patched + CS/ent/devmode bypass)
          → KernelCache (PCC, 25 base + ~34 JB patches)
            → Ramdisk (SSH-injected)
              → iOS userland (CFW + jetsam fix + procursus)
```

### Ramdisk Build (`ramdisk_build.py`)

1. Extract IM4M from SHSH blob
2. Process 8 components: iBSS, iBEC, SPTM, DeviceTree, SEP, TXM, KernelCache, Ramdisk+Trustcache
3. For ramdisk: extract base DMG → create 254 MB APFS volume → mount → inject SSH tools from `resources/ramdisk_input.tar.zst` → re-sign Mach-Os with ldid + signcert.p12 → build trustcache
4. Sign all components with IM4M manifest → output to `Ramdisk/` directory as IMG4 files

### CFW Installation (`cfw_install.sh`)

7 phases (+ 2 JB phases), safe to re-run (idempotent):
1. Decrypt/mount Cryptex SystemOS and AppOS DMGs (`ipsw` + `aea`)
2. Patch seputil (gigalocker UUID)
3. Install GPU driver (AppleParavirtGPUMetalIOGPUFamily)
4. Install iosbinpack64 (jailbreak tools)
5. Patch launchd_cache_loader (NOP cache validation)
6. Patch mobileactivationd (activation bypass)
7. Install LaunchDaemons (bash, dropbear SSH, trollvnc)

**JB-only phases** (enabled via `make cfw_install_jb` or `CFW_JB_MODE=1`):
- JB-1: Patch launchd jetsam guard (prevents jetsam panic on boot)
- JB-2: Install procursus bootstrap + optional Sileo to `/mnt5/<hash>/jb-vphone/`

---

## Coding Conventions

### Swift

- **Language:** Swift 6.0 (strict concurrency).
- **Style:** Pragmatic, minimal. No unnecessary abstractions.
- **Sections:** Use `// MARK: -` to organize code within files.
- **Access control:** Default (internal). Only mark `private` when needed for clarity.
- **Concurrency:** `@MainActor` for VM and UI classes. `nonisolated` delegate methods use `MainActor.isolated {}` to hop back safely.
- **Naming:** Types are `VPhone`-prefixed (`VPhoneVM`, `VPhoneWindowController`). Match Apple framework conventions.
- **Private APIs:** Use `Dynamic()` for runtime method dispatch. Touch objects use `NSClassFromString` + KVC to avoid designated initializer crashes.

### Shell Scripts

- Use `zsh` with `set -euo pipefail`.
- Scripts resolve their own directory via `${0:a:h}` or `$(cd "$(dirname "$0")" && pwd)`.
- Build uses `make build` which handles compilation and entitlement signing.

### Python Scripts

- Firmware patching uses `capstone` (disassembly), `keystone-engine` (assembly), and `pyimg4` (IM4P handling).
- `patchers/kernel.py` uses dynamic pattern finding (string anchors, ADRP+ADD xrefs, BL frequency analysis) — nothing is hardcoded to specific offsets.
- Each patch is logged with offset and before/after state.
- Scripts operate on a VM directory and auto-discover the `*Restore*` subdirectory.
- **Environment:** Use the project venv (`source .venv/bin/activate`). Create with `make setup_venv`. All deps in `requirements.txt`: `capstone`, `keystone-engine`, `pyimg4`.

## Build & Sign

The binary requires private entitlements to use PV=3 virtualization:

- `com.apple.private.virtualization`
- `com.apple.private.virtualization.security-research`
- `com.apple.security.virtualization`
- `com.apple.vm.networking`
- `com.apple.security.get-task-allow`

Always use `make build` — never `swift build` alone, as the unsigned binary will fail at runtime.

## VM Creation (`make vm_new`)

Creates a VM directory with:
- Sparse disk image (default 64 GB)
- SEP storage (512 KB flat file)
- AVPBooter + AVPSEPBooter ROMs (copied from `/System/Library/Frameworks/Virtualization.framework/`)
- machineIdentifier (created on first boot if missing, persisted for stable ECID)
- NVRAM (created/overwritten each boot)

All paths are passed explicitly via CLI (`--rom`, `--disk`, `--nvram`, `--machine-id`, `--sep-storage`, `--sep-rom`). SEP coprocessor is always enabled.

Display is configurable via `--screen-width`, `--screen-height`, `--screen-ppi`, `--screen-scale` (defaults: 1290x2796 @ 460 PPI, scale 3.0).

Override defaults: `make vm_new VM_DIR=myvm DISK_SIZE=32`.

## Design System

### Intent

**Who:** Security researchers working with Apple firmware and virtual devices. Technical, patient, comfortable in terminals. Likely running alongside GDB, serial consoles, and SSH sessions.

**Task:** Boot, configure, and interact with virtual iPhones for firmware research. Monitor boot state, capture serial output, debug at the firmware level.

**Feel:** Like a research instrument. Precise, informative, honest about internal state. No decoration — every pixel earns its place.

### Palette

- **Background:** Dark neutral (`#1a1a1a` — near-black, low blue to reduce eye strain during long sessions)
- **Surface:** `#242424` (elevated panels), `#2e2e2e` (interactive elements)
- **Text primary:** `#e0e0e0` (high contrast without being pure white)
- **Text secondary:** `#888888` (labels, metadata)
- **Accent — status green:** `#4ade80` (VM running, boot success)
- **Accent — amber:** `#fbbf24` (DFU mode, warnings, in-progress states)
- **Accent — red:** `#f87171` (errors, VM stopped with error)
- **Accent — blue:** `#60a5fa` (informational, links, interactive highlights)

Rationale: Dark surfaces match the terminal-adjacent workflow. Status colors borrow from oscilloscope/JTAG tooling — green for good, amber for attention, red for fault. No brand colors — this is a tool, not a product.

### Typography

- **UI font:** System monospace (SF Mono / Menlo). Everything in this tool is technical — monospace respects the content.
- **Headings:** System sans (SF Pro) semibold, used sparingly for section labels only.
- **Serial/log output:** Monospace, `#e0e0e0` on dark background. No syntax highlighting — raw output, exactly as received.

### Depth

- **Approach:** Flat with subtle 1px borders (`#333333`). No shadows, no blur. Depth through color difference only.
- **Rationale:** Shadows suggest consumer software. Borders suggest instrument panels. This is an instrument.

### Spacing

- **Base unit:** 8px
- **Component padding:** 12px (1.5 units)
- **Section gaps:** 16px (2 units)
- **Window margins:** 16px

### Components

- **Status indicator:** Small circle (8px) with color fill + label. No animation — state changes are instantaneous.
- **VM display:** Full-bleed within its container. No rounded corners on the display itself.
- **Log output:** Scrolling monospace region, bottom-anchored (newest at bottom). No line numbers unless requested.
- **Toolbar (if present):** Icon-only, 32px touch targets, subtle hover state (`#2e2e2e` -> `#3a3a3a`).

---

## JB Kernel Patcher Status (`patches-jb` branch)

Branch is 8 commits ahead of `main`. All changes are **additive** — non-JB code paths are unaffected.

### Diff vs Main

| File | Change | Impact on non-JB |
|------|--------|-----------------|
| `kernel.py` | +1 line: `self.patches = []` reset in `find_all()` | None (harmless init) |
| `cfw.py` | +`patch-launchd-jetsam`, +`inject-dylib` commands | None (new commands only) |
| `kernel_jb.py` | **New file** — 2128 lines | N/A |
| `txm_jb.py` | **New file** — 335 lines | N/A |
| `iboot_jb.py` | **New file** — 105 lines | N/A |
| `fw_patch_jb.py` | **New file** — 115 lines (WIP) | N/A |
| `cfw_install_jb.sh` | **New file** — 214 lines | N/A |
| `cfw_jb_input.tar.zst` | **New file** — JB resources | N/A |
| `Makefile` | +JB targets (`fw_patch_jb`, `cfw_install_jb`) | None (additive) |
| `AGENTS.md` | Documentation updates | N/A |

### Patch Counts

**Base patcher** (`kernel.py`): **25 patches** — verified identical to main.

**JB patcher** (`kernel_jb.py`): **160 patches** from 22 methods:
- **19 of 22 PASSING** — Groups A (sandbox hooks, AMFI, execve), B (string-anchored), C (shellcode)
- **3 FAILING** — see below

### 3 Remaining Failures

| Patch | Upstream Offset | Root Cause | Proposed Strategy |
|-------|----------------|------------|-------------------|
| `patch_nvram_verify_permission` | NOP BL at `0x1234034` | 332 identical IOKit methods match structural filter; "krn." string leads to wrong function | Find via "IONVRAMController" string → metaclass ctor → PAC disc `#0xcda1` → search `__DATA_CONST` vtable entries (first entry after 3 nulls) with matching PAC disc + BL to memmove |
| `patch_thid_should_crash` | Zero `0x67EB50` | String in `__PRELINK_INFO` plist (no code refs); value already `0x00000000` in PCC kernel | Safe to return True (no-op); or find via `sysctl_oid` struct search in `__DATA` |
| `patch_hook_cred_label_update_execve` | Shellcode at `0xAB17D8` + ops table at `0xA54518` | Needs `_vfs_context_current` (`0xCC5EAC`) and `_vnode_getattr` (`0xCC91C0`) — 0 symbols available | Find via sandbox ops table → original hook func → BL targets by caller count (vfs_context_current = highest, vnode_getattr = near `mov wN, #0x380`) |

### Key Findings (from `researchs/kernel_jb_remaining_patches.md`)

**All offsets in `kernel.py` are file offsets** — `bl_callers` dict, `_is_bl()`, `_disas_at()`, `find_string_refs()` all use file offsets, not VAs.

**IONVRAMController vtable discovery chain**:
```
"IONVRAMController" string @ 0xA2FEB
  → ADRP+ADD refs → metaclass ctor @ 0x125D2C0
    → PAC discriminator: movk x17, #0xcda1, lsl #48
    → instance size: mov w3, #0x88
  → class vtable in __DATA_CONST @ 0x7410B8 (preceded by 3 null entries)
    → vtable[0] = 0x1233E40 = verifyPermission
      → BL to memmove (3114 callers) at +0x1F4 = 0x1234034 ← NOP this
```

**vfs_context_current / vnode_getattr resolution**:
```
sandbox ops table → entry[16] = original hook @ 0x239A0B4
  → disassemble hook → find BL targets:
    - _vfs_context_current: BL target with >1000 callers, short function
    - _vnode_getattr: BL target near "mov wN, #0x380", moderate callers
```

### Upstream Reference Offsets (iPhone17,3 26.1)

| Symbol | File Offset | Notes |
|--------|-------------|-------|
| kern_text | `0xA74000` — `0x24B0000` | |
| base_va | `0xFFFFFE0007004000` | |
| verifyPermission func | `0x1233E40` | vtable @ `0x7410B8` |
| verifyPermission patch | `0x1234034` | NOP BL to memmove |
| _thid_should_crash var | `0x67EB50` | already 0 |
| _vfs_context_current | `0xCC5EAC` | from BL encoding |
| _vnode_getattr | `0xCC91C0` | from BL encoding |
| hook_cred_label orig | `0x239A0B4` | from B encoding |
| sandbox ops entry | `0xA54518` | index 16 |
| OSMetaClass::OSMetaClass() | `0x10EA790` | 5236 callers |
| memmove | `0x12CB0D0` | 3114 callers |

```

`CLAUDE.md`:

```md
# vphone-
```

`LICENSE`:

```
            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
                    Version 2, December 2004

 Copyright (C) 2026 Sam Hocevar <sam@hocevar.net>

 Everyone is permitted to copy and distribute verbatim or modified
 copies of this license document, and changing it is allowed as long
 as the name is changed.

            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. You just DO WHAT THE FUCK YOU WANT TO.

```

`Makefile`:

```
# ═══════════════════════════════════════════════════════════════════
# vphone-cli — Virtual iPhone boot tool
# ═══════════════════════════════════════════════════════════════════

# ─── Configuration (override with make VAR=value) ─────────────────
VM_DIR      ?= vm
CPU         ?= 8
MEMORY      ?= 8192
DISK_SIZE   ?= 64

# ─── Paths ────────────────────────────────────────────────────────
SCRIPTS     := scripts
BINARY      := .build/release/vphone-cli
ENTITLEMENTS := sources/vphone.entitlements
VENV        := .venv
LIMD_PREFIX := .limd
IRECOVERY   := $(LIMD_PREFIX)/bin/irecovery
IDEVICERESTORE := $(LIMD_PREFIX)/bin/idevicerestore
PYTHON      := $(CURDIR)/$(VENV)/bin/python3

SWIFT_SOURCES := $(shell find sources -name '*.swift')

# ─── Environment — prefer project-local binaries ────────────────
export PATH := $(CURDIR)/$(LIMD_PREFIX)/bin:$(CURDIR)/$(VENV)/bin:$(CURDIR)/.build/release:$(PATH)

# ─── Default ──────────────────────────────────────────────────────
.PHONY: help
help:
	@echo "vphone-cli — Virtual iPhone boot tool"
	@echo ""
	@echo "Setup (one-time):"
	@echo "  make setup_venv              Create Python .venv"
	@echo "  make setup_libimobiledevice  Build libimobiledevice toolchain"
	@echo ""
	@echo "Build:"
	@echo "  make build                   Build + sign vphone-cli"
	@echo "  make install                 Build + copy to ./bin/"
	@echo "  make clean                   Remove .build/"
	@echo ""
	@echo "VM management:"
	@echo "  make vm_new                  Create VM directory"
	@echo "  make boot                    Boot VM (GUI)"
	@echo "  make boot_dfu                Boot VM in DFU mode"
	@echo ""
	@echo "Firmware pipeline:"
	@echo "  make fw_prepare              Download IPSWs, extract, merge"
	@echo "  make fw_patch                Patch boot chain (6 components)"
	@echo "  make fw_patch_jb             Run fw_patch + JB extension patches (WIP)"
	@echo ""
	@echo "Restore:"
	@echo "  make restore_get_shsh        Fetch SHSH blob from device"
	@echo "  make restore                 idevicerestore to device"
	@echo ""
	@echo "Ramdisk:"
	@echo "  make ramdisk_build           Build signed SSH ramdisk"
	@echo "  make ramdisk_send            Send ramdisk to device"
	@echo ""
	@echo "CFW:"
	@echo "  make cfw_install             Install CFW mods via SSH"
	@echo "  make cfw_install_jb          Install CFW + JB extensions (jetsam/procursus/basebin)"
	@echo ""
	@echo "Variables: VM_DIR=$(VM_DIR) CPU=$(CPU) MEMORY=$(MEMORY) DISK_SIZE=$(DISK_SIZE)"

# ═══════════════════════════════════════════════════════════════════
# Setup
# ═══════════════════════════════════════════════════════════════════

.PHONY: setup_venv setup_libimobiledevice

setup_venv:
	zsh $(SCRIPTS)/setup_venv.sh

setup_libimobiledevice:
	bash $(SCRIPTS)/setup_libimobiledevice.sh

# ═══════════════════════════════════════════════════════════════════
# Build
# ═══════════════════════════════════════════════════════════════════

.PHONY: build install clean

build: $(BINARY)

$(BINARY): $(SWIFT_SOURCES) Package.swift $(ENTITLEMENTS)
	@echo "=== Building vphone-cli ==="
	swift build -c release 2>&1 | tail -5
	@echo ""
	@echo "=== Signing with entitlements ==="
	codesign --force --sign - --entitlements $(ENTITLEMENTS) $@
	@echo "  signed OK"

install: build
	mkdir -p ./bin
	cp -f $(BINARY) ./bin/vphone-cli
	@echo "Installed to ./bin/vphone-cli"

clean:
	swift package clean
	rm -rf .build

# ═══════════════════════════════════════════════════════════════════
# VM management
# ═══════════════════════════════════════════════════════════════════

.PHONY: vm_new boot boot_dfu

vm_new:
	zsh $(SCRIPTS)/vm_create.sh --dir $(VM_DIR) --disk-size $(DISK_SIZE)

boot: build
	cd $(VM_DIR) && "$(CURDIR)/$(BINARY)" \
		--rom ./AVPBooter.vresearch1.bin \
		--disk ./Disk.img \
		--nvram ./nvram.bin \
		--machine-id ./machineIdentifier.bin \
		--cpu $(CPU) --memory $(MEMORY) \
		--sep-rom ./AVPSEPBooter.vresearch1.bin \
		--sep-storage ./SEPStorage

boot_dfu: build
	cd $(VM_DIR) && "$(CURDIR)/$(BINARY)" \
		--rom ./AVPBooter.vresearch1.bin \
		--disk ./Disk.img \
		--nvram ./nvram.bin \
		--machine-id ./machineIdentifier.bin \
		--cpu $(CPU) --memory $(MEMORY) \
		--sep-rom ./AVPSEPBooter.vresearch1.bin \
		--sep-storage ./SEPStorage \
		--no-graphics --dfu

# ═══════════════════════════════════════════════════════════════════
# Firmware pipeline
# ═══════════════════════════════════════════════════════════════════

.PHONY: fw_prepare fw_patch fw_patch_jb

fw_prepare:
	cd $(VM_DIR) && bash "$(CURDIR)/$(SCRIPTS)/fw_prepare.sh"

fw_patch:
	cd $(VM_DIR) && $(PYTHON) "$(CURDIR)/$(SCRIPTS)/fw_patch.py" .

fw_patch_jb:
	cd $(VM_DIR) && $(PYTHON) "$(CURDIR)/$(SCRIPTS)/fw_patch_jb.py" .

# ═══════════════════════════════════════════════════════════════════
# Restore
# ═══════════════════════════════════════════════════════════════════

.PHONY: restore_get_shsh restore

restore_get_shsh:
	cd $(VM_DIR) && "$(CURDIR)/$(IDEVICERESTORE)" -e -y ./iPhone*_Restore -t

restore:
	cd $(VM_DIR) && "$(CURDIR)/$(IDEVICERESTORE)" -e -y ./iPhone*_Restore

# ═══════════════════════════════════════════════════════════════════
# Ramdisk
# ═══════════════════════════════════════════════════════════════════

.PHONY: ramdisk_build ramdisk_send

ramdisk_build:
	cd $(VM_DIR) && $(PYTHON) "$(CURDIR)/$(SCRIPTS)/ramdisk_build.py" .

ramdisk_send:
	cd $(VM_DIR) && IRECOVERY="$(CURDIR)/$(IRECOVERY)" zsh "$(CURDIR)/$(SCRIPTS)/ramdisk_send.sh"

# ═══════════════════════════════════════════════════════════════════
# CFW
# ═══════════════════════════════════════════════════════════════════

.PHONY: cfw_install cfw_install_jb

cfw_install:
	cd $(VM_DIR) && zsh "$(CURDIR)/$(SCRIPTS)/cfw_install.sh" .

cfw_install_jb:
	cd $(VM_DIR) && zsh "$(CURDIR)/$(SCRIPTS)/cfw_install_jb.sh" .

```

`Package.swift`:

```swift
// swift-tools-version:6.0

import PackageDescription

let package = Package(
    name: "vphone-cli",
    platforms: [
        .macOS(.v15),
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-argument-parser", from: "1.3.1"),
        .package(url: "https://github.com/mhdhejazi/Dynamic", from: "1.2.0"),
    ],
    targets: [
        .executableTarget(
            name: "vphone-cli",
            dependencies: [
                .product(name: "ArgumentParser", package: "swift-argument-parser"),
                .product(name: "Dynamic", package: "Dynamic"),
            ],
            path: "sources/vphone-cli",
            linkerSettings: [
                .linkedFramework("Virtualization"),
                .linkedFramework("AppKit"),
            ]
        ),
    ]
)

```

`README.md`:

```md
# vphone-cli

Boot a virtual iPhone (iOS 26) via Apple's Virtualization.framework using PCC research VM infrastructure.

![poc](./demo.png)

## Tested Environments

| Host | iPhone | CloudOS |
|------|--------|---------|
| Mac16,12 26.3 | `17,3_26.1_23B85` | `26.1-23B85` |
| Mac16,12 26.3 | `17,3_26.3_23D127` | `26.1-23B85` |
| Mac16,12 26.3 | `17,3_26.3_23D127` | `26.3-23D128` |

## Prerequisites

**Disable SIP and AMFI** — required for private Virtualization.framework entitlements.

Boot into Recovery (long press power button), open Terminal:

```bash
csrutil disable
csrutil allow-research-guests enable
```

After restarting into macOS:

```bash
sudo nvram boot-args="amfi_get_out_of_my_way=1 -v"
```

Restart once more.

**Install dependencies:**

```bash
make setup_libimobiledevice   # build libimobiledevice toolchain
make setup_venv               # create Python venv
source .venv/bin/activate
```

## Quick Start

```bash
make build                    # build + sign vphone-cli
make vm_new                   # create vm/ directory (ROMs, disk, SEP storage)
make fw_prepare               # download IPSWs, extract, merge, generate manifest
make fw_patch                 # patch boot chain (6 components, 41+ modifications)
```

## Restore

You'll need **two terminals** for the restore process. Keep terminal 1 running while using terminal 2.

```bash
# terminal 1
make boot_dfu                 # boot VM in DFU mode (keep running)
```

```bash
# terminal 2
make restore_get_shsh         # fetch SHSH blob
make restore                  # flash firmware via idevicerestore
```

## Ramdisk and CFW

Stop the DFU boot in terminal 1 (Ctrl+C), then boot into DFU again for the ramdisk:

```bash
# terminal 1
make boot_dfu                 # keep running
```

```bash
# terminal 2
make ramdisk_build            # build signed SSH ramdisk
make ramdisk_send             # send to device
```

Once connected, install CFW:

```bash
# terminal 2
iproxy 2222 22
make cfw_install
```

## First Boot

Stop the DFU boot in terminal 1 (Ctrl+C), then:

```bash
make boot
```

This gives you a **direct console** on the VM. When you see `bash-4.4#`, press Enter and run these commands to initialize the shell environment and generate SSH host keys:

```bash
export PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/games:/iosbinpack64/usr/local/sbin:/iosbinpack64/usr/local/bin:/iosbinpack64/usr/sbin:/iosbinpack64/usr/bin:/iosbinpack64/sbin:/iosbinpack64/bin'

mkdir -p /var/dropbear
cp /iosbinpack64/etc/profile /var/profile
cp /iosbinpack64/etc/motd /var/motd

# generate SSH host keys (required for SSH to work)
dropbearkey -t rsa -f /var/dropbear/dropbear_rsa_host_key
dropbearkey -t ecdsa -f /var/dropbear/dropbear_ecdsa_host_key

shutdown -h now
```

> **Note:** Without the host key generation step, dropbear (SSH server) will accept connections but immediately close them because it has no keys to perform the SSH handshake.

## Subsequent Boots

```bash
make boot
```

In a separate terminal, start iproxy tunnels:

```bash
iproxy 22222 22222   # SSH
iproxy 5901 5901     # VNC
```

Connect via:
- **SSH:** `ssh -p 22222 root@127.0.0.1` (password: `alpine`)
- **VNC:** `vnc://127.0.0.1:5901`

## All Make Targets

Run `make help` for the full list. Key targets:

| Target | Description |
|--------|-------------|
| `build` | Build + sign vphone-cli |
| `vm_new` | Create VM directory |
| `fw_prepare` | Download/merge IPSWs |
| `fw_patch` | Patch boot chain |
| `boot` / `boot_dfu` | Boot VM (GUI / DFU headless) |
| `restore_get_shsh` | Fetch SHSH blob |
| `restore` | Flash firmware |
| `ramdisk_build` | Build SSH ramdisk |
| `ramdisk_send` | Send ramdisk to device |
| `cfw_install` | Install CFW mods |
| `clean` | Remove build artifacts |

## FAQ

> **Before anything else — run `git pull` to make sure you have the latest version.**

**Q: I get `zsh: killed ./vphone-cli` when trying to run it.**

AMFI is not disabled. Set the boot-arg and restart:

```bash
sudo nvram boot-args="amfi_get_out_of_my_way=1 -v"
```

**Q: I'm stuck on the "Press home to continue" screen.**

Connect via VNC (`vnc://127.0.0.1:5901`) and right-click anywhere on the screen (two-finger click on a Mac trackpad). This simulates the home button press.

**Q: SSH connects but immediately closes (`Connection closed by 127.0.0.1`).**

Dropbear host keys were not generated during first boot. Connect via VNC or the `make boot` console and run:

```bash
export PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/games:/iosbinpack64/usr/local/sbin:/iosbinpack64/usr/local/bin:/iosbinpack64/usr/sbin:/iosbinpack64/usr/bin:/iosbinpack64/sbin:/iosbinpack64/bin'
mkdir -p /var/dropbear
dropbearkey -t rsa -f /var/dropbear/dropbear_rsa_host_key
dropbearkey -t ecdsa -f /var/dropbear/dropbear_ecdsa_host_key
killall dropbear
dropbear -R -p 22222
```

**Q: Can I update to a newer iOS version?**

Yes. Override `fw_prepare` with the IPSW URL for the version you want:

```bash
export IPHONE_SOURCE=/path/to/some_os.ipsw
export CLOUDOS_SOURCE=/path/to/some_os.ipsw
make fw_prepare
make fw_patch
```

Our patches are applied via binary analysis, not static offsets, so newer versions should work. If something breaks, ask AI for help.

## Acknowledgements

- [wh1te4ever/super-tart-vphone-writeup](https://github.com/wh1te4ever/super-tart-vphone-writeup)

```

`requirements.txt`:

```txt
capstone
keystone-engine
pyimg4

```

`researchs/binary_patches_kernelcache.md`:

```md
# Binary Kernelcache Patch Verification Report

Date: 2026-02-27

## Scope
Verify that the dynamic kernel patch finder (`Scripts/kernel_patcher.py`) produces
the same binary result as the legacy hardcoded patch list on vphone600, then
apply the dynamic patcher to a freshly extracted vresearch101 kernelcache.

## Inputs
- Original vphone600 raw kernel: `/tmp/kc_vphone600_orig.raw`
- vphone600 upstream hardcoded patch list: `super-tart-vphone-private/CFW/patch_fw.py`
- Dynamic patcher: `Scripts/kernel_patcher.py`
- VM kernelcache image (vresearch101): `VM/iPhone17,3_26.1_23B85_Restore/kernelcache.research.vresearch101`

## Method
1. Apply legacy hardcoded patches to `/tmp/kc_vphone600_orig.raw` using binary
   replacement (32-bit writes) and save as `/tmp/kc_vphone600_upstream.raw`.
2. Run `KernelPatcher.find_all()` on `/tmp/kc_vphone600_orig.raw`, apply all
   dynamic patches, and save as `/tmp/kc_vphone600_dynamic.raw`.
3. Compare the two patched binaries with `cmp -l`.
4. Re-extract a clean vresearch101 kernelcache using `pyimg4 im4p extract`, save
   as `/tmp/kc_vresearch1_orig.raw`.
5. Run the dynamic patcher on `/tmp/kc_vresearch1_orig.raw`, save as
   `/tmp/kc_vresearch1_dynamic.raw`.

## Outputs
- `/tmp/kc_vphone600_upstream.raw`
- `/tmp/kc_vphone600_dynamic.raw`
- `/tmp/kc_vresearch1_orig.raw`
- `/tmp/kc_vresearch1_dynamic.raw`

## Checksums (SHA-256)
- `/tmp/kc_vphone600_orig.raw`:
  `b6846048f3a60eab5f360fcc0f3dcb5198aa0476c86fb06eb42f6267cdbfcae0`
- `/tmp/kc_vphone600_upstream.raw`:
  `373e016d34ae5a2d8ba7ba96c920f4f6700dea503e3689d06a99e90ebec701c8`
- `/tmp/kc_vphone600_dynamic.raw`:
  `373e016d34ae5a2d8ba7ba96c920f4f6700dea503e3689d06a99e90ebec701c8`
- `/tmp/kc_vresearch1_orig.raw`:
  `c673c9b8226ea774d1d935427760e2e9a48200fd1daf0ef584dc88df0dccefde`
- `/tmp/kc_vresearch1_dynamic.raw`:
  `f36a78ce59c658df85ecdead56d46370a1107181689091cf798e529664f6e2b5`

## vphone600: Hardcoded vs Dynamic
Result: **byte-identical** output between hardcoded and dynamic patching.

- `KernelPatcher` patches found: 25
- Hardcoded patches applied: 25
- `cmp -l /tmp/kc_vphone600_upstream.raw /tmp/kc_vphone600_dynamic.raw`:
  no output (files identical)

### Hardcoded Patch List (vphone600)
Offsets and 32-bit patch values, taken from `patch_fw.py`:

| # | Offset (hex) | Patch value | Purpose |
|---|-------------:|------------:|---------|
| 1 | 0x2476964 | 0xD503201F | _apfs_vfsop_mount root snapshot NOP |
| 2 | 0x23CFDE4 | 0xD503201F | _authapfs_seal_is_broken NOP |
| 3 | 0x00F6D960 | 0xD503201F | _bsd_init rootvp NOP |
| 4 | 0x163863C | 0x52800000 | _proc_check_launch_constraints mov w0,#0 |
| 5 | 0x1638640 | 0xD65F03C0 | _proc_check_launch_constraints ret |
| 6 | 0x12C8138 | 0xD2800020 | _PE_i_can_has_debugger mov x0,#1 |
| 7 | 0x12C813C | 0xD65F03C0 | _PE_i_can_has_debugger ret |
| 8 | 0x00FFAB98 | 0xD503201F | TXM post-validation NOP (tbnz) |
| 9 | 0x16405AC | 0x6B00001F | postValidation cmp w0,w0 |
| 10 | 0x16410BC | 0x52800020 | _check_dyld_policy_internal mov w0,#1 (1) |
| 11 | 0x16410C8 | 0x52800020 | _check_dyld_policy_internal mov w0,#1 (2) |
| 12 | 0x242011C | 0x52800000 | _apfs_graft mov w0,#0 |
| 13 | 0x2475044 | 0xEB00001F | _apfs_vfsop_mount cmp x0,x0 |
| 14 | 0x2476C00 | 0x52800000 | _apfs_mount_upgrade_checks mov w0,#0 |
| 15 | 0x248C800 | 0x52800000 | _handle_fsioc_graft mov w0,#0 |
| 16 | 0x23AC528 | 0xD2800000 | _hook_file_check_mmap mov x0,#0 |
| 17 | 0x23AC52C | 0xD65F03C0 | _hook_file_check_mmap ret |
| 18 | 0x23AAB58 | 0xD2800000 | _hook_mount_check_mount mov x0,#0 |
| 19 | 0x23AAB5C | 0xD65F03C0 | _hook_mount_check_mount ret |
| 20 | 0x23AA9A0 | 0xD2800000 | _hook_mount_check_remount mov x0,#0 |
| 21 | 0x23AA9A4 | 0xD65F03C0 | _hook_mount_check_remount ret |
| 22 | 0x23AA80C | 0xD2800000 | _hook_mount_check_umount mov x0,#0 |
| 23 | 0x23AA810 | 0xD65F03C0 | _hook_mount_check_umount ret |
| 24 | 0x23A5514 | 0xD2800000 | _hook_vnode_check_rename mov x0,#0 |
| 25 | 0x23A5518 | 0xD65F03C0 | _hook_vnode_check_rename ret |

## TXM Patch Details
Dynamic patcher locates the `"TXM [Error]: CodeSignature"` string, finds the
following `tbnz` in the log/error path, and NOPs it.

### vphone600 disassembly around the patch (0xFFAB98)
Before:
```
0x00FFAB90: mov     w0, #5
0x00FFAB94: ldrb    w8, [x19, #6]
0x00FFAB98: tbnz    w8, #0, #0xffac80
0x00FFAB9C: ldp     x29, x30, [sp, #0x100]
```
After:
```
0x00FFAB90: mov     w0, #5
0x00FFAB94: ldrb    w8, [x19, #6]
0x00FFAB98: nop
0x00FFAB9C: ldp     x29, x30, [sp, #0x100]
```

## vresearch101: Dynamic Patch Run
Extraction:
```
pyimg4 im4p extract \
  -i VM/iPhone17,3_26.1_23B85_Restore/kernelcache.research.vresearch101 \
  -o /tmp/kc_vresearch1_orig.raw
```

Dynamic patcher results:
- Patches found/applied: 25
- TXM patch location: `0xFA6B98` (NOP `tbnz w8, #0, #0xfa6c80`)
- Patched output: `/tmp/kc_vresearch1_dynamic.raw`

## Conclusion
For vphone600, the dynamic patcher output is byte-identical to the legacy
hardcoded patch list, indicating functional equivalence on this kernelcache.
The same dynamic patcher also successfully patches the freshly extracted
vresearch101 kernelcache with the expected TXM NOP and a full 25-patch set.

```

`researchs/build_manifest.md`:

```md

# BuildManifest.plist Research

## 1. Multi-Source Comparison

### Identity Count Overview

| Source | Identities | DeviceClasses |
|--------|-----------|---------------|
| iPhone 26.1 | 5 | All d47ap |
| iPhone 26.3 | 5 | All d47ap |
| CloudOS 26.1 | 6 | j236cap, j475dap, vphone600ap (x2), vresearch101ap (x2) |
| KnownWork 26.1 | 5 | All vresearch101ap |

### CloudOS 26.1 Identity Structure (6 identities)

| Index | DeviceClass | Variant | BuildStyle | Manifest Keys |
|-------|-------------|---------|------------|---------------|
| [0] | j236cap | Darwin Cloud Customer Erase Install (IPSW) | RELEASE build | 37 keys (server hardware) |
| [1] | j475dap | Darwin Cloud Customer Erase Install (IPSW) | unknown (no path) | 0 keys (empty placeholder) |
| [2] | vphone600ap | Darwin Cloud Customer Erase Install (IPSW) | RELEASE build | 29 keys (includes UI assets) |
| [3] | vresearch101ap | Darwin Cloud Customer Erase Install (IPSW) | RELEASE build | 20 keys (no UI assets) |
| [4] | vphone600ap | Research Darwin Cloud Customer Erase Install (IPSW) | RESEARCH_RELEASE build | 29 keys (research kernel) |
| [5] | vresearch101ap | Research Darwin Cloud Customer Erase Install (IPSW) | RESEARCH_RELEASE build | 20 keys (research kernel) |

Key distinctions:
- CloudOS[2] vs [4] (vphone600ap): [2] uses RELEASE boot chain + release kernelcache; [4] uses RESEARCH_RELEASE + research kernelcache + txm.iphoneos.research.im4p
- CloudOS[3] vs [5] (vresearch101ap): Same pattern — [3] is RELEASE, [5] is RESEARCH_RELEASE
- **vphone600ap has components vresearch101ap lacks**: RecoveryMode, AppleLogo, Battery*, RestoreLogo, SEP (vphone600 variant)
- vresearch101ap has only 20 manifest keys (no UI assets, no RecoveryMode)

### vphone600ap vs vresearch101ap Key Differences

| Property | vphone600ap | vresearch101ap |
|----------|-------------|----------------|
| Ap,ProductType | iPhone99,11 | ComputeModule14,2 |
| Ap,Target | VPHONE600AP | VRESEARCH101AP |
| ApBoardID | 0x91 | 0x90 |
| DeviceTree | DeviceTree.vphone600ap.im4p | DeviceTree.vresearch101ap.im4p |
| SEP | sep-firmware.vphone600.RELEASE.im4p | sep-firmware.vresearch101.RELEASE.im4p |
| RecoveryMode | recoverymode@2556~iphone-USBc.im4p | **NOT PRESENT** |
| MKB dt flag | dt=1 (keybag-less boot OK) | dt=0 (fatal keybag error) |

---

## 2. Component Source Tracing (Corrected)

### Hybrid Identity: vresearch101 boot chain + vphone600 runtime

The working configuration mixes components from both board configs:

| Component | Source Identity | File | Why This Source |
|-----------|---------------|------|-----------------|
| LLB | PROD (vresearch101 release) | `LLB.vresearch101.RELEASE.im4p` | Matches DFU hardware (BDID 0x90) |
| iBSS | PROD | `iBSS.vresearch101.RELEASE.im4p` | Matches DFU hardware |
| iBEC | PROD | `iBEC.vresearch101.RELEASE.im4p` | Matches DFU hardware |
| iBoot | RES (vresearch101 research) | `iBoot.vresearch101.RESEARCH_RELEASE.im4p` | Only research identity has iBoot |
| SPTM (all) | PROD | `sptm.vresearch1.release.im4p` | Shared across board configs |
| TXM restore | PROD | `txm.iphoneos.release.im4p` | RELEASE for restore |
| TXM installed | RES | `txm.iphoneos.research.im4p` | Research variant, patched |
| **DeviceTree** | **VP (vphone600 release)** | `DeviceTree.vphone600ap.im4p` | Sets MKB dt=1 |
| **SEP/RestoreSEP** | **VP** | `sep-firmware.vphone600.RELEASE.im4p` | Must match device tree |
| **KernelCache** | **VPR (vphone600 research)** | `kernelcache.research.vphone600` | Patched by fw_patch.py |
| **RestoreKernelCache** | **VP (vphone600 release)** | `kernelcache.release.vphone600` | Unpatched, restore-time only |
| **RecoveryMode** | **VP** | `recoverymode@2556~iphone-USBc.im4p` | Only vphone600ap has it |
| RestoreRamDisk | PROD | cloudOS erase ramdisk | PCC restore ramdisk |
| OS / SVC / etc. | I_ERASE (iPhone) | iPhone OS image | iPhone system |

### Why Not All-vresearch101 or All-vphone600?

**Problem with all-vresearch101**: The vresearch101ap device tree sets MKB `dt=0`,
causing `MKB_INIT: FATAL KEYBAG ERROR` on first boot (no system keybag exists yet).
Also missing RecoveryMode entry.

**Problem with all-vphone600**: The DFU hardware identifies as BDID 0x90
(vresearch101ap). Using vphone600ap identity (BDID 0x91) fails TSS/SHSH signing
and idevicerestore identity matching (`Unable to find a matching build identity`).

**Solution**: vresearch101ap identity fields for DFU/TSS + vphone600 runtime
components for a working boot environment.

---

## 3. idevicerestore Identity Selection Logic

Source: `idevicerestore/src/idevicerestore.c` lines 2195-2242

### Matching Algorithm

idevicerestore selects a Build Identity by iterating through all `BuildIdentities` and returning the **first match** based on two fields:

1. **`Info.DeviceClass`** — case-insensitive match against device `hardware_model`
2. **`Info.Variant`** — substring match against the requested variant string

For DFU erase restore, the search variant is `"Erase Install (IPSW)"` (defined in `idevicerestore.h`).

### Matching Modes

```c
// Exact match
if (strcmp(str, variant) == 0) return ident;

// Partial match (when exact=0)
if (strstr(str, variant) && !strstr(str, "Research")) return ident;
```

**Critical**: Partial matching **excludes** variants containing `"Research"`. This means:
- `"Darwin Cloud Customer Erase Install (IPSW)"` — matches (contains "Erase Install (IPSW)", no "Research")
- `"Research Darwin Cloud Customer Erase Install (IPSW)"` — skipped (contains "Research")

### What idevicerestore Does NOT Check
- ApBoardID / ApChipID (used after selection, not for matching)
- Identity index or count (no hardcoded indices)

### Conclusion for Single Identity

A BuildManifest with **one identity** works fine. The loop iterates once, and if
DeviceClass and Variant match, it's returned. No minimum identity count required.

---

## 4. TSS/SHSH Signing

The TSS request sent to `gs.apple.com` includes:
- `ApBoardID = 144` (0x90) — must match vresearch101ap
- `ApChipID = 65025` (0xFE01)
- `Ap,ProductType = ComputeModule14,2`
- `Ap,Target = VRESEARCH101AP`
- Digests for all 21 manifest components

Apple's TSS server signs based on these identity fields + component digests.
Using vphone600ap identity (BDID 0x91) would fail because the DFU device
reports BDID 0x90.

---

## 5. Final Design: Single DFU Erase Identity

### Identity Metadata (fw_manifest.py)
```
DeviceClass     = vresearch101ap    (from C[PROD] deep copy)
Variant         = Darwin Cloud Customer Erase Install (IPSW)
Ap,ProductType  = ComputeModule14,2
Ap,Target       = VRESEARCH101AP
Ap,TargetType   = vresearch101
ApBoardID       = 0x90
ApChipID        = 0xFE01
FDRSupport      = False
```

### Source Variable Map
```
PROD = C[vresearch101ap release]   — boot chain, SPTM, ramdisk
RES  = C[vresearch101ap research]  — iBoot, TXM research
VP   = C[vphone600ap release]      — DeviceTree, SEP, RestoreKernelCache, RecoveryMode
VPR  = C[vphone600ap research]     — KernelCache (patched by fw_patch.py)
I_ERASE = I[iPhone erase]          — OS, trust caches, system volume
```

### All 21 Manifest Entries
```
Boot chain (PROD):           LLB, iBSS, iBEC
Research iBoot (RES):        iBoot
Security monitors (PROD):   Ap,RestoreSPTM, Ap,RestoreTXM, Ap,SPTM
Research TXM (RES):          Ap,TXM
Device tree (VP):            DeviceTree, RestoreDeviceTree
SEP (VP):                    SEP, RestoreSEP
Kernel (VPR/VP):             KernelCache (research), RestoreKernelCache (release)
Recovery (VP):               RecoveryMode
Ramdisk (PROD):              RestoreRamDisk, RestoreTrustCache
iPhone OS (I_ERASE):         OS, StaticTrustCache, SystemVolume, Ap,SVC Metadata
```

### Restore.plist
```
DeviceMap:     [d47ap (iPhone), vphone600ap, vresearch101ap]
ProductTypes:  [iPhone17,3, ComputeModule14,1, ComputeModule14,2, Mac14,14, iPhone99,11]
```

```

`researchs/erase_install_component_origins.md`:

```md
# Erase Install — Component Origins

The erase install firmware is a **hybrid** of three source sets:

1. **PCC vresearch101ap** — boot chain (LLB/iBSS/iBEC/iBoot) and security monitors (SPTM/TXM)
2. **PCC vphone600ap** — runtime components (DeviceTree, SEP, KernelCache, RecoveryMode)
3. **iPhone 17,3** — OS image, trust caches, filesystem

The VM hardware identifies as **vresearch101ap** (BDID 0x90) in DFU mode, so the
BuildManifest identity must use vresearch101ap fields for TSS/SHSH signing. However,
runtime components use the **vphone600** variant because:
- Its DeviceTree sets MKB `dt=1` (allows boot without system keybag)
- Its SEP firmware matches the vphone600 device tree
- `hardware target` reports as `vphone600ap` → proper iPhone emulation

`fw_prepare.sh` downloads both IPSWs, merges cloudOS firmware into the iPhone
restore directory, then `fw_manifest.py` generates the hybrid BuildManifest.

---

## Component Source Table

### Boot Chain (from PCC vresearch101ap)

| Component | Source Identity | File | Patches Applied |
|-----------|---------------|------|-----------------|
| **AVPBooter** | PCC vresearch1 | `AVPBooter*.bin` (vm dir) | DGST validation bypass (`mov x0, #0`) |
| **iBSS** | PROD (vresearch101ap release) | `Firmware/dfu/iBSS.vresearch101.RELEASE.im4p` | Serial labels + image4 callback bypass |
| **iBEC** | PROD (vresearch101ap release) | `Firmware/dfu/iBEC.vresearch101.RELEASE.im4p` | Serial labels + image4 callback + boot-args |
| **LLB** | PROD (vresearch101ap release) | `Firmware/all_flash/LLB.vresearch101.RELEASE.im4p` | Serial labels + image4 callback + boot-args + rootfs + panic (6 patches) |
| **iBoot** | RES (vresearch101ap research) | `Firmware/all_flash/iBoot.vresearch101.RESEARCH_RELEASE.im4p` | Not patched (only research identity carries iBoot) |

### Security Monitors (from PCC, shared across board configs)

| Component | Source Identity | File | Patches Applied |
|-----------|---------------|------|-----------------|
| **Ap,RestoreSecurePageTableMonitor** | PROD | `Firmware/sptm.vresearch1.release.im4p` | Not patched |
| **Ap,RestoreTrustedExecutionMonitor** | PROD | `Firmware/txm.iphoneos.release.im4p` | Not patched |
| **Ap,SecurePageTableMonitor** | PROD | `Firmware/sptm.vresearch1.release.im4p` | Not patched |
| **Ap,TrustedExecutionMonitor** | RES (research) | `Firmware/txm.iphoneos.research.im4p` | Trustcache bypass (`mov x0, #0` at 0x2C1F8) |

### Runtime Components (from PCC vphone600ap)

| Component | Source Identity | File | Patches Applied |
|-----------|---------------|------|-----------------|
| **DeviceTree** | VP (vphone600ap release) | `Firmware/all_flash/DeviceTree.vphone600ap.im4p` | Not patched |
| **RestoreDeviceTree** | VP | `Firmware/all_flash/DeviceTree.vphone600ap.im4p` | Not patched |
| **SEP** | VP | `Firmware/all_flash/sep-firmware.vphone600.RELEASE.im4p` | Not patched |
| **RestoreSEP** | VP | `Firmware/all_flash/sep-firmware.vphone600.RELEASE.im4p` | Not patched |
| **KernelCache** | VPR (vphone600ap research) | `kernelcache.research.vphone600` | 25 dynamic patches via KernelPatcher |
| **RestoreKernelCache** | VP (vphone600ap release) | `kernelcache.release.vphone600` | Not patched (used during restore only) |
| **RecoveryMode** | VP | `Firmware/all_flash/recoverymode@2556~iphone-USBc.im4p` | Not patched |

> **Important**: KernelCache (installed to disk, patched) uses the **research** variant.
> RestoreKernelCache (used during restore process only) uses the **release** variant.
> Only vphone600ap identities carry RecoveryMode — vresearch101ap does not.

### OS / Filesystem (from iPhone)

| Component | Source | Notes |
|-----------|--------|-------|
| **OS** | iPhone `iPhone17,3` erase identity | iPhone OS image |
| **SystemVolume** | iPhone erase | Root hash |
| **StaticTrustCache** | iPhone erase | Static trust cache |
| **Ap,SystemVolumeCanonicalMetadata** | iPhone erase | Metadata / mtree |

### Ramdisk (from PCC)

| Component | Source | Notes |
|-----------|--------|-------|
| **RestoreRamDisk** | PROD (vresearch101ap release) | CloudOS erase ramdisk |
| **RestoreTrustCache** | PROD | Ramdisk trust cache |

---

## Patched Components Summary

All 6 patched components in `fw_patch.py` come from **PCC (cloudOS)**:

| # | Component | Source Board | Patch Count | Purpose |
|---|-----------|-------------|-------------|---------|
| 1 | AVPBooter | vresearch1 | 1 | Bypass DGST signature validation |
| 2 | iBSS | vresearch101 | 2 | Enable serial output + bypass image4 verification |
| 3 | iBEC | vresearch101 | 3 | Enable serial + bypass image4 + inject boot-args |
| 4 | LLB | vresearch101 | 6 | Serial + image4 + boot-args + rootfs mount + panic handler |
| 5 | TXM | shared (iphoneos) | 1 | Bypass trustcache validation |
| 6 | KernelCache | vphone600 | 25 | APFS seal, MAC policy, debugger, launch constraints, etc. |

All 4 CFW-patched binaries in `patch_cfw.py` / `install_cfw.sh` come from **iPhone**:

| # | Binary | Source | Purpose |
|---|--------|--------|---------|
| 1 | seputil | iPhone (Cryptex SystemOS) | Gigalocker UUID patch (`/%s.gl` → `/AA.gl`) |
| 2 | launchd_cache_loader | iPhone (Cryptex SystemOS) | NOP cache validation check |
| 3 | mobileactivationd | iPhone (Cryptex SystemOS) | Force `should_hactivate` to return true |
| 4 | launchd.plist | iPhone (Cryptex SystemOS) | Inject bash/dropbear/trollvnc daemons |

---

## Why vphone600 Runtime Components?

The vresearch101ap device tree causes a **fatal keybag error** during boot:
```
MKB_INIT: dt = 0, bootarg = 0
MKB_INIT: FATAL KEYBAG ERROR: failed to load system bag
REBOOTING INTO RECOVERY MODE.
```

The vphone600ap device tree sets `dt=1`, allowing boot without a pre-existing
system keybag:
```
MKB_INIT: dt = 1, bootarg = 0
MKB_INIT: No system keybag loaded.
```

The SEP firmware must match the device tree (vphone600 SEP with vphone600 DT).

---

## Build Identity (Single DFU Erase)

Since vphone-cli always boots via DFU restore, only one Build Identity is needed.

### Identity Metadata (must match DFU hardware for TSS)
```
DeviceClass     = vresearch101ap
Variant         = Darwin Cloud Customer Erase Install (IPSW)
Ap,ProductType  = ComputeModule14,2
Ap,Target       = VRESEARCH101AP
Ap,TargetType   = vresearch101
ApBoardID       = 0x90
ApChipID        = 0xFE01
FDRSupport      = False
```

### Identity Source Map (fw_manifest.py variables)
```
PROD = vresearch101ap release    — boot chain, SPTM, ramdisk
RES  = vresearch101ap research   — iBoot, TXM (research)
VP   = vphone600ap release       — DeviceTree, SEP, RestoreKernelCache, RecoveryMode
VPR  = vphone600ap research      — KernelCache (research, patched by fw_patch.py)
I_ERASE = iPhone erase identity  — OS image, trust caches, system volume
```

### Manifest Components (21 total)
```
LLB                              ← PROD
iBSS                             ← PROD
iBEC                             ← PROD
iBoot                            ← RES
Ap,RestoreSecurePageTableMonitor ← PROD
Ap,RestoreTrustedExecutionMonitor← PROD
Ap,SecurePageTableMonitor        ← PROD
Ap,TrustedExecutionMonitor       ← RES
DeviceTree                       ← VP
RestoreDeviceTree                ← VP
SEP                              ← VP
RestoreSEP                       ← VP
KernelCache                      ← VPR  (research, patched)
RestoreKernelCache               ← VP   (release, unpatched)
RecoveryMode                     ← VP
RestoreRamDisk                   ← PROD
RestoreTrustCache                ← PROD
Ap,SystemVolumeCanonicalMetadata ← I_ERASE
OS                               ← I_ERASE
StaticTrustCache                 ← I_ERASE
SystemVolume                     ← I_ERASE
```

---

## TL;DR

**Boot chain = vresearch101 (matches DFU hardware); runtime = vphone600 (keybag-less boot); OS = iPhone.**

The firmware is a PCC shell wrapping an iPhone core. The vresearch101 boot chain
handles DFU/TSS signing. The vphone600 device tree + SEP + kernel provide the
runtime environment. The iPhone userland is patched post-install for activation
bypass, jailbreak tools, and persistent SSH/VNC.

```

`researchs/jailbreak_patches.md`:

```md
# Jailbreak Patches vs Base Patches

Comparison of base boot-chain patches (`make fw_patch`) vs jailbreak-extended patches (`make fw_patch_jb`).

Base patches enable VM boot with signature bypass and SSV override.
Jailbreak patches add code signing bypass, entitlement spoofing, task/VM security bypass,
sandbox hook neutralization, and kernel arbitrary call (kcall10).

## iBSS

| #   | Patch                             | Purpose                                 | Base | JB  |
| --- | --------------------------------- | --------------------------------------- | :--: | :-: |
| 1   | Serial labels (2x)                | "Loaded iBSS" in serial log             |  Y   |  Y  |
| 2   | image4_validate_property_callback | Signature bypass (nop b.ne + mov x0,#0) |  Y   |  Y  |
| 3   | Skip generate_nonce               | Keep apnonce stable for SHSH            |  —   |  Y  |

## iBEC

| #   | Patch                             | Purpose                        | Base | JB  |
| --- | --------------------------------- | ------------------------------ | :--: | :-: |
| 1   | Serial labels (2x)                | "Loaded iBEC" in serial log    |  Y   |  Y  |
| 2   | image4_validate_property_callback | Signature bypass               |  Y   |  Y  |
| 3   | Boot-args redirect                | `serial=3 -v debug=0x2014e %s` |  Y   |  Y  |

No additional JB patches for iBEC.

## LLB

| #   | Patch                             | Purpose                            | Base | JB  |
| --- | --------------------------------- | ---------------------------------- | :--: | :-: |
| 1   | Serial labels (2x)                | "Loaded LLB" in serial log         |  Y   |  Y  |
| 2   | image4_validate_property_callback | Signature bypass                   |  Y   |  Y  |
| 3   | Boot-args redirect                | `serial=3 -v debug=0x2014e %s`     |  Y   |  Y  |
| 4   | Rootfs bypass (5 patches)         | Allow edited rootfs loading        |  Y   |  Y  |
| 5   | Panic bypass                      | NOP cbnz after mov w8,#0x328 check |  Y   |  Y  |

No additional JB patches for LLB.

## TXM

| #   | Patch                                      | Purpose                           |                     Base                     | JB  |
| --- | ------------------------------------------ | --------------------------------- | :------------------------------------------: | :-: | --- |
| 1   | Trustcache binary search bypass            | `bl hash_cmp → mov x0,#0`         |                      Y                       |  Y  |
| 2   | CodeSignature selector 24 (3x mov x0,#0)   | Bypass CS validation return paths |                      —                       |  Y  |
| 3   | CodeSignature selector 24                  | 0xA1 (2x nop)                     |             Bypass CS error path             |  —  | Y   |
| 4   | get-task-allow (selector 41                | 29)                               |      `mov x0,#1` — allow get-task-allow      |  —  | Y   |
| 5   | Selector 42                                | 29 + shellcode                    | Branch to shellcode that sets flag + returns |  —  | Y   |
| 6   | com.apple.private.cs.debugger (selector 42 | 37)                               |   `mov w0,#1` — allow debugger entitlement   |  —  | Y   |
| 7   | Developer mode bypass                      | NOP developer mode enforcement    |                      —                       |  Y  |

## Kernelcache

### Base patches (SSV + basic AMFI + sandbox)

| #     | Patch                    | Function                         | Purpose                               | Base | JB  |
| ----- | ------------------------ | -------------------------------- | ------------------------------------- | :--: | :-: |
| 1     | NOP panic                | `_apfs_vfsop_mount`              | Skip "root snapshot" panic            |  Y   |  Y  |
| 2     | NOP panic                | `_authapfs_seal_is_broken`       | Skip "root volume seal" panic         |  Y   |  Y  |
| 3     | NOP panic                | `_bsd_init`                      | Skip "rootvp not authenticated" panic |  Y   |  Y  |
| 4-5   | mov w0,#0; ret           | `_proc_check_launch_constraints` | Bypass launch constraints             |  Y   |  Y  |
| 6-7   | mov x0,#1 (2x)           | `PE_i_can_has_debugger`          | Enable kernel debugger                |  Y   |  Y  |
| 8     | NOP                      | `_postValidation`                | Skip AMFI post-validation             |  Y   |  Y  |
| 9     | cmp w0,w0                | `_postValidation`                | Force comparison true                 |  Y   |  Y  |
| 10-11 | mov w0,#1 (2x)           | `_check_dyld_policy_internal`    | Allow dyld loading                    |  Y   |  Y  |
| 12    | mov w0,#0                | `_apfs_graft`                    | Allow APFS graft                      |  Y   |  Y  |
| 13    | cmp x0,x0                | `_apfs_vfsop_mount`              | Skip mount check                      |  Y   |  Y  |
| 14    | mov w0,#0                | `_apfs_mount_upgrade_checks`     | Allow mount upgrade                   |  Y   |  Y  |
| 15    | mov w0,#0                | `_handle_fsioc_graft`            | Allow fsioc graft                     |  Y   |  Y  |
| 16-25 | mov x0,#0; ret (5 hooks) | Sandbox MACF ops table           | Stub 5 sandbox hooks                  |  Y   |  Y  |

### Jailbreak-only kernel patches

| #   | Patch                      | Function                             | Purpose                                    | Base | JB  |
| --- | -------------------------- | ------------------------------------ | ------------------------------------------ | :--: | :-: |
| 26  | Rewrite function           | `AMFIIsCDHashInTrustCache`           | Always return true + store hash            |  —   |  Y  |
| 27  | Shellcode + branch         | `_cred_label_update_execve`          | Set cs_flags (platform+entitlements)       |  —   |  Y  |
| 28  | cmp w0,w0                  | `_postValidation` (additional)       | Force validation pass                      |  —   |  Y  |
| 29  | Shellcode + branch         | `_syscallmask_apply_to_proc`         | Patch zalloc_ro_mut for syscall mask       |  —   |  Y  |
| 30  | Shellcode + ops redirect   | `_hook_cred_label_update_execve`     | vnode_getattr ownership propagation + suid |  —   |  Y  |
| 31  | mov x0,#0; ret (20+ hooks) | Sandbox MACF ops table (extended)    | Stub remaining 20+ sandbox hooks           |  —   |  Y  |
| 32  | cmp xzr,xzr                | `_task_conversion_eval_internal`     | Allow task conversion                      |  —   |  Y  |
| 33  | mov x0,#0; ret             | `_proc_security_policy`              | Bypass security policy                     |  —   |  Y  |
| 34  | NOP (2x)                   | `_proc_pidinfo`                      | Allow pid 0 info                           |  —   |  Y  |
| 35  | b (skip panic)             | `_convert_port_to_map_with_flavor`   | Skip kernel map panic                      |  —   |  Y  |
| 36  | NOP                        | `_vm_fault_enter_prepare`            | Skip fault check                           |  —   |  Y  |
| 37  | b (skip check)             | `_vm_map_protect`                    | Allow VM protect                           |  —   |  Y  |
| 38  | NOP + mov x8,xzr           | `___mac_mount`                       | Bypass MAC mount check                     |  —   |  Y  |
| 39  | NOP                        | `_dounmount`                         | Allow unmount                              |  —   |  Y  |
| 40  | mov x0,#0                  | `_bsd_init` (2nd)                    | Skip auth at @%s:%d                        |  —   |  Y  |
| 41  | NOP (2x)                   | `_spawn_validate_persona`            | Skip persona validation                    |  —   |  Y  |
| 42  | NOP                        | `_task_for_pid`                      | Allow task_for_pid                         |  —   |  Y  |
| 43  | b (skip check)             | `_load_dylinker`                     | Allow dylinker loading                     |  —   |  Y  |
| 44  | cmp x0,x0                  | `_shared_region_map_and_slide_setup` | Force shared region                        |  —   |  Y  |
| 45  | NOP                        | `_verifyPermission` (NVRAM)          | Allow NVRAM writes                         |  —   |  Y  |
| 46  | b (skip check)             | `_IOSecureBSDRoot`                   | Skip secure root check                     |  —   |  Y  |
| 47  | Syscall 439 + shellcode    | kcall10 (SYS_kas_info replacement)   | Kernel arbitrary call from userspace       |  —   |  Y  |
| 48  | Zero out                   | `_thid_should_crash`                 | Prevent GUARD_TYPE_MACH_PORT crash         |  —   |  Y  |

## CFW (cfw_install)

| #   | Patch                | Binary               | Purpose                        | Base | JB  |
| --- | -------------------- | -------------------- | ------------------------------ | :--: | :-: |
| 1   | /%s.gl → /AA.gl      | seputil              | Gigalocker UUID fix            |  Y   |  Y  |
| 2   | NOP cache validation | launchd_cache_loader | Allow modified launchd.plist   |  Y   |  Y  |
| 3   | mov x0,#1; ret       | mobileactivationd    | Activation bypass              |  Y   |  Y  |
| 4   | Plist injection      | launchd.plist        | bash/dropbear/trollvnc daemons |  Y   |  Y  |
| 5   | b (skip jetsam)      | launchd              | Prevent jetsam panic on boot   |  —   |  Y  |
| 6   | procursus bootstrap  | `/mnt5/<hash>/jb-vphone` | Install procursus userspace + optional Sileo payload |  —   |  Y  |

### JB Install Flow (`make cfw_install_jb`)

- Entry: `scripts/cfw_install_jb.sh` (wrapper) -> `scripts/cfw_install.sh` with `CFW_JB_MODE=1`.
- Added JB phases in install pipeline:
  - `JB-1`: patch `/mnt1/sbin/launchd` via `patch-launchd-jetsam` (dynamic string+xref).
  - `JB-2`: unpack procursus bootstrap (`bootstrap-iphoneos-arm64.tar.zst`) into `/mnt5/<bootManifestHash>/jb-vphone/procursus`.
- JB resources now packaged in:
  - `scripts/resources/cfw_jb_input.tar.zst`
  - contains:
    - `jb/bootstrap-iphoneos-arm64.tar.zst`
    - `jb/org.coolstar.sileo_2.5.1_iphoneos-arm64.deb`

## Summary

| Binary      |  Base  | JB-only  |  Total   |
| ----------- | :----: | :------: | :------: |
| iBSS        |   2    |    1     |    3     |
| iBEC        |   3    |    0     |    3     |
| LLB         |   6    |    0     |    6     |
| TXM         |   1    |   ~13    |   ~14    |
| Kernelcache |   25   |   ~23+   |   ~48+   |
| CFW         |   4    |    1     |    5     |
| **Total**   | **41** | **~38+** | **~79+** |

## Dynamic Implementation Log (fw_patch_jb)

### TXM (Completed)

All TXM JB patches are now implemented with dynamic binary analysis and
keystone/capstone-encoded instructions only.

1. `selector24 hashcmp` (`bl -> mov x0,#0`, 2 residual sites in JB stage)
   - Locator: global instruction motif `mov w2,#0x14 ; bl ; cbz w0`.
   - Patch bytes: keystone `mov x0, #0`.
2. `selector24 A1` (`b.lo/cbz -> nop`)
   - Locator: unique guarded `mov w0,#0xa1` site with nearby `b.lo` and `cbz x9`.
   - Patch bytes: keystone `nop`.
3. `selector41|29 get-task-allow`
   - Locator: xref to `"get-task-allow"` + nearby `bl` followed by `tbnz w0,#0`.
   - Patch bytes: keystone `mov x0, #1`.
4. `selector42|29 shellcode trampoline`
   - Locator:
     - Find dispatch stub pattern `bti j ; mov x0,x20 ; bl ; mov x1,x21 ; mov x2,x22 ; bl ; b`.
     - Select stub whose second `bl` target is the debugger-gate function (pattern verified by string-xref + call-shape).
     - Find executable UDF cave dynamically.
   - Patch bytes:
     - Stub head -> keystone `b #cave`.
     - Cave payload -> `nop ; mov x0,#1 ; strb w0,[x20,#0x30] ; mov x0,x20 ; b #return`.
5. `selector42|37 debugger entitlement`
   - Locator: xref to `"com.apple.private.cs.debugger"` + strict nearby call-shape
     (`mov x0,#0 ; mov x2,#0 ; bl ; tbnz w0,#0`).
   - Patch bytes: keystone `mov w0, #1`.
6. `developer mode bypass`
   - Locator: xref to `"developer mode enabled due to system policy configuration"`
     + nearest guard branch on `w9`.
   - Patch bytes: keystone `nop`.

#### TXM Binary-Alignment Validation

- `patch.upstream.raw` generated from upstream-equivalent TXM static patch semantics.
- `patch.dyn.raw` generated by `TXMJBPatcher` on the same input.
- Result: byte-identical (`cmp -s` success, SHA-256 matched).

### Kernelcache (In Progress, Dynamic Ports Added)

Implemented in `scripts/patchers/kernel_jb.py` with capstone semantic matching
and keystone-generated patch bytes only:

1. `AMFIIsCDHashInTrustCache` function rewrite
   - Locator: semantic function-body matcher in AMFI text.
   - Patch: `mov x0,#1 ; cbz x2,+8 ; str x0,[x2] ; ret`.
2. AMFI execve kill path bypass (2 BL sites)
   - Locator: string xref to `"AMFI: hook..execve() killing"` (fallback `"execve() killing"`),
     then function-local early `bl` + `cbz/cbnz w0` pair matcher.
   - Patch: `bl -> mov x0,#0` at two helper callsites.
3. `task_conversion_eval_internal` guard bypass
   - Locator: unique cmp/branch motif:
     `ldr xN,[xN,#imm] ; cmp xN,x0 ; b.eq ; cmp xN,x1 ; b.eq`.
   - Patch: `cmp xN,x0 -> cmp xzr,xzr`.
4. Extended sandbox MACF hook stubs (JB-only set)
   - Locator: dynamic `mac_policy_conf -> mpc_ops` discovery, then hook-index resolution.
   - Patch per hook function: `mov x0,#0 ; ret`.
   - JB extended indices include vnode/proc hooks beyond base 5 hooks.

#### Cross-Version Dynamic Snapshot

Validated using pristine inputs from `updates-cdn/`:

| Case | TXM_JB_PATCHES | KERNEL_JB_PATCHES |
|------|----------------:|------------------:|
| PCC 26.1 (`23B85`) | 14 | 59 |
| PCC 26.3 (`23D128`) | 14 | 59 |
| iOS 26.1 (`23B85`) | 14 | 59 |
| iOS 26.3 (`23D127`) | 14 | 59 |

```

`researchs/kernel_jb_remaining_patches.md`:

```md
# Kernel JB Remaining Patches — Research Notes

Last updated: 2026-03-01

## Overview

`scripts/patchers/kernel_jb.py` has 22 patch methods in `find_all()`. As of this writing:

- **19 PASSING**: All Group A + most Group B + some Group C patches
- **3 FAILING**: `patch_nvram_verify_permission`, `patch_thid_should_crash`, `patch_hook_cred_label_update_execve`
- **1 FIXED this session**: `patch_syscallmask_apply_to_proc` (bl_callers key bug + now passing)
- **2 FIXED prior session**: `patch_task_for_pid`, `patch_load_dylinker` (complete rewrites)

Upstream reference: `/Users/qaq/Documents/GitHub/super-tart-vphone/CFW/patch_fw.py`

Test kernel: `vm/iPhone17,3_26.1_23B85_Restore/kernelcache.release.vphone600` (IM4P-wrapped, bvx2 compressed)

Key facts about the kernel:
- **0 symbols resolved** (fully stripped)
- `base_va = 0xFFFFFE0007004000` (typical PCC)
- `kern_text = 0xA74000 - 0x24B0000`
- All offsets in `kernel.py` helpers are **file offsets** (not VA)
- `bl_callers` dict: keyed by file offset → list of caller file offsets

---

## Patch 1: `patch_nvram_verify_permission` — FAILING

### Upstream Reference

```python
# patch __ZL16verifyPermission16IONVRAMOperationPKhPKcb
patch(0x1234034, 0xd503201f)  # NOP
```

One single NOP at file offset `0x1234034`. The BL being NOPed calls memmove (3114 callers).

### Function Analysis

**Function start**: `0x1233E40` (PACIBSP)
**Function end**: `0x1234094` (next PACIBSP)
**Size**: `0x254` bytes
**BL callers**: 0 (IOKit virtual method, dispatched via vtable)
**Instruction**: `retab` at end

#### Full BL targets in the function:

| Offset | Delta | Target | Callers | Likely Identity |
|--------|-------|--------|---------|-----------------|
| 0x1233F0C | +0x0CC | 0x0AD10DC | 6190 | lck_rw_done / lock_release |
| 0x1234034 | +0x1F4 | 0x12CB0D0 | 3114 | **memmove** ← PATCH THIS |
| 0x1234048 | +0x208 | 0x0ACB418 | 423 | OSObject::release |
| 0x1234070 | +0x230 | 0x0AD029C | 4921 | lck_rw_lock_exclusive |
| 0x123407C | +0x23C | 0x0AD10DC | 6190 | lck_rw_done |
| 0x123408C | +0x24C | 0x0AD10DC | 6190 | lck_rw_done |

#### Key instructions in the function:

- `CASA` at +0x54 (offset 0x1233E94) — atomic compare-and-swap for lock acquisition
- `CASL` at 3 locations — lock release
- 4x `BLRAA` — authenticated indirect calls through vtable pointers
- `movk x17, #0xcda1, lsl #48` — PAC discriminator for IONVRAMController class
- `RETAB` — PAC return
- `mov x8, #-1; str x8, [x19]` — cleanup pattern near end
- `ubfiz x2, x8, #3, #0x20` before BL memmove — size = count * 8

#### "Remove from array" pattern (at patch site):

```
0x1233FD8: adrp x8, #0x272f000
0x1233FDC: ldr x8, [x8, #0x10]      ; load observer list struct
0x1233FE0: cbz x8, skip             ; if null, skip
0x1233FE4: ldr w11, [x8, #0x10]     ; load count
0x1233FE8: cbz w11, skip            ; if 0, skip
0x1233FEC: mov x10, #0              ; index = 0
0x1233FF0: ldr x9, [x8, #0x18]     ; load array base
  loop:
0x1233FF4: add x12, x9, x10, lsl #3
0x1233FF8: ldr x12, [x12]          ; array[index]
0x1233FFC: cmp x12, x19            ; compare with self
0x1234000: b.eq found
0x1234004: add x10, x10, #1        ; index++
0x1234008: cmp x11, x10
0x123400C: b.ne loop
  found:
0x1234014: sub w11, w11, #1        ; count--
0x1234018: str w11, [x8, #0x10]    ; store
0x123401C: subs w8, w11, w10       ; remaining
0x1234020: b.ls skip
0x1234024: ubfiz x2, x8, #3, #0x20 ; size = remaining * 8
0x1234028: add x0, x9, w10, uxtw #3
0x123402C: add w8, w10, #1
0x1234030: add x1, x9, w8, uxtw #3
0x1234034: bl memmove              ; ← NOP THIS
```

### What I've Tried (and Failed)

1. **"krn." string anchor** → Leads to function at `0x11F7EE8`, NOT `0x1233E40`. Wrong function entirely.

2. **"nvram-write-access" entitlement string** → Also leads to a different function.

3. **CASA + 0 callers + retab + ubfiz + memmove filter** → **332 matches**. All IOKit virtual methods follow the same "remove observer from array" pattern with CASA locking.

4. **IONVRAMController metaclass string** → Found at `0xA2FEB`. Has ADRP+ADD refs at `0x125D2C0`, `0x125D310`, `0x125D38C` (metaclass constructors). These set up the metaclass, NOT instance methods.

5. **Chained fixup pointer search for IONVRAMController string** → Failed (different encoding).

### Findings That DO Work

**IONVRAMController vtable found via chained fixup search:**

The verifyPermission function at `0x1233E40` is referenced as a chained fixup pointer in `__DATA_CONST`:

```
__DATA_CONST @ 0x7410B8: raw=0x8011377101233E40 → decoded=0x1233E40 (verifyPermission)
```

**Vtable layout at 0x7410B8:**

| Vtable Idx | File Offset | Content | First Insn |
|------------|-------------|---------|------------|
| [-3] 0x7410A0 | | NULL | |
| [-2] 0x7410A8 | | NULL | |
| [-1] 0x7410B0 | | NULL | |
| [0] 0x7410B8 | 0x1233E40 | **verifyPermission** | pacibsp |
| [1] 0x7410C0 | 0x1233BF0 | sister method | pacibsp |
| [2] 0x7410C8 | 0x10EA4E0 | | ret |
| [3] 0x7410D0 | 0x10EA4D8 | | mov |

**IONVRAMController metaclass constructor pattern:**

```
0x125D2C0: pacibsp
  adrp x0, #0x26fe000
  add x0, x0, #0xa38        ; x0 = metaclass obj @ 0x26FEA38
  adrp x1, #0xa2000
  add x1, x1, #0xfeb        ; x1 = "IONVRAMController" @ 0xA2FEB
  adrp x2, #0x26fe000
  add x2, x2, #0xbf0        ; x2 = superclass metaclass @ 0x26FEBF0
  mov w3, #0x88              ; w3 = instance size = 136
  bl OSMetaClass::OSMetaClass()  ; [5236 callers]
  adrp x16, #0x76d000
  add x16, x16, #0xd60
  add x16, x16, #0x10       ; x16 = metaclass vtable @ 0x76DD70
  movk x17, #0xcda1, lsl #48  ; PAC discriminator
  pacda x16, x17
  str x16, [x0]             ; store PAC'd metaclass vtable
  retab
```

**There's ALSO a combined class registration function at 0x12376D8** that registers multiple classes and references the instance vtable:

```
0x12377F8: adrp x16, #0x741000
  add x16, x16, #0x0a8       ; → 0x7410A8 (vtable[-2])
```

Wait — it actually points to `0x7410A8`, not `0x7410B8`. The vtable pointer with the +0x10 adjustment gives `0x7410A8 + 0x10 = 0x7410B8` which is entry [0]. This is how IOKit vtables work: the isa pointer stores `vtable_base + 0x10` to skip the RTTI header.

### Proposed Dynamic Strategy

**Chain**: "IONVRAMController" string → ADRP+ADD refs → metaclass constructor → extract instance size `0x88` → find the combined class registration function (0x12376D8) that calls OSMetaClass::OSMetaClass() with `mov w3, #0x88` AND uses "IONVRAMController" name → extract the vtable base from the ADRP+ADD+ADD that follows → vtable[0] = verifyPermission → find BL to memmove-like target (>2000 callers) and NOP it.

**Alternative (simpler)**: From the metaclass constructor, extract the PAC discriminator `#0xcda1` and the instance size `#0x88`. Then search __DATA_CONST for chained fixup pointer entries where:
- The preceding 3 entries (at -8, -16, -24) are NULL (vtable header)
- The decoded function pointer has 0 BL callers
- The function contains CASA
- The function ends with RETAB
- The function contains a BL to memmove (>2000 callers)
- **The function contains `movk x17, #0xcda1`** (the IONVRAMController PAC discriminator)

This last filter is the KEY discriminator. Among the 332 candidate functions, only IONVRAMController methods use PAC disc `0xcda1`. Combined with "first entry in vtable" (preceded by 3 nulls), this should be unique.

**Simplest approach**: Search all chained fixup pointers in __DATA_CONST where:
1. Preceded by 3 null entries (vtable start)
2. Decoded target is a function in kern_text
3. Function contains `movk x17, #0xcda1, lsl #48`
4. Function contains BL to target with >2000 callers (memmove)
5. NOP that BL

---

## Patch 2: `patch_thid_should_crash` — FAILING

### Upstream Reference

```python
# patch _thid_should_crash to 0
patch(0x67EB50, 0x0)
```

Writes 4 bytes of zero at file offset `0x67EB50`.

### Analysis

- Offset `0x67EB50` is in a **DATA segment** (not code)
- The current value at this offset is **already 0x00000000** in the test kernel
- This is a sysctl boolean variable (`kern.thid_should_crash`)
- The patch is effectively a **no-op** on this kernel

### What I've Tried

1. **Symbol resolution** → 0 symbols, fails.
2. **"thid_should_crash" string** → Found, but has **no ADRP+ADD code references**. The string is in `__PRELINK_INFO` (XML plist), not in a standalone `__cstring` section.
3. **Sysctl structure search** → Searched for a raw VA pointer to the string in DATA segments. Failed because the string VA is in the plist text, not a standalone pointer.
4. **Pattern search for value=1** → The value is already 0 at the upstream offset, so searching for value=1 finds nothing.

### Proposed Dynamic Strategy

The variable at `0x67EB50` is in the kernel's `__DATA` segment (BSS or initialized data). Since:
- The string is only in `__PRELINK_INFO` (plist), not usable as a code anchor
- The variable has no symbols
- The value is already 0

**Option A: Skip this patch gracefully.** If the value is already 0, the patch has no effect. Log a message and return True (success, nothing to do).

**Option B: Find via sysctl table structure.** The sysctl_oid structure in __DATA contains:
- A pointer to the name string
- A pointer to the data variable
- Various flags

But the name string pointer would be a chained fixup pointer to the string in __PRELINK_INFO, which is hard to search for.

**Option C: Find via `__PRELINK_INFO` plist parsing.** Parse the XML plist to find the `_PrelinkKCID` or sysctl registration info. This is complex and fragile.

**Recommended: Option A** — the variable is already 0 in PCC kernels. Emit a write-zero anyway at the upstream-equivalent location if we can find it, or just return True if we can't find the variable (safe no-op).

Actually, better approach: search `__DATA` segments for a `sysctl_oid` struct. The struct layout includes:
```c
struct sysctl_oid {
    struct sysctl_oid_list *oid_parent;  // +0x00
    SLIST_ENTRY(sysctl_oid) oid_link;   // +0x08
    int oid_number;                      // +0x10
    int oid_kind;                        // +0x14
    void *oid_arg1;                      // +0x18 → points to the variable
    int oid_arg2;                        // +0x20
    const char *oid_name;               // +0x28 → points to "thid_should_crash" string
    ...
};
```

So search all `__DATA` segments for an 8-byte value at offset +0x28 that decodes to the "thid_should_crash" string offset. Then read +0x18 to get the variable pointer.

But the string is in __PRELINK_INFO, which complicates decoding the chained fixup pointer.

---

## Patch 3: `patch_hook_cred_label_update_execve` — FAILING

### Upstream Reference

```python
# Shellcode at 0xAB17D8 (46 instructions, ~184 bytes)
# Two critical BL targets:
#   BL _vfs_context_current at idx 9:  0x940851AC → target = 0xCC5EAC
#   BL _vnode_getattr at idx 17:       0x94085E69 → target = 0xCC91C0
# Ops table patch at 0xA54518: redirect to shellcode
# B _hook_cred_label_update_execve at idx 44: 0x146420B7 → target = 0x239A0B4
```

### Why It Fails

The patch needs two kernel functions that have **no symbols**:
- `_vfs_context_current` at file offset `0xCC5EAC`
- `_vnode_getattr` at file offset `0xCC91C0`

Without these, the shellcode can't be assembled (the BL offsets depend on the target addresses).

### Analysis of _vfs_context_current (0xCC5EAC)

```
Expected: A very short function (2-4 instructions) that:
  - Reads the current thread (mrs xN, TPIDR_EL1 or load from per-CPU data)
  - Loads the VFS context from the thread struct
  - Returns it in x0

Should have extremely high caller count (VFS is used everywhere).
```

Let me verify: check `bl_callers.get(0xCC5EAC, [])` — should have many callers.

### Analysis of _vnode_getattr (0xCC91C0)

```
Expected: A moderate-sized function that:
  - Takes (vnode, vnode_attr, vfs_context) parameters
  - Calls the vnode op (VNOP_GETATTR)
  - Returns error code

Should have moderate caller count (hundreds).
```

### Finding Strategy for _vfs_context_current

1. **From sandbox ops table**: We already have `_find_sandbox_ops_table_via_conf()`. The hook_cred_label_update_execve entry (index 16) in the ops table points to the original sandbox hook function (at `0x239A0B4` per upstream).

2. **From the original hook function**: Disassemble the original hook function. It likely calls `_vfs_context_current` (to get the VFS context for vnode operations). Find the BL target in the hook that has a very high caller count — that's likely `_vfs_context_current`.

3. **Pattern match**: Search kern_text for short functions (size < 0x20) with:
   - `mrs xN, TPIDR_EL1` instruction
   - Very high caller count (>1000)
   - Return type is pointer (loads from struct offset)

### Finding Strategy for _vnode_getattr

1. **From the original hook function**: The hook function likely also calls `_vnode_getattr`. Find BL targets in the hook that have moderate caller count.

2. **String anchor**: Search for `"vnode_getattr"` string (not in plist but in `__cstring`). Find ADRP+ADD refs, trace to function.

3. **Pattern match**: The function signature includes a `vnode_attr` structure initialization with size `0x380`.

### Proposed Implementation

```
1. Find sandbox ops table → read entry at index 16 → get original hook func
2. Disassemble original hook function
3. Find _vfs_context_current: BL target in the hook with highest caller count (>1000)
4. Find _vnode_getattr: BL target that:
   - Has moderate callers (50-1000)
   - The calling site has nearby `mov wN, #0x380` (vnode_attr struct size)
5. With both functions found, build shellcode and patch ops table
```

---

## Patch Status Summary

| Patch | Status | Blocker | Strategy |
|-------|--------|---------|----------|
| nvram_verify_permission | FAILING | Can't distinguish among 332 identical IOKit methods | Use PAC disc `#0xcda1` + vtable header (3 nulls) to find unique IONVRAMController vtable entry |
| thid_should_crash | FAILING | String in __PRELINK_INFO, no code refs, value already 0 | Option A: return True (safe no-op); Option B: sysctl_oid struct search |
| hook_cred_label_update_execve | FAILING | Can't find vfs_context_current and vnode_getattr without symbols | Find via sandbox ops table → original hook → BL targets by caller count |

---

## Previously Fixed Patches (This Session)

### patch_task_for_pid — FIXED

**Problem**: Old code searched for "proc_ro_ref_task" string → wrong function.
**Solution**: Pattern search: 0 BL callers + 2x ldadda + 2x `ldr wN,[xN,#0x490]; str wN,[xN,#0xc]` + movk #0xc8a2 + non-panic BL >500 callers. NOP the second `ldr wN,[xN,#0x490]`.
**Upstream**: `patch(0xFC383C, 0xd503201f)` — NOP in function at `0xFC3718`.

### patch_load_dylinker — FIXED

**Problem**: Old code searched for "/usr/lib/dyld" → wrong function (0 BL callers, no string ref).
**Solution**: Search for functions with 3+ `TST xN, #-0x40000000000000; B.EQ; MOVK xN, #0xc8a2` triplets and 0 BL callers. Replace LAST TST with unconditional B to B.EQ target.
**Upstream**: `patch(0x1052A28, B #0x44)` — in function at `0x105239C`.

### patch_syscallmask_apply_to_proc — FIXED

**Problem**: `bl_callers` key bug: code used `target + self.base_va` but bl_callers is keyed by file offset.
**Fix**: Changed to `self.bl_callers.get(target, [])` at line ~1661.
**Status**: Now PASSING (40 patches emitted for shellcode + redirect).

---

## Environment Notes

### Running on macOS (current)

```bash
cd /Users/qaq/Documents/GitHub/vphone-cli
source .venv/bin/activate
python3 -c "
import sys; sys.path.insert(0, 'scripts')
from fw_patch import load_firmware
from patchers.kernel_jb import KernelJBPatcher
_, data, _, _ = load_firmware('vm/iPhone17,3_26.1_23B85_Restore/kernelcache.release.vphone600')
p = KernelJBPatcher(data)
patches = p.find_all()
print(f'Total patches: {len(patches)}')
"
```

### Running on Linux (cloud)

Requirements:
- Python 3.10+
- `pip install capstone keystone-engine pyimg4`
- Note: `keystone-engine` may need `cmake` and C++ compiler on Linux
- Copy the kernelcache file and upstream reference
- The `setup_venv.sh` script has macOS-specific keystone dylib handling — on Linux, pip install should work directly

Files needed:
- `scripts/patchers/kernel.py` (base class)
- `scripts/patchers/kernel_jb.py` (JB patcher)
- `scripts/patchers/__init__.py`
- `scripts/fw_patch.py` (for `load_firmware()`)
- `vm/iPhone17,3_26.1_23B85_Restore/kernelcache.release.vphone600` (test kernel)
- `/Users/qaq/Documents/GitHub/super-tart-vphone/CFW/patch_fw.py` (upstream reference)

### Quick Test Script

```python
#!/usr/bin/env python3
"""Quick test for failing patches."""
import sys
sys.path.insert(0, 'scripts')
from fw_patch import load_firmware
from patchers.kernel_jb import KernelJBPatcher

_, data, _, _ = load_firmware('vm/iPhone17,3_26.1_23B85_Restore/kernelcache.release.vphone600')
p = KernelJBPatcher(data, verbose=True)

failing = ['patch_nvram_verify_permission', 'patch_thid_should_crash',
           'patch_hook_cred_label_update_execve']
for name in failing:
    p.patches = []
    result = getattr(p, name)()
    status = "PASS" if result else "FAIL"
    print(f'\n>>> {name}: {status} ({len(p.patches)} patches)')
```

---

## Upstream Offsets Reference (iPhone17,3 26.1 23B85)

| Symbol / Patch | File Offset | Notes |
|----------------|-------------|-------|
| kern_text start | 0xA74000 | |
| kern_text end | 0x24B0000 | |
| base_va | 0xFFFFFE0007004000 | |
| _thid_should_crash var | 0x67EB50 | DATA, value=0 |
| _task_for_pid func | 0xFC3718 | patch at 0xFC383C |
| _load_dylinker patch | 0x1052A28 | TST → B |
| verifyPermission func | 0x1233E40 | patch BL at 0x1234034 |
| verifyPermission vtable | 0x7410B8 | __DATA_CONST |
| IONVRAMController metaclass | 0x26FEA38 | |
| IONVRAMController metaclass ctor | 0x125D2C0 | refs "IONVRAMController" string |
| IONVRAMController PAC disc | 0xcda1 | movk x17, #0xcda1 |
| IONVRAMController instance size | 0x88 | mov w3, #0x88 |
| _vfs_context_current | 0xCC5EAC | (from upstream BL encoding) |
| _vnode_getattr | 0xCC91C0 | (from upstream BL encoding) |
| shellcode cave (upstream) | 0xAB1740 | syscallmask |
| shellcode cave 2 (upstream) | 0xAB17D8 | hook_cred_label |
| sandbox ops table (hook entry) | 0xA54518 | index 16 |
| _hook_cred_label_update_execve | 0x239A0B4 | original hook func |
| memmove | 0x12CB0D0 | 3114 callers |
| OSMetaClass::OSMetaClass() | 0x10EA790 | 5236 callers |
| _panic | varies | 8000+ callers typically |

```

`researchs/keyboard_event_pipeline.md`:

```md
# Virtualization.framework Keyboard Event Pipeline

Reverse engineering findings for the keyboard event pipeline in Apple's
Virtualization.framework (macOS 26.2, version 259.3.3.0.0). Documents how
keyboard events flow from the macOS host to the virtual iPhone guest.

---

## Event Flow Architecture

There are two pipelines for sending keyboard events to the VM:

### Pipeline 1: _VZKeyEvent -> sendKeyEvents: (Standard Keys)

```
_VZKeyEvent(type, keyCode)
  -> _VZKeyboard.sendKeyEvents:(NSArray<_VZKeyEvent>)
    -> table lookup: keyCode -> intermediate index
    -> pack: uint64_t = (index << 32) | is_key_down
    -> std::vector<uint64_t>
    -> [if type==2] sendKeyboardEventsHIDReport:keyboardID: (switch -> IOHIDEvent -> HID reports)
    -> [fallback]   eventSender.sendKeyboardEvents:keyboardID: (VzCore C++ layer)
```

### Pipeline 2: _processHIDReports (Raw HID Reports)

```
Raw HID report bytes
  -> std::span<const unsigned char>{data_ptr, length}
  -> std::vector<std::span<...>>{begin, end, cap}
  -> VZVirtualMachine._processHIDReports:forDevice:deviceType:
    -> XpcEncoder::encode_data(span) -> xpc_data_create
    -> XPC to VMM process
```

---

## _VZKeyEvent Structure

From IDA + LLDB inspection:

```c
struct _VZKeyEvent {  // sizeof = 0x18
    uint8_t  isa[8];      // offset 0x00 -- ObjC isa pointer
    uint16_t _keyCode;    // offset 0x08 -- Apple VK code (0x00-0xB2)
    uint8_t  _pad[6];     // offset 0x0A -- padding
    int64_t  _type;       // offset 0x10 -- 0 = keyDown, 1 = keyUp
};
```

Initializer: `_VZKeyEvent(type: Int64, keyCode: UInt16)`

---

## _VZKeyboard Object Layout

From LLDB memory dump:

```
+0x00: isa
+0x08: _eventSender (weak, id<_VZHIDAdditions, _VZKeyboardEventSender>)
+0x10: _deviceIdentifier (uint32_t) -- value 1 for first keyboard
+0x18: type (int64_t) -- 0 for USB keyboard, 2 for type that tries HIDReport first
```

---

## Lookup Tables in sendKeyEvents:

Two tables indexed by Apple VK keyCode (0x00-0xB2, 179 entries x 8 bytes each):

**Table 1** (validity flags): All valid entries = `0x0000000100000000` (bit 32 set).
Invalid entries = 0.

**Table 2** (intermediate indices): Maps Apple VK codes to internal indices (0x00-0x72).

The tables are OR'd: `combined = table1[vk] | table2[vk]`. Bit 32 check validates
the entry. The lower 32 bits of combined become the intermediate index.

### Sample Table 2 Entries

| Apple VK | Key     | Table2 (Index) | HID Page | HID Usage |
|----------|---------|----------------|----------|-----------|
| 0x00     | A       | 0x00           | 7        | 0x04      |
| 0x01     | S       | 0x12           | 7        | 0x16      |
| 0x24     | Return  | 0x24           | 7        | 0x28      |
| 0x31     | Space   | 0x29           | 7        | 0x2C      |
| 0x35     | Escape  | 0x25           | 7        | 0x29      |
| 0x38     | Shift   | 0x51           | 7        | 0xE1      |
| 0x37     | Command | 0x53           | 7        | 0xE3      |

### Invalid VK Codes (both tables = 0, silently dropped)

0x48 (Volume Up), 0x49 (Volume Down), 0x4A (Mute), and many others.

---

## Packed Event Format (std::vector<uint64_t>)

Each element in the vector sent to `sendKeyboardEvents:keyboardID:`:

```
bits 63:32 = intermediate_index (from table2, lower 32 bits of combined)
bits 31:1  = 0
bit  0     = is_key_down (1 = down, 0 = up)
```

---

## sendKeyboardEventsHIDReport Switch Statement

For type-2 keyboards, the intermediate index is mapped to
`IOHIDEventCreateKeyboardEvent(page, usage)` via a large switch.

### Standard Keyboard Entries (HID Page 7)

| Index     | HID Page | HID Usage | Meaning          |
|-----------|----------|-----------|------------------|
| 0x00-0x19 | 7        | 4-29      | Letters a-z      |
| 0x1A-0x23 | 7        | 30-39     | Digits 1-0       |
| 0x24      | 7        | 40        | Return           |
| 0x25      | 7        | 41        | Escape           |
| 0x29      | 7        | 44        | Space            |
| 0x48-0x4B | 7        | 79-82     | Arrow keys       |
| 0x50-0x53 | 7        | 224-227   | L-Ctrl/Shift/Alt/Cmd |

### Consumer / System Entries (Non-Standard Pages)

| Index | HID Page | HID Usage | Meaning                   |
|-------|----------|-----------|---------------------------|
| 0x6E  | **12**   | 671       | **Consumer Volume Down**  |
| 0x6F  | **12**   | 674       | **Consumer Volume Up**    |
| 0x70  | **12**   | 207       | **Consumer Play/Pause**   |
| 0x71  | **12**   | 545       | **Consumer Snapshot**     |
| 0x72  | **1**    | 155       | **Generic Desktop Wake**  |

**Home/Menu (Consumer page 0x0C, usage 0x40) has NO intermediate index.** It cannot
be sent through Pipeline 1 at all.

---

## _processHIDReports Parameter Format

From IDA decompilation of
`VZVirtualMachine._processHIDReports:forDevice:deviceType:` at 0x2301b2310.

The `void *` parameter is a **pointer to std::vector<std::span<const unsigned char>>**:

```
Level 3 (outermost): std::vector (24 bytes, passed by pointer)
  +0x00: __begin_    (pointer to span array)
  +0x08: __end_      (pointer past last span)
  +0x10: __end_cap_  (capacity pointer)

Level 2: std::span (16 bytes per element in the array)
  +0x00: data_ptr    (const unsigned char *)
  +0x08: length      (size_t)

Level 1 (innermost): raw HID report bytes
```

The function iterates spans in the vector:

```c
begin = *vec;           // vec->__begin_
end   = *(vec + 1);     // vec->__end_
for (span = begin; span != end; span += 16) {
    data_ptr = *(uint64_t*)span;
    length   = *(uint64_t*)(span + 8);
    encoder.encode_data(data_ptr, length);  // -> xpc_data_create
}
```

**deviceType**: 0 = keyboard, 1 = pointing device

**device**: device identifier (uint32_t, matches `_VZKeyboard._deviceIdentifier`)

---

## Crash Analysis: Why Raw Bytes Crashed

Passing raw `[0x40, 0x00]` as the `void*` parameter:

1. Function reads bytes as vector struct: begin = 0x0040 (first 8 bytes), end = garbage
2. Dereferences begin as span pointer -> reads from address ~0x0040
3. Gets garbage data_ptr (0x700420e) and garbage length (0x300000020 = 12GB)
4. `xpc_data_create(0x700420e, 0x300000020)` -> EXC_BAD_ACCESS in memcpy

The three-level indirection (vector -> span -> bytes) must be constructed correctly
or the framework will dereference invalid pointers.

---

## Swift Implementation Notes

### Accessing _VZKeyboard

```swift
// Get keyboards array
let arr = Dynamic(vm)._keyboards.asObject as? NSArray
let keyboard = arr?.object(at: 0) as AnyObject

// _deviceIdentifier is an ivar, not a property -- use KVC
(keyboard as? NSObject)?.value(forKey: "_deviceIdentifier") as? UInt32
```

### Constructing std::vector<uint64_t> for sendKeyboardEvents

```swift
let data = UnsafeMutablePointer<UInt64>.allocate(capacity: 1)
data.pointee = (index << 32) | (isKeyDown ? 1 : 0)
var vec = (data, data.advanced(by: 1), data.advanced(by: 1))
withUnsafeMutablePointer(to: &vec) { vecPtr in
    Dynamic(vm).sendKeyboardEvents(UnsafeMutableRawPointer(vecPtr), keyboardID: deviceId)
}
```

### Constructing vector<span<unsigned char>> for _processHIDReports

```swift
let reportPtr = UnsafeMutablePointer<UInt8>.allocate(capacity: N)
// fill report bytes...

let spanPtr = UnsafeMutablePointer<Int>.allocate(capacity: 2)
spanPtr[0] = Int(bitPattern: reportPtr)  // data pointer
spanPtr[1] = N                           // length

let vecPtr = UnsafeMutablePointer<Int>.allocate(capacity: 3)
vecPtr[0] = Int(bitPattern: UnsafeRawPointer(spanPtr))                   // begin
vecPtr[1] = Int(bitPattern: UnsafeRawPointer(spanPtr).advanced(by: 16))  // end
vecPtr[2] = vecPtr[1]                                                    // cap

Dynamic(vm)._processHIDReports(UnsafeRawPointer(vecPtr), forDevice: deviceId, deviceType: 0)
```

---

## Source Files

- Class dumps: `/Users/qaq/Documents/GitHub/super-tart-vphone-private/Virtualization_26.2-class-dump/`
- IDA database: dyld_shared_cache_arm64e with Virtualization.framework

### Key Functions Analyzed

| Function | Address |
|----------|---------|
| `-[_VZKeyboard sendKeyEvents:]` | 0x2301b2f54 |
| `-[_VZKeyboard sendKeyboardEventsHIDReport:keyboardID:]` | 0x2301b3230 |
| `-[VZVirtualMachine(_VZHIDAdditions) _processHIDReports:forDevice:deviceType:]` | 0x2301b2310 |
| `-[VZVirtualMachineView _sendKeyEventsToVirtualMachine:]` | -- |
| `-[_VZHIDEventMonitor getHIDReportsFromHIDEvent:]` | 0x2301b2af0 |

```

`scripts/cfw_install.sh`:

```sh
#!/bin/zsh
# cfw_install.sh — Install base CFW modifications on vphone via SSH ramdisk.
#
# Installs Cryptexes, patches system binaries, installs jailbreak tools
# and configures LaunchDaemons for persistent SSH/VNC access.
#
# Safe to run multiple times — always patches from original .bak files,
# keeps decrypted Cryptex DMGs cached, handles already-mounted filesystems.
#
# Prerequisites:
#   - Device booted into SSH ramdisk (make ramdisk_send)
#   - `ipsw` tool installed (brew install blacktop/tap/ipsw)
#   - `aea` tool available (macOS 12+)
#   - Python: make setup_venv && source .venv/bin/activate
#   - cfw_input/ or resources/cfw_input.tar.zst present
#
# Usage: make cfw_install
set -euo pipefail

VM_DIR="${1:-.}"
SCRIPT_DIR="${0:a:h}"
CFW_SKIP_HALT="${CFW_SKIP_HALT:-0}"

# Resolve absolute paths
VM_DIR="$(cd "$VM_DIR" && pwd)"

# ── Configuration ───────────────────────────────────────────────
CFW_INPUT="cfw_input"
CFW_ARCHIVE="cfw_input.tar.zst"
TEMP_DIR="$VM_DIR/.cfw_temp"

SSH_PORT=2222
SSH_PASS="alpine"
SSH_USER="root"
SSH_HOST="localhost"
SSH_OPTS=(
    -o StrictHostKeyChecking=no
    -o UserKnownHostsFile=/dev/null
    -o PreferredAuthentications=password
    -o ConnectTimeout=30
    -q
)

# ── Helpers ─────────────────────────────────────────────────────
die() { echo "[-] $*" >&2; exit 1; }

_sshpass() {
    "$VM_DIR/$CFW_INPUT/tools/sshpass" -p "$SSH_PASS" "$@"
}

ssh_cmd() {
    _sshpass ssh "${SSH_OPTS[@]}" -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "$@"
}

scp_to() {
    _sshpass scp -q "${SSH_OPTS[@]}" -P "$SSH_PORT" -r "$1" "$SSH_USER@$SSH_HOST:$2"
}

scp_from() {
    _sshpass scp -q "${SSH_OPTS[@]}" -P "$SSH_PORT" "$SSH_USER@$SSH_HOST:$1" "$2"
}

remote_file_exists() {
    ssh_cmd "test -f '$1'" 2>/dev/null
}

ldid_sign() {
    local file="$1" bundle_id="${2:-}"
    local args=(-S -M "-K$VM_DIR/$CFW_INPUT/signcert.p12")
    [[ -n "$bundle_id" ]] && args+=("-I$bundle_id")
    "$VM_DIR/$CFW_INPUT/tools/ldid_macosx_arm64" "${args[@]}" "$file"
}

# Detach a DMG mountpoint if currently mounted, ignore errors
safe_detach() {
    local mnt="$1"
    if mount | grep -q "$mnt"; then
        sudo hdiutil detach -force "$mnt" 2>/dev/null || true
    fi
}

# Mount device filesystem, tolerate already-mounted
remote_mount() {
    local dev="$1" mnt="$2" opts="${3:-rw}"
    ssh_cmd "/sbin/mount_apfs -o $opts $dev $mnt 2>/dev/null || true"
}

# ── Find restore directory ─────────────────────────────────────
find_restore_dir() {
    for dir in "$VM_DIR"/iPhone*_Restore; do
        [[ -f "$dir/BuildManifest.plist" ]] && echo "$dir" && return
    done
    die "No restore directory found in $VM_DIR"
}

# ── Setup input resources ──────────────────────────────────────
setup_cfw_input() {
    [[ -d "$VM_DIR/$CFW_INPUT" ]] && return
    local archive
    for search_dir in "$SCRIPT_DIR/resources" "$SCRIPT_DIR" "$VM_DIR"; do
        archive="$search_dir/$CFW_ARCHIVE"
        if [[ -f "$archive" ]]; then
            echo "  Extracting $CFW_ARCHIVE..."
            tar --zstd -xf "$archive" -C "$VM_DIR"
            return
        fi
    done
    die "Neither $CFW_INPUT/ nor $CFW_ARCHIVE found"
}

# ── Check prerequisites ────────────────────────────────────────
check_prereqs() {
    command -v ipsw  >/dev/null 2>&1 || die "'ipsw' not found. Install: brew install blacktop/tap/ipsw"
    command -v aea   >/dev/null 2>&1 || die "'aea' not found (requires macOS 12+)"
    command -v python3 >/dev/null 2>&1 || die "python3 not found"
    python3 -c "import capstone, keystone" 2>/dev/null \
        || die "Missing Python deps. Install: pip install capstone keystone-engine"
}

# ── Cleanup trap (unmount DMGs on error) ───────────────────────
cleanup_on_exit() {
    safe_detach "$TEMP_DIR/mnt_sysos"
    safe_detach "$TEMP_DIR/mnt_appos"
}
trap cleanup_on_exit EXIT

# ════════════════════════════════════════════════════════════════
# Main
# ════════════════════════════════════════════════════════════════
echo "[*] cfw_install.sh — Installing CFW on vphone..."

check_prereqs

RESTORE_DIR=$(find_restore_dir)
echo "[+] Restore directory: $RESTORE_DIR"

setup_cfw_input
INPUT_DIR="$VM_DIR/$CFW_INPUT"
echo "[+] Input resources: $INPUT_DIR"

mkdir -p "$TEMP_DIR"

# ── Parse Cryptex paths from BuildManifest ─────────────────────
echo ""
echo "[*] Parsing iPhone BuildManifest for Cryptex paths..."
CRYPTEX_PATHS=$(python3 "$SCRIPT_DIR/patchers/cfw.py" cryptex-paths "$RESTORE_DIR/BuildManifest-iPhone.plist")
CRYPTEX_SYSOS=$(echo "$CRYPTEX_PATHS" | head -1)
CRYPTEX_APPOS=$(echo "$CRYPTEX_PATHS" | tail -1)
echo "  SystemOS: $CRYPTEX_SYSOS"
echo "  AppOS:    $CRYPTEX_APPOS"

# ═══════════ 1/7 INSTALL CRYPTEX ══════════════════════════════
echo ""
echo "[1/7] Installing Cryptex (SystemOS + AppOS)..."

SYSOS_DMG="$TEMP_DIR/CryptexSystemOS.dmg"
APPOS_DMG="$TEMP_DIR/CryptexAppOS.dmg"
MNT_SYSOS="$TEMP_DIR/mnt_sysos"
MNT_APPOS="$TEMP_DIR/mnt_appos"

# Decrypt SystemOS AEA (cached — skip if already decrypted)
if [[ ! -f "$SYSOS_DMG" ]]; then
    echo "  Extracting AEA key..."
    AEA_KEY=$(ipsw fw aea --key "$RESTORE_DIR/$CRYPTEX_SYSOS")
    echo "  key: $AEA_KEY"
    echo "  Decrypting SystemOS..."
    aea decrypt -i "$RESTORE_DIR/$CRYPTEX_SYSOS" -o "$SYSOS_DMG" -key-value "$AEA_KEY"
else
    echo "  Using cached SystemOS DMG"
fi

# Copy AppOS (unencrypted, cached)
if [[ ! -f "$APPOS_DMG" ]]; then
    cp "$RESTORE_DIR/$CRYPTEX_APPOS" "$APPOS_DMG"
else
    echo "  Using cached AppOS DMG"
fi

# Detach any leftover mounts from previous runs
safe_detach "$MNT_SYSOS"
safe_detach "$MNT_APPOS"
mkdir -p "$MNT_SYSOS" "$MNT_APPOS"

echo "  Mounting SystemOS..."
sudo hdiutil attach -mountpoint "$MNT_SYSOS" "$SYSOS_DMG" -owners off
echo "  Mounting AppOS..."
sudo hdiutil attach -mountpoint "$MNT_APPOS" "$APPOS_DMG" -owners off

# Mount device rootfs (tolerate already-mounted)
echo "  Mounting device rootfs rw..."
remote_mount /dev/disk1s1 /mnt1

# Rename APFS update snapshot to orig-fs (idempotent)
echo "  Checking APFS snapshots..."
SNAP_LIST=$(ssh_cmd "snaputil -l /mnt1 2>/dev/null" || true)
if echo "$SNAP_LIST" | grep -q "^orig-fs$"; then
    echo "  Snapshot 'orig-fs' already exists, skipping rename"
else
    UPDATE_SNAP=$(echo "$SNAP_LIST" | grep "^com\.apple\.os\.update-" | head -1)
    if [[ -n "$UPDATE_SNAP" ]]; then
        echo "  Renaming snapshot: $UPDATE_SNAP -> orig-fs"
        ssh_cmd "snaputil -n '$UPDATE_SNAP' orig-fs /mnt1"
        # Verify rename succeeded
        if ! ssh_cmd "snaputil -l /mnt1 2>/dev/null" | grep -q "^orig-fs$"; then
            die "Failed to rename snapshot to orig-fs"
        fi
        echo "  Snapshot renamed, remounting..."
        ssh_cmd "/sbin/umount /mnt1"
        remote_mount /dev/disk1s1 /mnt1
        echo "  [+] Snapshot renamed to orig-fs"
    else
        echo "  No com.apple.os.update- snapshot found, skipping"
    fi
fi

ssh_cmd "/bin/rm -rf /mnt1/System/Cryptexes/App /mnt1/System/Cryptexes/OS"
ssh_cmd "/bin/mkdir -p /mnt1/System/Cryptexes/App /mnt1/System/Cryptexes/OS"
ssh_cmd "/bin/chmod 0755 /mnt1/System/Cryptexes/App /mnt1/System/Cryptexes/OS"

# Copy Cryptex files to device
echo "  Copying Cryptexes to device (this takes ~3 minutes)..."
scp_to "$MNT_SYSOS/." "/mnt1/System/Cryptexes/OS"
scp_to "$MNT_APPOS/." "/mnt1/System/Cryptexes/App"

# Create dyld symlinks (ln -sf is idempotent)
echo "  Creating dyld symlinks..."
ssh_cmd "/bin/ln -sf ../../../System/Cryptexes/OS/System/Library/Caches/com.apple.dyld \
    /mnt1/System/Library/Caches/com.apple.dyld"
ssh_cmd "/bin/ln -sf ../../../../System/Cryptexes/OS/System/DriverKit/System/Library/dyld \
    /mnt1/System/DriverKit/System/Library/dyld"

# Unmount Cryptex DMGs
echo "  Unmounting Cryptex DMGs..."
safe_detach "$MNT_SYSOS"
safe_detach "$MNT_APPOS"

echo "  [+] Cryptex installed"

# ═══════════ 2/7 PATCH SEPUTIL ════════════════════════════════
echo ""
echo "[2/7] Patching seputil..."

# Always patch from .bak (original unpatched binary)
if ! remote_file_exists "/mnt1/usr/libexec/seputil.bak"; then
    echo "  Creating backup..."
    ssh_cmd "/bin/cp /mnt1/usr/libexec/seputil /mnt1/usr/libexec/seputil.bak"
fi

scp_from "/mnt1/usr/libexec/seputil.bak" "$TEMP_DIR/seputil"
python3 "$SCRIPT_DIR/patchers/cfw.py" patch-seputil "$TEMP_DIR/seputil"
ldid_sign "$TEMP_DIR/seputil" "com.apple.seputil"
scp_to "$TEMP_DIR/seputil" "/mnt1/usr/libexec/seputil"
ssh_cmd "/bin/chmod 0755 /mnt1/usr/libexec/seputil"

# Rename gigalocker (mv to same name is fine on re-run)
echo "  Renaming gigalocker..."
remote_mount /dev/disk1s3 /mnt3
ssh_cmd '/bin/mv /mnt3/*.gl /mnt3/AA.gl 2>/dev/null || true'

echo "  [+] seputil patched"

# ═══════════ 3/7 INSTALL GPU DRIVER ══════════════════════════
echo ""
echo "[3/7] Installing AppleParavirtGPUMetalIOGPUFamily..."

scp_to "$INPUT_DIR/custom/AppleParavirtGPUMetalIOGPUFamily.tar" "/mnt1"
ssh_cmd "/usr/bin/tar --preserve-permissions --no-overwrite-dir \
    -xf /mnt1/AppleParavirtGPUMetalIOGPUFamily.tar -C /mnt1"

BUNDLE="/mnt1/System/Library/Extensions/AppleParavirtGPUMetalIOGPUFamily.bundle"
# Clean macOS resource fork files (._* files from tar xattrs)
ssh_cmd "find $BUNDLE -name '._*' -delete 2>/dev/null || true"
ssh_cmd "/usr/sbin/chown -R 0:0 $BUNDLE"
ssh_cmd "/bin/chmod 0755 $BUNDLE"
ssh_cmd "/bin/chmod 0755 $BUNDLE/libAppleParavirtCompilerPluginIOGPUFamily.dylib"
ssh_cmd "/bin/chmod 0755 $BUNDLE/AppleParavirtGPUMetalIOGPUFamily"
ssh_cmd "/bin/chmod 0755 $BUNDLE/_CodeSignature"
ssh_cmd "/bin/chmod 0644 $BUNDLE/_CodeSignature/CodeResources"
ssh_cmd "/bin/chmod 0644 $BUNDLE/Info.plist"
ssh_cmd "/bin/rm -f /mnt1/AppleParavirtGPUMetalIOGPUFamily.tar"

echo "  [+] GPU driver installed"

# ═══════════ 4/7 INSTALL IOSBINPACK64 ════════════════════════
echo ""
echo "[4/7] Installing iosbinpack64..."

scp_to "$INPUT_DIR/jb/iosbinpack64.tar" "/mnt1"
ssh_cmd "/usr/bin/tar --preserve-permissions --no-overwrite-dir \
    -xf /mnt1/iosbinpack64.tar -C /mnt1"
ssh_cmd "/bin/rm -f /mnt1/iosbinpack64.tar"

echo "  [+] iosbinpack64 installed"

# ═══════════ 5/7 PATCH LAUNCHD_CACHE_LOADER ══════════════════
echo ""
echo "[5/7] Patching launchd_cache_loader..."

# Always patch from .bak (original unpatched binary)
if ! remote_file_exists "/mnt1/usr/libexec/launchd_cache_loader.bak"; then
    echo "  Creating backup..."
    ssh_cmd "/bin/cp /mnt1/usr/libexec/launchd_cache_loader /mnt1/usr/libexec/launchd_cache_loader.bak"
fi

scp_from "/mnt1/usr/libexec/launchd_cache_loader.bak" "$TEMP_DIR/launchd_cache_loader"
python3 "$SCRIPT_DIR/patchers/cfw.py" patch-launchd-cache-loader "$TEMP_DIR/launchd_cache_loader"
ldid_sign "$TEMP_DIR/launchd_cache_loader" "com.apple.launchd_cache_loader"
scp_to "$TEMP_DIR/launchd_cache_loader" "/mnt1/usr/libexec/launchd_cache_loader"
ssh_cmd "/bin/chmod 0755 /mnt1/usr/libexec/launchd_cache_loader"

echo "  [+] launchd_cache_loader patched"

# ═══════════ 6/7 PATCH MOBILEACTIVATIOND ═════════════════════
echo ""
echo "[6/7] Patching mobileactivationd..."

# Always patch from .bak (original unpatched binary)
if ! remote_file_exists "/mnt1/usr/libexec/mobileactivationd.bak"; then
    echo "  Creating backup..."
    ssh_cmd "/bin/cp /mnt1/usr/libexec/mobileactivationd /mnt1/usr/libexec/mobileactivationd.bak"
fi

scp_from "/mnt1/usr/libexec/mobileactivationd.bak" "$TEMP_DIR/mobileactivationd"
python3 "$SCRIPT_DIR/patchers/cfw.py" patch-mobileactivationd "$TEMP_DIR/mobileactivationd"
ldid_sign "$TEMP_DIR/mobileactivationd"
scp_to "$TEMP_DIR/mobileactivationd" "/mnt1/usr/libexec/mobileactivationd"
ssh_cmd "/bin/chmod 0755 /mnt1/usr/libexec/mobileactivationd"

echo "  [+] mobileactivationd patched"

# ═══════════ 7/7 LAUNCHDAEMONS + LAUNCHD.PLIST ══════════════
echo ""
echo "[7/7] Installing LaunchDaemons..."

# Send daemon plists (overwrite on re-run)
for plist in bash.plist dropbear.plist trollvnc.plist; do
    scp_to "$INPUT_DIR/jb/LaunchDaemons/$plist" "/mnt1/System/Library/LaunchDaemons/"
    ssh_cmd "/bin/chmod 0644 /mnt1/System/Library/LaunchDaemons/$plist"
done

# Always patch launchd.plist from .bak (original)
echo "  Patching launchd.plist..."
if ! remote_file_exists "/mnt1/System/Library/xpc/launchd.plist.bak"; then
    echo "  Creating backup..."
    ssh_cmd "/bin/cp /mnt1/System/Library/xpc/launchd.plist /mnt1/System/Library/xpc/launchd.plist.bak"
fi

scp_from "/mnt1/System/Library/xpc/launchd.plist.bak" "$TEMP_DIR/launchd.plist"
python3 "$SCRIPT_DIR/patchers/cfw.py" inject-daemons "$TEMP_DIR/launchd.plist" "$INPUT_DIR/jb/LaunchDaemons"
scp_to "$TEMP_DIR/launchd.plist" "/mnt1/System/Library/xpc/launchd.plist"
ssh_cmd "/bin/chmod 0644 /mnt1/System/Library/xpc/launchd.plist"

echo "  [+] LaunchDaemons installed"

# ═══════════ CLEANUP ═════════════════════════════════════════
echo ""
echo "[*] Unmounting device filesystems..."
ssh_cmd "/sbin/umount /mnt1 2>/dev/null || true"
ssh_cmd "/sbin/umount /mnt3 2>/dev/null || true"

# Keep .cfw_temp/Cryptex*.dmg cached (slow to re-create)
# Only remove temp binaries
echo "[*] Cleaning up temp binaries..."
rm -f "$TEMP_DIR/seputil" \
      "$TEMP_DIR/launchd_cache_loader" \
      "$TEMP_DIR/mobileactivationd" \
      "$TEMP_DIR/launchd.plist"

echo ""
echo "[+] CFW installation complete!"
echo "    Reboot the device for changes to take effect."
echo "    After boot, SSH will be available on port 22222 (password: alpine)"

if [[ "$CFW_SKIP_HALT" == "1" ]]; then
    echo "[*] CFW_SKIP_HALT=1, skipping halt."
else
    ssh_cmd "/sbin/halt" || true
fi

```

`scripts/cfw_install_jb.sh`:

```sh
#!/bin/zsh
# cfw_install_jb.sh — Install base CFW + JB extensions on vphone via SSH ramdisk.
#
# Runs the base CFW installer first (phases 1-7), then applies JB-specific
# modifications: launchd jetsam patch, dylib injection, procursus bootstrap,
# and BaseBin hook deployment.
#
# Prerequisites (in addition to cfw_install.sh requirements):
#   - cfw_jb_input/ or resources/cfw_jb_input.tar.zst present
#   - zstd (for bootstrap decompression)
#
# Usage: make cfw_install_jb
set -euo pipefail

VM_DIR="${1:-.}"
SCRIPT_DIR="${0:a:h}"

# ════════════════════════════════════════════════════════════════
# Step 1: Run base CFW install (skip halt — we continue with JB phases)
# ════════════════════════════════════════════════════════════════
echo "[*] cfw_install_jb.sh — Installing CFW + JB extensions..."
echo ""
CFW_SKIP_HALT=1 zsh "$SCRIPT_DIR/cfw_install.sh" "$VM_DIR"

# ════════════════════════════════════════════════════════════════
# Step 2: JB-specific phases
# ════════════════════════════════════════════════════════════════

# Resolve absolute paths (same as base script)
VM_DIR="$(cd "${VM_DIR}" && pwd)"

# ── Configuration ───────────────────────────────────────────────
CFW_INPUT="cfw_input"
CFW_JB_INPUT="cfw_jb_input"
CFW_JB_ARCHIVE="cfw_jb_input.tar.zst"
TEMP_DIR="$VM_DIR/.cfw_temp"

SSH_PORT=2222
SSH_PASS="alpine"
SSH_USER="root"
SSH_HOST="localhost"
SSH_OPTS=(
    -o StrictHostKeyChecking=no
    -o UserKnownHostsFile=/dev/null
    -o PreferredAuthentications=password
    -o ConnectTimeout=30
    -q
)

# ── Helpers ─────────────────────────────────────────────────────
die() { echo "[-] $*" >&2; exit 1; }

_sshpass() {
    "$VM_DIR/$CFW_INPUT/tools/sshpass" -p "$SSH_PASS" "$@"
}

ssh_cmd() {
    _sshpass ssh "${SSH_OPTS[@]}" -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" "$@"
}

scp_to() {
    _sshpass scp -q "${SSH_OPTS[@]}" -P "$SSH_PORT" -r "$1" "$SSH_USER@$SSH_HOST:$2"
}

scp_from() {
    _sshpass scp -q "${SSH_OPTS[@]}" -P "$SSH_PORT" "$SSH_USER@$SSH_HOST:$1" "$2"
}

remote_file_exists() {
    ssh_cmd "test -f '$1'" 2>/dev/null
}

ldid_sign() {
    local file="$1" bundle_id="${2:-}"
    local args=(-S -M "-K$VM_DIR/$CFW_INPUT/signcert.p12")
    [[ -n "$bundle_id" ]] && args+=("-I$bundle_id")
    "$VM_DIR/$CFW_INPUT/tools/ldid_macosx_arm64" "${args[@]}" "$file"
}

remote_mount() {
    local dev="$1" mnt="$2" opts="${3:-rw}"
    ssh_cmd "/sbin/mount_apfs -o $opts $dev $mnt 2>/dev/null || true"
}

get_boot_manifest_hash() {
    ssh_cmd "/bin/ls /mnt5 2>/dev/null" | awk 'length($0)==96{print; exit}'
}

# ── Setup JB input resources ──────────────────────────────────
setup_cfw_jb_input() {
    [[ -d "$VM_DIR/$CFW_JB_INPUT" ]] && return
    local archive
    for search_dir in "$SCRIPT_DIR/resources" "$SCRIPT_DIR" "$VM_DIR"; do
        archive="$search_dir/$CFW_JB_ARCHIVE"
        if [[ -f "$archive" ]]; then
            echo "  Extracting $CFW_JB_ARCHIVE..."
            tar --zstd -xf "$archive" -C "$VM_DIR"
            return
        fi
    done
    die "JB mode: neither $CFW_JB_INPUT/ nor $CFW_JB_ARCHIVE found"
}

# ── Check JB prerequisites ────────────────────────────────────
command -v zstd >/dev/null 2>&1 || die "'zstd' not found (required for JB bootstrap phase)"

setup_cfw_jb_input
JB_INPUT_DIR="$VM_DIR/$CFW_JB_INPUT"
echo ""
echo "[+] JB input resources: $JB_INPUT_DIR"

mkdir -p "$TEMP_DIR"

# Mount device rootfs (may already be mounted from base install)
remote_mount /dev/disk1s1 /mnt1

# ═══════════ JB-1 PATCH LAUNCHD (JETSAM + DYLIB INJECTION) ════
echo ""
echo "[JB-1] Patching launchd (jetsam guard + hook injection)..."

if ! remote_file_exists "/mnt1/sbin/launchd.bak"; then
    echo "  Creating backup..."
    ssh_cmd "/bin/cp /mnt1/sbin/launchd /mnt1/sbin/launchd.bak"
fi

scp_from "/mnt1/sbin/launchd.bak" "$TEMP_DIR/launchd"

# Inject launchdhook.dylib load command (idempotent — skips if already present)
if [[ -d "$JB_INPUT_DIR/basebin" ]]; then
    echo "  Injecting LC_LOAD_DYLIB for /cores/launchdhook.dylib..."
    python3 "$SCRIPT_DIR/patchers/cfw.py" inject-dylib "$TEMP_DIR/launchd" "/cores/launchdhook.dylib"
fi

python3 "$SCRIPT_DIR/patchers/cfw.py" patch-launchd-jetsam "$TEMP_DIR/launchd"
ldid_sign "$TEMP_DIR/launchd"
scp_to "$TEMP_DIR/launchd" "/mnt1/sbin/launchd"
ssh_cmd "/bin/chmod 0755 /mnt1/sbin/launchd"

echo "  [+] launchd patched"

# ═══════════ JB-2 INSTALL PROCURSUS BOOTSTRAP ══════════════════
echo ""
echo "[JB-2] Installing procursus bootstrap..."

remote_mount /dev/disk1s5 /mnt5
BOOT_HASH="$(get_boot_manifest_hash)"
[[ -n "$BOOT_HASH" ]] || die "Could not find 96-char boot manifest hash in /mnt5"
echo "  Boot manifest hash: $BOOT_HASH"

BOOTSTRAP_ZST="$JB_INPUT_DIR/jb/bootstrap-iphoneos-arm64.tar.zst"
SILEO_DEB="$JB_INPUT_DIR/jb/org.coolstar.sileo_2.5.1_iphoneos-arm64.deb"
[[ -f "$BOOTSTRAP_ZST" ]] || die "Missing $BOOTSTRAP_ZST"

BOOTSTRAP_TAR="$TEMP_DIR/bootstrap-iphoneos-arm64.tar"
zstd -d -f "$BOOTSTRAP_ZST" -o "$BOOTSTRAP_TAR"

scp_to "$BOOTSTRAP_TAR" "/mnt5/$BOOT_HASH/bootstrap-iphoneos-arm64.tar"
if [[ -f "$SILEO_DEB" ]]; then
    scp_to "$SILEO_DEB" "/mnt5/$BOOT_HASH/org.coolstar.sileo_2.5.1_iphoneos-arm64.deb"
fi

ssh_cmd "/bin/mkdir -p /mnt5/$BOOT_HASH/jb-vphone"
ssh_cmd "/bin/chmod 0755 /mnt5/$BOOT_HASH/jb-vphone"
ssh_cmd "/usr/sbin/chown 0:0 /mnt5/$BOOT_HASH/jb-vphone"
ssh_cmd "/usr/bin/tar --preserve-permissions -xkf /mnt5/$BOOT_HASH/bootstrap-iphoneos-arm64.tar \
    -C /mnt5/$BOOT_HASH/jb-vphone/"
ssh_cmd "/bin/mv /mnt5/$BOOT_HASH/jb-vphone/var /mnt5/$BOOT_HASH/jb-vphone/procursus"
ssh_cmd "/bin/mkdir -p /mnt5/$BOOT_HASH/jb-vphone/procursus"
ssh_cmd "/bin/mv /mnt5/$BOOT_HASH/jb-vphone/procursus/jb/* /mnt5/$BOOT_HASH/jb-vphone/procursus 2>/dev/null || true"
ssh_cmd "/bin/rm -rf /mnt5/$BOOT_HASH/jb-vphone/procursus/jb"
ssh_cmd "/bin/rm -f /mnt5/$BOOT_HASH/bootstrap-iphoneos-arm64.tar"
rm -f "$BOOTSTRAP_TAR"

echo "  [+] procursus bootstrap installed"

# ═══════════ JB-3 DEPLOY BASEBIN HOOKS ═════════════════════════
BASEBIN_DIR="$JB_INPUT_DIR/basebin"
if [[ -d "$BASEBIN_DIR" ]]; then
    echo ""
    echo "[JB-3] Deploying BaseBin hooks to /cores/..."

    ssh_cmd "/bin/mkdir -p /mnt1/cores"
    ssh_cmd "/bin/chmod 0755 /mnt1/cores"

    for dylib in "$BASEBIN_DIR"/*.dylib; do
        [[ -f "$dylib" ]] || continue
        dylib_name="$(basename "$dylib")"
        echo "  Installing $dylib_name..."
        # Re-sign with our certificate before deploying
        ldid_sign "$dylib"
        scp_to "$dylib" "/mnt1/cores/$dylib_name"
        ssh_cmd "/bin/chmod 0755 /mnt1/cores/$dylib_name"
    done

    echo "  [+] BaseBin hooks deployed"
fi

# ═══════════ CLEANUP ═════════════════════════════════════════
echo ""
echo "[*] Unmounting device filesystems..."
ssh_cmd "/sbin/umount /mnt1 2>/dev/null || true"
ssh_cmd "/sbin/umount /mnt3 2>/dev/null || true"
ssh_cmd "/sbin/umount /mnt5 2>/dev/null || true"

echo "[*] Cleaning up temp binaries..."
rm -f "$TEMP_DIR/launchd" \
      "$TEMP_DIR/bootstrap-iphoneos-arm64.tar"

echo ""
echo "[+] CFW + JB installation complete!"
echo "    Reboot the device for changes to take effect."
echo "    After boot, SSH will be available on port 22222 (password: alpine)"

ssh_cmd "/sbin/halt" || true

```

`scripts/fw_manifest.py`:

```py
#!/usr/bin/env python3
"""Generate hybrid BuildManifest.plist and Restore.plist for vresearch1 restore.

Merges cloudOS boot-chain (vresearch101ap) with vphone600 runtime components
(device tree, SEP, kernel) and iPhone OS images into a single DFU erase-install
Build Identity.

The VM hardware identifies as vresearch101ap (BDID 0x90) in DFU mode, so the
identity fields must match for TSS/SHSH signing.  Runtime components use the
vphone600 variant because its device tree sets MKB dt=1 (keybag-less boot).

Usage:
    python3 fw_manifest.py <iphone_dir> <cloudos_dir>
"""

import copy, os, plistlib, sys


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def load(path):
    with open(path, "rb") as f:
        return plistlib.load(f)


def entry(identities, idx, key):
    """Deep-copy a single Manifest entry from a build identity."""
    return copy.deepcopy(identities[idx]["Manifest"][key])


# ---------------------------------------------------------------------------
# Identity discovery
# ---------------------------------------------------------------------------

def _is_research(bi):
    """Determine whether a build identity is a research variant."""
    for comp in ("LLB", "iBSS", "iBEC"):
        path = bi.get("Manifest", {}).get(comp, {}).get("Info", {}).get("Path", "")
        if not path:
            continue
        parts = os.path.basename(path).split(".")
        if len(parts) == 4:
            return "RESEARCH" in parts[2]
    variant = bi.get("Info", {}).get("Variant", "")
    return "research" in variant.lower()


def find_cloudos(identities, device_class):
    """Find release and research identity indices for the given DeviceClass."""
    release = research = None
    for i, bi in enumerate(identities):
        dc = bi.get("Info", {}).get("DeviceClass", "")
        if dc != device_class:
            continue
        if _is_research(bi):
            if research is None:
                research = i
        else:
            if release is None:
                release = i
    if release is None:
        raise KeyError(f"No release identity for DeviceClass={device_class}")
    if research is None:
        raise KeyError(f"No research identity for DeviceClass={device_class}")
    return release, research


def find_iphone_erase(identities):
    """Return the index of the first iPhone erase identity."""
    for i, bi in enumerate(identities):
        var = bi.get("Info", {}).get("Variant", "").lower()
        if "research" not in var and "upgrade" not in var and "recovery" not in var:
            return i
    raise KeyError("No erase identity found in iPhone manifest")


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <iphone_dir> <cloudos_dir>",
              file=sys.stderr)
        sys.exit(1)

    iphone_dir, cloudos_dir = sys.argv[1], sys.argv[2]

    cloudos_bm = load(os.path.join(cloudos_dir, "BuildManifest.plist"))
    iphone_bm  = load(os.path.join(iphone_dir,  "BuildManifest.plist"))
    cloudos_rp = load(os.path.join(cloudos_dir, "Restore.plist"))
    iphone_rp  = load(os.path.join(iphone_dir,  "Restore.plist"))

    C = cloudos_bm["BuildIdentities"]
    I = iphone_bm["BuildIdentities"]

    # ── Discover source identities ───────────────────────────────────
    #   PROD / RES  = vresearch101ap release / research  (boot chain)
    #   VP   / VPR  = vphone600ap    release / research  (runtime)
    PROD, RES = find_cloudos(C, "vresearch101ap")
    VP, VPR   = find_cloudos(C, "vphone600ap")
    I_ERASE   = find_iphone_erase(I)

    print(f"  cloudOS vresearch101ap: release=#{PROD}, research=#{RES}")
    print(f"  cloudOS vphone600ap:    release=#{VP}, research=#{VPR}")
    print(f"  iPhone  erase: #{I_ERASE}")

    # ── Build the single DFU erase identity ──────────────────────────
    # Identity base from vresearch101ap PROD — must match DFU hardware
    # (BDID 0x90) for TSS/SHSH signing.
    bi = copy.deepcopy(C[PROD])
    bi["Manifest"] = {}
    bi["Ap,ProductType"]   = "ComputeModule14,2"
    bi["Ap,Target"]        = "VRESEARCH101AP"
    bi["Ap,TargetType"]    = "vresearch101"
    bi["ApBoardID"]        = "0x90"
    bi["ApChipID"]         = "0xFE01"
    bi["ApSecurityDomain"] = "0x01"
    for k in ("NeRDEpoch", "RestoreAttestationMode"):
        bi.pop(k, None)
        bi.get("Info", {}).pop(k, None)
    bi["Info"]["FDRSupport"] = False
    bi["Info"]["Variant"] = "Darwin Cloud Customer Erase Install (IPSW)"
    bi["Info"]["VariantContents"] = {
        "BasebandFirmware": "Release",
        "DCP": "DarwinProduction",
        "DFU": "DarwinProduction",
        "Firmware": "DarwinProduction",
        "InitiumBaseband": "Production",
        "InstalledKernelCache": "Production",
        "InstalledSPTM": "Production",
        "OS": "Production",
        "RestoreKernelCache": "Production",
        "RestoreRamDisk": "Production",
        "RestoreSEP": "DarwinProduction",
        "RestoreSPTM": "Production",
        "SEP": "DarwinProduction",
        "VinylFirmware": "Release",
    }

    m = bi["Manifest"]

    # ── Boot chain (vresearch101 — matches DFU hardware) ─────────────
    m["LLB"]  = entry(C, PROD, "LLB")
    m["iBSS"] = entry(C, PROD, "iBSS")
    m["iBEC"] = entry(C, PROD, "iBEC")
    m["iBoot"] = entry(C, RES, "iBoot")       # research iBoot

    # ── Security monitors (shared across board configs) ──────────────
    m["Ap,RestoreSecurePageTableMonitor"]  = entry(C, PROD, "Ap,RestoreSecurePageTableMonitor")
    m["Ap,RestoreTrustedExecutionMonitor"] = entry(C, PROD, "Ap,RestoreTrustedExecutionMonitor")
    m["Ap,SecurePageTableMonitor"]         = entry(C, PROD, "Ap,SecurePageTableMonitor")
    m["Ap,TrustedExecutionMonitor"]        = entry(C, RES,  "Ap,TrustedExecutionMonitor")

    # ── Device tree (vphone600ap — sets MKB dt=1 for keybag-less boot)
    m["DeviceTree"]        = entry(C, VP, "DeviceTree")
    m["RestoreDeviceTree"] = entry(C, VP, "RestoreDeviceTree")

    # ── SEP (vphone600 — matches device tree) ────────────────────────
    m["SEP"]        = entry(C, VP, "SEP")
    m["RestoreSEP"] = entry(C, VP, "RestoreSEP")

    # ── Kernel (vphone600, patched by fw_patch.py) ────────────────────
    m["KernelCache"]        = entry(C, VPR, "KernelCache")         # research
    m["RestoreKernelCache"] = entry(C, VP,  "RestoreKernelCache")  # release

    # ── Recovery mode (vphone600ap carries this entry) ────────────────
    m["RecoveryMode"] = entry(C, VP, "RecoveryMode")

    # ── CloudOS erase ramdisk ────────────────────────────────────────
    m["RestoreRamDisk"]    = entry(C, PROD, "RestoreRamDisk")
    m["RestoreTrustCache"] = entry(C, PROD, "RestoreTrustCache")

    # ── iPhone OS image ──────────────────────────────────────────────
    m["Ap,SystemVolumeCanonicalMetadata"] = entry(I, I_ERASE, "Ap,SystemVolumeCanonicalMetadata")
    m["OS"]               = entry(I, I_ERASE, "OS")
    m["StaticTrustCache"] = entry(I, I_ERASE, "StaticTrustCache")
    m["SystemVolume"]     = entry(I, I_ERASE, "SystemVolume")

    # ── Assemble BuildManifest ───────────────────────────────────────
    build_manifest = {
        "BuildIdentities":      [bi],
        "ManifestVersion":      cloudos_bm["ManifestVersion"],
        "ProductBuildVersion":  cloudos_bm["ProductBuildVersion"],
        "ProductVersion":       cloudos_bm["ProductVersion"],
        "SupportedProductTypes": ["iPhone99,11"],
    }

    # ── Assemble Restore.plist ───────────────────────────────────────
    restore = {
        "ProductBuildVersion": cloudos_rp["ProductBuildVersion"],
        "ProductVersion":      cloudos_rp["ProductVersion"],
        "DeviceMap": [iphone_rp["DeviceMap"][0]] + [
            d for d in cloudos_rp["DeviceMap"]
            if d["BoardConfig"] in ("vphone600ap", "vresearch101ap")
        ],
        "SupportedProductTypeIDs": {
            cat: (iphone_rp["SupportedProductTypeIDs"][cat]
                  + cloudos_rp["SupportedProductTypeIDs"][cat])
            for cat in ("DFU", "Recovery")
        },
        "SupportedProductTypes": (
            iphone_rp.get("SupportedProductTypes", [])
            + cloudos_rp.get("SupportedProductTypes", [])
        ),
        "SystemRestoreImageFileSystems": copy.deepcopy(
            iphone_rp["SystemRestoreImageFileSystems"]),
    }

    # ── Write output ─────────────────────────────────────────────────
    for name, data in [("BuildManifest.plist", build_manifest),
                       ("Restore.plist", restore)]:
        path = os.path.join(iphone_dir, name)
        with open(path, "wb") as f:
            plistlib.dump(data, f, sort_keys=True)
        print(f"  wrote {name}")


if __name__ == "__main__":
    main()

```

`scripts/fw_patch.py`:

```py
#!/usr/bin/env python3
"""
patch_firmware.py — Patch all boot-chain components for vphone600.

Run this AFTER prepare_firmware.sh from the VM directory.

Usage:
    python3 patch_firmware.py [vm_directory]

    vm_directory defaults to the current working directory.
    The script auto-discovers the iPhone*_Restore directory and all
    firmware files by searching for known patterns.

Components patched (ALL dynamically — no hardcoded offsets):
  1. AVPBooter        — DGST validation bypass (mov x0, #0)
  2. iBSS             — serial labels + image4 callback bypass
  3. iBEC             — serial labels + image4 callback + boot-args
  4. LLB              — serial labels + image4 callback + boot-args + rootfs + panic
  5. TXM              — trustcache bypass (mov x0, #0)
  6. kernelcache      — 25 patches (APFS, MAC, debugger, launch constraints, etc.)

Dependencies:
    pip install keystone-engine capstone pyimg4
"""

import sys, os, glob, subprocess, tempfile

from capstone import Cs, CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN as KS_MODE_LE
from pyimg4 import IM4P

from patchers.kernel import KernelPatcher
from patchers.iboot import IBootPatcher
from patchers.txm import TXMPatcher

# ══════════════════════════════════════════════════════════════════
# Assembler helpers (for AVPBooter only — iBoot/TXM/kernel are
# handled by their own patcher classes)
# ══════════════════════════════════════════════════════════════════

_ks = Ks(KS_ARCH_ARM64, KS_MODE_LE)


def _asm(s):
    enc, _ = _ks.asm(s)
    if not enc:
        raise RuntimeError(f"asm failed: {s}")
    return bytes(enc)


MOV_X0_0 = _asm("mov x0, #0")
RET_MNEMONICS = {"ret", "retaa", "retab"}


# ══════════════════════════════════════════════════════════════════
# IM4P / raw file helpers — auto-detect format
# ══════════════════════════════════════════════════════════════════

def load_firmware(path):
    """Load firmware file, auto-detecting IM4P vs raw.

    Returns (im4p_or_None, raw_bytearray, is_im4p_bool, original_bytes).
    """
    with open(path, "rb") as f:
        raw = f.read()

    try:
        im4p = IM4P(raw)
        if im4p.payload.compression:
            im4p.payload.decompress()
        return im4p, bytearray(im4p.payload.data), True, raw
    except Exception:
        return None, bytearray(raw), False, raw


def save_firmware(path, im4p_obj, patched_data, was_im4p, original_raw=None):
    """Save patched firmware, repackaging as IM4P if the original was IM4P."""
    if was_im4p and im4p_obj is not None:
        if original_raw is not None:
            _save_im4p_with_payp(path, im4p_obj.fourcc, patched_data, original_raw)
        else:
            new_im4p = IM4P(
                fourcc=im4p_obj.fourcc,
                description=im4p_obj.description,
                payload=bytes(patched_data),
            )
            with open(path, "wb") as f:
                f.write(new_im4p.output())
    else:
        with open(path, "wb") as f:
            f.write(patched_data)


def _save_im4p_with_payp(path, fourcc, patched_data, original_raw):
    """Repackage as lzfse-compressed IM4P and append PAYP from original."""
    with tempfile.NamedTemporaryFile(suffix=".raw", delete=False) as tmp_raw, \
         tempfile.NamedTemporaryFile(suffix=".im4p", delete=False) as tmp_im4p:
        tmp_raw_path = tmp_raw.name
        tmp_im4p_path = tmp_im4p.name
        tmp_raw.write(bytes(patched_data))

    try:
        subprocess.run(
            ["pyimg4", "im4p", "create",
             "-i", tmp_raw_path, "-o", tmp_im4p_path,
             "-f", fourcc, "--lzfse"],
            check=True, capture_output=True,
        )
        output = bytearray(open(tmp_im4p_path, "rb").read())
    finally:
        os.unlink(tmp_raw_path)
        os.unlink(tmp_im4p_path)

    payp_offset = original_raw.rfind(b"PAYP")
    if payp_offset >= 0:
        payp_data = original_raw[payp_offset - 10:]
        output.extend(payp_data)
        old_len = int.from_bytes(output[2:5], "big")
        output[2:5] = (old_len + len(payp_data)).to_bytes(3, "big")
        print(f"  [+] preserved PAYP ({len(payp_data)} bytes)")

    with open(path, "wb") as f:
        f.write(output)


# ══════════════════════════════════════════════════════════════════
# Per-component patch functions
# ══════════════════════════════════════════════════════════════════

# ── 1. AVPBooter ──────────────────────────────────────────────────
# Already dynamic — finds DGST constant, locates x0 setter before
# ret, replaces with mov x0, #0.  Base address is irrelevant
# (cancels out in the offset calculation).

AVP_SEARCH = "0x4447"


def patch_avpbooter(data):
    md = Cs(CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN)
    md.skipdata = True
    insns = list(md.disasm(bytes(data), 0))

    hits = [i for i in insns if AVP_SEARCH in f"{i.mnemonic} {i.op_str}"]
    if not hits:
        print("  [-] DGST constant not found")
        return False

    addr2idx = {insn.address: i for i, insn in enumerate(insns)}
    idx = addr2idx[hits[0].address]

    ret_idx = None
    for i in range(idx, min(idx + 512, len(insns))):
        if insns[i].mnemonic in RET_MNEMONICS:
            ret_idx = i
            break
    if ret_idx is None:
        print("  [-] epilogue not found")
        return False

    x0_idx = None
    for i in range(ret_idx - 1, max(ret_idx - 32, -1), -1):
        op, mn = insns[i].op_str, insns[i].mnemonic
        if mn == "mov" and op.startswith(("x0,", "w0,")):
            x0_idx = i
            break
        if mn in ("cset", "csinc", "csinv", "csneg") and op.startswith(("x0,", "w0,")):
            x0_idx = i
            break
        if mn in RET_MNEMONICS or mn in ("b", "bl", "br", "blr"):
            break
    if x0_idx is None:
        print("  [-] x0 setter not found")
        return False

    target = insns[x0_idx]
    file_off = target.address
    data[file_off:file_off + 4] = MOV_X0_0
    print(f"  0x{file_off:X}: {target.mnemonic} {target.op_str} -> mov x0, #0")
    return True


# ── 2–4. iBSS / iBEC / LLB ───────────────────────────────────────
# Fully dynamic via IBootPatcher — no hardcoded offsets.

def patch_ibss(data):
    p = IBootPatcher(data, mode='ibss', label="Loaded iBSS")
    n = p.apply()
    print(f"  [+] {n} iBSS patches applied dynamically")
    return n > 0


def patch_ibec(data):
    p = IBootPatcher(data, mode='ibec', label="Loaded iBEC")
    n = p.apply()
    print(f"  [+] {n} iBEC patches applied dynamically")
    return n > 0


def patch_llb(data):
    p = IBootPatcher(data, mode='llb', label="Loaded LLB")
    n = p.apply()
    print(f"  [+] {n} LLB patches applied dynamically")
    return n > 0


# ── 5. TXM ───────────────────────────────────────────────────────
# Fully dynamic via TXMPatcher — no hardcoded offsets.

def patch_txm(data):
    p = TXMPatcher(data)
    n = p.apply()
    print(f"  [+] {n} TXM patches applied dynamically")
    return n > 0


# ── 6. Kernelcache ───────────────────────────────────────────────
# Fully dynamic via KernelPatcher — no hardcoded offsets.

def patch_kernelcache(data):
    kp = KernelPatcher(data)
    n = kp.apply()
    print(f"  [+] {n} kernel patches applied dynamically")
    return n > 0


# ══════════════════════════════════════════════════════════════════
# File discovery
# ══════════════════════════════════════════════════════════════════

def find_restore_dir(base_dir):
    for entry in sorted(os.listdir(base_dir)):
        full = os.path.join(base_dir, entry)
        if os.path.isdir(full) and "Restore" in entry:
            return full
    return None


def find_file(base_dir, patterns, label):
    for pattern in patterns:
        matches = sorted(glob.glob(os.path.join(base_dir, pattern)))
        if matches:
            return matches[0]
    print(f"[-] {label} not found. Searched patterns:")
    for p in patterns:
        print(f"    {os.path.join(base_dir, p)}")
    sys.exit(1)


# ══════════════════════════════════════════════════════════════════
# Main
# ══════════════════════════════════════════════════════════════════

COMPONENTS = [
    # (name, search_base_is_restore, search_patterns, patch_function, preserve_payp)
    ("AVPBooter", False, ["AVPBooter*.bin"], patch_avpbooter, False),
    ("iBSS", True, ["Firmware/dfu/iBSS.vresearch101.RELEASE.im4p"], patch_ibss, False),
    ("iBEC", True, ["Firmware/dfu/iBEC.vresearch101.RELEASE.im4p"], patch_ibec, False),
    ("LLB", True, ["Firmware/all_flash/LLB.vresearch101.RELEASE.im4p"], patch_llb, False),
    ("TXM", True, ["Firmware/txm.iphoneos.research.im4p"], patch_txm, True),
    ("kernelcache", True, ["kernelcache.research.vphone600"], patch_kernelcache, True),
]


def patch_component(path, patch_fn, name, preserve_payp):
    print(f"\n{'=' * 60}")
    print(f"  {name}: {path}")
    print(f"{'=' * 60}")

    im4p, data, was_im4p, original_raw = load_firmware(path)
    fmt = "IM4P" if was_im4p else "raw"
    extra = ""
    if was_im4p and im4p:
        extra = f", fourcc={im4p.fourcc}"
    print(f"  format: {fmt}{extra}, {len(data)} bytes")

    if not patch_fn(data):
        print(f"  [-] FAILED: {name}")
        sys.exit(1)

    save_firmware(path, im4p, data, was_im4p,
                  original_raw if preserve_payp else None)
    print(f"  [+] saved ({fmt})")


def main():
    vm_dir = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
    vm_dir = os.path.abspath(vm_dir)

    if not os.path.isdir(vm_dir):
        print(f"[-] Not a directory: {vm_dir}")
        sys.exit(1)

    restore_dir = find_restore_dir(vm_dir)
    if not restore_dir:
        print(f"[-] No *Restore* directory found in {vm_dir}")
        print("    Run prepare_firmware_v2.sh first.")
        sys.exit(1)

    print(f"[*] VM directory:      {vm_dir}")
    print(f"[*] Restore directory: {restore_dir}")
    print(f"[*] Patching {len(COMPONENTS)} boot-chain components ...")

    for name, in_restore, patterns, patch_fn, preserve_payp in COMPONENTS:
        search_base = restore_dir if in_restore else vm_dir
        path = find_file(search_base, patterns, name)
        patch_component(path, patch_fn, name, preserve_payp)

    print(f"\n{'=' * 60}")
    print(f"  All {len(COMPONENTS)} components patched successfully!")
    print(f"{'=' * 60}")


if __name__ == "__main__":
    main()

```

`scripts/fw_patch_jb.py`:

```py
#!/usr/bin/env python3
"""
fw_patch_jb.py — Apply jailbreak extension patches after base fw_patch.

Usage:
    python3 fw_patch_jb.py [vm_directory]

This script runs base `fw_patch.py` first, then applies additional JB-oriented
patches found dynamically.
"""

import os
import subprocess
import sys

from fw_patch import (
    find_file,
    find_restore_dir,
    load_firmware,
    save_firmware,
)
from patchers.kernel_jb import KernelJBPatcher
from patchers.txm_jb import TXMJBPatcher


def patch_kernelcache_jb(data):
    kp = KernelJBPatcher(data, verbose=True)
    n = kp.apply()
    print(f"  [+] {n} kernel JB patches applied dynamically")
    return n > 0


def patch_txm_jb(data):
    p = TXMJBPatcher(data, verbose=True)
    n = p.apply()
    print(f"  [+] {n} TXM JB patches applied dynamically")
    return n > 0


COMPONENTS = [
    # (name, search_base_is_restore, search_patterns, patch_function, preserve_payp)
    # NOTE: iBSS nonce skip removed — nonce is not required for boot.
    ("TXM (JB)", True,
     ["Firmware/txm.iphoneos.research.im4p"],
     patch_txm_jb, True),
    ("kernelcache (JB)", True,
     ["kernelcache.research.vphone600"],
     patch_kernelcache_jb, True),
]


def patch_component(path, patch_fn, name, preserve_payp):
    print(f"\n{'=' * 60}")
    print(f"  {name}: {path}")
    print(f"{'=' * 60}")

    im4p, data, was_im4p, original_raw = load_firmware(path)
    fmt = "IM4P" if was_im4p else "raw"
    extra = f", fourcc={im4p.fourcc}" if was_im4p and im4p else ""
    print(f"  format: {fmt}{extra}, {len(data)} bytes")

    if not patch_fn(data):
        print(f"  [-] FAILED: {name}")
        sys.exit(1)

    save_firmware(path, im4p, data, was_im4p,
                  original_raw if preserve_payp else None)
    print(f"  [+] saved ({fmt})")


def main():
    vm_dir = sys.argv[1] if len(sys.argv) > 1 else os.getcwd()
    vm_dir = os.path.abspath(vm_dir)

    if not os.path.isdir(vm_dir):
        print(f"[-] Not a directory: {vm_dir}")
        sys.exit(1)

    script_dir = os.path.dirname(os.path.abspath(__file__))
    fw_patch_script = os.path.join(script_dir, "fw_patch.py")

    print("[*] Running base fw_patch first ...", flush=True)
    subprocess.run([sys.executable, fw_patch_script, vm_dir], check=True)

    restore_dir = find_restore_dir(vm_dir)
    if not restore_dir:
        print(f"[-] No *Restore* directory found in {vm_dir}")
        sys.exit(1)

    print(f"[*] VM directory:      {vm_dir}")
    print(f"[*] Restore directory: {restore_dir}")
    print(f"[*] Applying {len(COMPONENTS)} JB extension components ...")

    for name, in_restore, patterns, patch_fn, preserve_payp in COMPONENTS:
        search_base = restore_dir if in_restore else vm_dir
        path = find_file(search_base, patterns, name)
        patch_component(path, patch_fn, name, preserve_payp)

    print(f"\n{'=' * 60}")
    print("  JB extension patching complete!")
    print(f"{'=' * 60}")


if __name__ == "__main__":
    main()

```

`scripts/fw_prepare.sh`:

```sh
#!/bin/bash
# fw_prepare.sh — Download/copy, merge, and generate hybrid restore firmware.
# Combines cloudOS boot chain with iPhone OS images for vresearch101.
#
# Accepts URLs or local file paths. Local paths are copied instead of downloaded.
# All output goes to the current working directory.
#
# Usage:
#   make fw_prepare
#
# Environment variables (override positional args):
#   IPHONE_SOURCE  — URL or local path to iPhone IPSW
#   CLOUDOS_SOURCE — URL or local path to cloudOS IPSW
set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

IPHONE_SOURCE="${IPHONE_SOURCE:-${1:-https://updates.cdn-apple.com/2025FallFCS/fullrestores/089-13864/668EFC0E-5911-454C-96C6-E1063CB80042/iPhone17,3_26.1_23B85_Restore.ipsw}}"
CLOUDOS_SOURCE="${CLOUDOS_SOURCE:-${2:-https://updates.cdn-apple.com/private-cloud-compute/399b664dd623358c3de118ffc114e42dcd51c9309e751d43bc949b98f4e31349}}"

# Derive local filenames from source basename
IPHONE_IPSW="${IPHONE_SOURCE##*/}"
IPHONE_DIR="${IPHONE_IPSW%.ipsw}"
CLOUDOS_IPSW="${CLOUDOS_SOURCE##*/}"
# Fallback name if the source basename has no extension (e.g. raw CDN hash URL)
[[ "$CLOUDOS_IPSW" == *.ipsw ]] || CLOUDOS_IPSW="pcc-base.ipsw"
CLOUDOS_DIR="${CLOUDOS_IPSW%.ipsw}"

echo "=== prepare_firmware ==="
echo "  iPhone:  $IPHONE_SOURCE"
echo "  CloudOS: $CLOUDOS_SOURCE"
echo "  Output:  $(pwd)/$IPHONE_DIR/"
echo ""

# ── Fetch (download or copy) ─────────────────────────────────────────
is_local() { [[ "$1" != http://* && "$1" != https://* ]]; }

fetch() {
    local src="$1" out="$2"
    if [[ -f "$out" ]]; then
        echo "==> Skipping: '$out' already exists."
        return
    fi
    if is_local "$src"; then
        echo "==> Copying ${src##*/} ..."
        cp -- "$src" "$out"
    else
        echo "==> Downloading $out ..."
        if ! wget --no-check-certificate --show-progress -O "$out" "$src"; then
            echo "ERROR: Failed to download '$src'" >&2
            rm -f "$out"
            exit 1
        fi
    fi
}

fetch "$IPHONE_SOURCE"  "$IPHONE_IPSW"
fetch "$CLOUDOS_SOURCE" "$CLOUDOS_IPSW"

# ── Extract ───────────────────────────────────────────────────────────
extract() {
    local zip="$1" dir="$2"
    rm -rf "$dir"
    echo "==> Extracting $zip ..."
    mkdir -p "$dir"
    unzip -oq "$zip" -d "$dir"
    chmod -R u+w "$dir"
}

extract "$IPHONE_IPSW" "$IPHONE_DIR"
extract "$CLOUDOS_IPSW" "$CLOUDOS_DIR"

# ── Merge cloudOS firmware into iPhone restore directory ──────────────
echo "==> Importing cloudOS firmware components ..."

cp ${CLOUDOS_DIR}/kernelcache.* "$IPHONE_DIR"/

for sub in agx all_flash ane dfu pmp; do
    cp ${CLOUDOS_DIR}/Firmware/${sub}/* "$IPHONE_DIR/Firmware/${sub}"/
done

cp ${CLOUDOS_DIR}/Firmware/*.im4p "$IPHONE_DIR/Firmware"/

# CloudOS ramdisk DMGs and trustcaches (RestoreRamDisk / RestoreTrustCache)
cp -n ${CLOUDOS_DIR}/*.dmg "$IPHONE_DIR"/ 2>/dev/null || true
cp -n ${CLOUDOS_DIR}/Firmware/*.dmg.trustcache "$IPHONE_DIR/Firmware"/ 2>/dev/null || true

# ── Preserve original iPhone BuildManifest (cfw_install.sh reads Cryptex paths) ──
cp "$IPHONE_DIR/BuildManifest.plist" "$IPHONE_DIR/BuildManifest-iPhone.plist"

# ── Generate hybrid BuildManifest.plist & Restore.plist ───────────────
echo "==> Generating hybrid plists ..."

python3 "$SCRIPT_DIR/fw_manifest.py" "$IPHONE_DIR" "$CLOUDOS_DIR"

# ── Cleanup (keep IPSWs, remove intermediate files) ──────────────────
echo "==> Cleaning up ..."
rm -rf "$CLOUDOS_DIR"

echo "==> Done. Restore directory ready: $IPHONE_DIR/"
echo "    Run 'make fw_patch' to patch boot-chain components."

```

`scripts/patchers/__init__.py`:

```py
from .iboot import IBootPatcher
from .kernel import KernelPatcher
from .txm import TXMPatcher

__all__ = ["IBootPatcher", "KernelPatcher", "TXMPatcher"]

```

`scripts/patchers/cfw.py`:

```py
#!/usr/bin/env python3
"""
patch_cfw.py — Dynamic binary patching for CFW installation on vphone600.

Uses capstone for disassembly-based anchoring and keystone for instruction
assembly, producing reliable, upgrade-proof patches.

Called by install_cfw.sh during CFW installation.

Commands:
    cryptex-paths <BuildManifest.plist>
        Print SystemOS and AppOS DMG paths from BuildManifest.

    patch-seputil <binary>
        Patch seputil gigalocker UUID to "AA".

    patch-launchd-cache-loader <binary>
        NOP the cache validation check in launchd_cache_loader.

    patch-mobileactivationd <binary>
        Patch -[DeviceType should_hactivate] to always return true.

    patch-launchd-jetsam <binary>
        Patch launchd jetsam panic guard to avoid initproc crash loop.

    inject-daemons <launchd.plist> <daemon_dir>
        Inject bash/dropbear/trollvnc into launchd.plist.

    inject-dylib <binary> <dylib_path>
        Inject LC_LOAD_DYLIB into Mach-O binary (thin or universal).
        Equivalent to: optool install -c load -p <dylib_path> -t <binary>

Dependencies:
    pip install capstone keystone-engine
"""

import os
import plistlib
import struct
import subprocess
import sys

from capstone import Cs, CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN
from capstone.arm64_const import ARM64_OP_IMM
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN as KS_MODE_LE

# ══════════════════════════════════════════════════════════════════
# ARM64 assembler / disassembler
# ══════════════════════════════════════════════════════════════════

_cs = Cs(CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN)
_cs.detail = True
_ks = Ks(KS_ARCH_ARM64, KS_MODE_LE)


def asm(s):
    enc, _ = _ks.asm(s)
    if not enc:
        raise RuntimeError(f"asm failed: {s}")
    return bytes(enc)


def asm_at(s, addr):
    enc, _ = _ks.asm(s, addr=addr)
    if not enc:
        raise RuntimeError(f"asm failed at 0x{addr:X}: {s}")
    return bytes(enc)


NOP = asm("nop")
MOV_X0_1 = asm("mov x0, #1")
RET = asm("ret")


def rd32(data, off):
    return struct.unpack_from("<I", data, off)[0]


def wr32(data, off, val):
    struct.pack_into("<I", data, off, val)


def disasm_at(data, off, n=8):
    """Disassemble n instructions at file offset."""
    return list(_cs.disasm(bytes(data[off : off + n * 4]), off))


def _log_asm(data, offset, count=5, marker_off=-1):
    """Log disassembly of `count` instructions at file offset for before/after comparison."""
    insns = disasm_at(data, offset, count)
    for insn in insns:
        tag = " >>>" if insn.address == marker_off else "    "
        print(f"  {tag} 0x{insn.address:08X}: {insn.mnemonic:8s} {insn.op_str}")


# ══════════════════════════════════════════════════════════════════
# Mach-O helpers
# ══════════════════════════════════════════════════════════════════


def parse_macho_sections(data):
    """Parse Mach-O 64-bit to extract section info.

    Returns dict: "segment,section" -> (vm_addr, size, file_offset)
    """
    magic = struct.unpack_from("<I", data, 0)[0]
    if magic != 0xFEEDFACF:
        raise ValueError(f"Not a 64-bit Mach-O (magic=0x{magic:X})")

    ncmds = struct.unpack_from("<I", data, 16)[0]
    sections = {}
    offset = 32  # sizeof(mach_header_64)

    for _ in range(ncmds):
        cmd, cmdsize = struct.unpack_from("<II", data, offset)
        if cmd == 0x19:  # LC_SEGMENT_64
            segname = data[offset + 8 : offset + 24].split(b"\x00")[0].decode()
            nsects = struct.unpack_from("<I", data, offset + 64)[0]
            sect_off = offset + 72
            for _ in range(nsects):
                sectname = (
                    data[sect_off : sect_off + 16].split(b"\x00")[0].decode()
                )
                addr = struct.unpack_from("<Q", data, sect_off + 32)[0]
                size = struct.unpack_from("<Q", data, sect_off + 40)[0]
                file_off = struct.unpack_from("<I", data, sect_off + 48)[0]
                sections[f"{segname},{sectname}"] = (addr, size, file_off)
                sect_off += 80
        offset += cmdsize
    return sections


def va_to_foff(data, va):
    """Convert virtual address to file offset using LC_SEGMENT_64 commands."""
    ncmds = struct.unpack_from("<I", data, 16)[0]
    offset = 32

    for _ in range(ncmds):
        cmd, cmdsize = struct.unpack_from("<II", data, offset)
        if cmd == 0x19:  # LC_SEGMENT_64
            vmaddr = struct.unpack_from("<Q", data, offset + 24)[0]
            vmsize = struct.unpack_from("<Q", data, offset + 32)[0]
            fileoff = struct.unpack_from("<Q", data, offset + 40)[0]
            if vmaddr <= va < vmaddr + vmsize:
                return fileoff + (va - vmaddr)
        offset += cmdsize
    return -1


def find_section(sections, *candidates):
    """Find the first matching section from candidates."""
    for name in candidates:
        if name in sections:
            return sections[name]
    return None


def find_symtab(data):
    """Parse LC_SYMTAB from Mach-O header.

    Returns (symoff, nsyms, stroff, strsize) or None.
    """
    ncmds = struct.unpack_from("<I", data, 16)[0]
    offset = 32
    for _ in range(ncmds):
        cmd, cmdsize = struct.unpack_from("<II", data, offset)
        if cmd == 0x02:  # LC_SYMTAB
            symoff = struct.unpack_from("<I", data, offset + 8)[0]
            nsyms = struct.unpack_from("<I", data, offset + 12)[0]
            stroff = struct.unpack_from("<I", data, offset + 16)[0]
            strsize = struct.unpack_from("<I", data, offset + 20)[0]
            return symoff, nsyms, stroff, strsize
        offset += cmdsize
    return None


def find_symbol_va(data, name_fragment):
    """Search Mach-O symbol table for a symbol containing name_fragment.

    Returns the symbol's VA, or -1 if not found.
    """
    st = find_symtab(data)
    if not st:
        return -1
    symoff, nsyms, stroff, strsize = st

    for i in range(nsyms):
        entry_off = symoff + i * 16  # sizeof(nlist_64)
        n_strx = struct.unpack_from("<I", data, entry_off)[0]
        n_value = struct.unpack_from("<Q", data, entry_off + 8)[0]

        if n_strx >= strsize or n_value == 0:
            continue

        # Read null-terminated symbol name
        end = data.index(0, stroff + n_strx)
        sym_name = data[stroff + n_strx : end].decode("ascii", errors="replace")

        if name_fragment in sym_name:
            return n_value

    return -1


# ══════════════════════════════════════════════════════════════════
# 1. seputil — Gigalocker UUID patch
# ══════════════════════════════════════════════════════════════════


def patch_seputil(filepath):
    """Dynamically find and patch the gigalocker path format string in seputil.

    Anchor: The format string "/%s.gl" used by seputil to construct the
    gigalocker file path as "{mountpoint}/{uuid}.gl".

    Patching "%s" to "AA" in "/%s.gl" makes it "/AA.gl", so the
    full path becomes /mnt7/AA.gl regardless of the device's UUID.
    The actual .gl file on disk is also renamed to AA.gl.
    """
    data = bytearray(open(filepath, "rb").read())

    # Search for the format string "/%s.gl\0" — this is the gigalocker
    # filename pattern where %s gets replaced with the device UUID.
    anchor = b"/%s.gl\x00"
    offset = data.find(anchor)

    if offset < 0:
        print("  [-] Format string '/%s.gl' not found in seputil")
        return False

    # The %s is at offset+1 (2 bytes: 0x25 0x73)
    pct_s_off = offset + 1
    original = bytes(data[offset : offset + len(anchor)])
    print(f"  Found format string at 0x{offset:X}: {original!r}")

    print(f"  Before: {bytes(data[offset:offset+7]).hex(' ')}")

    # Replace %s (2 bytes) with AA — turns "/%s.gl" into "/AA.gl"
    data[pct_s_off] = ord("A")
    data[pct_s_off + 1] = ord("A")

    print(f"  After:  {bytes(data[offset:offset+7]).hex(' ')}")

    open(filepath, "wb").write(data)
    print(f"  [+] Patched at 0x{pct_s_off:X}: %s -> AA")
    print(f"      /{anchor[1:-1].decode()} -> /AA.gl")
    return True


# ══════════════════════════════════════════════════════════════════
# 2. launchd_cache_loader — Unsecure cache bypass
# ══════════════════════════════════════════════════════════════════


def patch_launchd_cache_loader(filepath):
    """NOP the cache validation check in launchd_cache_loader.

    Anchor strategy:
    Search for "unsecure_cache" substring, resolve to full null-terminated
    string start, find ADRP+ADD xref to it, NOP the nearby cbz/cbnz branch.

    The binary checks boot-arg "launchd_unsecure_cache=" — if not found,
    it skips the unsecure path via a conditional branch. NOPping that branch
    allows modified launchd.plist to be loaded.
    """
    data = bytearray(open(filepath, "rb").read())
    sections = parse_macho_sections(data)

    text_sec = find_section(sections, "__TEXT,__text")
    if not text_sec:
        print("  [-] __TEXT,__text not found")
        return False

    text_va, text_size, text_foff = text_sec

    # Strategy 1: Search for anchor strings in __cstring
    # Code always references the START of a C string, so after finding a
    # substring match, back-scan to the enclosing string's first byte.
    cstring_sec = find_section(sections, "__TEXT,__cstring")
    anchor_strings = [
        b"unsecure_cache",
        b"unsecure",
        b"cache_valid",
        b"validation",
    ]

    for anchor_str in anchor_strings:
        anchor_off = data.find(anchor_str)
        if anchor_off < 0:
            continue

        # Find which section this belongs to and compute VA
        anchor_sec_foff = -1
        anchor_sec_va = -1
        for sec_name, (sva, ssz, sfoff) in sections.items():
            if sfoff <= anchor_off < sfoff + ssz:
                anchor_sec_foff = sfoff
                anchor_sec_va = sva
                break

        if anchor_sec_foff < 0:
            continue

        # Back-scan to the start of the enclosing null-terminated C string.
        # Code loads strings from their beginning, not from a substring.
        str_start_off = _find_cstring_start(data, anchor_off, anchor_sec_foff)
        str_start_va = anchor_sec_va + (str_start_off - anchor_sec_foff)
        substr_va = anchor_sec_va + (anchor_off - anchor_sec_foff)

        if str_start_off != anchor_off:
            end = data.index(0, str_start_off)
            full_str = data[str_start_off:end].decode("ascii", errors="replace")
            print(f"  Found anchor '{anchor_str.decode()}' inside \"{full_str}\"")
            print(f"    String start: va:0x{str_start_va:X}  (match at va:0x{substr_va:X})")
        else:
            print(f"  Found anchor '{anchor_str.decode()}' at va:0x{str_start_va:X}")

        # Search __TEXT for ADRP+ADD that resolves to the string START VA
        code = bytes(data[text_foff : text_foff + text_size])
        ref_off = _find_adrp_add_ref(code, text_va, str_start_va)

        if ref_off < 0:
            # Also try the exact substring VA as fallback
            ref_off = _find_adrp_add_ref(code, text_va, substr_va)

        if ref_off < 0:
            continue

        ref_foff = text_foff + (ref_off - text_va)
        print(f"  Found string ref at 0x{ref_foff:X}")

        # Find conditional branch AFTER the string ref (within +32 instructions).
        # The pattern is: ADRP+ADD (load string) -> BL (call check) -> CBZ/CBNZ (branch on result)
        # So only search forward from the ref, not backwards.
        branch_foff = _find_nearby_branch(data, ref_foff, text_foff, text_size)
        if branch_foff >= 0:
            ctx_start = max(text_foff, branch_foff - 8)
            print(f"  Before:")
            _log_asm(data, ctx_start, 5, branch_foff)

            data[branch_foff : branch_foff + 4] = NOP

            print(f"  After:")
            _log_asm(data, ctx_start, 5, branch_foff)

            open(filepath, "wb").write(data)
            print(f"  [+] NOPped at 0x{branch_foff:X}")
            return True

    print("  [-] Dynamic anchor not found — all strategies exhausted")
    return False


def _find_cstring_start(data, match_off, section_foff):
    """Find the start of the null-terminated C string containing match_off.

    Scans backwards from match_off to find the previous null byte (or section
    start). Returns the file offset of the first byte of the enclosing string.
    This is needed because code always references the start of a string, not
    a substring within it.
    """
    pos = match_off - 1
    while pos >= section_foff and data[pos] != 0:
        pos -= 1
    return pos + 1


def _find_adrp_add_ref(code, base_va, target_va):
    """Find ADRP+ADD pair that computes target_va in code.

    Handles non-adjacent pairs: tracks recent ADRP results per register
    and matches them with ADD instructions up to 8 instructions later.
    """
    target_page = target_va & ~0xFFF
    target_pageoff = target_va & 0xFFF

    # Track recent ADRP instructions: reg -> (insn_va, page_value, instruction_index)
    adrp_cache = {}

    for off in range(0, len(code) - 4, 4):
        insns = list(_cs.disasm(code[off : off + 4], base_va + off))
        if not insns:
            continue
        insn = insns[0]
        idx = off // 4

        if insn.mnemonic == "adrp" and len(insn.operands) >= 2:
            reg = insn.operands[0].reg
            page = insn.operands[1].imm
            adrp_cache[reg] = (insn.address, page, idx)

        elif insn.mnemonic == "add" and len(insn.operands) >= 3:
            src_reg = insn.operands[1].reg
            imm = insn.operands[2].imm
            if src_reg in adrp_cache:
                adrp_va, page, adrp_idx = adrp_cache[src_reg]
                # Only match if ADRP was within 8 instructions
                if page == target_page and imm == target_pageoff and idx - adrp_idx <= 8:
                    return adrp_va

    return -1


def _find_nearby_branch(data, ref_foff, text_foff, text_size):
    """Find a conditional branch after a BL (function call) near ref_foff.

    The typical pattern is:
        ADRP+ADD  (load string argument)  ← ref_foff points here
        ...       (setup other args)
        BL        (call check function)
        CBZ/CBNZ  (branch on return value)

    Searches forward from ref_foff for a BL, then finds the first
    conditional branch after it (within 8 instructions of the BL).
    Falls back to first conditional branch within +32 instructions.
    """
    branch_mnemonics = {"cbz", "cbnz", "tbz", "tbnz"}

    # Strategy A: find BL → then first conditional branch after it
    for delta in range(0, 16):
        check_foff = ref_foff + delta * 4
        if check_foff >= text_foff + text_size:
            break
        insns = disasm_at(data, check_foff, 1)
        if not insns:
            continue
        if insns[0].mnemonic == "bl":
            # Found a function call; scan the next 8 instructions for a branch
            for d2 in range(1, 9):
                br_foff = check_foff + d2 * 4
                if br_foff >= text_foff + text_size:
                    break
                br_insns = disasm_at(data, br_foff, 1)
                if not br_insns:
                    continue
                mn = br_insns[0].mnemonic
                if mn in branch_mnemonics or mn.startswith("b."):
                    return br_foff
            break  # Found BL but no branch after it

    # Strategy B: fallback — first conditional branch forward within 32 insns
    for delta in range(1, 33):
        check_foff = ref_foff + delta * 4
        if check_foff >= text_foff + text_size:
            break
        insns = disasm_at(data, check_foff, 1)
        if not insns:
            continue
        mn = insns[0].mnemonic
        if mn in branch_mnemonics or mn.startswith("b."):
            return check_foff

    return -1


# ══════════════════════════════════════════════════════════════════
# 3. mobileactivationd — Hackivation bypass
# ══════════════════════════════════════════════════════════════════


def patch_mobileactivationd(filepath):
    """Dynamically find -[DeviceType should_hactivate] and patch to return YES.

    Anchor strategies (in order):
    1. Search LC_SYMTAB for symbol containing "should_hactivate"
    2. Parse ObjC metadata: methnames -> selrefs -> method_list -> IMP

    The method determines if the device should self-activate (hackivation).
    Patching it to always return YES bypasses activation lock.
    """
    data = bytearray(open(filepath, "rb").read())

    imp_foff = -1

    # Strategy 1: Symbol table lookup (most reliable)
    imp_va = find_symbol_va(bytes(data), "should_hactivate")
    if imp_va > 0:
        imp_foff = va_to_foff(bytes(data), imp_va)
        if imp_foff >= 0:
            print(f"  Found via symtab: va:0x{imp_va:X} -> foff:0x{imp_foff:X}")

    # Strategy 2: ObjC metadata chain
    if imp_foff < 0:
        imp_foff = _find_via_objc_metadata(data)

    # All dynamic strategies exhausted
    if imp_foff < 0:
        print("  [-] Dynamic anchor not found — all strategies exhausted")
        return False

    # Verify the target looks like code
    if imp_foff + 8 > len(data):
        print(f"  [-] IMP offset 0x{imp_foff:X} out of bounds")
        return False

    print(f"  Before:")
    _log_asm(data, imp_foff, 4, imp_foff)

    # Patch to: mov x0, #1; ret
    data[imp_foff : imp_foff + 4] = MOV_X0_1
    data[imp_foff + 4 : imp_foff + 8] = RET

    print(f"  After:")
    _log_asm(data, imp_foff, 4, imp_foff)

    open(filepath, "wb").write(data)
    print(f"  [+] Patched at 0x{imp_foff:X}: mov x0, #1; ret")
    return True


# ══════════════════════════════════════════════════════════════════
# 4. launchd — Jetsam panic bypass
# ══════════════════════════════════════════════════════════════════


def _extract_branch_target_off(insn):
    for op in reversed(insn.operands):
        if op.type == ARM64_OP_IMM:
            return op.imm
    return -1


def _is_return_block(data, foff, text_foff, text_size):
    """Check if foff points to a function return sequence (ret/retab within 8 insns)."""
    for i in range(8):
        check = foff + i * 4
        if check >= text_foff + text_size:
            break
        insns = disasm_at(data, check, 1)
        if not insns:
            continue
        if insns[0].mnemonic in ("ret", "retab"):
            return True
        # Stop at unconditional branches (different block)
        if insns[0].mnemonic in ("b", "bl", "br", "blr"):
            break
    return False


def patch_launchd_jetsam(filepath):
    """Bypass launchd jetsam panic path via dynamic string-xref branch rewrite.

    Anchor strategy:
    1. Find jetsam panic string in cstring-like data.
    2. Find ADRP+ADD xref to the string start in __TEXT,__text.
    3. Search backward for a conditional branch whose target is the function's
       return/success path (basic block containing ret/retab).
    4. Rewrite that conditional branch to unconditional `b <same_target>`,
       so the function always returns success and never reaches the panic.
    """
    data = bytearray(open(filepath, "rb").read())
    sections = parse_macho_sections(data)

    text_sec = find_section(sections, "__TEXT,__text")
    if not text_sec:
        print("  [-] __TEXT,__text not found")
        return False

    text_va, text_size, text_foff = text_sec
    code = bytes(data[text_foff : text_foff + text_size])

    cond_mnemonics = {
        "b.eq", "b.ne", "b.cs", "b.hs", "b.cc", "b.lo",
        "b.mi", "b.pl", "b.vs", "b.vc", "b.hi", "b.ls",
        "b.ge", "b.lt", "b.gt", "b.le",
        "cbz", "cbnz", "tbz", "tbnz",
    }

    anchors = [
        b"jetsam property category (Daemon) is not initialized",
        b"jetsam property category",
        b"initproc exited -- exit reason namespace 7 subcode 0x1",
    ]

    for anchor in anchors:
        hit_off = data.find(anchor)
        if hit_off < 0:
            continue

        sec_foff = -1
        sec_va = -1
        for _, (sva, ssz, sfoff) in sections.items():
            if sfoff <= hit_off < sfoff + ssz:
                sec_foff = sfoff
                sec_va = sva
                break
        if sec_foff < 0:
            continue

        str_start_off = _find_cstring_start(data, hit_off, sec_foff)
        str_start_va = sec_va + (str_start_off - sec_foff)

        ref_va = _find_adrp_add_ref(code, text_va, str_start_va)
        if ref_va < 0:
            continue
        ref_foff = text_foff + (ref_va - text_va)

        print(f"  Found jetsam anchor '{anchor.decode(errors='ignore')}'")
        print(f"    string start: va:0x{str_start_va:X}")
        print(f"    xref at foff:0x{ref_foff:X}")

        # Search backward from xref for conditional branches targeting
        # the function's return path (block containing ret/retab).
        # Pick the earliest (farthest back) one — it skips the most
        # jetsam-related code and matches the upstream patch strategy.
        scan_lo = max(text_foff, ref_foff - 0x300)
        patch_off = -1
        patch_target = -1

        for back in range(ref_foff - 4, scan_lo - 1, -4):
            insns = disasm_at(data, back, 1)
            if not insns:
                continue
            insn = insns[0]
            if insn.mnemonic not in cond_mnemonics:
                continue

            tgt = _extract_branch_target_off(insn)
            if tgt < 0:
                continue
            # Target must be a valid file offset within __text
            if tgt < text_foff or tgt >= text_foff + text_size:
                continue
            # Target must be a return block (contains ret/retab)
            if _is_return_block(data, tgt, text_foff, text_size):
                patch_off = back
                patch_target = tgt
                # Don't break — keep scanning for an earlier match

        if patch_off < 0:
            continue

        ctx_start = max(text_foff, patch_off - 8)
        print(f"  Before:")
        _log_asm(data, ctx_start, 5, patch_off)

        data[patch_off : patch_off + 4] = asm_at(f"b #0x{patch_target:X}", patch_off)

        print(f"  After:")
        _log_asm(data, ctx_start, 5, patch_off)

        open(filepath, "wb").write(data)
        print(f"  [+] Patched at 0x{patch_off:X}: jetsam panic guard bypass")
        return True

    print("  [-] Dynamic jetsam anchor/xref not found")
    return False


def _find_via_objc_metadata(data):
    """Find method IMP through ObjC runtime metadata."""
    sections = parse_macho_sections(data)

    # Find "should_hactivate\0" string
    selector = b"should_hactivate\x00"
    sel_foff = data.find(selector)
    if sel_foff < 0:
        print("  [-] Selector 'should_hactivate' not found in binary")
        return -1

    # Compute selector VA
    sel_va = -1
    for sec_name, (sva, ssz, sfoff) in sections.items():
        if sfoff <= sel_foff < sfoff + ssz:
            sel_va = sva + (sel_foff - sfoff)
            break

    if sel_va < 0:
        print(f"  [-] Could not compute VA for selector at foff:0x{sel_foff:X}")
        return -1

    print(f"  Selector at foff:0x{sel_foff:X} va:0x{sel_va:X}")

    # Find selref that points to this selector
    selrefs = find_section(
        sections,
        "__DATA_CONST,__objc_selrefs",
        "__DATA,__objc_selrefs",
        "__AUTH_CONST,__objc_selrefs",
    )

    selref_foff = -1
    selref_va = -1

    if selrefs:
        sr_va, sr_size, sr_foff = selrefs
        for i in range(0, sr_size, 8):
            ptr = struct.unpack_from("<Q", data, sr_foff + i)[0]
            # Handle chained fixups: try exact and masked match
            if ptr == sel_va or (ptr & 0x0000FFFFFFFFFFFF) == sel_va:
                selref_foff = sr_foff + i
                selref_va = sr_va + i
                break

            # Also try: lower 32 bits might encode the target in chained fixups
            if (ptr & 0xFFFFFFFF) == (sel_va & 0xFFFFFFFF):
                selref_foff = sr_foff + i
                selref_va = sr_va + i
                break

    if selref_foff < 0:
        print("  [-] Selref not found (chained fixups may obscure pointers)")
        return -1

    print(f"  Selref at foff:0x{selref_foff:X} va:0x{selref_va:X}")

    # Search for relative method list entry pointing to this selref
    # Relative method entries: { int32 name_rel, int32 types_rel, int32 imp_rel }
    # name_field_va + name_rel = selref_va

    objc_const = find_section(
        sections,
        "__DATA_CONST,__objc_const",
        "__DATA,__objc_const",
        "__AUTH_CONST,__objc_const",
    )

    if objc_const:
        oc_va, oc_size, oc_foff = objc_const

        for i in range(0, oc_size - 12, 4):
            entry_foff = oc_foff + i
            entry_va = oc_va + i
            rel_name = struct.unpack_from("<i", data, entry_foff)[0]
            target_va = entry_va + rel_name

            if target_va == selref_va:
                # Found the method entry! Read IMP relative offset
                imp_field_foff = entry_foff + 8
                imp_field_va = entry_va + 8
                rel_imp = struct.unpack_from("<i", data, imp_field_foff)[0]
                imp_va = imp_field_va + rel_imp
                imp_foff = va_to_foff(bytes(data), imp_va)

                if imp_foff >= 0:
                    print(
                        f"  Found via relative method list: IMP va:0x{imp_va:X} foff:0x{imp_foff:X}"
                    )
                    return imp_foff
                else:
                    print(
                        f"  [!] IMP va:0x{imp_va:X} could not be mapped to file offset"
                    )

    return -1


# ══════════════════════════════════════════════════════════════════
# 5. Mach-O dylib injection (optool replacement)
# ══════════════════════════════════════════════════════════════════


def _align(n, alignment):
    return (n + alignment - 1) & ~(alignment - 1)


def _find_first_section_offset(data):
    """Find the file offset of the earliest section data in the Mach-O.

    This tells us how much space is available after load commands.
    For fat/universal binaries, we operate on the first slice.
    """
    magic = struct.unpack_from("<I", data, 0)[0]
    if magic != 0xFEEDFACF:
        return -1

    ncmds = struct.unpack_from("<I", data, 16)[0]
    offset = 32  # sizeof(mach_header_64)
    earliest = len(data)

    for _ in range(ncmds):
        cmd, cmdsize = struct.unpack_from("<II", data, offset)
        if cmd == 0x19:  # LC_SEGMENT_64
            nsects = struct.unpack_from("<I", data, offset + 64)[0]
            sect_off = offset + 72
            for _ in range(nsects):
                file_off = struct.unpack_from("<I", data, sect_off + 48)[0]
                size = struct.unpack_from("<Q", data, sect_off + 40)[0]
                if file_off > 0 and size > 0 and file_off < earliest:
                    earliest = file_off
                sect_off += 80
        offset += cmdsize
    return earliest


def _get_fat_slices(data):
    """Parse FAT (universal) binary header and return list of (offset, size) tuples.

    Returns [(0, len(data))] for thin binaries.
    """
    magic = struct.unpack_from(">I", data, 0)[0]
    if magic == 0xCAFEBABE:  # FAT_MAGIC
        nfat = struct.unpack_from(">I", data, 4)[0]
        slices = []
        for i in range(nfat):
            off = 8 + i * 20
            slice_off = struct.unpack_from(">I", data, off + 8)[0]
            slice_size = struct.unpack_from(">I", data, off + 12)[0]
            slices.append((slice_off, slice_size))
        return slices
    elif magic == 0xBEBAFECA:  # FAT_MAGIC_64
        nfat = struct.unpack_from(">I", data, 4)[0]
        slices = []
        for i in range(nfat):
            off = 8 + i * 32
            slice_off = struct.unpack_from(">Q", data, off + 8)[0]
            slice_size = struct.unpack_from(">Q", data, off + 16)[0]
            slices.append((slice_off, slice_size))
        return slices
    else:
        return [(0, len(data))]


def _check_existing_dylib(data, base, dylib_path):
    """Check if the dylib is already loaded in this Mach-O slice."""
    magic = struct.unpack_from("<I", data, base)[0]
    if magic != 0xFEEDFACF:
        return False

    ncmds = struct.unpack_from("<I", data, base + 16)[0]
    offset = base + 32

    for _ in range(ncmds):
        cmd, cmdsize = struct.unpack_from("<II", data, offset)
        if cmd in (0xC, 0xD, 0x18, 0x1F, 0x80000018):
            # LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB, LC_LAZY_LOAD_DYLIB,
            # LC_REEXPORT_DYLIB, LC_LOAD_UPWARD_DYLIB
            name_offset = struct.unpack_from("<I", data, offset + 8)[0]
            name_end = data.index(0, offset + name_offset)
            name = data[offset + name_offset : name_end].decode("ascii", errors="replace")
            if name == dylib_path:
                return True
        offset += cmdsize
    return False


def _strip_codesig(data, base):
    """Strip LC_CODE_SIGNATURE if it's the last load command.

    Zeros out the command bytes and decrements ncmds/sizeofcmds.
    Returns the cmdsize of the removed command, or 0 if not stripped.
    Since the binary will be re-signed by ldid, this is always safe.
    """
    ncmds = struct.unpack_from("<I", data, base + 16)[0]
    sizeofcmds = struct.unpack_from("<I", data, base + 20)[0]

    offset = base + 32
    last_offset = -1
    last_cmd = 0
    last_cmdsize = 0

    for i in range(ncmds):
        cmd, cmdsize = struct.unpack_from("<II", data, offset)
        if i == ncmds - 1:
            last_offset = offset
            last_cmd = cmd
            last_cmdsize = cmdsize
        offset += cmdsize

    if last_cmd != 0x1D:  # LC_CODE_SIGNATURE
        return 0

    # Zero out the LC_CODE_SIGNATURE command
    data[last_offset : last_offset + last_cmdsize] = b"\x00" * last_cmdsize

    # Update header
    struct.pack_into("<I", data, base + 16, ncmds - 1)
    struct.pack_into("<I", data, base + 20, sizeofcmds - last_cmdsize)

    print(f"  Stripped LC_CODE_SIGNATURE ({last_cmdsize} bytes freed)")
    return last_cmdsize


def _inject_lc_load_dylib(data, base, dylib_path):
    """Inject LC_LOAD_DYLIB into a single Mach-O slice starting at `base`.

    Strategy (matches optool/insert_dylib behavior):
    1. Try to fit new LC in existing zero-padding after load commands.
    2. If not enough space, strip LC_CODE_SIGNATURE (re-signed by ldid anyway).
    3. If still not enough, allow header to overflow into section data
       (same approach as optool — the overwritten bytes are typically stub
       code that the jailbreak hook replaces).

    Returns True on success.
    """
    magic = struct.unpack_from("<I", data, base)[0]
    if magic != 0xFEEDFACF:
        print(f"  [-] Not a 64-bit Mach-O at offset 0x{base:X}")
        return False

    ncmds = struct.unpack_from("<I", data, base + 16)[0]
    sizeofcmds = struct.unpack_from("<I", data, base + 20)[0]

    # Build the LC_LOAD_DYLIB command
    name_bytes = dylib_path.encode("ascii") + b"\x00"
    name_offset_in_cmd = 24  # sizeof(dylib_command) header
    cmd_size = _align(name_offset_in_cmd + len(name_bytes), 8)
    lc_data = bytearray(cmd_size)

    struct.pack_into("<I", lc_data, 0, 0xC)  # cmd = LC_LOAD_DYLIB
    struct.pack_into("<I", lc_data, 4, cmd_size)  # cmdsize
    struct.pack_into("<I", lc_data, 8, name_offset_in_cmd)  # name offset
    struct.pack_into("<I", lc_data, 12, 2)  # timestamp
    struct.pack_into("<I", lc_data, 16, 0)  # current_version
    struct.pack_into("<I", lc_data, 20, 0)  # compat_version
    lc_data[name_offset_in_cmd : name_offset_in_cmd + len(name_bytes)] = name_bytes

    # Check available space
    header_end = base + 32 + sizeofcmds  # end of current load commands
    first_section = _find_first_section_offset(data[base:])
    if first_section < 0:
        print(f"  [-] Could not determine section offsets")
        return False
    first_section_abs = base + first_section
    available = first_section_abs - header_end

    print(f"  Header end: 0x{header_end:X}, first section: 0x{first_section_abs:X}, "
          f"available: {available}, need: {cmd_size}")

    if available < cmd_size:
        # Strip LC_CODE_SIGNATURE to reclaim header space (re-signed by ldid)
        freed = _strip_codesig(data, base)
        if freed > 0:
            ncmds = struct.unpack_from("<I", data, base + 16)[0]
            sizeofcmds = struct.unpack_from("<I", data, base + 20)[0]
            header_end = base + 32 + sizeofcmds
            available = first_section_abs - header_end
            print(f"  After strip: available={available}, need={cmd_size}")

    if available < cmd_size:
        overflow = cmd_size - available
        # Allow up to 256 bytes overflow (same behavior as optool/insert_dylib)
        if overflow > 256:
            print(f"  [-] Would overflow {overflow} bytes into section data (too much)")
            return False
        print(f"  [!] Header overflow: {overflow} bytes into section data "
              f"(same as optool — binary will be re-signed)")

    # Write the new load command at the end of existing commands
    data[header_end : header_end + cmd_size] = lc_data

    # Update header: ncmds += 1, sizeofcmds += cmd_size
    struct.pack_into("<I", data, base + 16, ncmds + 1)
    struct.pack_into("<I", data, base + 20, sizeofcmds + cmd_size)

    return True


def inject_dylib(filepath, dylib_path):
    """Inject LC_LOAD_DYLIB into a Mach-O binary (thin or universal/FAT).

    Equivalent to: optool install -c load -p <dylib_path> -t <filepath>
    """
    data = bytearray(open(filepath, "rb").read())
    slices = _get_fat_slices(bytes(data))

    injected = 0
    for slice_off, slice_size in slices:
        if _check_existing_dylib(data, slice_off, dylib_path):
            print(f"  [!] Dylib already loaded in slice at 0x{slice_off:X}, skipping")
            injected += 1
            continue

        if _inject_lc_load_dylib(data, slice_off, dylib_path):
            print(f"  [+] Injected LC_LOAD_DYLIB '{dylib_path}' at slice 0x{slice_off:X}")
            injected += 1

    if injected == len(slices):
        open(filepath, "wb").write(data)
        print(f"  [+] Wrote {filepath} ({injected} slice(s) patched)")
        return True
    else:
        print(f"  [-] Only {injected}/{len(slices)} slices patched")
        return False


# ══════════════════════════════════════════════════════════════════
# BuildManifest parsing
# ══════════════════════════════════════════════════════════════════


def parse_cryptex_paths(manifest_path):
    """Extract Cryptex DMG paths from BuildManifest.plist.

    Searches ALL BuildIdentities for:
    - Cryptex1,SystemOS -> Info -> Path
    - Cryptex1,AppOS -> Info -> Path

    vResearch IPSWs may have Cryptex entries in a non-first identity.
    """
    with open(manifest_path, "rb") as f:
        manifest = plistlib.load(f)

    # Search all BuildIdentities for Cryptex paths
    for bi in manifest.get("BuildIdentities", []):
        m = bi.get("Manifest", {})
        sysos = m.get("Cryptex1,SystemOS", {}).get("Info", {}).get("Path", "")
        appos = m.get("Cryptex1,AppOS", {}).get("Info", {}).get("Path", "")
        if sysos and appos:
            return sysos, appos

    print("[-] Cryptex1,SystemOS/AppOS paths not found in any BuildIdentity",
          file=sys.stderr)
    sys.exit(1)


# ══════════════════════════════════════════════════════════════════
# LaunchDaemon injection
# ══════════════════════════════════════════════════════════════════


def inject_daemons(plist_path, daemon_dir):
    """Inject bash/dropbear/trollvnc entries into launchd.plist."""
    # Convert to XML first (macOS binary plist -> XML)
    subprocess.run(["plutil", "-convert", "xml1", plist_path],
                   capture_output=True)

    with open(plist_path, "rb") as f:
        target = plistlib.load(f)

    for name in ("bash", "dropbear", "trollvnc"):
        src = os.path.join(daemon_dir, f"{name}.plist")
        if not os.path.exists(src):
            print(f"  [!] Missing {src}, skipping")
            continue

        with open(src, "rb") as f:
            daemon = plistlib.load(f)

        key = f"/System/Library/LaunchDaemons/{name}.plist"
        target.setdefault("LaunchDaemons", {})[key] = daemon
        print(f"  [+] Injected {name}")

    with open(plist_path, "wb") as f:
        plistlib.dump(target, f, sort_keys=False)


# ══════════════════════════════════════════════════════════════════
# CLI
# ══════════════════════════════════════════════════════════════════


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    cmd = sys.argv[1]

    if cmd == "cryptex-paths":
        if len(sys.argv) < 3:
            print("Usage: patch_cfw.py cryptex-paths <BuildManifest.plist>")
            sys.exit(1)
        sysos, appos = parse_cryptex_paths(sys.argv[2])
        print(sysos)
        print(appos)

    elif cmd == "patch-seputil":
        if len(sys.argv) < 3:
            print("Usage: patch_cfw.py patch-seputil <binary>")
            sys.exit(1)
        if not patch_seputil(sys.argv[2]):
            sys.exit(1)

    elif cmd == "patch-launchd-cache-loader":
        if len(sys.argv) < 3:
            print("Usage: patch_cfw.py patch-launchd-cache-loader <binary>")
            sys.exit(1)
        if not patch_launchd_cache_loader(sys.argv[2]):
            sys.exit(1)

    elif cmd == "patch-mobileactivationd":
        if len(sys.argv) < 3:
            print("Usage: patch_cfw.py patch-mobileactivationd <binary>")
            sys.exit(1)
        if not patch_mobileactivationd(sys.argv[2]):
            sys.exit(1)

    elif cmd == "patch-launchd-jetsam":
        if len(sys.argv) < 3:
            print("Usage: patch_cfw.py patch-launchd-jetsam <binary>")
            sys.exit(1)
        if not patch_launchd_jetsam(sys.argv[2]):
            sys.exit(1)

    elif cmd == "inject-daemons":
        if len(sys.argv) < 4:
            print("Usage: patch_cfw.py inject-daemons <launchd.plist> <daemon_dir>")
            sys.exit(1)
        inject_daemons(sys.argv[2], sys.argv[3])

    elif cmd == "inject-dylib":
        if len(sys.argv) < 4:
            print("Usage: patch_cfw.py inject-dylib <binary> <dylib_path>")
            sys.exit(1)
        if not inject_dylib(sys.argv[2], sys.argv[3]):
            sys.exit(1)

    else:
        print(f"Unknown command: {cmd}")
        print("Commands: cryptex-paths, patch-seputil, patch-launchd-cache-loader,")
        print("          patch-mobileactivationd, patch-launchd-jetsam,")
        print("          inject-daemons, inject-dylib")
        sys.exit(1)


if __name__ == "__main__":
    main()

```

`scripts/patchers/iboot.py`:

```py
#!/usr/bin/env python3
"""
iboot_patcher.py — Dynamic patcher for iBoot-based images (iBSS, iBEC, LLB).

Finds all patch sites by string anchors, instruction patterns, and unique
error-code constants — NO hardcoded offsets.  Works across iBoot variants
as long as the code structure is preserved.

iBSS, iBEC, and LLB share the same raw binary; the difference is which
patches are applied:
  - iBSS:  serial labels + image4 callback bypass
  - iBEC:  iBSS + boot-args
  - LLB:   iBEC + rootfs bypass (6 patches) + panic bypass

Dependencies:  keystone-engine, capstone
"""

import struct
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN as KS_MODE_LE
from capstone import Cs, CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN

# ── Assembly / disassembly singletons ──────────────────────────
_ks = Ks(KS_ARCH_ARM64, KS_MODE_LE)
_cs = Cs(CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN)
_cs.detail = True
_cs.skipdata = True


def _asm(s):
    enc, _ = _ks.asm(s)
    if not enc:
        raise RuntimeError(f"asm failed: {s}")
    return bytes(enc)


NOP      = _asm("nop")
MOV_X0_0 = _asm("mov x0, #0")
PACIBSP  = _asm("hint #27")


def _rd32(buf, off):
    return struct.unpack_from("<I", buf, off)[0]


def _wr32(buf, off, v):
    struct.pack_into("<I", buf, off, v)


def _disasm_one(data, off):
    insns = list(_cs.disasm(data[off:off + 4], off))
    return insns[0] if insns else None


def _disasm_n(data, off, n):
    return list(_cs.disasm(data[off:off + n * 4], off))


def _find_asm_pattern(data, asm_str):
    """Find all file offsets where the assembled instruction appears."""
    enc, _ = _ks.asm(asm_str)
    pattern = bytes(enc)
    results = []
    off = 0
    while True:
        idx = data.find(pattern, off)
        if idx < 0:
            break
        results.append(idx)
        off = idx + 4
    return results


def _encode_b(pc, target):
    """Encode an unconditional `b` instruction at pc targeting target."""
    offset = (target - pc) >> 2
    return 0x14000000 | (offset & 0x3FFFFFF)


def _encode_adrp(rd, pc, target):
    imm = ((target & ~0xFFF) - (pc & ~0xFFF)) >> 12
    imm &= (1 << 21) - 1
    return 0x90000000 | ((imm & 3) << 29) | ((imm >> 2) << 5) | (rd & 0x1F)


def _encode_add_imm12(rd, rn, imm12):
    return 0x91000000 | ((imm12 & 0xFFF) << 10) | ((rn & 0x1F) << 5) | (rd & 0x1F)


# ── IBootPatcher ───────────────────────────────────────────────

class IBootPatcher:
    """Dynamic patcher for iBoot binaries (iBSS / iBEC / LLB).

    mode controls which patches are applied:
      'ibss' — serial labels + image4 callback
      'ibec' — ibss + boot-args
      'llb'  — ibec + rootfs bypass + panic bypass
    """

    BOOT_ARGS = b"serial=3 -v debug=0x2014e %s"
    CHUNK_SIZE, OVERLAP = 0x2000, 0x100

    def __init__(self, data, mode='ibss', label=None, verbose=True):
        self.data    = data            # bytearray (mutable)
        self.raw     = bytes(data)     # immutable snapshot
        self.size    = len(data)
        self.mode    = mode
        self.label   = label or f"Loaded {mode.upper()}"
        self.verbose = verbose
        self.patches = []

    def _log(self, msg):
        if self.verbose:
            print(msg)

    # ── emit / apply ───────────────────────────────────────────
    def emit(self, off, patch_bytes, desc):
        self.patches.append((off, patch_bytes, desc))
        if self.verbose:
            original = self.raw[off:off + len(patch_bytes)]
            before_insns = _disasm_n(self.raw, off, len(patch_bytes) // 4)
            after_insns = list(_cs.disasm(patch_bytes, off))
            b_str = "; ".join(f"{i.mnemonic} {i.op_str}" for i in before_insns) or "???"
            a_str = "; ".join(f"{i.mnemonic} {i.op_str}" for i in after_insns) or "???"
            print(f"  0x{off:06X}: {b_str} → {a_str}  [{desc}]")

    def emit_string(self, off, data_bytes, desc):
        """Record a string/data patch (not disassemblable)."""
        self.patches.append((off, data_bytes, desc))
        if self.verbose:
            try:
                txt = data_bytes.decode('ascii')
            except Exception:
                txt = data_bytes.hex()
            print(f"  0x{off:06X}: → {repr(txt)}  [{desc}]")

    def apply(self):
        """Find all patches, apply them, return count."""
        self.find_all()
        for off, pb, _ in self.patches:
            self.data[off:off + len(pb)] = pb

        if self.verbose and self.patches:
            self._log(f"\n  [{len(self.patches)} {self.mode.upper()} patches applied]")
        return len(self.patches)

    # ── Master find ────────────────────────────────────────────
    def find_all(self):
        self.patches = []

        self.patch_serial_labels()
        self.patch_image4_callback()

        if self.mode in ('ibec', 'llb'):
            self.patch_boot_args()

        if self.mode == 'llb':
            self.patch_rootfs_bypass()
            self.patch_panic_bypass()

        return self.patches

    # ═══════════════════════════════════════════════════════════
    #  1. Serial labels — find two long '====...' banner runs
    # ═══════════════════════════════════════════════════════════
    def patch_serial_labels(self):
        label_bytes = self.label.encode() if isinstance(self.label, str) else self.label
        eq_runs = []
        i = 0
        while i < self.size:
            if self.raw[i] == ord('='):
                start = i
                while i < self.size and self.raw[i] == ord('='):
                    i += 1
                if i - start >= 20:
                    eq_runs.append(start)
            else:
                i += 1

        if len(eq_runs) < 2:
            self._log("  [-] serial labels: <2 banner runs found")
            return

        for run_start in eq_runs[:2]:
            write_off = run_start + 1
            self.emit_string(write_off, label_bytes, f"serial label")

    # ═══════════════════════════════════════════════════════════
    #  2. image4_validate_property_callback
    #     Pattern: b.ne + mov x0, x22 (preceded by cmp within 8 insns)
    #     Patch: b.ne → NOP, mov x0, x22 → mov x0, #0
    # ═══════════════════════════════════════════════════════════
    def patch_image4_callback(self):
        candidates = []
        for insns in self._chunked_disasm():
            for i in range(len(insns) - 1):
                if insns[i].mnemonic != "b.ne":
                    continue
                if not (insns[i + 1].mnemonic == "mov"
                        and insns[i + 1].op_str == "x0, x22"):
                    continue
                addr = insns[i].address
                if not any(insns[j].mnemonic == "cmp"
                           for j in range(max(0, i - 8), i)):
                    continue
                # Prefer candidate with movn w22 (sets -1) earlier
                neg1 = any(
                    (insns[j].mnemonic == "movn"
                     and insns[j].op_str.startswith("w22,"))
                    or (insns[j].mnemonic == "mov"
                        and "w22" in insns[j].op_str
                        and ("#-1" in insns[j].op_str
                             or "#0xffffffff" in insns[j].op_str))
                    for j in range(max(0, i - 64), i)
                )
                candidates.append((addr, neg1))

        if not candidates:
            self._log("  [-] image4 callback: pattern not found")
            return

        # Prefer the candidate with the movn w22 (error return -1)
        off = None
        for a, n in candidates:
            if n:
                off = a
                break
        if off is None:
            off = candidates[-1][0]

        self.emit(off, NOP, "image4 callback: b.ne → nop")
        self.emit(off + 4, MOV_X0_0, "image4 callback: mov x0,x22 → mov x0,#0")

    # ═══════════════════════════════════════════════════════════
    #  3. Boot-args — redirect ADRP+ADD x2 to custom string
    # ═══════════════════════════════════════════════════════════
    def patch_boot_args(self, new_args=None):
        if new_args is None:
            new_args = self.BOOT_ARGS

        # Find the standalone "%s" format string near "rd=md0"
        fmt_off = self._find_boot_args_fmt()
        if fmt_off < 0:
            self._log("  [-] boot-args: format string not found")
            return

        # Find ADRP+ADD x2 referencing it
        adrp_off, add_off = self._find_boot_args_adrp(fmt_off)
        if adrp_off < 0:
            self._log("  [-] boot-args: ADRP+ADD x2 not found")
            return

        # Find a NUL slot for the new string
        new_off = self._find_string_slot(len(new_args))
        if new_off < 0:
            self._log("  [-] boot-args: no NUL slot")
            return

        self.emit_string(new_off, new_args, "boot-args string")
        new_adrp = struct.pack("<I", _encode_adrp(2, adrp_off, new_off))
        new_add = struct.pack("<I", _encode_add_imm12(2, 2, new_off & 0xFFF))
        self.emit(adrp_off, new_adrp, "boot-args: adrp x2 → new string page")
        self.emit(add_off, new_add, "boot-args: add x2 → new string offset")

    def _find_boot_args_fmt(self):
        anchor = self.raw.find(b"rd=md0")
        if anchor < 0:
            anchor = self.raw.find(b"BootArgs")
        if anchor < 0:
            return -1
        off = anchor
        while off < anchor + 0x40:
            off = self.raw.find(b"%s", off)
            if off < 0 or off >= anchor + 0x40:
                return -1
            if self.raw[off - 1] == 0 and self.raw[off + 2] == 0:
                return off
            off += 1
        return -1

    def _find_boot_args_adrp(self, fmt_off):
        for insns in self._chunked_disasm():
            for i in range(len(insns) - 1):
                a, b = insns[i], insns[i + 1]
                if a.mnemonic != "adrp" or b.mnemonic != "add":
                    continue
                if a.op_str.split(",")[0].strip() != "x2":
                    continue
                if len(a.operands) < 2 or len(b.operands) < 3:
                    continue
                if a.operands[0].reg != b.operands[1].reg:
                    continue
                if a.operands[1].imm + b.operands[2].imm == fmt_off:
                    return a.address, b.address
        return -1, -1

    def _find_string_slot(self, string_len, search_start=0x14000):
        off = search_start
        while off < self.size:
            if self.raw[off] == 0:
                run_start = off
                while off < self.size and self.raw[off] == 0:
                    off += 1
                if off - run_start >= 64:
                    write_off = (run_start + 8 + 15) & ~15
                    if write_off + string_len <= off:
                        return write_off
            else:
                off += 1
        return -1

    # ═══════════════════════════════════════════════════════════
    #  4. LLB rootfs bypass — 6 patches in two functions
    # ═══════════════════════════════════════════════════════════
    def patch_rootfs_bypass(self):
        # ── 4a: cbz w0 → unconditional b  (error code 0x3B7) ──
        self._patch_cbz_before_error(0x3B7, "rootfs: skip sig check (0x3B7)")

        # ── 4b: cmp x8, #0x400; b.hs → nop ────────────────────
        self._patch_bhs_after_cmp_0x400()

        # ── 4c: cbz w0 → unconditional b  (error code 0x3C2) ──
        self._patch_cbz_before_error(0x3C2, "rootfs: skip sig verify (0x3C2)")

        # ── 4d: cbz x8 → nop  (ldr xR, [xN, #0x78]) ──────────
        self._patch_null_check_0x78()

        # ── 4e: cbz w0 → unconditional b  (error code 0x110) ──
        self._patch_cbz_before_error(0x110, "rootfs: skip size verify (0x110)")

    def _patch_cbz_before_error(self, error_code, desc):
        """Find unique 'mov w8, #<error_code>', cbz/cbnz is 4 bytes before.
        Convert conditional branch to unconditional b to same target."""
        locs = _find_asm_pattern(self.raw, f"mov w8, #{error_code}")
        if len(locs) != 1:
            self._log(f"  [-] {desc}: expected 1 'mov w8, #{error_code:#x}', "
                       f"found {len(locs)}")
            return

        err_off = locs[0]
        cbz_off = err_off - 4
        insn = _disasm_one(self.raw, cbz_off)
        if not insn or insn.mnemonic not in ('cbz', 'cbnz'):
            self._log(f"  [-] {desc}: expected cbz/cbnz at 0x{cbz_off:X}, "
                       f"got {insn.mnemonic if insn else '???'}")
            return

        # Extract the branch target from the conditional instruction
        target = insn.operands[1].imm
        b_word = _encode_b(cbz_off, target)
        self.emit(cbz_off, struct.pack("<I", b_word), desc)

    def _patch_bhs_after_cmp_0x400(self):
        """Find unique 'cmp x8, #0x400', NOP the b.hs that follows."""
        locs = _find_asm_pattern(self.raw, "cmp x8, #0x400")
        if len(locs) != 1:
            self._log(f"  [-] rootfs b.hs: expected 1 'cmp x8, #0x400', "
                       f"found {len(locs)}")
            return

        cmp_off = locs[0]
        bhs_off = cmp_off + 4
        insn = _disasm_one(self.raw, bhs_off)
        if not insn or insn.mnemonic != 'b.hs':
            self._log(f"  [-] rootfs b.hs: expected b.hs at 0x{bhs_off:X}, "
                       f"got {insn.mnemonic if insn else '???'}")
            return

        self.emit(bhs_off, NOP, "rootfs: NOP b.hs size check (0x400)")

    def _patch_null_check_0x78(self):
        """Find 'ldr x8, [xN, #0x78]; cbz x8' preceding unique error 0x110.
        NOP the cbz."""
        locs = _find_asm_pattern(self.raw, "mov w8, #0x110")
        if len(locs) != 1:
            self._log(f"  [-] rootfs null check: expected 1 'mov w8, #0x110', "
                       f"found {len(locs)}")
            return

        err_off = locs[0]
        # Walk backwards from the error code to find ldr+cbz pattern
        for scan in range(err_off - 4, max(err_off - 0x300, 0), -4):
            i1 = _disasm_one(self.raw, scan)
            i2 = _disasm_one(self.raw, scan + 4)
            if (i1 and i2
                    and i1.mnemonic == 'ldr' and '#0x78' in i1.op_str
                    and i2.mnemonic == 'cbz' and i2.op_str.startswith('x')):
                self.emit(scan + 4, NOP,
                          "rootfs: NOP cbz x8 null check (#0x78)")
                return

        self._log("  [-] rootfs null check: ldr+cbz #0x78 pattern not found")

    # ═══════════════════════════════════════════════════════════
    #  5. LLB panic bypass
    #     Pattern: mov w8, #0x328; movk w8, #0x40, lsl #16;
    #              str wzr, ...; str wzr, ...; bl X; cbnz w0
    #     Patch: NOP the cbnz
    # ═══════════════════════════════════════════════════════════
    def patch_panic_bypass(self):
        mov328_locs = _find_asm_pattern(self.raw, "mov w8, #0x328")
        for loc in mov328_locs:
            # Verify movk w8, #0x40, lsl #16 follows
            next_insn = _disasm_one(self.raw, loc + 4)
            if not (next_insn and next_insn.mnemonic == 'movk'
                    and 'w8' in next_insn.op_str
                    and '#0x40' in next_insn.op_str
                    and 'lsl #16' in next_insn.op_str):
                continue

            # Walk forward to find bl; cbnz w0
            for step in range(loc + 8, loc + 32, 4):
                i = _disasm_one(self.raw, step)
                if i and i.mnemonic == 'bl':
                    ni = _disasm_one(self.raw, step + 4)
                    if ni and ni.mnemonic == 'cbnz':
                        self.emit(step + 4, NOP,
                                  "panic bypass: NOP cbnz w0")
                        return
                    break

        self._log("  [-] panic bypass: pattern not found")

    # ── Chunked disassembly helper ─────────────────────────────
    def _chunked_disasm(self):
        off = 0
        while off < self.size:
            end = min(off + self.CHUNK_SIZE, self.size)
            insns = list(_cs.disasm(self.raw[off:end], off))
            yield insns
            off += self.CHUNK_SIZE - self.OVERLAP


# ── CLI entry point ────────────────────────────────────────────
if __name__ == "__main__":
    import sys, argparse

    parser = argparse.ArgumentParser(
        description="Dynamic iBoot patcher (iBSS / iBEC / LLB)")
    parser.add_argument("firmware", help="Path to raw or IM4P iBoot image")
    parser.add_argument("-m", "--mode", choices=["ibss", "ibec", "llb"],
                        default="llb",
                        help="Patch mode (default: llb = all patches)")
    parser.add_argument("-l", "--label", default=None,
                        help="Serial label text (default: 'Loaded MODE')")
    parser.add_argument("-q", "--quiet", action="store_true")
    args = parser.parse_args()

    print(f"Loading {args.firmware}...")
    file_raw = open(args.firmware, "rb").read()

    # Auto-detect IM4P
    try:
        from pyimg4 import IM4P
        im4p = IM4P(file_raw)
        if im4p.payload.compression:
            im4p.payload.decompress()
        payload = im4p.payload.data
        print(f"  format: IM4P (fourcc={im4p.fourcc})")
    except Exception:
        payload = file_raw
        print(f"  format: raw")

    data = bytearray(payload)
    print(f"  size:   {len(data)} bytes ({len(data)/1024:.1f} KB)\n")

    patcher = IBootPatcher(data, mode=args.mode, label=args.label,
                           verbose=not args.quiet)
    n = patcher.apply()
    print(f"\n  {n} patches applied.")

```

`scripts/patchers/iboot_jb.py`:

```py
#!/usr/bin/env python3
"""
iboot_jb.py — Jailbreak extension patcher for iBoot-based images.

Currently adds iBSS-only nonce generation bypass used by fw_patch_jb.py.
"""

from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN as KS_MODE_LE

from capstone.arm64_const import ARM64_OP_IMM, ARM64_OP_REG, ARM64_REG_W0

from .iboot import IBootPatcher, _disasm_one


_ks = Ks(KS_ARCH_ARM64, KS_MODE_LE)


class IBootJBPatcher(IBootPatcher):
    """JB-only patcher for iBoot images."""

    def _asm_at(self, asm_line, addr):
        enc, _ = _ks.asm(asm_line, addr=addr)
        if not enc:
            raise RuntimeError(f"asm failed at 0x{addr:X}: {asm_line}")
        return bytes(enc)

    def apply(self):
        self.patches = []
        if self.mode == "ibss":
            self.patch_skip_generate_nonce()

        for off, pb, _ in self.patches:
            self.data[off:off + len(pb)] = pb

        if self.verbose and self.patches:
            self._log(f"\n  [{len(self.patches)} {self.mode.upper()} JB patches applied]")
        return len(self.patches)

    def _find_refs_to_offset(self, target_off):
        refs = []
        for insns in self._chunked_disasm():
            for i in range(len(insns) - 1):
                a, b = insns[i], insns[i + 1]
                if a.mnemonic != "adrp" or b.mnemonic != "add":
                    continue
                if len(a.operands) < 2 or len(b.operands) < 3:
                    continue
                if a.operands[0].reg != b.operands[1].reg:
                    continue
                if a.operands[1].imm + b.operands[2].imm == target_off:
                    refs.append((a.address, b.address, b.operands[0].reg))
        return refs

    def _find_string_refs(self, needle):
        if isinstance(needle, str):
            needle = needle.encode()
        seen = set()
        refs = []
        off = 0
        while True:
            s_off = self.raw.find(needle, off)
            if s_off < 0:
                break
            off = s_off + 1
            for r in self._find_refs_to_offset(s_off):
                if r[0] not in seen:
                    seen.add(r[0])
                    refs.append(r)
        return refs

    def patch_skip_generate_nonce(self):
        refs = self._find_string_refs(b"boot-nonce")
        if not refs:
            self._log("  [-] iBSS JB: no refs to 'boot-nonce'")
            return False

        for _, add_off, _ in refs:
            for scan in range(add_off, min(add_off + 0x100, self.size - 12), 4):
                i0 = _disasm_one(self.raw, scan)
                i1 = _disasm_one(self.raw, scan + 4)
                i2 = _disasm_one(self.raw, scan + 8)
                if not i0 or not i1 or not i2:
                    continue
                if i0.mnemonic not in ("tbz", "tbnz"):
                    continue
                if len(i0.operands) < 3:
                    continue
                if not (i0.operands[0].type == ARM64_OP_REG
                        and i0.operands[0].reg == ARM64_REG_W0):
                    continue
                if not (i0.operands[1].type == ARM64_OP_IMM
                        and i0.operands[1].imm == 0):
                    continue
                if i1.mnemonic != "mov" or i1.op_str != "w0, #0":
                    continue
                if i2.mnemonic != "bl":
                    continue

                target = i0.operands[2].imm
                self.emit(scan, self._asm_at(f"b #0x{target:X}", scan),
                          "JB: skip generate_nonce")
                return True

        self._log("  [-] iBSS JB: generate_nonce branch pattern not found")
        return False

```

`scripts/patchers/kernel.py`:

```py
#!/usr/bin/env python3
"""
kernel_patcher.py — Dynamic kernel patcher for iOS prelinked kernelcaches.

Finds all patch sites by string anchors, ADRP+ADD cross-references,
BL frequency analysis, and Mach-O structure parsing.  Nothing is hardcoded;
works across kernel variants (vresearch101, vphone600, etc.).

Dependencies:  keystone-engine, capstone
"""

import struct, plistlib
from collections import defaultdict
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN as KS_MODE_LE
from capstone import Cs, CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN
from capstone.arm64_const import (ARM64_OP_REG, ARM64_OP_IMM,
                                  ARM64_REG_W0, ARM64_REG_X0, ARM64_REG_X8)

# ── Assembly / disassembly helpers ───────────────────────────────
_ks = Ks(KS_ARCH_ARM64, KS_MODE_LE)
_cs = Cs(CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN)
_cs.detail = True


def asm(s):
    enc, _ = _ks.asm(s)
    if not enc:
        raise RuntimeError(f"asm failed: {s}")
    return bytes(enc)


NOP       = asm("nop")
MOV_X0_0  = asm("mov x0, #0")
MOV_X0_1  = asm("mov x0, #1")
MOV_W0_0  = asm("mov w0, #0")
MOV_W0_1  = asm("mov w0, #1")
RET       = asm("ret")
CMP_W0_W0 = asm("cmp w0, w0")
CMP_X0_X0 = asm("cmp x0, x0")


def _asm_u32(s):
    """Assemble a single instruction and return its uint32 encoding."""
    return struct.unpack("<I", asm(s))[0]


def _verify_disas(u32_val, expected_mnemonic):
    """Verify a uint32 encoding disassembles to expected mnemonic via capstone."""
    code = struct.pack("<I", u32_val)
    insns = list(_cs.disasm(code, 0, 1))
    assert insns and insns[0].mnemonic == expected_mnemonic, \
        f"0x{u32_val:08X} disassembles to {insns[0].mnemonic if insns else '???'}, expected {expected_mnemonic}"
    return u32_val


# Named instruction constants (via keystone where possible, capstone-verified otherwise)
_PACIBSP_U32 = _asm_u32("hint #27")     # keystone doesn't know 'pacibsp'
_RET_U32     = _asm_u32("ret")
_RETAA_U32   = _verify_disas(0xD65F0BFF, "retaa")   # keystone can't assemble PAC returns
_RETAB_U32   = _verify_disas(0xD65F0FFF, "retab")   # verified via capstone disassembly
_FUNC_BOUNDARY_U32S = frozenset((_RET_U32, _RETAA_U32, _RETAB_U32, _PACIBSP_U32))


def _rd32(buf, off):
    return struct.unpack_from("<I", buf, off)[0]


def _rd64(buf, off):
    return struct.unpack_from("<Q", buf, off)[0]


# ── KernelPatcher ────────────────────────────────────────────────

class KernelPatcher:
    """Dynamic kernel patcher — all offsets found at runtime."""

    def __init__(self, data, verbose=True):
        self.data    = data            # bytearray (mutable)
        self.raw     = bytes(data)     # immutable snapshot for searching
        self.size    = len(data)
        self.patches = []              # collected (offset, bytes, description)
        self.verbose = verbose

        self._log("[*] Parsing Mach-O segments …")
        self._parse_macho()

        self._log("[*] Discovering kext code ranges from __PRELINK_INFO …")
        self._discover_kext_ranges()

        self._log("[*] Building ADRP index …")
        self._build_adrp_index()

        self._log("[*] Building BL index …")
        self._build_bl_index()

        self._find_panic()
        self._log(f"[*] _panic at foff 0x{self.panic_off:X}  "
                  f"({len(self.bl_callers[self.panic_off])} callers)")

    # ── Logging ──────────────────────────────────────────────────
    def _log(self, msg):
        if self.verbose:
            print(msg)

    # ── Mach-O / segment parsing ─────────────────────────────────
    def _parse_macho(self):
        """Parse top-level Mach-O: discover BASE_VA, segments, code ranges."""
        magic = _rd32(self.raw, 0)
        if magic != 0xFEEDFACF:
            raise ValueError(f"Not a 64-bit Mach-O (magic 0x{magic:08X})")

        self.code_ranges  = []   # [(start_foff, end_foff), ...]
        self.all_segments = []   # [(name, vmaddr, fileoff, filesize, initprot)]
        self.base_va      = None

        ncmds = struct.unpack_from("<I", self.raw, 16)[0]
        off = 32  # past mach_header_64
        for _ in range(ncmds):
            cmd, cmdsize = struct.unpack_from("<II", self.raw, off)
            if cmd == 0x19:  # LC_SEGMENT_64
                segname = self.raw[off+8:off+24].split(b'\x00')[0].decode()
                vmaddr, vmsize, fileoff, filesize = struct.unpack_from(
                    "<QQQQ", self.raw, off + 24)
                initprot = struct.unpack_from("<I", self.raw, off + 60)[0]
                self.all_segments.append(
                    (segname, vmaddr, fileoff, filesize, initprot))
                if segname == "__TEXT":
                    self.base_va = vmaddr
                CODE_SEGS = ("__PRELINK_TEXT", "__TEXT_EXEC", "__TEXT_BOOT_EXEC")
                if segname in CODE_SEGS and filesize > 0:
                    self.code_ranges.append((fileoff, fileoff + filesize))
            off += cmdsize

        if self.base_va is None:
            raise ValueError("__TEXT segment not found — cannot determine BASE_VA")

        self.code_ranges.sort()
        total_mb = sum(e - s for s, e in self.code_ranges) / (1024 * 1024)
        self._log(f"  BASE_VA = 0x{self.base_va:016X}")
        self._log(f"  {len(self.code_ranges)} executable ranges, total {total_mb:.1f} MB")

    def _va(self, foff):
        return self.base_va + foff

    def _foff(self, va):
        return va - self.base_va

    # ── Kext range discovery ─────────────────────────────────────
    def _discover_kext_ranges(self):
        """Parse __PRELINK_INFO + embedded kext Mach-Os to find code section ranges."""
        self.kext_ranges = {}   # bundle_id -> (text_start, text_end)

        # Find __PRELINK_INFO segment
        prelink_info = None
        for name, vmaddr, fileoff, filesize, _ in self.all_segments:
            if name == "__PRELINK_INFO":
                prelink_info = (fileoff, filesize)
                break

        if prelink_info is None:
            self._log("  [-] __PRELINK_INFO not found, using __TEXT_EXEC for all")
            self._set_fallback_ranges()
            return

        foff, fsize = prelink_info
        pdata = self.raw[foff:foff + fsize]

        # Parse the XML plist
        xml_start = pdata.find(b"<?xml")
        xml_end = pdata.find(b"</plist>")
        if xml_start < 0 or xml_end < 0:
            self._log("  [-] __PRELINK_INFO plist not found")
            self._set_fallback_ranges()
            return

        xml = pdata[xml_start:xml_end + len(b"</plist>")]
        pl = plistlib.loads(xml)
        items = pl.get("_PrelinkInfoDictionary", [])

        # Kexts we need ranges for
        WANTED = {
            "com.apple.filesystems.apfs": "apfs",
            "com.apple.security.sandbox": "sandbox",
            "com.apple.driver.AppleMobileFileIntegrity": "amfi",
        }

        for item in items:
            bid = item.get("CFBundleIdentifier", "")
            tag = WANTED.get(bid)
            if tag is None:
                continue

            exec_addr = item.get("_PrelinkExecutableLoadAddr", 0) & 0xFFFFFFFFFFFFFFFF
            kext_foff = exec_addr - self.base_va
            if kext_foff < 0 or kext_foff >= self.size:
                continue

            # Parse this kext's embedded Mach-O to find __TEXT_EXEC.__text
            text_range = self._parse_kext_text_exec(kext_foff)
            if text_range:
                self.kext_ranges[tag] = text_range
                self._log(f"  {tag:10s} __text: 0x{text_range[0]:08X} - 0x{text_range[1]:08X} "
                          f"({(text_range[1]-text_range[0])//1024} KB)")

        # Derive the ranges used by patch methods
        self._set_ranges_from_kexts()

    def _parse_kext_text_exec(self, kext_foff):
        """Parse an embedded kext Mach-O header and return (__text start, end) in file offsets."""
        if kext_foff + 32 > self.size:
            return None
        magic = _rd32(self.raw, kext_foff)
        if magic != 0xFEEDFACF:
            return None

        ncmds = struct.unpack_from("<I", self.raw, kext_foff + 16)[0]
        off = kext_foff + 32
        for _ in range(ncmds):
            if off + 8 > self.size:
                break
            cmd, cmdsize = struct.unpack_from("<II", self.raw, off)
            if cmd == 0x19:  # LC_SEGMENT_64
                segname = self.raw[off+8:off+24].split(b'\x00')[0].decode()
                if segname == "__TEXT_EXEC":
                    vmaddr = struct.unpack_from("<Q", self.raw, off + 24)[0]
                    filesize = struct.unpack_from("<Q", self.raw, off + 48)[0]
                    nsects = struct.unpack_from("<I", self.raw, off + 64)[0]
                    # Parse sections to find __text
                    sect_off = off + 72
                    for _ in range(nsects):
                        if sect_off + 80 > self.size:
                            break
                        sectname = self.raw[sect_off:sect_off+16].split(b'\x00')[0].decode()
                        if sectname == "__text":
                            sect_addr = struct.unpack_from("<Q", self.raw, sect_off + 32)[0]
                            sect_size = struct.unpack_from("<Q", self.raw, sect_off + 40)[0]
                            sect_foff = sect_addr - self.base_va
                            return (sect_foff, sect_foff + sect_size)
                        sect_off += 80
                    # No __text section found, use the segment
                    seg_foff = vmaddr - self.base_va
                    return (seg_foff, seg_foff + filesize)
            off += cmdsize
        return None

    def _set_ranges_from_kexts(self):
        """Set patch-method ranges from discovered kext info, with fallbacks."""
        # Full __TEXT_EXEC range
        text_exec = None
        for name, vmaddr, fileoff, filesize, _ in self.all_segments:
            if name == "__TEXT_EXEC":
                text_exec = (fileoff, fileoff + filesize)
                break

        if text_exec is None:
            text_exec = (0, self.size)

        self.text_exec_range = text_exec
        self.apfs_text    = self.kext_ranges.get("apfs",    text_exec)
        self.amfi_text    = self.kext_ranges.get("amfi",    text_exec)
        self.sandbox_text = self.kext_ranges.get("sandbox", text_exec)
        # Kernel code = full __TEXT_EXEC (includes all kexts, but that's OK)
        self.kern_text    = text_exec

    def _set_fallback_ranges(self):
        """Use __TEXT_EXEC for everything when __PRELINK_INFO is unavailable."""
        text_exec = None
        for name, vmaddr, fileoff, filesize, _ in self.all_segments:
            if name == "__TEXT_EXEC":
                text_exec = (fileoff, fileoff + filesize)
                break
        if text_exec is None:
            text_exec = (0, self.size)

        self.text_exec_range = text_exec
        self.apfs_text    = text_exec
        self.amfi_text    = text_exec
        self.sandbox_text = text_exec
        self.kern_text    = text_exec

    # ── Index builders ───────────────────────────────────────────
    def _build_adrp_index(self):
        """Index ADRP instructions by target page for O(1) string-ref lookup."""
        self.adrp_by_page = defaultdict(list)
        for rng_start, rng_end in self.code_ranges:
            for off in range(rng_start, rng_end, 4):
                insn = _rd32(self.raw, off)
                if (insn & 0x9F000000) != 0x90000000:
                    continue
                rd    = insn & 0x1F
                immhi = (insn >> 5)  & 0x7FFFF
                immlo = (insn >> 29) & 0x3
                imm   = (immhi << 2) | immlo
                if imm & (1 << 20):
                    imm -= (1 << 21)
                pc   = self._va(off)
                page = (pc & ~0xFFF) + (imm << 12)
                self.adrp_by_page[page].append((off, rd))

        n = sum(len(v) for v in self.adrp_by_page.values())
        self._log(f"  {n} ADRP entries, {len(self.adrp_by_page)} distinct pages")

    def _build_bl_index(self):
        """Index BL instructions by target offset."""
        self.bl_callers = defaultdict(list)  # target_off -> [caller_off, ...]
        for rng_start, rng_end in self.code_ranges:
            for off in range(rng_start, rng_end, 4):
                insn = _rd32(self.raw, off)
                if (insn & 0xFC000000) != 0x94000000:
                    continue
                imm26 = insn & 0x3FFFFFF
                if imm26 & (1 << 25):
                    imm26 -= (1 << 26)
                target = off + imm26 * 4
                self.bl_callers[target].append(off)

    def _find_panic(self):
        """Find _panic: most-called function whose callers reference '@%s:%d' strings."""
        candidates = sorted(self.bl_callers.items(), key=lambda x: -len(x[1]))[:15]
        for target_off, callers in candidates:
            if len(callers) < 2000:
                break
            confirmed = 0
            for caller_off in callers[:30]:
                for back in range(caller_off - 4, max(caller_off - 32, 0), -4):
                    insn = _rd32(self.raw, back)
                    # ADD x0, x0, #imm
                    if (insn & 0xFFC003E0) == 0x91000000:
                        add_imm = (insn >> 10) & 0xFFF
                        if back >= 4:
                            prev = _rd32(self.raw, back - 4)
                            if (prev & 0x9F00001F) == 0x90000000:  # ADRP x0
                                immhi = (prev >> 5) & 0x7FFFF
                                immlo = (prev >> 29) & 0x3
                                imm = (immhi << 2) | immlo
                                if imm & (1 << 20):
                                    imm -= (1 << 21)
                                pc   = self._va(back - 4)
                                page = (pc & ~0xFFF) + (imm << 12)
                                str_foff = self._foff(page + add_imm)
                                if 0 <= str_foff < self.size - 10:
                                    snippet = self.raw[str_foff:str_foff + 60]
                                    if b"@%s:%d" in snippet or b"%s:%d" in snippet:
                                        confirmed += 1
                                        break
                        break
            if confirmed >= 3:
                self.panic_off = target_off
                return
        self.panic_off = candidates[2][0] if len(candidates) > 2 else candidates[0][0]

    # ── Helpers ──────────────────────────────────────────────────
    def _disas_at(self, off, count=1):
        """Disassemble *count* instructions at file offset.  Returns a list."""
        end = min(off + count * 4, self.size)
        if off < 0 or off >= self.size:
            return []
        code = bytes(self.raw[off:end])
        return list(_cs.disasm(code, off, count))

    def _is_bl(self, off):
        """Return BL target file offset, or -1 if not a BL."""
        insns = self._disas_at(off)
        if insns and insns[0].mnemonic == "bl":
            return insns[0].operands[0].imm
        return -1

    def _is_cond_branch_w0(self, off):
        """Return True if instruction is a conditional branch on w0 (cbz/cbnz/tbz/tbnz)."""
        insns = self._disas_at(off)
        if not insns:
            return False
        i = insns[0]
        if i.mnemonic in ("cbz", "cbnz", "tbz", "tbnz"):
            return i.operands[0].type == ARM64_OP_REG and i.operands[0].reg == ARM64_REG_W0
        return False

    def find_string(self, s, start=0):
        """Find string, return file offset of the enclosing C string start."""
        if isinstance(s, str):
            s = s.encode()
        off = self.raw.find(s, start)
        if off < 0:
            return -1
        # Walk backward to the preceding NUL — that's the C string start
        cstr = off
        while cstr > 0 and self.raw[cstr - 1] != 0:
            cstr -= 1
        return cstr

    def find_string_refs(self, str_off, code_start=None, code_end=None):
        """Find all (adrp_off, add_off, dest_reg) referencing str_off via ADRP+ADD."""
        target_va   = self._va(str_off)
        target_page = target_va & ~0xFFF
        page_off    = target_va & 0xFFF

        refs = []
        for adrp_off, rd in self.adrp_by_page.get(target_page, []):
            if code_start is not None and adrp_off < code_start:
                continue
            if code_end is not None and adrp_off >= code_end:
                continue
            if adrp_off + 4 >= self.size:
                continue
            nxt = _rd32(self.raw, adrp_off + 4)
            # ADD (imm) 64-bit: 1001_0001_00_imm12_Rn_Rd
            if (nxt & 0xFFC00000) != 0x91000000:
                continue
            add_rn  = (nxt >> 5)  & 0x1F
            add_imm = (nxt >> 10) & 0xFFF
            if add_rn == rd and add_imm == page_off:
                add_rd = nxt & 0x1F
                refs.append((adrp_off, adrp_off + 4, add_rd))
        return refs

    def find_function_start(self, off, max_back=0x4000):
        """Walk backwards to find PACIBSP or STP x29,x30,[sp,#imm].

        When STP x29,x30 is found, continues backward up to 0x20 more
        bytes to look for PACIBSP (ARM64e functions may have several STP
        instructions in the prologue before STP x29,x30).
        """
        for o in range(off - 4, max(off - max_back, 0), -4):
            insn = _rd32(self.raw, o)
            if insn == _PACIBSP_U32:
                return o
            dis = self._disas_at(o)
            if dis and dis[0].mnemonic == "stp" and "x29, x30, [sp" in dis[0].op_str:
                # Check further back for PACIBSP (prologue may have
                # multiple STP instructions before x29,x30)
                for k in range(o - 4, max(o - 0x24, 0), -4):
                    if _rd32(self.raw, k) == _PACIBSP_U32:
                        return k
                return o
        return -1

    def _disas_n(self, buf, off, count):
        """Disassemble *count* instructions from *buf* at file offset *off*."""
        end = min(off + count * 4, len(buf))
        if off < 0 or off >= len(buf):
            return []
        code = bytes(buf[off:end])
        return list(_cs.disasm(code, off, count))

    def _fmt_insn(self, insn, marker=""):
        """Format one capstone instruction for display."""
        raw = insn.bytes
        hex_str = " ".join(f"{b:02x}" for b in raw)
        s = f"  0x{insn.address:08X}: {hex_str:12s}  {insn.mnemonic:8s} {insn.op_str}"
        if marker:
            s += f"  {marker}"
        return s

    def _print_patch_context(self, off, patch_bytes, desc):
        """Print disassembly before/after a patch site for debugging."""
        ctx = 3  # instructions of context before and after
        # -- BEFORE (original bytes) --
        lines = [f"  ┌─ PATCH 0x{off:08X}: {desc}"]
        lines.append("  │ BEFORE:")
        start = max(off - ctx * 4, 0)
        before_insns = self._disas_n(self.raw, start, ctx + 1 + ctx)
        for insn in before_insns:
            if insn.address == off:
                lines.append(self._fmt_insn(insn, "  ◄━━ PATCHED"))
            elif off < insn.address < off + len(patch_bytes):
                lines.append(self._fmt_insn(insn, "  ◄━━ PATCHED"))
            else:
                lines.append(self._fmt_insn(insn))

        # -- AFTER (new bytes) --
        lines.append("  │ AFTER:")
        after_insns = self._disas_n(self.raw, start, ctx)
        for insn in after_insns:
            lines.append(self._fmt_insn(insn))
        # Decode the patch bytes themselves
        patch_insns = list(_cs.disasm(patch_bytes, off, len(patch_bytes) // 4))
        for insn in patch_insns:
            lines.append(self._fmt_insn(insn, "  ◄━━ NEW"))
        # Trailing context after the patch
        trail_start = off + len(patch_bytes)
        trail_insns = self._disas_n(self.raw, trail_start, ctx)
        for insn in trail_insns:
            lines.append(self._fmt_insn(insn))
        lines.append(f"  └─")
        self._log("\n".join(lines))

    def emit(self, off, patch_bytes, desc):
        """Record a patch and apply it to self.data immediately.

        Writing through to self.data ensures _find_code_cave() sees
        previously allocated shellcode and won't reuse the same cave.
        """
        self.patches.append((off, patch_bytes, desc))
        self.data[off:off + len(patch_bytes)] = patch_bytes
        if self.verbose:
            self._print_patch_context(off, patch_bytes, desc)

    def _find_by_string_in_range(self, string, code_range, label):
        """Find string, find ADRP+ADD ref in code_range, return ref list."""
        str_off = self.find_string(string)
        if str_off < 0:
            self._log(f"  [-] string not found: {string!r}")
            return []
        refs = self.find_string_refs(str_off, code_range[0], code_range[1])
        if not refs:
            self._log(f"  [-] no code refs to {label} (str at 0x{str_off:X})")
        return refs

    # ── Chained fixup pointer decoding ───────────────────────────
    def _decode_chained_ptr(self, val):
        """Decode an arm64e chained fixup pointer to a file offset.

        - auth rebase (bit63=1):     foff = bits[31:0]
        - non-auth rebase (bit63=0): VA = (bits[50:43] << 56) | bits[42:0]
        """
        if val == 0:
            return -1
        if val & (1 << 63):  # auth rebase
            return val & 0xFFFFFFFF
        else:  # non-auth rebase
            target = val & 0x7FFFFFFFFFF  # bits[42:0]
            high8  = (val >> 43) & 0xFF
            full_va = (high8 << 56) | target
            if full_va > self.base_va:
                return full_va - self.base_va
            return -1

    # ═══════════════════════════════════════════════════════════════
    # Per-patch finders
    # ═══════════════════════════════════════════════════════════════

    def patch_apfs_root_snapshot(self):
        """Patch 1: NOP the tbnz w8,#5 that gates sealed-volume root snapshot panic."""
        self._log("\n[1] _apfs_vfsop_mount: root snapshot sealed volume check")

        refs = self._find_by_string_in_range(
            b"Rooting from snapshot with xid",
            self.apfs_text, "apfs_vfsop_mount log")
        if not refs:
            refs = self._find_by_string_in_range(
                b"Failed to find the root snapshot",
                self.apfs_text, "root snapshot panic")
            if not refs:
                return False

        for adrp_off, add_off, _ in refs:
            for scan in range(add_off, min(add_off + 0x200, self.size), 4):
                insns = self._disas_at(scan)
                if not insns:
                    continue
                i = insns[0]
                if i.mnemonic not in ("tbnz", "tbz"):
                    continue
                # Check: tbz/tbnz w8, #5, ...
                ops = i.operands
                if (len(ops) >= 2
                        and ops[0].type == ARM64_OP_REG
                        and ops[1].type == ARM64_OP_IMM
                        and ops[1].imm == 5):
                    self.emit(scan, NOP,
                              f"NOP {i.mnemonic} {i.op_str} "
                              "(sealed vol check) [_apfs_vfsop_mount]")
                    return True

        self._log("  [-] tbz/tbnz w8,#5 not found near xref")
        return False

    def patch_apfs_seal_broken(self):
        """Patch 2: NOP the conditional branch leading to 'root volume seal is broken' panic."""
        self._log("\n[2] _authapfs_seal_is_broken: seal broken panic")

        str_off = self.find_string(b"root volume seal is broken")
        if str_off < 0:
            self._log("  [-] string not found")
            return False

        refs = self.find_string_refs(str_off, *self.apfs_text)
        if not refs:
            self._log("  [-] no code refs")
            return False

        for adrp_off, add_off, _ in refs:
            # Find BL _panic after string ref
            bl_off = -1
            for scan in range(add_off, min(add_off + 0x40, self.size), 4):
                bl_target = self._is_bl(scan)
                if bl_target == self.panic_off:
                    bl_off = scan
                    break

            if bl_off < 0:
                continue

            # Search backwards for a conditional branch that jumps INTO the
            # panic path.  The error block may set up __FILE__/line args
            # before the string ADRP, so allow target up to 0x40 before it.
            err_lo = adrp_off - 0x40
            for back in range(adrp_off - 4, max(adrp_off - 0x200, 0), -4):
                target, kind = self._decode_branch_target(back)
                if target is not None and err_lo <= target <= bl_off + 4:
                    self.emit(back, NOP,
                              f"NOP {kind} (seal broken) "
                              "[_authapfs_seal_is_broken]")
                    return True

        self._log("  [-] could not find conditional branch to NOP")
        return False

    _COND_BRANCH_MNEMONICS = frozenset((
        "b.eq", "b.ne", "b.cs", "b.hs", "b.cc", "b.lo",
        "b.mi", "b.pl", "b.vs", "b.vc", "b.hi", "b.ls",
        "b.ge", "b.lt", "b.gt", "b.le", "b.al",
        "cbz", "cbnz", "tbz", "tbnz",
    ))

    def _decode_branch_target(self, off):
        """Decode conditional branch at off via capstone. Returns (target, mnemonic) or (None, None)."""
        insns = self._disas_at(off)
        if not insns:
            return None, None
        i = insns[0]
        if i.mnemonic in self._COND_BRANCH_MNEMONICS:
            # Target is always the last IMM operand
            for op in reversed(i.operands):
                if op.type == ARM64_OP_IMM:
                    return op.imm, i.mnemonic
        return None, None

    def patch_bsd_init_rootvp(self):
        """Patch 3: NOP the conditional branch guarding the 'rootvp not authenticated' panic."""
        self._log("\n[3] _bsd_init: rootvp not authenticated panic")

        str_off = self.find_string(b"rootvp not authenticated after mounting")
        if str_off < 0:
            self._log("  [-] string not found")
            return False

        refs = self.find_string_refs(str_off, *self.kern_text)
        if not refs:
            self._log("  [-] no code refs in kernel __text")
            return False

        for adrp_off, add_off, _ in refs:
            # Find the BL _panic after the string ref
            bl_panic_off = -1
            for scan in range(add_off, min(add_off + 0x40, self.size), 4):
                bl_target = self._is_bl(scan)
                if bl_target == self.panic_off:
                    bl_panic_off = scan
                    break

            if bl_panic_off < 0:
                continue

            # Search backwards for a conditional branch whose target is in
            # the error path (the block ending with BL _panic).
            # The error path is typically a few instructions before BL _panic.
            err_lo = bl_panic_off - 0x40   # error block start (generous)
            err_hi = bl_panic_off + 4      # error block end

            for back in range(adrp_off - 4, max(adrp_off - 0x400, 0), -4):
                target, kind = self._decode_branch_target(back)
                if target is not None and err_lo <= target <= err_hi:
                    self.emit(back, NOP,
                              f"NOP {kind} (rootvp auth) [_bsd_init]")
                    return True

        self._log("  [-] conditional branch into panic path not found")
        return False

    def patch_proc_check_launch_constraints(self):
        """Patches 4-5: mov w0,#0; ret at _proc_check_launch_constraints start.

        The AMFI function does NOT reference the symbol name string
        '_proc_check_launch_constraints' — only the kernel wrapper does.
        Instead, use 'AMFI: Validation Category info' which IS referenced
        from the actual AMFI function.
        """
        self._log("\n[4-5] _proc_check_launch_constraints: stub with mov w0,#0; ret")

        str_off = self.find_string(b"AMFI: Validation Category info")
        if str_off < 0:
            self._log("  [-] 'AMFI: Validation Category info' string not found")
            return False

        refs = self.find_string_refs(str_off, *self.amfi_text)
        if not refs:
            self._log("  [-] no code refs in AMFI")
            return False

        for adrp_off, add_off, _ in refs:
            func_start = self.find_function_start(adrp_off)
            if func_start < 0:
                continue
            self.emit(func_start, MOV_W0_0,
                      "mov w0,#0 [_proc_check_launch_constraints]")
            self.emit(func_start + 4, RET,
                      "ret [_proc_check_launch_constraints]")
            return True

        self._log("  [-] function start not found")
        return False

    def _get_kernel_text_range(self):
        """Return (start, end) file offsets of the kernel's own __TEXT_EXEC.__text.

        Parses fileset entries (LC_FILESET_ENTRY) to find the kernel component,
        then reads its Mach-O header to get the __TEXT_EXEC.__text section.
        Falls back to the full __TEXT_EXEC segment.
        """
        # Try fileset entries
        ncmds = struct.unpack_from("<I", self.raw, 16)[0]
        off = 32
        for _ in range(ncmds):
            cmd, cmdsize = struct.unpack_from("<II", self.raw, off)
            if cmd == 0x80000035:  # LC_FILESET_ENTRY
                vmaddr = struct.unpack_from("<Q", self.raw, off + 8)[0]
                str_off_in_cmd = struct.unpack_from("<I", self.raw, off + 24)[0]
                entry_id = self.raw[off + str_off_in_cmd:].split(b'\x00')[0].decode()
                if entry_id == "com.apple.kernel":
                    kext_foff = vmaddr - self.base_va
                    text_range = self._parse_kext_text_exec(kext_foff)
                    if text_range:
                        return text_range
            off += cmdsize
        return self.kern_text

    @staticmethod
    def _is_func_boundary(insn):
        """Return True if *insn* typically ends/starts a function."""
        return insn in _FUNC_BOUNDARY_U32S

    def patch_PE_i_can_has_debugger(self):
        """Patches 6-7: mov x0,#1; ret at _PE_i_can_has_debugger."""
        self._log("\n[6-7] _PE_i_can_has_debugger: stub with mov x0,#1; ret")

        # Strategy 1: find symbol name in __LINKEDIT and parse nearby VA
        str_off = self.find_string(b"\x00_PE_i_can_has_debugger\x00")
        if str_off < 0:
            str_off = self.find_string(b"PE_i_can_has_debugger")
        if str_off >= 0:
            linkedit = None
            for name, vmaddr, fileoff, filesize, _ in self.all_segments:
                if name == "__LINKEDIT":
                    linkedit = (fileoff, fileoff + filesize)
            if linkedit and linkedit[0] <= str_off < linkedit[1]:
                name_end = self.raw.find(b'\x00', str_off + 1)
                if name_end > 0:
                    for probe in range(name_end + 1, min(name_end + 32, self.size - 7)):
                        val = _rd64(self.raw, probe)
                        func_foff = val - self.base_va
                        if self.kern_text[0] <= func_foff < self.kern_text[1]:
                            first_insn = _rd32(self.raw, func_foff)
                            if first_insn != 0 and first_insn != 0xD503201F:
                                self.emit(func_foff, MOV_X0_1,
                                          "mov x0,#1 [_PE_i_can_has_debugger]")
                                self.emit(func_foff + 4, RET,
                                          "ret [_PE_i_can_has_debugger]")
                                return True

        # Strategy 2: code pattern — function starts with ADRP x8,
        # preceded by a function boundary, has many BL callers,
        # and reads a 32-bit (w-register) value within first few instructions.
        self._log("  [*] trying code pattern search...")

        # Determine kernel-only __text range from fileset entries if available
        kern_text_start, kern_text_end = self._get_kernel_text_range()

        best_off = -1
        best_callers = 0
        for off in range(kern_text_start, kern_text_end - 12, 4):
            dis = self._disas_at(off)
            if not dis or dis[0].mnemonic != "adrp":
                continue
            # Must target x8
            if dis[0].operands[0].reg != ARM64_REG_X8:
                continue
            # Must be preceded by function boundary
            if off >= 4:
                prev = _rd32(self.raw, off - 4)
                if not self._is_func_boundary(prev):
                    continue
            # Must read a w-register (32-bit) from [x8, #imm] within first 6 instructions
            has_w_load = False
            for k in range(1, 7):
                if off + k * 4 >= self.size:
                    break
                dk = self._disas_at(off + k * 4)
                if dk and dk[0].mnemonic == "ldr" and dk[0].op_str.startswith("w") and "x8" in dk[0].op_str:
                    has_w_load = True
                    break
            if not has_w_load:
                continue
            # Count callers — _PE_i_can_has_debugger has ~80-200 callers
            # (widely used but not a basic kernel primitive)
            n_callers = len(self.bl_callers.get(off, []))
            if 50 <= n_callers <= 250 and n_callers > best_callers:
                best_callers = n_callers
                best_off = off

        if best_off >= 0:
            self._log(f"  [+] code pattern match at 0x{best_off:X} ({best_callers} callers)")
            self.emit(best_off, MOV_X0_1, "mov x0,#1 [_PE_i_can_has_debugger]")
            self.emit(best_off + 4, RET, "ret [_PE_i_can_has_debugger]")
            return True

        self._log("  [-] function not found")
        return False

    def patch_post_validation_nop(self):
        """Patch 8: NOP the TBNZ after TXM CodeSignature error logging.

        The 'TXM [Error]: CodeSignature: selector: ...' string is followed
        by a BL (printf/log), then a TBNZ that branches to an additional
        validation path.  NOP the TBNZ to skip it.
        """
        self._log("\n[8] post-validation NOP (txm-related)")

        str_off = self.find_string(b"TXM [Error]: CodeSignature")
        if str_off < 0:
            self._log("  [-] 'TXM [Error]: CodeSignature' string not found")
            return False

        refs = self.find_string_refs(str_off, *self.kern_text)
        if not refs:
            refs = self.find_string_refs(str_off)
        if not refs:
            self._log("  [-] no code refs")
            return False

        for adrp_off, add_off, _ in refs:
            # Scan forward past the BL (printf/log) for a TBNZ
            for scan in range(add_off, min(add_off + 0x40, self.size), 4):
                insns = self._disas_at(scan)
                if not insns:
                    continue
                if insns[0].mnemonic == "tbnz":
                    self.emit(scan, NOP,
                              f"NOP {insns[0].mnemonic} {insns[0].op_str} "
                              "[txm post-validation]")
                    return True

        self._log("  [-] TBNZ not found after TXM error string ref")
        return False

    def patch_post_validation_cmp(self):
        """Patch 9: cmp w0,w0 in postValidation (AMFI code signing).

        The 'AMFI: code signature validation failed' string is in the CALLER
        function, not in postValidation itself.  We find the caller, collect
        its BL targets, then look inside each target for CMP W0, #imm + B.NE.
        """
        self._log("\n[9] postValidation: cmp w0,w0 (AMFI code signing)")

        str_off = self.find_string(b"AMFI: code signature validation failed")
        if str_off < 0:
            self._log("  [-] string not found")
            return False

        refs = self.find_string_refs(str_off, *self.amfi_text)
        if not refs:
            refs = self.find_string_refs(str_off)
        if not refs:
            self._log("  [-] no code refs")
            return False

        caller_start = self.find_function_start(refs[0][0])
        if caller_start < 0:
            self._log("  [-] caller function start not found")
            return False

        # Collect unique BL targets from the caller function
        # Only stop at PACIBSP (new function), not at ret/retab (early returns)
        bl_targets = set()
        for scan in range(caller_start, min(caller_start + 0x2000, self.size), 4):
            if scan > caller_start + 8 and _rd32(self.raw, scan) == _PACIBSP_U32:
                break
            target = self._is_bl(scan)
            if target >= 0:
                bl_targets.add(target)

        # In each BL target in AMFI, look for:  BL ... ; CMP W0, #imm ; B.NE
        # The CMP must check W0 (return value of preceding BL call).
        for target in sorted(bl_targets):
            if not (self.amfi_text[0] <= target < self.amfi_text[1]):
                continue
            for off in range(target, min(target + 0x200, self.size), 4):
                if off > target + 8 and _rd32(self.raw, off) == _PACIBSP_U32:
                    break
                dis = self._disas_at(off, 2)
                if len(dis) < 2:
                    continue
                i0, i1 = dis[0], dis[1]
                if i0.mnemonic != "cmp" or i1.mnemonic != "b.ne":
                    continue
                # Must be CMP W0, #imm (first operand = w0, second = immediate)
                ops = i0.operands
                if len(ops) < 2:
                    continue
                if ops[0].type != ARM64_OP_REG or ops[0].reg != ARM64_REG_W0:
                    continue
                if ops[1].type != ARM64_OP_IMM:
                    continue
                # Must be preceded by a BL within 2 instructions
                has_bl = False
                for gap in (4, 8):
                    if self._is_bl(off - gap) >= 0:
                        has_bl = True
                        break
                if not has_bl:
                    continue
                self.emit(off, CMP_W0_W0,
                          f"cmp w0,w0 (was {i0.mnemonic} {i0.op_str}) "
                          "[postValidation]")
                return True

        self._log("  [-] CMP+B.NE pattern not found in caller's BL targets")
        return False

    def patch_check_dyld_policy(self):
        """Patches 10-11: Replace two BL calls in _check_dyld_policy_internal with mov w0,#1.

        The function is found via its reference to the Swift Playgrounds
        entitlement string.  The two BLs immediately preceding that string
        reference (each followed by a conditional branch on w0) are patched.
        """
        self._log("\n[10-11] _check_dyld_policy_internal: mov w0,#1 (two BLs)")

        # Anchor: entitlement string referenced from within the function
        str_off = self.find_string(
            b"com.apple.developer.swift-playgrounds-app.development-build")
        if str_off < 0:
            self._log("  [-] swift-playgrounds entitlement string not found")
            return False

        refs = self.find_string_refs(str_off, *self.amfi_text)
        if not refs:
            refs = self.find_string_refs(str_off)
        if not refs:
            self._log("  [-] no code refs in AMFI")
            return False

        for adrp_off, add_off, _ in refs:
            # Walk backward from the ADRP, looking for BL + conditional-on-w0 pairs
            bls_with_cond = []   # [(bl_off, bl_target), ...]
            for back in range(adrp_off - 4, max(adrp_off - 80, 0), -4):
                bl_target = self._is_bl(back)
                if bl_target < 0:
                    continue
                if self._is_cond_branch_w0(back + 4):
                    bls_with_cond.append((back, bl_target))

            if len(bls_with_cond) >= 2:
                bl2_off, bl2_tgt = bls_with_cond[0]   # closer  to ADRP
                bl1_off, bl1_tgt = bls_with_cond[1]   # farther from ADRP
                # The two BLs must call DIFFERENT functions — this
                # distinguishes _check_dyld_policy_internal from other
                # functions that repeat calls to the same helper.
                if bl1_tgt == bl2_tgt:
                    continue
                self.emit(bl1_off, MOV_W0_1,
                          "mov w0,#1 (was BL) [_check_dyld_policy_internal @1]")
                self.emit(bl2_off, MOV_W0_1,
                          "mov w0,#1 (was BL) [_check_dyld_policy_internal @2]")
                return True

        self._log("  [-] _check_dyld_policy_internal BL pair not found")
        return False

    def _find_validate_root_hash_func(self):
        """Find validate_on_disk_root_hash function via 'authenticate_root_hash' string."""
        str_off = self.find_string(b"authenticate_root_hash")
        if str_off < 0:
            return -1
        refs = self.find_string_refs(str_off, *self.apfs_text)
        if not refs:
            return -1
        return self.find_function_start(refs[0][0])

    def patch_apfs_graft(self):
        """Patch 12: Replace BL to validate_on_disk_root_hash with mov w0,#0.

        Instead of stubbing _apfs_graft at entry, find the specific BL
        that calls the root hash validation and neutralize just that call.
        """
        self._log("\n[12] _apfs_graft: mov w0,#0 (validate_root_hash BL)")

        # Find _apfs_graft function
        exact = self.raw.find(b"\x00apfs_graft\x00")
        if exact < 0:
            self._log("  [-] 'apfs_graft' string not found")
            return False
        str_off = exact + 1

        refs = self.find_string_refs(str_off, *self.apfs_text)
        if not refs:
            self._log("  [-] no code refs")
            return False

        graft_start = self.find_function_start(refs[0][0])
        if graft_start < 0:
            self._log("  [-] _apfs_graft function start not found")
            return False

        # Find validate_on_disk_root_hash function
        vrh_func = self._find_validate_root_hash_func()
        if vrh_func < 0:
            self._log("  [-] validate_on_disk_root_hash not found")
            return False

        # Scan _apfs_graft for BL to validate_on_disk_root_hash
        # Don't stop at ret/retab (early returns) — only stop at PACIBSP (new function)
        for scan in range(graft_start, min(graft_start + 0x2000, self.size), 4):
            if scan > graft_start + 8 and _rd32(self.raw, scan) == _PACIBSP_U32:
                break
            bl_target = self._is_bl(scan)
            if bl_target == vrh_func:
                self.emit(scan, MOV_W0_0, "mov w0,#0 [_apfs_graft]")
                return True

        self._log("  [-] BL to validate_on_disk_root_hash not found in _apfs_graft")
        return False

    def patch_apfs_vfsop_mount_cmp(self):
        """Patch 13: cmp x0,x0 in _apfs_vfsop_mount (current_thread == kernel_task check).

        The target CMP follows the pattern: BL (returns current_thread in x0),
        ADRP + LDR + LDR (load kernel_task global), CMP x0, Xm, B.EQ.
        We require x0 as the first CMP operand to distinguish it from other
        CMP Xn,Xm instructions in the same function.
        """
        self._log("\n[13] _apfs_vfsop_mount: cmp x0,x0 (mount rw check)")

        refs_upgrade = self._find_by_string_in_range(
            b"apfs_mount_upgrade_checks\x00",
            self.apfs_text, "apfs_mount_upgrade_checks")
        if not refs_upgrade:
            return False

        func_start = self.find_function_start(refs_upgrade[0][0])
        if func_start < 0:
            return False

        # Find BL callers of _apfs_mount_upgrade_checks
        callers = self.bl_callers.get(func_start, [])
        if not callers:
            for off_try in [func_start, func_start + 4]:
                callers = self.bl_callers.get(off_try, [])
                if callers:
                    break

        if not callers:
            self._log("  [-] no BL callers of _apfs_mount_upgrade_checks found")
            for off in range(self.apfs_text[0], self.apfs_text[1], 4):
                bl_target = self._is_bl(off)
                if bl_target >= 0 and func_start <= bl_target <= func_start + 4:
                    callers.append(off)

        for caller_off in callers:
            if not (self.apfs_text[0] <= caller_off < self.apfs_text[1]):
                continue
            # Scan a wider range — the CMP can be 0x800+ bytes before the BL
            caller_func = self.find_function_start(caller_off)
            scan_start = caller_func if caller_func >= 0 else max(caller_off - 0x800, self.apfs_text[0])
            scan_end = min(caller_off + 0x100, self.apfs_text[1])

            for scan in range(scan_start, scan_end, 4):
                dis = self._disas_at(scan)
                if not dis or dis[0].mnemonic != "cmp":
                    continue
                ops = dis[0].operands
                if len(ops) < 2:
                    continue
                # Require CMP Xn, Xm (both register operands)
                if ops[0].type != ARM64_OP_REG or ops[1].type != ARM64_OP_REG:
                    continue
                # Require x0 as first operand (return value from BL)
                if ops[0].reg != ARM64_REG_X0:
                    continue
                # Skip CMP x0, x0 (already patched or trivial)
                if ops[0].reg == ops[1].reg:
                    continue
                self.emit(scan, CMP_X0_X0,
                          f"cmp x0,x0 (was {dis[0].mnemonic} {dis[0].op_str}) "
                          "[_apfs_vfsop_mount]")
                return True

        self._log("  [-] CMP x0,Xm not found near mount_upgrade_checks caller")
        return False

    def patch_apfs_mount_upgrade_checks(self):
        """Patch 14: Replace TBNZ w0,#0xe with mov w0,#0 in _apfs_mount_upgrade_checks.

        Within the function, a BL calls a small flag-reading leaf function,
        then TBNZ w0,#0xe branches to the error path.  Replace the TBNZ
        with mov w0,#0 to force the success path.
        """
        self._log("\n[14] _apfs_mount_upgrade_checks: mov w0,#0 (tbnz bypass)")

        refs = self._find_by_string_in_range(
            b"apfs_mount_upgrade_checks\x00",
            self.apfs_text, "apfs_mount_upgrade_checks")
        if not refs:
            return False

        func_start = self.find_function_start(refs[0][0])
        if func_start < 0:
            self._log("  [-] function start not found")
            return False

        # Scan for BL followed by TBNZ w0
        # Don't stop at ret/retab (early returns) — only stop at PACIBSP (new function)
        for scan in range(func_start, min(func_start + 0x200, self.size), 4):
            if scan > func_start + 8 and _rd32(self.raw, scan) == _PACIBSP_U32:
                break
            bl_target = self._is_bl(scan)
            if bl_target < 0:
                continue
            # Check if BL target is a small leaf function (< 0x20 bytes, ends with ret)
            is_leaf = False
            for k in range(0, 0x20, 4):
                if bl_target + k >= self.size:
                    break
                dis = self._disas_at(bl_target + k)
                if dis and dis[0].mnemonic == "ret":
                    is_leaf = True
                    break
            if not is_leaf:
                continue
            # Check next instruction is TBNZ w0, #0xe
            next_off = scan + 4
            insns = self._disas_at(next_off)
            if not insns:
                continue
            i = insns[0]
            if i.mnemonic == "tbnz" and len(i.operands) >= 1:
                if (i.operands[0].type == ARM64_OP_REG and
                        i.operands[0].reg == ARM64_REG_W0):
                    self.emit(next_off, MOV_W0_0,
                              "mov w0,#0 [_apfs_mount_upgrade_checks]")
                    return True

        self._log("  [-] BL + TBNZ w0 pattern not found")
        return False

    def _find_validate_payload_manifest_func(self):
        """Find the AppleImage4 validate_payload_and_manifest function."""
        str_off = self.find_string(b"validate_payload_and_manifest")
        if str_off < 0:
            return -1
        refs = self.find_string_refs(str_off, *self.apfs_text)
        if not refs:
            return -1
        return self.find_function_start(refs[0][0])

    def patch_handle_fsioc_graft(self):
        """Patch 15: Replace BL to validate_payload_and_manifest with mov w0,#0.

        Instead of stubbing _handle_fsioc_graft at entry, find the specific
        BL that calls AppleImage4 validation and neutralize just that call.
        """
        self._log("\n[15] _handle_fsioc_graft: mov w0,#0 (validate BL)")

        exact = self.raw.find(b"\x00handle_fsioc_graft\x00")
        if exact < 0:
            self._log("  [-] 'handle_fsioc_graft' string not found")
            return False
        str_off = exact + 1

        refs = self.find_string_refs(str_off, *self.apfs_text)
        if not refs:
            self._log("  [-] no code refs")
            return False

        fsioc_start = self.find_function_start(refs[0][0])
        if fsioc_start < 0:
            self._log("  [-] function start not found")
            return False

        # Find the validation function
        val_func = self._find_validate_payload_manifest_func()
        if val_func < 0:
            self._log("  [-] validate_payload_and_manifest not found")
            return False

        # Scan _handle_fsioc_graft for BL to validation function
        for scan in range(fsioc_start, min(fsioc_start + 0x400, self.size), 4):
            insns = self._disas_at(scan)
            if not insns:
                continue
            if scan > fsioc_start + 8 and insns[0].mnemonic == "pacibsp":
                break
            bl_target = self._is_bl(scan)
            if bl_target == val_func:
                self.emit(scan, MOV_W0_0, "mov w0,#0 [_handle_fsioc_graft]")
                return True

        self._log("  [-] BL to validate_payload_and_manifest not found")
        return False

    # ── Sandbox MACF hooks ───────────────────────────────────────

    def _find_sandbox_ops_table_via_conf(self):
        """Find Sandbox mac_policy_ops table via mac_policy_conf struct."""
        self._log("\n[*] Finding Sandbox mac_policy_ops via mac_policy_conf...")

        seatbelt_off = self.find_string(b"Seatbelt sandbox policy")
        sandbox_raw = self.raw.find(b"\x00Sandbox\x00")
        sandbox_off = sandbox_raw + 1 if sandbox_raw >= 0 else -1
        if seatbelt_off < 0 or sandbox_off < 0:
            self._log("  [-] Sandbox/Seatbelt strings not found")
            return None
        self._log(f"  [*] Sandbox string at foff 0x{sandbox_off:X}, "
                  f"Seatbelt at 0x{seatbelt_off:X}")

        data_ranges = []
        for name, vmaddr, fileoff, filesize, prot in self.all_segments:
            if name in ("__DATA_CONST", "__DATA") and filesize > 0:
                data_ranges.append((fileoff, fileoff + filesize))

        for d_start, d_end in data_ranges:
            for i in range(d_start, d_end - 40, 8):
                val = _rd64(self.raw, i)
                if val == 0 or (val & (1 << 63)):
                    continue
                if (val & 0x7FFFFFFFFFF) != sandbox_off:
                    continue
                val2 = _rd64(self.raw, i + 8)
                if (val2 & (1 << 63)) or (val2 & 0x7FFFFFFFFFF) != seatbelt_off:
                    continue
                val_ops = _rd64(self.raw, i + 32)
                if not (val_ops & (1 << 63)):
                    ops_off = val_ops & 0x7FFFFFFFFFF
                    self._log(f"  [+] mac_policy_conf at foff 0x{i:X}, "
                              f"mpc_ops -> 0x{ops_off:X}")
                    return ops_off

        self._log("  [-] mac_policy_conf not found")
        return None

    def _read_ops_entry(self, table_off, index):
        """Read a function pointer from the ops table, handling chained fixups."""
        off = table_off + index * 8
        if off + 8 > self.size:
            return -1
        val = _rd64(self.raw, off)
        if val == 0:
            return 0
        return self._decode_chained_ptr(val)

    def patch_sandbox_hooks(self):
        """Patches 16-25: Stub Sandbox MACF hooks with mov x0,#0; ret.

        Uses mac_policy_ops struct indices from XNU source (xnu-11215+).
        """
        self._log("\n[16-25] Sandbox MACF hooks")

        ops_table = self._find_sandbox_ops_table_via_conf()
        if ops_table is None:
            return False

        HOOK_INDICES = {
            "file_check_mmap":     36,
            "mount_check_mount":   87,
            "mount_check_remount": 88,
            "mount_check_umount":  91,
            "vnode_check_rename":  120,
        }

        sb_start, sb_end = self.sandbox_text
        patched_count = 0

        for hook_name, idx in HOOK_INDICES.items():
            func_off = self._read_ops_entry(ops_table, idx)
            if func_off is None or func_off <= 0:
                self._log(f"  [-] ops[{idx}] {hook_name}: NULL or invalid")
                continue
            if not (sb_start <= func_off < sb_end):
                self._log(f"  [-] ops[{idx}] {hook_name}: foff 0x{func_off:X} "
                          f"outside Sandbox (0x{sb_start:X}-0x{sb_end:X})")
                continue

            self.emit(func_off, MOV_X0_0, f"mov x0,#0 [_hook_{hook_name}]")
            self.emit(func_off + 4, RET, f"ret [_hook_{hook_name}]")
            self._log(f"  [+] ops[{idx}] {hook_name} at foff 0x{func_off:X}")
            patched_count += 1

        return patched_count > 0

    # ═══════════════════════════════════════════════════════════════
    # Main entry point
    # ═══════════════════════════════════════════════════════════════

    def find_all(self):
        """Find and record all kernel patches.  Returns list of (offset, bytes, desc)."""
        self.patches = []
        self.patch_apfs_root_snapshot()               #  1
        self.patch_apfs_seal_broken()                  #  2
        self.patch_bsd_init_rootvp()                   #  3
        self.patch_proc_check_launch_constraints()     #  4-5
        self.patch_PE_i_can_has_debugger()             #  6-7
        self.patch_post_validation_nop()               #  8
        self.patch_post_validation_cmp()               #  9
        self.patch_check_dyld_policy()                 # 10-11
        self.patch_apfs_graft()                        # 12
        self.patch_apfs_vfsop_mount_cmp()              # 13
        self.patch_apfs_mount_upgrade_checks()         # 14
        self.patch_handle_fsioc_graft()                # 15
        self.patch_sandbox_hooks()                     # 16-25
        return self.patches

    def apply(self):
        """Find all patches and apply them to self.data.  Returns patch count."""
        patches = self.find_all()
        for off, patch_bytes, desc in patches:
            self.data[off:off + len(patch_bytes)] = patch_bytes

        if self.verbose and patches:
            self._log(f"\n{'═'*60}")
            self._log(f"VERIFICATION: {len(patches)} patches applied")
            self._log(f"{'═'*60}")
            for off, patch_bytes, desc in sorted(patches):
                insns = self._disas_n(self.data, off, len(patch_bytes) // 4)
                if insns:
                    dis_str = "; ".join(f"{i.mnemonic} {i.op_str}" for i in insns)
                else:
                    dis_str = "???"
                self._log(f"  0x{off:08X}: {dis_str:40s} — {desc}")

        return len(patches)


# ── CLI entry point ──────────────────────────────────────────────
if __name__ == "__main__":
    import sys, argparse

    parser = argparse.ArgumentParser(
        description="Dynamic kernel patcher — find & apply patches on iOS kernelcaches")
    parser.add_argument("kernelcache", help="Path to raw or IM4P kernelcache")
    parser.add_argument("-c", "--context", type=int, default=5,
                        help="Instructions of context before/after each patch (default: 5)")
    parser.add_argument("-q", "--quiet", action="store_true",
                        help="Suppress index-building progress (only show patches)")
    args = parser.parse_args()

    path = args.kernelcache
    print(f"Loading {path}...")
    file_raw = open(path, "rb").read()

    # Auto-detect IM4P vs raw Mach-O
    if file_raw[:4] == b"\xcf\xfa\xed\xfe":
        payload = file_raw
        print(f"  format: raw Mach-O")
    else:
        try:
            from pyimg4 import IM4P
            im4p = IM4P(file_raw)
            if im4p.payload.compression:
                im4p.payload.decompress()
            payload = im4p.payload.data
            print(f"  format: IM4P (fourcc={im4p.fourcc})")
        except Exception:
            payload = file_raw
            print(f"  format: unknown (treating as raw)")

    data = bytearray(payload)
    print(f"  size:   {len(data)} bytes ({len(data)/1024/1024:.1f} MB)\n")

    kp = KernelPatcher(data, verbose=not args.quiet)
    patches = kp.find_all()

    # ── Print ranged before / after disassembly for every patch ──
    ctx = args.context

    print(f"\n{'═'*72}")
    print(f"  {len(patches)} PATCHES — before / after disassembly (context={ctx})")
    print(f"{'═'*72}")

    # Apply patches to get the "after" image
    after = bytearray(kp.raw)  # start from original
    for off, pb, _ in patches:
        after[off:off + len(pb)] = pb

    for i, (off, patch_bytes, desc) in enumerate(sorted(patches), 1):
        n_insns = len(patch_bytes) // 4
        start = max(off - ctx * 4, 0)
        end = off + n_insns * 4 + ctx * 4
        total = (end - start) // 4

        before_insns = kp._disas_n(kp.raw, start, total)
        after_insns  = kp._disas_n(after,   start, total)

        print(f"\n  ┌{'─'*70}")
        print(f"  │ [{i:2d}] 0x{off:08X}: {desc}")
        print(f"  ├{'─'*34}┬{'─'*35}")
        print(f"  │ {'BEFORE':^33}│ {'AFTER':^34}")
        print(f"  ├{'─'*34}┼{'─'*35}")

        # Build line pairs
        max_lines = max(len(before_insns), len(after_insns))
        for j in range(max_lines):
            def fmt(insn):
                if insn is None:
                    return " " * 33
                h = insn.bytes.hex()
                return f"0x{insn.address:07X} {h:8s} {insn.mnemonic:6s} {insn.op_str}"

            bi = before_insns[j] if j < len(before_insns) else None
            ai = after_insns[j]  if j < len(after_insns)  else None

            bl = fmt(bi)
            al = fmt(ai)

            # Mark if this address is inside the patched range
            addr = (bi.address if bi else ai.address) if (bi or ai) else 0
            in_patch = off <= addr < off + len(patch_bytes)
            marker = " ◄" if in_patch else "  "

            print(f"  │ {bl:33s}│ {al:33s}{marker}")

        print(f"  └{'─'*34}┴{'─'*35}")

```

`scripts/patchers/kernel_jb.py`:

```py
#!/usr/bin/env python3
"""
kernel_jb.py — Jailbreak extension patcher for iOS kernelcache.

Builds on kernel.py's Mach-O parsing / indexing helpers while keeping JB logic
in a separate file for clean layering.

All patches use dynamic matchers:
  - String anchors → ADRP+ADD xrefs → function scope → patch site
  - BL frequency analysis to identify stub targets
  - Pattern matching (≤3 instruction sequences)
  - No symbols or hardcoded offsets

Patches are split into:
  - Group A: Already implemented (AMFI trustcache, execve, task conversion, sandbox)
  - Group B: Simple patches (string-anchored / pattern-matched)
  - Group C: Complex shellcode patches (code cave + branch redirects)
"""

import struct
from collections import Counter

from capstone.arm64_const import (
    ARM64_OP_REG, ARM64_OP_IMM, ARM64_OP_MEM,
    ARM64_REG_X0, ARM64_REG_X1, ARM64_REG_W0, ARM64_REG_X8,
)

from .kernel import (
    KernelPatcher,
    NOP,
    MOV_X0_0,
    MOV_X0_1,
    MOV_W0_0,
    MOV_W0_1,
    CMP_W0_W0,
    CMP_X0_X0,
    RET,
    asm,
    _rd32,
    _rd64,
)


CBZ_X2_8 = asm("cbz x2, #8")
STR_X0_X2 = asm("str x0, [x2]")
CMP_XZR_XZR = asm("cmp xzr, xzr")
MOV_X8_XZR = asm("mov x8, xzr")


class KernelJBPatcher(KernelPatcher):
    """JB-only kernel patcher."""

    def __init__(self, data, verbose=True):
        super().__init__(data, verbose)
        self._build_symbol_table()

    # ── Symbol table (best-effort, may find 0 on stripped kernels) ──

    def _build_symbol_table(self):
        """Parse nlist entries from LC_SYMTAB to build symbol→foff map."""
        self.symbols = {}

        # Parse top-level LC_SYMTAB
        ncmds = struct.unpack_from("<I", self.raw, 16)[0]
        off = 32
        for _ in range(ncmds):
            if off + 8 > self.size:
                break
            cmd, cmdsize = struct.unpack_from("<II", self.raw, off)
            if cmd == 0x2:  # LC_SYMTAB
                symoff = struct.unpack_from("<I", self.raw, off + 8)[0]
                nsyms = struct.unpack_from("<I", self.raw, off + 12)[0]
                stroff = struct.unpack_from("<I", self.raw, off + 16)[0]
                self._parse_nlist(symoff, nsyms, stroff)
            off += cmdsize

        # Parse fileset entries' LC_SYMTAB
        off = 32
        for _ in range(ncmds):
            if off + 8 > self.size:
                break
            cmd, cmdsize = struct.unpack_from("<II", self.raw, off)
            if cmd == 0x80000035:  # LC_FILESET_ENTRY
                # fileoff is at off+16
                foff_entry = struct.unpack_from("<Q", self.raw, off + 16)[0]
                self._parse_fileset_symtab(foff_entry)
            off += cmdsize

        self._log(f"[*] Symbol table: {len(self.symbols)} symbols resolved")

    def _parse_fileset_symtab(self, mh_off):
        """Parse LC_SYMTAB from a fileset entry Mach-O."""
        if mh_off < 0 or mh_off + 32 > self.size:
            return
        magic = _rd32(self.raw, mh_off)
        if magic != 0xFEEDFACF:
            return
        ncmds = struct.unpack_from("<I", self.raw, mh_off + 16)[0]
        off = mh_off + 32
        for _ in range(ncmds):
            if off + 8 > self.size:
                break
            cmd, cmdsize = struct.unpack_from("<II", self.raw, off)
            if cmd == 0x2:  # LC_SYMTAB
                symoff = struct.unpack_from("<I", self.raw, off + 8)[0]
                nsyms = struct.unpack_from("<I", self.raw, off + 12)[0]
                stroff = struct.unpack_from("<I", self.raw, off + 16)[0]
                self._parse_nlist(symoff, nsyms, stroff)
            off += cmdsize

    def _parse_nlist(self, symoff, nsyms, stroff):
        """Parse nlist64 entries: add defined function symbols to self.symbols."""
        for i in range(nsyms):
            entry_off = symoff + i * 16
            if entry_off + 16 > self.size:
                break
            n_strx, n_type, n_sect, n_desc, n_value = struct.unpack_from(
                "<IBBHQ", self.raw, entry_off)
            if n_type & 0x0E != 0x0E:
                continue
            if n_value == 0:
                continue
            name_off = stroff + n_strx
            if name_off >= self.size:
                continue
            name_end = self.raw.find(b'\x00', name_off)
            if name_end < 0 or name_end - name_off > 512:
                continue
            name = self.raw[name_off:name_end].decode('ascii', errors='replace')
            foff = n_value - self.base_va
            if 0 <= foff < self.size:
                self.symbols[name] = foff

    def _resolve_symbol(self, name):
        """Look up a function symbol, return file offset or -1."""
        return self.symbols.get(name, -1)

    # ── Code cave finder ──────────────────────────────────────────

    def _find_code_cave(self, size, align=4):
        """Find a region of zeros/0xFF/UDF in executable memory for shellcode.
        Returns file offset of the cave start, or -1 if not found.
        Reads from self.data (mutable) so previously allocated caves are skipped.
        """
        needed = (size + align - 1) // align * align
        for rng_start, rng_end in self.code_ranges:
            run_start = -1
            run_len = 0
            for off in range(rng_start, rng_end, 4):
                val = _rd32(self.data, off)
                if val == 0x00000000 or val == 0xFFFFFFFF or val == 0xD4200000:
                    if run_start < 0:
                        run_start = off
                        run_len = 4
                    else:
                        run_len += 4
                    if run_len >= needed:
                        return run_start
                else:
                    run_start = -1
                    run_len = 0
        return -1

    # ── Branch encoding helpers ───────────────────────────────────

    def _encode_b(self, from_off, to_off):
        """Encode an unconditional B instruction."""
        delta = (to_off - from_off) // 4
        if delta < -(1 << 25) or delta >= (1 << 25):
            return None
        return struct.pack("<I", 0x14000000 | (delta & 0x3FFFFFF))

    def _encode_bl(self, from_off, to_off):
        """Encode a BL instruction."""
        delta = (to_off - from_off) // 4
        if delta < -(1 << 25) or delta >= (1 << 25):
            return None
        return struct.pack("<I", 0x94000000 | (delta & 0x3FFFFFF))

    # ── Function finding helpers ──────────────────────────────────

    def _find_func_end(self, func_start, max_size=0x4000):
        """Find the end of a function (next PACIBSP or limit)."""
        limit = min(func_start + max_size, self.size)
        for off in range(func_start + 4, limit, 4):
            d = self._disas_at(off)
            if d and d[0].mnemonic == "pacibsp":
                return off
        return limit

    def _find_bl_to_panic_in_range(self, start, end):
        """Find first BL to _panic in range, return offset or -1."""
        for off in range(start, end, 4):
            bl_target = self._is_bl(off)
            if bl_target == self.panic_off:
                return off
        return -1

    def _find_func_by_string(self, string, code_range=None):
        """Find a function that references a given string.
        Returns the function start (PACIBSP), or -1.
        """
        str_off = self.find_string(string)
        if str_off < 0:
            return -1
        if code_range:
            refs = self.find_string_refs(str_off, *code_range)
        else:
            refs = self.find_string_refs(str_off)
        if not refs:
            return -1
        func_start = self.find_function_start(refs[0][0])
        return func_start

    def _find_func_containing_string(self, string, code_range=None):
        """Find a function containing a string reference.
        Returns (func_start, func_end, refs) or (None, None, None).
        """
        str_off = self.find_string(string)
        if str_off < 0:
            return None, None, None
        if code_range:
            refs = self.find_string_refs(str_off, *code_range)
        else:
            refs = self.find_string_refs(str_off)
        if not refs:
            return None, None, None
        func_start = self.find_function_start(refs[0][0])
        if func_start < 0:
            return None, None, None
        func_end = self._find_func_end(func_start)
        return func_start, func_end, refs

    def _find_nosys(self):
        """Find _nosys: a tiny function that returns ENOSYS (78 = 0x4e).
        Pattern: mov w0, #0x4e; ret (or with PACIBSP wrapper).
        """
        # Search for: mov w0, #0x4e (= 0x528009C0) followed by ret (= 0xD65F03C0)
        mov_w0_4e = struct.unpack("<I", asm("mov w0, #0x4e"))[0]
        ret_val = struct.unpack("<I", RET)[0]
        for s, e in self.code_ranges:
            for off in range(s, e - 4, 4):
                v0 = _rd32(self.raw, off)
                v1 = _rd32(self.raw, off + 4)
                if v0 == mov_w0_4e and v1 == ret_val:
                    return off
                # Also check with PACIBSP prefix
                if v0 == 0xD503237F and v1 == mov_w0_4e:
                    v2 = _rd32(self.raw, off + 8)
                    if v2 == ret_val:
                        return off
        return -1

    # ══════════════════════════════════════════════════════════════
    # Patch dispatcher
    # ══════════════════════════════════════════════════════════════

    def find_all(self):
        self.patches = []

        # Group A: Existing patches
        self.patch_amfi_cdhash_in_trustcache()
        self.patch_amfi_execve_kill_path()
        self.patch_task_conversion_eval_internal()
        self.patch_sandbox_hooks_extended()

        # Group B: Simple patches (string-anchored / pattern-matched)
        self.patch_post_validation_additional()
        self.patch_proc_security_policy()
        self.patch_proc_pidinfo()
        self.patch_convert_port_to_map()
        self.patch_vm_fault_enter_prepare()
        self.patch_vm_map_protect()
        self.patch_mac_mount()
        self.patch_dounmount()
        self.patch_bsd_init_auth()
        self.patch_spawn_validate_persona()
        self.patch_task_for_pid()
        self.patch_load_dylinker()
        self.patch_shared_region_map()
        self.patch_nvram_verify_permission()
        self.patch_io_secure_bsd_root()
        self.patch_thid_should_crash()

        # Group C: Complex shellcode patches
        self.patch_cred_label_update_execve()
        self.patch_syscallmask_apply_to_proc()
        self.patch_hook_cred_label_update_execve()
        self.patch_kcall10()

        return self.patches

    def apply(self):
        patches = self.find_all()
        for off, patch_bytes, _ in patches:
            self.data[off:off + len(patch_bytes)] = patch_bytes
        return len(patches)

    # ══════════════════════════════════════════════════════════════
    # Group A: Existing patches (unchanged)
    # ══════════════════════════════════════════════════════════════

    def patch_amfi_cdhash_in_trustcache(self):
        """AMFIIsCDHashInTrustCache rewrite (semantic function matching)."""
        self._log("\n[JB] AMFIIsCDHashInTrustCache: always allow + store flag")

        def _find_after(insns, start, pred):
            for idx in range(start, len(insns)):
                if pred(insns[idx]):
                    return idx
            return -1

        hits = []
        s, e = self.amfi_text
        for off in range(s, e - 4, 4):
            d0 = self._disas_at(off)
            if not d0 or d0[0].mnemonic != "pacibsp":
                continue

            func_end = min(off + 0x200, e)
            for p in range(off + 4, func_end, 4):
                dp = self._disas_at(p)
                if dp and dp[0].mnemonic == "pacibsp":
                    func_end = p
                    break

            insns = []
            for p in range(off, func_end, 4):
                d = self._disas_at(p)
                if not d:
                    break
                insns.append(d[0])

            i1 = _find_after(insns, 0,
                             lambda x: x.mnemonic == "mov" and x.op_str == "x19, x2")
            if i1 < 0:
                continue
            i2 = _find_after(insns, i1 + 1,
                             lambda x: x.mnemonic == "stp"
                             and x.op_str.startswith("xzr, xzr, [sp"))
            if i2 < 0:
                continue
            i3 = _find_after(insns, i2 + 1,
                             lambda x: x.mnemonic == "mov" and x.op_str == "x2, sp")
            if i3 < 0:
                continue
            i4 = _find_after(insns, i3 + 1, lambda x: x.mnemonic == "bl")
            if i4 < 0:
                continue
            i5 = _find_after(insns, i4 + 1,
                             lambda x: x.mnemonic == "mov" and x.op_str == "x20, x0")
            if i5 < 0:
                continue
            i6 = _find_after(insns, i5 + 1,
                             lambda x: x.mnemonic == "cbnz" and x.op_str.startswith("w0,"))
            if i6 < 0:
                continue
            i7 = _find_after(insns, i6 + 1,
                             lambda x: x.mnemonic == "cbz" and x.op_str.startswith("x19,"))
            if i7 < 0:
                continue

            hits.append(off)

        if len(hits) != 1:
            self._log(f"  [-] expected 1 AMFI trustcache body hit, found {len(hits)}")
            return False

        func_start = hits[0]
        self.emit(func_start, MOV_X0_1,
                  "mov x0,#1 [AMFIIsCDHashInTrustCache]")
        self.emit(func_start + 4, CBZ_X2_8,
                  "cbz x2,+8 [AMFIIsCDHashInTrustCache]")
        self.emit(func_start + 8, STR_X0_X2,
                  "str x0,[x2] [AMFIIsCDHashInTrustCache]")
        self.emit(func_start + 12, RET,
                  "ret [AMFIIsCDHashInTrustCache]")
        return True

    def patch_amfi_execve_kill_path(self):
        """Bypass AMFI execve kill helpers (string xref -> function local pair)."""
        self._log("\n[JB] AMFI execve kill path: BL -> mov x0,#0 (2 sites)")

        str_off = self.find_string(b"AMFI: hook..execve() killing")
        if str_off < 0:
            str_off = self.find_string(b"execve() killing")
        if str_off < 0:
            self._log("  [-] execve kill log string not found")
            return False

        refs = self.find_string_refs(str_off, *self.kern_text)
        if not refs:
            refs = self.find_string_refs(str_off)
        if not refs:
            self._log("  [-] no refs to execve kill log string")
            return False

        patched = False
        seen_funcs = set()
        for adrp_off, _, _ in refs:
            func_start = self.find_function_start(adrp_off)
            if func_start < 0 or func_start in seen_funcs:
                continue
            seen_funcs.add(func_start)

            func_end = min(func_start + 0x800, self.kern_text[1])
            for p in range(func_start + 4, func_end, 4):
                d = self._disas_at(p)
                if d and d[0].mnemonic == "pacibsp":
                    func_end = p
                    break

            early_window_end = min(func_start + 0x120, func_end)
            hits = []
            for off in range(func_start, early_window_end - 4, 4):
                d0 = self._disas_at(off)
                d1 = self._disas_at(off + 4)
                if not d0 or not d1:
                    continue
                i0, i1 = d0[0], d1[0]
                if i0.mnemonic != "bl":
                    continue
                if i1.mnemonic in ("cbz", "cbnz") and i1.op_str.startswith("w0,"):
                    hits.append(off)

            if len(hits) != 2:
                self._log(f"  [-] execve helper at 0x{func_start:X}: "
                          f"expected 2 early BL+W0-branch sites, found {len(hits)}")
                continue

            self.emit(hits[0], MOV_X0_0, "mov x0,#0 [AMFI execve helper A]")
            self.emit(hits[1], MOV_X0_0, "mov x0,#0 [AMFI execve helper B]")
            patched = True
            break

        if not patched:
            self._log("  [-] AMFI execve helper patch sites not found")
        return patched

    def patch_task_conversion_eval_internal(self):
        """Allow task conversion: cmp Xn,x0 -> cmp xzr,xzr at unique guard site."""
        self._log("\n[JB] task_conversion_eval_internal: cmp xzr,xzr")

        candidates = []
        ks, ke = self.kern_text
        for off in range(ks + 4, ke - 12, 4):
            d0 = self._disas_at(off)
            if not d0:
                continue
            i0 = d0[0]
            if i0.mnemonic != "cmp" or len(i0.operands) < 2:
                continue
            a0, a1 = i0.operands[0], i0.operands[1]
            if not (a0.type == ARM64_OP_REG and a1.type == ARM64_OP_REG):
                continue
            if a1.reg != ARM64_REG_X0:
                continue
            cmp_reg = a0.reg

            dp = self._disas_at(off - 4)
            d1 = self._disas_at(off + 4)
            d2 = self._disas_at(off + 8)
            d3 = self._disas_at(off + 12)
            if not dp or not d1 or not d2 or not d3:
                continue
            p = dp[0]
            i1, i2, i3 = d1[0], d2[0], d3[0]

            if p.mnemonic != "ldr" or len(p.operands) < 2:
                continue
            p0, p1 = p.operands[0], p.operands[1]
            if p0.type != ARM64_OP_REG or p0.reg != cmp_reg:
                continue
            if p1.type != ARM64_OP_MEM:
                continue
            if p1.mem.base != cmp_reg:
                continue

            if i1.mnemonic != "b.eq":
                continue
            if i2.mnemonic != "cmp" or len(i2.operands) < 2:
                continue
            j0, j1 = i2.operands[0], i2.operands[1]
            if not (j0.type == ARM64_OP_REG and j1.type == ARM64_OP_REG):
                continue
            if not (j0.reg == cmp_reg and j1.reg == ARM64_REG_X1):
                continue
            if i3.mnemonic != "b.eq":
                continue

            candidates.append(off)

        if len(candidates) != 1:
            self._log(f"  [-] expected 1 task-conversion guard site, found {len(candidates)}")
            return False

        self.emit(candidates[0], CMP_XZR_XZR,
                  "cmp xzr,xzr [_task_conversion_eval_internal]")
        return True

    def patch_sandbox_hooks_extended(self):
        """Stub remaining sandbox MACF hooks (JB extension beyond base 5 hooks)."""
        self._log("\n[JB] Sandbox extended hooks: mov x0,#0; ret")

        ops_table = self._find_sandbox_ops_table_via_conf()
        if ops_table is None:
            return False

        HOOK_INDICES_EXT = {
            "vnode_check_getattr": 245,
            "proc_check_get_cs_info": 249,
            "proc_check_set_cs_info": 250,
            "proc_check_set_cs_info2": 252,
            "vnode_check_chroot": 254,
            "vnode_check_create": 255,
            "vnode_check_deleteextattr": 256,
            "vnode_check_exchangedata": 257,
            "vnode_check_exec": 258,
            "vnode_check_getattrlist": 259,
            "vnode_check_getextattr": 260,
            "vnode_check_ioctl": 261,
            "vnode_check_link": 264,
            "vnode_check_listextattr": 265,
            "vnode_check_open": 267,
            "vnode_check_readlink": 270,
            "vnode_check_setattrlist": 275,
            "vnode_check_setextattr": 276,
            "vnode_check_setflags": 277,
            "vnode_check_setmode": 278,
            "vnode_check_setowner": 279,
            "vnode_check_setutimes": 280,
            "vnode_check_stat": 281,
            "vnode_check_truncate": 282,
            "vnode_check_unlink": 283,
            "vnode_check_fsgetpath": 316,
        }

        sb_start, sb_end = self.sandbox_text
        patched = 0
        seen = set()

        for hook_name, idx in HOOK_INDICES_EXT.items():
            func_off = self._read_ops_entry(ops_table, idx)
            if func_off is None or func_off <= 0:
                continue
            if not (sb_start <= func_off < sb_end):
                continue
            if func_off in seen:
                continue
            seen.add(func_off)

            self.emit(func_off, MOV_X0_0, f"mov x0,#0 [_hook_{hook_name}]")
            self.emit(func_off + 4, RET, f"ret [_hook_{hook_name}]")
            patched += 1

        if patched == 0:
            self._log("  [-] no extended sandbox hooks patched")
            return False
        return True

    # ══════════════════════════════════════════════════════════════
    # Group B: Simple patches
    # ══════════════════════════════════════════════════════════════

    def patch_post_validation_additional(self):
        """Additional postValidation CMP W0,W0 in AMFI code signing path."""
        self._log("\n[JB] postValidation additional: cmp w0,w0")

        str_off = self.find_string(b"AMFI: code signature validation failed")
        if str_off < 0:
            self._log("  [-] string not found")
            return False

        refs = self.find_string_refs(str_off, *self.amfi_text)
        if not refs:
            refs = self.find_string_refs(str_off)
        if not refs:
            self._log("  [-] no code refs")
            return False

        caller_start = self.find_function_start(refs[0][0])
        if caller_start < 0:
            return False

        bl_targets = set()
        func_end = self._find_func_end(caller_start, 0x2000)
        for scan in range(caller_start, func_end, 4):
            target = self._is_bl(scan)
            if target >= 0:
                bl_targets.add(target)

        patched = 0
        for target in sorted(bl_targets):
            if not (self.amfi_text[0] <= target < self.amfi_text[1]):
                continue
            callee_end = self._find_func_end(target, 0x200)
            for off in range(target, callee_end, 4):
                d = self._disas_at(off, 2)
                if len(d) < 2:
                    continue
                i0, i1 = d[0], d[1]
                if i0.mnemonic != "cmp" or i1.mnemonic != "b.ne":
                    continue
                ops = i0.operands
                if len(ops) < 2:
                    continue
                if ops[0].type != ARM64_OP_REG or ops[0].reg != ARM64_REG_W0:
                    continue
                if ops[1].type != ARM64_OP_IMM:
                    continue
                has_bl = False
                for back in range(off - 4, max(off - 12, target), -4):
                    bt = self._is_bl(back)
                    if bt >= 0:
                        has_bl = True
                        break
                if has_bl:
                    self.emit(off, CMP_W0_W0,
                              f"cmp w0,w0 [postValidation additional]")
                    patched += 1

        if patched == 0:
            self._log("  [-] no additional postValidation CMP sites found")
            return False
        return True

    def patch_proc_security_policy(self):
        """Stub _proc_security_policy: mov x0,#0; ret.

        Anchor: find _proc_info via its distinctive switch-table pattern
        (sub wN,wM,#1; cmp wN,#0x21), then identify the most-called BL
        target within that function — that's _proc_security_policy.
        """
        self._log("\n[JB] _proc_security_policy: mov x0,#0; ret")

        # Try symbol first
        foff = self._resolve_symbol("_proc_security_policy")
        if foff >= 0:
            self.emit(foff, MOV_X0_0, "mov x0,#0 [_proc_security_policy]")
            self.emit(foff + 4, RET, "ret [_proc_security_policy]")
            return True

        # Find _proc_info by its distinctive switch table
        # Pattern: sub wN, wM, #1; cmp wN, #0x21 (33 = max proc_info callnum)
        proc_info_func = -1
        ks, ke = self.kern_text
        for off in range(ks, ke - 8, 4):
            d = self._disas_at(off, 2)
            if len(d) < 2:
                continue
            i0, i1 = d[0], d[1]
            if i0.mnemonic != "sub" or i1.mnemonic != "cmp":
                continue
            # sub wN, wM, #1
            if len(i0.operands) < 3:
                continue
            if i0.operands[2].type != ARM64_OP_IMM or i0.operands[2].imm != 1:
                continue
            # cmp wN, #0x21
            if len(i1.operands) < 2:
                continue
            if i1.operands[1].type != ARM64_OP_IMM or i1.operands[1].imm != 0x21:
                continue
            # Verify same register
            if i0.operands[0].reg != i1.operands[0].reg:
                continue
            # Found it — find function start
            proc_info_func = self.find_function_start(off)
            break

        if proc_info_func < 0:
            self._log("  [-] _proc_info function not found")
            return False

        proc_info_end = self._find_func_end(proc_info_func, 0x4000)
        self._log(f"  [+] _proc_info at 0x{proc_info_func:X} (size 0x{proc_info_end - proc_info_func:X})")

        # Count BL targets within _proc_info — the most frequent one
        # is _proc_security_policy (called once per switch case)
        bl_targets = Counter()
        for off in range(proc_info_func, proc_info_end, 4):
            target = self._is_bl(off)
            if target >= 0 and ks <= target < ke:
                bl_targets[target] += 1

        if not bl_targets:
            self._log("  [-] no BL targets found in _proc_info")
            return False

        # The security policy check is called the most (once per case)
        most_called = bl_targets.most_common(1)[0]
        foff = most_called[0]
        count = most_called[1]
        self._log(f"  [+] most-called BL target: 0x{foff:X} ({count} calls)")

        if count < 3:
            self._log("  [-] most-called target has too few calls")
            return False

        self.emit(foff, MOV_X0_0, "mov x0,#0 [_proc_security_policy]")
        self.emit(foff + 4, RET, "ret [_proc_security_policy]")
        return True

    def patch_proc_pidinfo(self):
        """Bypass pid-0 checks in _proc_info: NOP first 2 CBZ/CBNZ on w-regs.

        Anchor: find _proc_info via its switch-table pattern, then NOP the
        first two CBZ/CBNZ instructions that guard against pid 0.
        """
        self._log("\n[JB] _proc_pidinfo: NOP pid-0 guard (2 sites)")

        # Try symbol first
        foff = self._resolve_symbol("_proc_pidinfo")
        if foff >= 0:
            func_end = min(foff + 0x80, self.size)
            hits = []
            for off in range(foff, func_end, 4):
                d = self._disas_at(off)
                if d and d[0].mnemonic in ("cbz", "cbnz") and d[0].op_str.startswith("w"):
                    hits.append(off)
            if len(hits) >= 2:
                self.emit(hits[0], NOP, "NOP [_proc_pidinfo pid-0 guard A]")
                self.emit(hits[1], NOP, "NOP [_proc_pidinfo pid-0 guard B]")
                return True

        # Find _proc_info by switch table pattern (same as proc_security_policy)
        proc_info_func = -1
        ks, ke = self.kern_text
        for off in range(ks, ke - 8, 4):
            d = self._disas_at(off, 2)
            if len(d) < 2:
                continue
            i0, i1 = d[0], d[1]
            if i0.mnemonic != "sub" or i1.mnemonic != "cmp":
                continue
            if len(i0.operands) < 3:
                continue
            if i0.operands[2].type != ARM64_OP_IMM or i0.operands[2].imm != 1:
                continue
            if len(i1.operands) < 2:
                continue
            if i1.operands[1].type != ARM64_OP_IMM or i1.operands[1].imm != 0x21:
                continue
            if i0.operands[0].reg != i1.operands[0].reg:
                continue
            proc_info_func = self.find_function_start(off)
            break

        if proc_info_func < 0:
            self._log("  [-] _proc_info function not found")
            return False

        # Find first CBZ x0 (null proc check) and the CBZ/CBNZ wN after
        # the first BL in the prologue region
        hits = []
        prologue_end = min(proc_info_func + 0x80, self.size)
        for off in range(proc_info_func, prologue_end, 4):
            d = self._disas_at(off)
            if not d:
                continue
            i = d[0]
            if i.mnemonic in ("cbz", "cbnz"):
                # CBZ x0 (null check) or CBZ wN (pid-0 check)
                hits.append(off)

        if len(hits) < 2:
            self._log(f"  [-] expected 2+ early CBZ/CBNZ, found {len(hits)}")
            return False

        self.emit(hits[0], NOP, "NOP [_proc_pidinfo pid-0 guard A]")
        self.emit(hits[1], NOP, "NOP [_proc_pidinfo pid-0 guard B]")
        return True

    def patch_convert_port_to_map(self):
        """Skip panic in _convert_port_to_map_with_flavor.
        Anchor: 'userspace has control access to a kernel map' panic string.
        """
        self._log("\n[JB] _convert_port_to_map_with_flavor: skip panic")

        str_off = self.find_string(b"userspace has control access to a kernel map")
        if str_off < 0:
            self._log("  [-] panic string not found")
            return False

        refs = self.find_string_refs(str_off, *self.kern_text)
        if not refs:
            self._log("  [-] no code refs")
            return False

        for adrp_off, add_off, _ in refs:
            bl_panic = self._find_bl_to_panic_in_range(add_off, min(add_off + 0x40, self.size))
            if bl_panic < 0:
                continue
            resume_off = bl_panic + 4
            err_lo = adrp_off - 0x40
            for back in range(adrp_off - 4, max(adrp_off - 0x200, 0), -4):
                target, kind = self._decode_branch_target(back)
                if target is not None and err_lo <= target <= bl_panic + 4:
                    b_bytes = self._encode_b(back, resume_off)
                    if b_bytes:
                        self.emit(back, b_bytes,
                                  f"b #0x{resume_off - back:X} "
                                  f"[_convert_port_to_map skip panic]")
                        return True

        self._log("  [-] branch site not found")
        return False

    def patch_vm_fault_enter_prepare(self):
        """NOP a PMAP check in _vm_fault_enter_prepare.
        Find BL to a rarely-called function followed within 4 instructions
        by TBZ/TBNZ on w0.
        """
        self._log("\n[JB] _vm_fault_enter_prepare: NOP")

        # Try symbol first
        foff = self._resolve_symbol("_vm_fault_enter_prepare")
        if foff >= 0:
            func_end = self._find_func_end(foff, 0x2000)
            result = self._find_bl_tbz_pmap(foff + 0x100, func_end)
            if result:
                self.emit(result, NOP, "NOP [_vm_fault_enter_prepare]")
                return True

        # String anchor: all refs to "vm_fault_enter_prepare"
        str_off = self.find_string(b"vm_fault_enter_prepare")
        if str_off >= 0:
            refs = self.find_string_refs(str_off)
            for adrp_off, _, _ in refs:
                func_start = self.find_function_start(adrp_off)
                if func_start < 0:
                    continue
                func_end = self._find_func_end(func_start, 0x4000)
                result = self._find_bl_tbz_pmap(func_start + 0x100, func_end)
                if result:
                    self.emit(result, NOP, "NOP [_vm_fault_enter_prepare]")
                    return True

        # Broader: scan all kern_text for BL to rarely-called func + TBZ w0
        # in a large function (>0x2000 bytes)
        ks, ke = self.kern_text
        for off in range(ks, ke - 16, 4):
            result = self._find_bl_tbz_pmap(off, min(off + 16, ke))
            if result:
                # Verify it's in a large function
                func_start = self.find_function_start(result)
                if func_start >= 0:
                    func_end = self._find_func_end(func_start, 0x4000)
                    if func_end - func_start > 0x2000:
                        self.emit(result, NOP, "NOP [_vm_fault_enter_prepare]")
                        return True

        self._log("  [-] patch site not found")
        return False

    def _find_bl_tbz_pmap(self, start, end):
        """Find BL to a rarely-called function followed within 4 insns by TBZ/TBNZ w0.
        Returns the BL offset, or None."""
        for off in range(start, end - 4, 4):
            d0 = self._disas_at(off)
            if not d0 or d0[0].mnemonic != "bl":
                continue
            bl_target = d0[0].operands[0].imm
            n_callers = len(self.bl_callers.get(bl_target, []))
            if n_callers >= 20:
                continue
            # Check next 4 instructions for TBZ/TBNZ on w0
            for delta in range(1, 5):
                d1 = self._disas_at(off + delta * 4)
                if not d1:
                    break
                i1 = d1[0]
                if i1.mnemonic in ("tbnz", "tbz") and len(i1.operands) >= 2:
                    if i1.operands[0].type == ARM64_OP_REG and \
                            i1.operands[0].reg == ARM64_REG_W0:
                        return off
        return None

    def patch_vm_map_protect(self):
        """Skip a check in _vm_map_protect: branch over guard.
        Anchor: 'vm_map_protect(' panic string → function → TBNZ with high bit.
        """
        self._log("\n[JB] _vm_map_protect: skip check")

        # Try symbol first
        foff = self._resolve_symbol("_vm_map_protect")
        if foff < 0:
            # String anchor
            foff = self._find_func_by_string(b"vm_map_protect(", self.kern_text)
        if foff < 0:
            foff = self._find_func_by_string(b"vm_map_protect(")
        if foff < 0:
            self._log("  [-] function not found")
            return False

        func_end = self._find_func_end(foff, 0x2000)

        # Find TBNZ with bit >= 24 that branches forward (permission check guard)
        for off in range(foff, func_end - 4, 4):
            d = self._disas_at(off)
            if not d:
                continue
            i = d[0]
            if i.mnemonic != "tbnz":
                continue
            if len(i.operands) < 3:
                continue
            bit_op = i.operands[1]
            if bit_op.type == ARM64_OP_IMM and bit_op.imm >= 24:
                target = i.operands[2].imm if i.operands[2].type == ARM64_OP_IMM else -1
                if target > off:
                    b_bytes = self._encode_b(off, target)
                    if b_bytes:
                        self.emit(off, b_bytes,
                                  f"b #0x{target - off:X} [_vm_map_protect]")
                        return True

        self._log("  [-] patch site not found")
        return False

    def patch_mac_mount(self):
        """Bypass MAC mount check: NOP + mov x8,xzr in ___mac_mount.
        Anchor: 'mount_common()' string → find nearby ___mac_mount function.
        """
        self._log("\n[JB] ___mac_mount: NOP + mov x8,xzr")

        # Try symbol first
        foff = self._resolve_symbol("___mac_mount")
        if foff < 0:
            foff = self._resolve_symbol("__mac_mount")
        if foff < 0:
            # Find via 'mount_common()' string → function area
            # ___mac_mount is typically called from mount_common/kernel_mount
            # Search for a function containing a BL+CBNZ w0 pattern
            # near the mount_common string reference area
            str_off = self.find_string(b"mount_common()")
            if str_off >= 0:
                refs = self.find_string_refs(str_off, *self.kern_text)
                if refs:
                    mount_common_func = self.find_function_start(refs[0][0])
                    if mount_common_func >= 0:
                        # __mac_mount is called from mount_common
                        # Find BL targets from mount_common
                        mc_end = self._find_func_end(mount_common_func, 0x2000)
                        for off in range(mount_common_func, mc_end, 4):
                            target = self._is_bl(off)
                            if target >= 0 and self.kern_text[0] <= target < self.kern_text[1]:
                                # Check if this target contains BL+CBNZ w0 pattern
                                # (mac check) followed by a mov to x8
                                te = self._find_func_end(target, 0x1000)
                                for off2 in range(target, te - 8, 4):
                                    d0 = self._disas_at(off2)
                                    if not d0 or d0[0].mnemonic != "bl":
                                        continue
                                    d1 = self._disas_at(off2 + 4)
                                    if d1 and d1[0].mnemonic == "cbnz" and d1[0].op_str.startswith("w0,"):
                                        foff = target
                                        break
                                if foff >= 0:
                                    break

        if foff < 0:
            self._log("  [-] function not found")
            return False

        func_end = self._find_func_end(foff, 0x1000)
        patched = 0

        for off in range(foff, func_end - 8, 4):
            d0 = self._disas_at(off)
            if not d0 or d0[0].mnemonic != "bl":
                continue
            d1 = self._disas_at(off + 4)
            if not d1:
                continue
            if d1[0].mnemonic == "cbnz" and d1[0].op_str.startswith("w0,"):
                self.emit(off, NOP, "NOP [___mac_mount BL check]")
                patched += 1
                for off2 in range(off + 8, min(off + 0x60, func_end), 4):
                    d2 = self._disas_at(off2)
                    if not d2:
                        continue
                    if d2[0].mnemonic == "mov" and "x8" in d2[0].op_str:
                        if d2[0].op_str != "x8, xzr":
                            self.emit(off2, MOV_X8_XZR,
                                      "mov x8,xzr [___mac_mount]")
                            patched += 1
                            break
                break

        if patched == 0:
            self._log("  [-] patch sites not found")
            return False
        return True

    def patch_dounmount(self):
        """NOP a MAC check in _dounmount.
        Pattern: mov w1,#0; mov x2,#0; bl TARGET (MAC policy check pattern).
        """
        self._log("\n[JB] _dounmount: NOP")

        # Try symbol first
        foff = self._resolve_symbol("_dounmount")
        if foff >= 0:
            func_end = self._find_func_end(foff, 0x1000)
            result = self._find_mac_check_bl(foff, func_end)
            if result:
                self.emit(result, NOP, "NOP [_dounmount MAC check]")
                return True

        # String anchor: "dounmount:" → find function → search BL targets
        # for the actual _dounmount with MAC check
        str_off = self.find_string(b"dounmount:")
        if str_off >= 0:
            refs = self.find_string_refs(str_off)
            for adrp_off, _, _ in refs:
                caller = self.find_function_start(adrp_off)
                if caller < 0:
                    continue
                caller_end = self._find_func_end(caller, 0x2000)
                # Check BL targets from this function
                for off in range(caller, caller_end, 4):
                    target = self._is_bl(off)
                    if target < 0 or not (self.kern_text[0] <= target < self.kern_text[1]):
                        continue
                    te = self._find_func_end(target, 0x400)
                    result = self._find_mac_check_bl(target, te)
                    if result:
                        self.emit(result, NOP, "NOP [_dounmount MAC check]")
                        return True

        # Broader: scan kern_text for short functions with MAC check pattern
        ks, ke = self.kern_text
        for off in range(ks, ke - 12, 4):
            d = self._disas_at(off)
            if not d or d[0].mnemonic != "pacibsp":
                continue
            func_end = self._find_func_end(off, 0x400)
            if func_end - off > 0x400:
                continue
            result = self._find_mac_check_bl(off, func_end)
            if result:
                # Verify: function should have "unmount" context
                # (contain a BL to a function also called from known mount code)
                self.emit(result, NOP, "NOP [_dounmount MAC check]")
                return True

        self._log("  [-] patch site not found")
        return False

    def _find_mac_check_bl(self, start, end):
        """Find mov w1,#0; mov x2,#0; bl TARGET pattern. Returns BL offset or None."""
        for off in range(start, end - 8, 4):
            d = self._disas_at(off, 3)
            if len(d) < 3:
                continue
            i0, i1, i2 = d[0], d[1], d[2]
            if i0.mnemonic != "mov" or i1.mnemonic != "mov" or i2.mnemonic != "bl":
                continue
            # Check: mov w1, #0; mov x2, #0
            if "w1" in i0.op_str and "#0" in i0.op_str:
                if "x2" in i1.op_str and "#0" in i1.op_str:
                    return off + 8
            # Also match: mov x2, #0; mov w1, #0
            if "x2" in i0.op_str and "#0" in i0.op_str:
                if "w1" in i1.op_str and "#0" in i1.op_str:
                    return off + 8
        return None

    def patch_bsd_init_auth(self):
        """Bypass rootvp authentication check in _bsd_init.
        Pattern: ldr x0, [xN, #0x2b8]; cbz x0, ...; bl AUTH_FUNC
        Replace the BL with mov x0, #0.
        """
        self._log("\n[JB] _bsd_init: mov x0,#0 (auth bypass)")

        # Try symbol first
        foff = self._resolve_symbol("_bsd_init")
        if foff >= 0:
            func_end = self._find_func_end(foff, 0x2000)
            result = self._find_auth_bl(foff, func_end)
            if result:
                self.emit(result, MOV_X0_0, "mov x0,#0 [_bsd_init auth]")
                return True

        # Pattern search: ldr x0, [xN, #0x2b8]; cbz x0; bl
        ks, ke = self.kern_text
        candidates = []
        for off in range(ks, ke - 8, 4):
            d = self._disas_at(off, 3)
            if len(d) < 3:
                continue
            i0, i1, i2 = d[0], d[1], d[2]
            if i0.mnemonic != "ldr" or i1.mnemonic != "cbz" or i2.mnemonic != "bl":
                continue
            if not i0.op_str.startswith("x0,"):
                continue
            if "#0x2b8" not in i0.op_str:
                continue
            if not i1.op_str.startswith("x0,"):
                continue
            candidates.append(off + 8)  # the BL offset

        if not candidates:
            self._log("  [-] ldr+cbz+bl pattern not found")
            return False

        # Filter to kern_text range (exclude kexts)
        kern_candidates = [c for c in candidates
                           if ks <= c < ke]
        if not kern_candidates:
            kern_candidates = candidates

        # Pick the last one in the kernel (bsd_init is typically late in boot)
        bl_off = kern_candidates[-1]
        self._log(f"  [+] auth BL at 0x{bl_off:X} "
                  f"({len(kern_candidates)} kern candidates)")
        self.emit(bl_off, MOV_X0_0, "mov x0,#0 [_bsd_init auth]")
        return True

    def _find_auth_bl(self, start, end):
        """Find ldr x0,[xN,#0x2b8]; cbz x0; bl pattern. Returns BL offset."""
        for off in range(start, end - 8, 4):
            d = self._disas_at(off, 3)
            if len(d) < 3:
                continue
            i0, i1, i2 = d[0], d[1], d[2]
            if i0.mnemonic == "ldr" and i1.mnemonic == "cbz" and i2.mnemonic == "bl":
                if i0.op_str.startswith("x0,") and "#0x2b8" in i0.op_str:
                    if i1.op_str.startswith("x0,"):
                        return off + 8
        return None

    def patch_spawn_validate_persona(self):
        """NOP persona validation: LDR + TBNZ sites.
        Pattern: ldr wN, [xN, #0x600] (unique struct offset) followed by
        cbz wN then tbnz wN, #1 — NOP both the LDR and the TBNZ.
        """
        self._log("\n[JB] _spawn_validate_persona: NOP (2 sites)")

        # Try symbol first
        foff = self._resolve_symbol("_spawn_validate_persona")
        if foff >= 0:
            func_end = self._find_func_end(foff, 0x800)
            result = self._find_persona_pattern(foff, func_end)
            if result:
                self.emit(result[0], NOP, "NOP [_spawn_validate_persona LDR]")
                self.emit(result[1], NOP, "NOP [_spawn_validate_persona TBNZ]")
                return True

        # Pattern search: ldr wN, [xN, #0x600] ... tbnz wN, #1
        # This pattern is unique to _spawn_validate_persona
        ks, ke = self.kern_text
        for off in range(ks, ke - 0x30, 4):
            d = self._disas_at(off)
            if not d or d[0].mnemonic != "ldr":
                continue
            if "#0x600" not in d[0].op_str:
                continue
            if not d[0].op_str.startswith("w"):
                continue
            # Found LDR wN, [xN, #0x600] — look for TBNZ wN, #1 within 0x30
            for delta in range(4, 0x30, 4):
                d2 = self._disas_at(off + delta)
                if not d2:
                    continue
                if d2[0].mnemonic == "tbnz" and "#1" in d2[0].op_str:
                    # Verify it's a w-register
                    if d2[0].op_str.startswith("w"):
                        self._log(f"  [+] LDR at 0x{off:X}, "
                                  f"TBNZ at 0x{off + delta:X}")
                        self.emit(off, NOP,
                                  "NOP [_spawn_validate_persona LDR]")
                        self.emit(off + delta, NOP,
                                  "NOP [_spawn_validate_persona TBNZ]")
                        return True

        self._log("  [-] pattern not found")
        return False

    def _find_persona_pattern(self, start, end):
        """Find ldr wN,[xN,#0x600] + tbnz wN,#1 pattern. Returns (ldr_off, tbnz_off)."""
        for off in range(start, end - 0x30, 4):
            d = self._disas_at(off)
            if not d or d[0].mnemonic != "ldr":
                continue
            if "#0x600" not in d[0].op_str or not d[0].op_str.startswith("w"):
                continue
            for delta in range(4, 0x30, 4):
                d2 = self._disas_at(off + delta)
                if d2 and d2[0].mnemonic == "tbnz" and "#1" in d2[0].op_str:
                    if d2[0].op_str.startswith("w"):
                        return (off, off + delta)
        return None

    def patch_task_for_pid(self):
        """NOP proc_ro security policy copy in _task_for_pid.

        Pattern: _task_for_pid is a Mach trap handler (0 BL callers) with:
          - 2x ldadda (proc reference counting)
          - 2x ldr wN,[xN,#0x490]; str wN,[xN,#0xc] (proc_ro security copy)
          - movk xN, #0xc8a2, lsl #48 (PAC discriminator)
          - BL to a non-panic function with >500 callers (proc_find etc.)
        NOP the second ldr wN,[xN,#0x490] (the target process security copy).
        """
        self._log("\n[JB] _task_for_pid: NOP")

        # Try symbol first
        foff = self._resolve_symbol("_task_for_pid")
        if foff >= 0:
            func_end = self._find_func_end(foff, 0x800)
            patch_off = self._find_second_ldr490(foff, func_end)
            if patch_off:
                self.emit(patch_off, NOP,
                          "NOP [_task_for_pid proc_ro copy]")
                return True

        # Pattern search: scan kern_text for functions matching the profile
        ks, ke = self.kern_text
        off = ks
        while off < ke - 4:
            d = self._disas_at(off)
            if not d or d[0].mnemonic != "pacibsp":
                off += 4
                continue
            func_start = off
            func_end = self._find_func_end(func_start, 0x1000)

            # Quick filter: skip functions with BL callers (Mach trap = indirect)
            if self.bl_callers.get(func_start, []):
                off = func_end
                continue

            ldadda_count = 0
            ldr490_count = 0
            ldr490_offs = []
            has_movk_c8a2 = False
            has_high_caller_bl = False

            for o in range(func_start, func_end, 4):
                d = self._disas_at(o)
                if not d:
                    continue
                i = d[0]
                if i.mnemonic == "ldadda":
                    ldadda_count += 1
                elif i.mnemonic == "ldr" and "#0x490" in i.op_str \
                        and i.op_str.startswith("w"):
                    d2 = self._disas_at(o + 4)
                    if d2 and d2[0].mnemonic == "str" \
                            and "#0xc" in d2[0].op_str \
                            and d2[0].op_str.startswith("w"):
                        ldr490_count += 1
                        ldr490_offs.append(o)
                elif i.mnemonic == "movk" and "#0xc8a2" in i.op_str:
                    has_movk_c8a2 = True
                elif i.mnemonic == "bl":
                    target = i.operands[0].imm
                    n_callers = len(self.bl_callers.get(target, []))
                    # >500 but <8000 excludes _panic (typically 8000+)
                    if 500 < n_callers < 8000:
                        has_high_caller_bl = True

            if ldadda_count >= 2 and ldr490_count >= 2 \
                    and has_movk_c8a2 and has_high_caller_bl:
                patch_off = ldr490_offs[1]  # NOP the second occurrence
                self._log(f"  [+] _task_for_pid at 0x{func_start:X}, "
                          f"patch at 0x{patch_off:X}")
                self.emit(patch_off, NOP,
                          "NOP [_task_for_pid proc_ro copy]")
                return True

            off = func_end

        self._log("  [-] function not found")
        return False

    def _find_second_ldr490(self, start, end):
        """Find the second ldr wN,[xN,#0x490]+str wN,[xN,#0xc] in range."""
        count = 0
        for off in range(start, end - 4, 4):
            d = self._disas_at(off)
            if not d or d[0].mnemonic != "ldr":
                continue
            if "#0x490" not in d[0].op_str or not d[0].op_str.startswith("w"):
                continue
            d2 = self._disas_at(off + 4)
            if d2 and d2[0].mnemonic == "str" \
                    and "#0xc" in d2[0].op_str \
                    and d2[0].op_str.startswith("w"):
                count += 1
                if count == 2:
                    return off
        return None

    def patch_load_dylinker(self):
        """Bypass PAC auth check in Mach-O chained fixup rebase code.

        The kernel's chained fixup pointer rebase function contains PAC
        authentication triplets: TST xN, #high; B.EQ skip; MOVK xN, #0xc8a2.
        This function has 3+ such triplets and 0 BL callers (indirect call).

        Find the function and replace the LAST TST with an unconditional
        branch to the B.EQ target (always skip PAC re-signing).
        """
        self._log("\n[JB] _load_dylinker: PAC rebase bypass")

        # Try symbol first
        foff = self._resolve_symbol("_load_dylinker")
        if foff >= 0:
            func_end = self._find_func_end(foff, 0x2000)
            result = self._find_tst_pac_triplet(foff, func_end)
            if result:
                tst_off, beq_target = result
                b_bytes = self._encode_b(tst_off, beq_target)
                if b_bytes:
                    self.emit(tst_off, b_bytes,
                              f"b #0x{beq_target - tst_off:X} [_load_dylinker]")
                    return True

        # Pattern search: find functions with 3+ TST+B.EQ+MOVK(#0xc8a2)
        # triplets and 0 BL callers. This is the chained fixup rebase code.
        ks, ke = self.kern_text
        off = ks
        while off < ke - 4:
            d = self._disas_at(off)
            if not d or d[0].mnemonic != "pacibsp":
                off += 4
                continue
            func_start = off
            func_end = self._find_func_end(func_start, 0x2000)

            # Must have 0 BL callers (indirect call via function pointer)
            if self.bl_callers.get(func_start, []):
                off = func_end
                continue

            # Count TST+B.EQ+MOVK(#0xc8a2) triplets
            triplets = []
            for o in range(func_start, func_end - 8, 4):
                d3 = self._disas_at(o, 3)
                if len(d3) < 3:
                    continue
                i0, i1, i2 = d3[0], d3[1], d3[2]
                if i0.mnemonic == "tst" \
                        and "40000000000000" in i0.op_str \
                        and i1.mnemonic == "b.eq" \
                        and i2.mnemonic == "movk" \
                        and "#0xc8a2" in i2.op_str:
                    beq_target = i1.operands[-1].imm
                    triplets.append((o, beq_target))

            if len(triplets) >= 3:
                # Patch the last triplet (deepest in the function)
                tst_off, beq_target = triplets[-1]
                b_bytes = self._encode_b(tst_off, beq_target)
                if b_bytes:
                    self._log(f"  [+] rebase func at 0x{func_start:X}, "
                              f"patch TST at 0x{tst_off:X}")
                    self.emit(tst_off, b_bytes,
                              f"b #0x{beq_target - tst_off:X} "
                              f"[_load_dylinker PAC bypass]")
                    return True

            off = func_end

        self._log("  [-] PAC rebase function not found")
        return False

    def _find_tst_pac_triplet(self, start, end):
        """Find last TST+B.EQ+MOVK(#0xc8a2) triplet. Returns (tst_off, beq_target)."""
        last = None
        for off in range(start, end - 8, 4):
            d = self._disas_at(off, 3)
            if len(d) < 3:
                continue
            i0, i1, i2 = d[0], d[1], d[2]
            if i0.mnemonic == "tst" \
                    and "40000000000000" in i0.op_str \
                    and i1.mnemonic == "b.eq" \
                    and i2.mnemonic == "movk" \
                    and "#0xc8a2" in i2.op_str:
                last = (off, i1.operands[-1].imm)
        return last

    def patch_shared_region_map(self):
        """Force shared region check: cmp x0,x0.
        Anchor: '/private/preboot/Cryptexes' string → function → CMP+B.NE.
        """
        self._log("\n[JB] _shared_region_map_and_slide_setup: cmp x0,x0")

        # Try symbol first
        foff = self._resolve_symbol("_shared_region_map_and_slide_setup")
        if foff < 0:
            foff = self._find_func_by_string(
                b"/private/preboot/Cryptexes", self.kern_text)
        if foff < 0:
            foff = self._find_func_by_string(b"/private/preboot/Cryptexes")
        if foff < 0:
            self._log("  [-] function not found")
            return False

        func_end = self._find_func_end(foff, 0x2000)

        for off in range(foff, func_end - 4, 4):
            d = self._disas_at(off, 2)
            if len(d) < 2:
                continue
            i0, i1 = d[0], d[1]
            if i0.mnemonic != "cmp" or i1.mnemonic != "b.ne":
                continue
            ops = i0.operands
            if len(ops) < 2:
                continue
            if ops[0].type == ARM64_OP_REG and ops[1].type == ARM64_OP_REG:
                self.emit(off, CMP_X0_X0,
                          "cmp x0,x0 [_shared_region_map_and_slide_setup]")
                return True

        self._log("  [-] CMP+B.NE pattern not found")
        return False

    def patch_nvram_verify_permission(self):
        """NOP verification in IONVRAMController's verifyPermission.
        Anchor: 'krn.' string (NVRAM key prefix) → xref → function → TBZ/TBNZ.
        """
        self._log("\n[JB] verifyPermission (NVRAM): NOP")

        # Try symbol first
        sym_off = self._resolve_symbol(
            "__ZL16verifyPermission16IONVRAMOperationPKhPKcb")
        if sym_off < 0:
            for sym, off in self.symbols.items():
                if "verifyPermission" in sym and "NVRAM" in sym:
                    sym_off = off
                    break

        # String anchor: "krn." is referenced in verifyPermission.
        # The TBZ/TBNZ guard is immediately before the ADRP+ADD that
        # loads the "krn." string, so search backward from that ref.
        str_off = self.find_string(b"krn.")
        ref_off = -1
        if str_off >= 0:
            refs = self.find_string_refs(str_off)
            if refs:
                ref_off = refs[0][0]  # ADRP instruction offset

        foff = sym_off if sym_off >= 0 else (
            self.find_function_start(ref_off) if ref_off >= 0 else -1)

        if foff < 0:
            # Fallback: try NVRAM entitlement string
            ent_off = self.find_string(
                b"com.apple.private.iokit.nvram-write-access")
            if ent_off >= 0:
                ent_refs = self.find_string_refs(ent_off)
                if ent_refs:
                    foff = self.find_function_start(ent_refs[0][0])

        if foff < 0:
            self._log("  [-] function not found")
            return False

        func_end = self._find_func_end(foff, 0x600)

        # Strategy 1: search backward from "krn." string ref for
        # nearest TBZ/TBNZ — the guard branch is typically within
        # a few instructions before the ADRP that loads "krn.".
        if ref_off > foff:
            for off in range(ref_off - 4, max(foff - 4, ref_off - 0x20), -4):
                d = self._disas_at(off)
                if d and d[0].mnemonic in ("tbnz", "tbz"):
                    self.emit(off, NOP, "NOP [verifyPermission NVRAM]")
                    return True

        # Strategy 2: scan full function for first TBZ/TBNZ
        for off in range(foff, func_end, 4):
            d = self._disas_at(off)
            if not d:
                continue
            if d[0].mnemonic in ("tbnz", "tbz"):
                self.emit(off, NOP, "NOP [verifyPermission NVRAM]")
                return True

        self._log("  [-] TBZ/TBNZ not found in function")
        return False

    def patch_io_secure_bsd_root(self):
        """Skip security check in _IOSecureBSDRoot.
        Anchor: 'SecureRootName' string → function → CBZ/CBNZ → unconditional B.
        """
        self._log("\n[JB] _IOSecureBSDRoot: skip check")

        # Try symbol first
        foff = self._resolve_symbol("_IOSecureBSDRoot")
        if foff < 0:
            foff = self._find_func_by_string(b"SecureRootName")
        if foff < 0:
            self._log("  [-] function not found")
            return False

        func_end = self._find_func_end(foff, 0x400)

        for off in range(foff, func_end - 4, 4):
            d = self._disas_at(off)
            if not d:
                continue
            i = d[0]
            if i.mnemonic in ("cbnz", "cbz", "tbnz", "tbz"):
                target = None
                for op in reversed(i.operands):
                    if op.type == ARM64_OP_IMM:
                        target = op.imm
                        break
                if target and target > off:
                    b_bytes = self._encode_b(off, target)
                    if b_bytes:
                        self.emit(off, b_bytes,
                                  f"b #0x{target - off:X} [_IOSecureBSDRoot]")
                        return True

        self._log("  [-] conditional branch not found")
        return False

    def patch_thid_should_crash(self):
        """Zero out _thid_should_crash global variable.
        Anchor: 'thid_should_crash' string in __DATA → nearby sysctl_oid struct
        contains a raw pointer (low32 = file offset) to the variable.
        """
        self._log("\n[JB] _thid_should_crash: zero out")

        # Try symbol first
        foff = self._resolve_symbol("_thid_should_crash")
        if foff >= 0:
            self.emit(foff, b'\x00\x00\x00\x00',
                      "zero [_thid_should_crash]")
            return True

        # Find the string in __DATA (sysctl name string)
        str_off = self.find_string(b"thid_should_crash")
        if str_off < 0:
            self._log("  [-] string not found")
            return False

        self._log(f"  [*] string at foff 0x{str_off:X}")

        # The sysctl_oid struct is near the string in __DATA.
        # It contains 8-byte entries, one of which has its low32 bits
        # equal to the file offset of the variable (chained fixup encoding).
        # The variable is a 4-byte int (typically value 1) in __DATA_CONST.
        #
        # Search forward from the string for 8-byte values whose low32
        # points to a valid location holding a small non-zero value.
        data_const_ranges = [(fo, fo + fs) for name, _, fo, fs, _
                             in self.all_segments
                             if name in ("__DATA_CONST",) and fs > 0]

        for delta in range(0, 128, 8):
            check = str_off + delta
            if check + 8 > self.size:
                break
            val = _rd64(self.raw, check)
            if val == 0:
                continue
            low32 = val & 0xFFFFFFFF
            # The variable should be in __DATA_CONST or __DATA
            if low32 == 0 or low32 >= self.size:
                continue
            # Check if low32 points to a location holding a small int (1-255)
            target_val = _rd32(self.raw, low32)
            if 1 <= target_val <= 255:
                # Verify it's in a data segment (not code)
                in_data = any(s <= low32 < e for s, e in data_const_ranges)
                if not in_data:
                    # Also accept __DATA segments
                    in_data = any(
                        fo <= low32 < fo + fs
                        for name, _, fo, fs, _ in self.all_segments
                        if "DATA" in name and fs > 0)
                if in_data:
                    self._log(f"  [+] variable at foff 0x{low32:X} "
                              f"(value={target_val}, found via sysctl_oid "
                              f"at str+0x{delta:X})")
                    self.emit(low32, b'\x00\x00\x00\x00',
                              "zero [_thid_should_crash]")
                    return True

        # Fallback: if string has code refs, search via ADRP+ADD
        refs = self.find_string_refs(str_off)
        if refs:
            func_start = self.find_function_start(refs[0][0])
            if func_start >= 0:
                func_end = self._find_func_end(func_start, 0x200)
                for off in range(func_start, func_end - 4, 4):
                    d = self._disas_at(off, 2)
                    if len(d) < 2:
                        continue
                    i0, i1 = d[0], d[1]
                    if i0.mnemonic == "adrp" and i1.mnemonic == "add":
                        page = (i0.operands[1].imm - self.base_va) & ~0xFFF
                        imm12 = (i1.operands[2].imm if len(i1.operands) > 2
                                 else 0)
                        target = page + imm12
                        if 0 < target < self.size:
                            tv = _rd32(self.raw, target)
                            if 1 <= tv <= 255:
                                self.emit(target, b'\x00\x00\x00\x00',
                                          "zero [_thid_should_crash]")
                                return True

        self._log("  [-] variable not found")
        return False

    # ══════════════════════════════════════════════════════════════
    # Group C: Complex shellcode patches
    # ══════════════════════════════════════════════════════════════

    def patch_cred_label_update_execve(self):
        """Redirect _cred_label_update_execve to shellcode that sets cs_flags.

        Shellcode: LDR x0,[sp,#8]; LDR w1,[x0]; ORR w1,w1,#0x4000000;
                   ORR w1,w1,#0xF; AND w1,w1,#0xFFFFC0FF; STR w1,[x0];
                   MOV x0,xzr; RETAB
        """
        self._log("\n[JB] _cred_label_update_execve: shellcode (cs_flags)")

        # Find the function via AMFI string reference
        func_off = -1

        # Try symbol
        for sym, off in self.symbols.items():
            if "cred_label_update_execve" in sym and "hook" not in sym:
                func_off = off
                break

        if func_off < 0:
            # String anchor: the function is near execve-related AMFI code.
            # Look for the function that contains the AMFI string ref and
            # then find _cred_label_update_execve through BL targets.
            str_off = self.find_string(b"AMFI: code signature validation failed")
            if str_off >= 0:
                refs = self.find_string_refs(str_off, *self.amfi_text)
                if refs:
                    caller = self.find_function_start(refs[0][0])
                    if caller >= 0:
                        # Walk through the AMFI text section to find functions
                        # that have a RETAB at the end and take many arguments
                        # The _cred_label_update_execve has many args and a
                        # distinctive prologue.
                        pass

        if func_off < 0:
            # Alternative: search AMFI text for functions that match the pattern
            # of _cred_label_update_execve (long prologue, many saved regs, RETAB)
            # Look for the specific pattern: mov xN, x2 in early prologue
            # (saves the vnode arg) followed by stp xzr,xzr pattern
            s, e = self.amfi_text
            # Search for PACIBSP functions in AMFI that are BL targets from
            # the execve kill path area
            str_off = self.find_string(b"AMFI: hook..execve() killing")
            if str_off < 0:
                str_off = self.find_string(b"execve() killing")
            if str_off >= 0:
                refs = self.find_string_refs(str_off, s, e)
                if not refs:
                    refs = self.find_string_refs(str_off)
                if refs:
                    kill_func = self.find_function_start(refs[0][0])
                    if kill_func >= 0:
                        kill_end = self._find_func_end(kill_func, 0x800)
                        # The kill function ends with RETAB. The next function
                        # after it should be close to _cred_label_update_execve.
                        # Actually, _cred_label_update_execve is typically the
                        # function BEFORE the kill function.
                        # Search backward from kill_func for a RETAB/RET
                        for back in range(kill_func - 4, max(kill_func - 0x400, s), -4):
                            val = _rd32(self.raw, back)
                            if val in (0xD65F0FFF, 0xD65F0BFF, 0xD65F03C0):
                                # Found end of previous function.
                                # The function we want starts at the next PACIBSP before back.
                                for scan in range(back - 4, max(back - 0x400, s), -4):
                                    d = self._disas_at(scan)
                                    if d and d[0].mnemonic == "pacibsp":
                                        func_off = scan
                                        break
                                break

        if func_off < 0:
            self._log("  [-] function not found, skipping shellcode patch")
            return False

        # Find code cave
        cave = self._find_code_cave(32)  # 8 instructions = 32 bytes
        if cave < 0:
            self._log("  [-] no code cave found for shellcode")
            return False

        # Assemble shellcode
        shellcode = (
            asm("ldr x0, [sp, #8]") +         # load cred pointer
            asm("ldr w1, [x0]") +              # load cs_flags
            asm("orr w1, w1, #0x4000000") +    # set CS_PLATFORM_BINARY
            asm("orr w1, w1, #0xF") +          # set CS_VALID|CS_ADHOC|CS_GET_TASK_ALLOW|CS_INSTALLER
            bytes([0x21, 0x64, 0x12, 0x12]) +  # AND w1, w1, #0xFFFFC0FF (clear CS_HARD|CS_KILL etc)
            asm("str w1, [x0]") +              # store back
            asm("mov x0, xzr") +               # return 0
            bytes([0xFF, 0x0F, 0x5F, 0xD6])    # RETAB
        )

        # Find the return site in the function (last RETAB)
        func_end = self._find_func_end(func_off, 0x200)
        ret_off = -1
        for off in range(func_end - 4, func_off, -4):
            val = _rd32(self.raw, off)
            if val in (0xD65F0FFF, 0xD65F0BFF, 0xD65F03C0):
                ret_off = off
                break
        if ret_off < 0:
            self._log("  [-] function return not found")
            return False

        # Write shellcode to cave
        for i in range(0, len(shellcode), 4):
            self.emit(cave + i, shellcode[i:i+4],
                      f"shellcode+{i} [_cred_label_update_execve]")

        # Branch from function return to cave
        b_bytes = self._encode_b(ret_off, cave)
        if b_bytes:
            self.emit(ret_off, b_bytes,
                      f"b cave [_cred_label_update_execve -> 0x{cave:X}]")
        else:
            self._log("  [-] branch to cave out of range")
            return False

        return True

    def patch_syscallmask_apply_to_proc(self):
        """Redirect _syscallmask_apply_to_proc to custom filter shellcode.
        Anchor: 'syscallmask.c' string → find function → redirect to cave.
        """
        self._log("\n[JB] _syscallmask_apply_to_proc: shellcode (filter mask)")

        # Resolve required functions
        func_off = self._resolve_symbol("_syscallmask_apply_to_proc")
        zalloc_off = self._resolve_symbol("_zalloc_ro_mut")
        filter_off = self._resolve_symbol("_proc_set_syscall_filter_mask")

        if func_off < 0:
            # String anchor: "syscallmask.c"
            str_off = self.find_string(b"syscallmask.c")
            if str_off >= 0:
                refs = self.find_string_refs(str_off, *self.kern_text)
                if not refs:
                    refs = self.find_string_refs(str_off)
                if refs:
                    # The function containing this string ref is in the
                    # syscallmask module. Find _syscallmask_apply_to_proc
                    # by looking for a function nearby that takes 4 args.
                    base_func = self.find_function_start(refs[0][0])
                    if base_func >= 0:
                        # Search nearby functions for the one that has a
                        # BL to _proc_set_syscall_filter_mask-like function.
                        # Actually, the function with "syscallmask.c" IS likely
                        # _syscallmask_apply_to_proc or very close to it.
                        func_off = base_func

        if func_off < 0:
            self._log("  [-] _syscallmask_apply_to_proc not found")
            return False

        # Find _zalloc_ro_mut: search for the BL target from within the function
        # that's called with specific arguments. Use BL callers analysis.
        if zalloc_off < 0:
            func_end = self._find_func_end(func_off, 0x200)
            for off in range(func_off, func_end, 4):
                target = self._is_bl(off)
                if target >= 0:
                    # _zalloc_ro_mut is typically one of the BL targets
                    # It's the one with many callers (>50)
                    # bl_callers is keyed by file offset (same as _is_bl returns)
                    n = len(self.bl_callers.get(target, []))
                    if n > 50:
                        zalloc_off = target
                        break

        # Find _proc_set_syscall_filter_mask: search for a BL or B target
        if filter_off < 0:
            func_end = self._find_func_end(func_off, 0x200)
            # It's typically the last BL/B target in the function (tail call)
            for off in range(func_end - 4, func_off, -4):
                target = self._is_bl(off)
                if target >= 0:
                    filter_off = target
                    break
                # Also check for unconditional B
                val = _rd32(self.raw, off)
                if (val & 0xFC000000) == 0x14000000:
                    imm26 = val & 0x3FFFFFF
                    if imm26 & (1 << 25):
                        imm26 -= (1 << 26)
                    target = off + imm26 * 4
                    if self.kern_text[0] <= target < self.kern_text[1]:
                        filter_off = target
                        break

        if zalloc_off < 0 or filter_off < 0:
            self._log(f"  [-] required functions not found "
                      f"(zalloc={'found' if zalloc_off >= 0 else 'missing'}, "
                      f"filter={'found' if filter_off >= 0 else 'missing'})")
            return False

        # Find code cave (need ~160 bytes)
        cave = self._find_code_cave(160)
        if cave < 0:
            self._log("  [-] no code cave found")
            return False

        cave_base = cave

        # Encode BL to _zalloc_ro_mut (at cave + 28*4)
        zalloc_bl_off = cave_base + 28 * 4
        zalloc_bl = self._encode_bl(zalloc_bl_off, zalloc_off)
        if not zalloc_bl:
            self._log("  [-] BL to _zalloc_ro_mut out of range")
            return False

        # Encode B to _proc_set_syscall_filter_mask (at end of shellcode)
        filter_b_off = cave_base + 37 * 4
        filter_b = self._encode_b(filter_b_off, filter_off)
        if not filter_b:
            self._log("  [-] B to _proc_set_syscall_filter_mask out of range")
            return False

        # Build shellcode
        shellcode_parts = []
        for _ in range(10):
            shellcode_parts.append(b'\xff\xff\xff\xff')

        shellcode_parts.append(asm("cbz x2, #0x6c"))       # idx 10
        shellcode_parts.append(asm("sub sp, sp, #0x40"))    # idx 11
        shellcode_parts.append(asm("stp x19, x20, [sp, #0x10]"))  # idx 12
        shellcode_parts.append(asm("stp x21, x22, [sp, #0x20]"))  # idx 13
        shellcode_parts.append(asm("stp x29, x30, [sp, #0x30]"))  # idx 14
        shellcode_parts.append(asm("mov x19, x0"))          # idx 15
        shellcode_parts.append(asm("mov x20, x1"))          # idx 16
        shellcode_parts.append(asm("mov x21, x2"))          # idx 17
        shellcode_parts.append(asm("mov x22, x3"))          # idx 18
        shellcode_parts.append(asm("mov x8, #8"))           # idx 19
        shellcode_parts.append(asm("mov x0, x17"))          # idx 20
        shellcode_parts.append(asm("mov x1, x21"))          # idx 21
        shellcode_parts.append(asm("mov x2, #0"))           # idx 22
        # adr x3, #-0x5C — encode manually
        adr_delta = -(23 * 4)
        immhi = (adr_delta >> 2) & 0x7FFFF
        immlo = adr_delta & 0x3
        adr_insn = 0x10000003 | (immlo << 29) | (immhi << 5)
        shellcode_parts.append(struct.pack("<I", adr_insn))  # idx 23
        shellcode_parts.append(asm("udiv x4, x22, x8"))     # idx 24
        shellcode_parts.append(asm("msub x10, x4, x8, x22"))  # idx 25
        shellcode_parts.append(asm("cbz x10, #8"))          # idx 26
        shellcode_parts.append(asm("add x4, x4, #1"))       # idx 27
        shellcode_parts.append(zalloc_bl)                    # idx 28
        shellcode_parts.append(asm("mov x0, x19"))           # idx 29
        shellcode_parts.append(asm("mov x1, x20"))           # idx 30
        shellcode_parts.append(asm("mov x2, x21"))           # idx 31
        shellcode_parts.append(asm("mov x3, x22"))           # idx 32
        shellcode_parts.append(asm("ldp x19, x20, [sp, #0x10]"))  # idx 33
        shellcode_parts.append(asm("ldp x21, x22, [sp, #0x20]"))  # idx 34
        shellcode_parts.append(asm("ldp x29, x30, [sp, #0x30]"))  # idx 35
        shellcode_parts.append(asm("add sp, sp, #0x40"))    # idx 36
        shellcode_parts.append(filter_b)                     # idx 37

        # Write shellcode
        for i, part in enumerate(shellcode_parts):
            self.emit(cave_base + i * 4, part,
                      f"shellcode+{i*4} [_syscallmask_apply_to_proc]")

        # Redirect original function
        func_end = self._find_func_end(func_off, 0x200)
        for off in range(func_off, min(func_off + 0x100, func_end), 4):
            d = self._disas_at(off)
            if not d:
                continue
            if d[0].mnemonic == "bl":
                self.emit(off - 4, asm("mov x17, x0"),
                          "mov x17,x0 [_syscallmask_apply_to_proc inject]")
                b_to_cave = self._encode_b(off, cave_base + 10 * 4)
                if b_to_cave:
                    self.emit(off, b_to_cave,
                              f"b cave [_syscallmask_apply_to_proc -> 0x{cave_base + 40:X}]")
                return True

        self._log("  [-] injection point not found")
        return False

    def patch_hook_cred_label_update_execve(self):
        """Redirect _hook_cred_label_update_execve ops table entry to shellcode.

        Patches the sandbox MAC ops table entry for cred_label_update_execve
        to point to custom shellcode that performs vnode_getattr ownership
        propagation.  Instead of calling vfs_context_current (which may not
        exist as a BL-callable function), we construct a vfs_context on the
        stack using current_thread (mrs tpidr_el1) and the caller's
        credential (x0 = old_cred).
        """
        self._log("\n[JB] _hook_cred_label_update_execve: ops table + shellcode")

        # ── 1. Find vnode_getattr via string anchor ──────────────
        vnode_getattr_off = self._resolve_symbol("_vnode_getattr")
        if vnode_getattr_off < 0:
            str_off = self.find_string(b"vnode_getattr")
            if str_off >= 0:
                refs = self.find_string_refs(str_off)
                if refs:
                    vnode_getattr_off = self.find_function_start(refs[0][0])
                    if vnode_getattr_off >= 0:
                        self._log(f"  [+] vnode_getattr at 0x"
                                  f"{vnode_getattr_off:X} (via string)")

        if vnode_getattr_off < 0:
            self._log("  [-] vnode_getattr not found")
            return False

        # ── 2. Find sandbox ops table ────────────────────────────
        ops_table = self._find_sandbox_ops_table_via_conf()
        if ops_table is None:
            self._log("  [-] sandbox ops table not found")
            return False

        # ── 3. Find hook index dynamically ───────────────────────
        # mpo_cred_label_update_execve is one of the largest sandbox
        # hooks at an early index (< 30).  Scan for it.
        hook_index = -1
        orig_hook = -1
        best_size = 0
        for idx in range(0, 30):
            entry = self._read_ops_entry(ops_table, idx)
            if entry is None or entry <= 0:
                continue
            if not any(s <= entry < e for s, e in self.code_ranges):
                continue
            fend = self._find_func_end(entry, 0x2000)
            fsize = fend - entry
            if fsize > best_size:
                best_size = fsize
                hook_index = idx
                orig_hook = entry

        if hook_index < 0 or best_size < 1000:
            self._log("  [-] hook entry not found in ops table "
                      f"(best: idx={hook_index}, size={best_size})")
            return False

        self._log(f"  [+] hook at ops[{hook_index}] = 0x{orig_hook:X} "
                  f"({best_size} bytes)")

        # ── 4. Find code cave ────────────────────────────────────
        cave = self._find_code_cave(180)
        if cave < 0:
            self._log("  [-] no code cave found")
            return False
        self._log(f"  [+] code cave at 0x{cave:X}")

        # ── 5. Encode BL to vnode_getattr ────────────────────────
        vnode_bl_off = cave + 17 * 4
        vnode_bl = self._encode_bl(vnode_bl_off, vnode_getattr_off)
        if not vnode_bl:
            self._log("  [-] BL to vnode_getattr out of range")
            return False

        # ── 6. Encode B to original hook ─────────────────────────
        b_back_off = cave + 44 * 4
        b_back = self._encode_b(b_back_off, orig_hook)
        if not b_back:
            self._log("  [-] B to original hook out of range")
            return False

        # ── 7. Build shellcode ───────────────────────────────────
        # MAC hook args: x0=old_cred, x1=new_cred, x2=proc, x3=vp
        #
        # Parts [8-10] construct a vfs_context on the stack instead
        # of calling vfs_context_current, which may not exist as a
        # direct BL target in stripped ARM64e kernels.
        #
        # struct vfs_context { thread_t vc_thread; kauth_cred_t vc_ucred; }
        # We place it at [sp, #0x70] (between saved regs and vattr buffer).
        parts = []
        parts.append(NOP)                                       # 0
        parts.append(asm("cbz x3, #0xa8"))                     # 1
        parts.append(asm("sub sp, sp, #0x400"))                # 2
        parts.append(asm("stp x29, x30, [sp]"))               # 3
        parts.append(asm("stp x0, x1, [sp, #16]"))            # 4
        parts.append(asm("stp x2, x3, [sp, #32]"))            # 5
        parts.append(asm("stp x4, x5, [sp, #48]"))            # 6
        parts.append(asm("stp x6, x7, [sp, #64]"))            # 7
        # Construct vfs_context inline (replaces BL vfs_context_current)
        parts.append(asm("mrs x8, tpidr_el1"))                 # 8: current_thread
        parts.append(asm("stp x8, x0, [sp, #0x70]"))          # 9: {thread, cred}
        parts.append(asm("add x2, sp, #0x70"))                 # 10: ctx = &vfs_ctx
        # Setup vnode_getattr(vp, &vattr, ctx)
        parts.append(asm("ldr x0, [sp, #0x28]"))              # 11: x0 = vp
        parts.append(asm("add x1, sp, #0x80"))                # 12: x1 = &vattr
        parts.append(asm("mov w8, #0x380"))                    # 13: vattr size
        parts.append(asm("stp xzr, x8, [x1]"))               # 14: init vattr
        parts.append(asm("stp xzr, xzr, [x1, #0x10]"))       # 15: init vattr
        parts.append(NOP)                                       # 16
        parts.append(vnode_bl)                                  # 17: BL vnode_getattr
        # Check result + propagate ownership
        parts.append(asm("cbnz x0, #0x50"))                   # 18: error → skip
        parts.append(asm("mov w2, #0"))                        # 19: changed = 0
        parts.append(asm("ldr w8, [sp, #0xCC]"))              # 20: va_mode
        parts.append(bytes([0xa8, 0x00, 0x58, 0x36]))          # 21: tbz w8,#11
        parts.append(asm("ldr w8, [sp, #0xC4]"))              # 22: va_uid
        parts.append(asm("ldr x0, [sp, #0x18]"))              # 23: new_cred
        parts.append(asm("str w8, [x0, #0x18]"))              # 24: cred->uid
        parts.append(asm("mov w2, #1"))                        # 25: changed = 1
        parts.append(asm("ldr w8, [sp, #0xCC]"))              # 26: va_mode
        parts.append(bytes([0xa8, 0x00, 0x50, 0x36]))          # 27: tbz w8,#10
        parts.append(asm("mov w2, #1"))                        # 28: changed = 1
        parts.append(asm("ldr w8, [sp, #0xC8]"))              # 29: va_gid
        parts.append(asm("ldr x0, [sp, #0x18]"))              # 30: new_cred
        parts.append(asm("str w8, [x0, #0x28]"))              # 31: cred->gid
        parts.append(asm("cbz w2, #0x1c"))                     # 32: if !changed
        parts.append(asm("ldr x0, [sp, #0x20]"))              # 33: proc
        parts.append(asm("ldr w8, [x0, #0x454]"))             # 34: p_csflags
        parts.append(asm("orr w8, w8, #0x100"))               # 35: CS_VALID
        parts.append(asm("str w8, [x0, #0x454]"))             # 36: store
        parts.append(asm("ldp x0, x1, [sp, #16]"))            # 37: restore
        parts.append(asm("ldp x2, x3, [sp, #32]"))            # 38
        parts.append(asm("ldp x4, x5, [sp, #48]"))            # 39
        parts.append(asm("ldp x6, x7, [sp, #64]"))            # 40
        parts.append(asm("ldp x29, x30, [sp]"))               # 41
        parts.append(asm("add sp, sp, #0x400"))                # 42
        parts.append(NOP)                                       # 43
        parts.append(b_back)                                    # 44: B orig_hook

        for i, part in enumerate(parts):
            self.emit(cave + i * 4, part,
                      f"shellcode+{i*4} [_hook_cred_label_update_execve]")

        # ── 8. Rewrite ops table entry ───────────────────────────
        # Preserve auth rebase upper 32 bits (PAC key, diversity,
        # chain next) and replace lower 32 bits with cave foff.
        entry_off = ops_table + hook_index * 8
        orig_raw = _rd64(self.raw, entry_off)
        new_raw = (orig_raw & 0xFFFFFFFF00000000) | (cave & 0xFFFFFFFF)
        self.emit(entry_off, struct.pack("<Q", new_raw),
                  f"ops_table[{hook_index}] = cave 0x{cave:X} "
                  f"[_hook_cred_label_update_execve]")

        return True

    def patch_kcall10(self):
        """Replace SYS_kas_info (syscall 439) with kcall10 shellcode.

        Anchor: find _nosys function by pattern, then search DATA segments
        for the sysent table (first entry points to _nosys).
        """
        self._log("\n[JB] kcall10: syscall 439 replacement")

        # Find _nosys
        nosys_off = self._resolve_symbol("_nosys")
        if nosys_off < 0:
            nosys_off = self._find_nosys()
        if nosys_off < 0:
            self._log("  [-] _nosys not found")
            return False

        self._log(f"  [+] _nosys at 0x{nosys_off:X}")

        # Find _munge_wwwwwwww
        munge_off = self._resolve_symbol("_munge_wwwwwwww")
        if munge_off < 0:
            for sym, off in self.symbols.items():
                if "munge_wwwwwwww" in sym:
                    munge_off = off
                    break

        # Search for sysent table in DATA segments
        sysent_off = -1
        for seg_name, vmaddr, fileoff, filesize, _ in self.all_segments:
            if "DATA" not in seg_name:
                continue
            for off in range(fileoff, fileoff + filesize - 24, 8):
                val = _rd64(self.raw, off)
                decoded = self._decode_chained_ptr(val)
                if decoded == nosys_off:
                    # Verify: sysent[1] should also point to valid code
                    val2 = _rd64(self.raw, off + 24)
                    decoded2 = self._decode_chained_ptr(val2)
                    if decoded2 > 0 and any(
                            s <= decoded2 < e for s, e in self.code_ranges):
                        sysent_off = off
                        break
            if sysent_off >= 0:
                break

        if sysent_off < 0:
            self._log("  [-] sysent table not found")
            return False

        self._log(f"  [+] sysent table at file offset 0x{sysent_off:X}")

        # Entry 439 (SYS_kas_info)
        entry_439 = sysent_off + 439 * 24

        # Find code cave for kcall10 shellcode (~128 bytes = 32 instructions)
        cave = self._find_code_cave(128)
        if cave < 0:
            self._log("  [-] no code cave found")
            return False

        # Build kcall10 shellcode
        parts = [
            asm("ldr x10, [sp, #0x40]"),     # 0
            asm("ldp x0, x1, [x10, #0]"),    # 1
            asm("ldp x2, x3, [x10, #0x10]"), # 2
            asm("ldp x4, x5, [x10, #0x20]"), # 3
            asm("ldp x6, x7, [x10, #0x30]"), # 4
            asm("ldp x8, x9, [x10, #0x40]"), # 5
            asm("ldr x10, [x10, #0x50]"),    # 6
            asm("mov x16, x0"),               # 7
            asm("mov x0, x1"),                # 8
            asm("mov x1, x2"),                # 9
            asm("mov x2, x3"),                # 10
            asm("mov x3, x4"),                # 11
            asm("mov x4, x5"),                # 12
            asm("mov x5, x6"),                # 13
            asm("mov x6, x7"),                # 14
            asm("mov x7, x8"),                # 15
            asm("mov x8, x9"),                # 16
            asm("mov x9, x10"),               # 17
            asm("stp x29, x30, [sp, #-0x10]!"),  # 18
            bytes([0x00, 0x02, 0x3F, 0xD6]),  # 19: BLR x16
            asm("ldp x29, x30, [sp], #0x10"), # 20
            asm("ldr x11, [sp, #0x40]"),      # 21
            NOP,                               # 22
            asm("stp x0, x1, [x11, #0]"),     # 23
            asm("stp x2, x3, [x11, #0x10]"),  # 24
            asm("stp x4, x5, [x11, #0x20]"),  # 25
            asm("stp x6, x7, [x11, #0x30]"),  # 26
            asm("stp x8, x9, [x11, #0x40]"),  # 27
            asm("str x10, [x11, #0x50]"),     # 28
            asm("mov x0, #0"),                 # 29
            asm("ret"),                        # 30
            NOP,                               # 31
        ]

        for i, part in enumerate(parts):
            self.emit(cave + i * 4, part,
                      f"shellcode+{i*4} [kcall10]")

        # Patch sysent[439]
        cave_va = self.base_va + cave
        self.emit(entry_439, struct.pack("<Q", cave_va),
                  f"sysent[439].sy_call = 0x{cave_va:X} [kcall10]")

        if munge_off >= 0:
            munge_va = self.base_va + munge_off
            self.emit(entry_439 + 8, struct.pack("<Q", munge_va),
                      f"sysent[439].sy_munge32 = 0x{munge_va:X} [kcall10]")

        # sy_return_type = SYSCALL_RET_UINT64_T (7)
        self.emit(entry_439 + 16, struct.pack("<I", 7),
                  "sysent[439].sy_return_type = 7 [kcall10]")

        # sy_narg = 8, sy_arg_bytes = 0x20
        self.emit(entry_439 + 20, struct.pack("<I", 0x200008),
                  "sysent[439].sy_narg=8,sy_arg_bytes=0x20 [kcall10]")

        return True

```

`scripts/patchers/txm.py`:

```py
#!/usr/bin/env python3
"""
txm_patcher.py — Dynamic patcher for TXM (Trusted Execution Monitor) images.

Finds the trustcache hash lookup (binary search) in the AMFI certificate
verification function and bypasses it.  NO hardcoded offsets.

Dependencies:  keystone-engine, capstone
"""

import struct
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN as KS_MODE_LE
from capstone import Cs, CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN

# ── Assembly / disassembly singletons ──────────────────────────
_ks = Ks(KS_ARCH_ARM64, KS_MODE_LE)
_cs = Cs(CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN)
_cs.detail = True
_cs.skipdata = True


def _asm(s):
    enc, _ = _ks.asm(s)
    if not enc:
        raise RuntimeError(f"asm failed: {s}")
    return bytes(enc)


MOV_X0_0 = _asm("mov x0, #0")


def _disasm_one(data, off):
    insns = list(_cs.disasm(data[off:off + 4], off))
    return insns[0] if insns else None


def _find_asm_pattern(data, asm_str):
    enc, _ = _ks.asm(asm_str)
    pattern = bytes(enc)
    results = []
    off = 0
    while True:
        idx = data.find(pattern, off)
        if idx < 0:
            break
        results.append(idx)
        off = idx + 4
    return results


# ── TXMPatcher ─────────────────────────────────────────────────

class TXMPatcher:
    """Dynamic patcher for TXM images.

    Patches:
      1. Trustcache binary-search BL → mov x0, #0
         (in the AMFI cert verification function identified by the
          unique constant 0x20446 loaded into w19)
    """

    def __init__(self, data, verbose=True):
        self.data    = data
        self.raw     = bytes(data)
        self.size    = len(data)
        self.verbose = verbose
        self.patches = []

    def _log(self, msg):
        if self.verbose:
            print(msg)

    def emit(self, off, patch_bytes, desc):
        self.patches.append((off, patch_bytes, desc))
        if self.verbose:
            before_insns = list(_cs.disasm(self.raw[off:off + 4], off))
            after_insns = list(_cs.disasm(patch_bytes, off))
            b_str = (f"{before_insns[0].mnemonic} {before_insns[0].op_str}"
                     if before_insns else "???")
            a_str = (f"{after_insns[0].mnemonic} {after_insns[0].op_str}"
                     if after_insns else "???")
            print(f"  0x{off:06X}: {b_str} → {a_str}  [{desc}]")

    def apply(self):
        self.find_all()
        for off, pb, _ in self.patches:
            self.data[off:off + len(pb)] = pb
        if self.verbose and self.patches:
            self._log(f"\n  [{len(self.patches)} TXM patches applied]")
        return len(self.patches)

    def find_all(self):
        self.patches = []
        self.patch_trustcache_bypass()
        return self.patches

    # ═══════════════════════════════════════════════════════════
    #  Trustcache bypass
    #
    #  The AMFI cert verification function has a unique constant:
    #    mov w19, #0x2446; movk w19, #2, lsl #16  (= 0x20446)
    #
    #  Within that function, a binary search calls a hash-compare
    #  function with SHA-1 size:
    #    mov w2, #0x14; bl <hash_cmp>; cbz w0, <match>
    #  followed by:
    #    tbnz w0, #0x1f, <lower_half>   (sign bit = search direction)
    #
    #  Patch: bl <hash_cmp> → mov x0, #0
    #    This makes cbz always branch to <match>, bypassing the
    #    trustcache lookup entirely.
    # ═══════════════════════════════════════════════════════════
    def patch_trustcache_bypass(self):
        # Step 1: Find the unique function marker (mov w19, #0x2446)
        locs = _find_asm_pattern(self.raw, "mov w19, #0x2446")
        if len(locs) != 1:
            self._log(f"  [-] TXM: expected 1 'mov w19, #0x2446', "
                       f"found {len(locs)}")
            return
        marker_off = locs[0]

        # Step 2: Find the containing function (scan back for PACIBSP)
        pacibsp = _asm("hint #27")
        func_start = None
        for scan in range(marker_off & ~3, max(0, marker_off - 0x200), -4):
            if self.raw[scan:scan + 4] == pacibsp:
                func_start = scan
                break
        if func_start is None:
            self._log("  [-] TXM: function start not found")
            return

        # Step 3: Within the function, find mov w2, #0x14; bl; cbz w0; tbnz w0, #0x1f
        func_end = min(func_start + 0x2000, self.size)
        insns = list(_cs.disasm(self.raw[func_start:func_end], func_start))

        for i, ins in enumerate(insns):
            if not (ins.mnemonic == 'mov' and ins.op_str == 'w2, #0x14'):
                continue
            if i + 3 >= len(insns):
                continue
            bl_ins = insns[i + 1]
            cbz_ins = insns[i + 2]
            tbnz_ins = insns[i + 3]
            if (bl_ins.mnemonic == 'bl'
                    and cbz_ins.mnemonic == 'cbz' and 'w0' in cbz_ins.op_str
                    and tbnz_ins.mnemonic in ('tbnz', 'tbz')
                    and '#0x1f' in tbnz_ins.op_str):
                self.emit(bl_ins.address, MOV_X0_0,
                          "trustcache bypass: bl → mov x0, #0")
                return

        self._log("  [-] TXM: binary search pattern not found in function")


# ── CLI entry point ────────────────────────────────────────────
if __name__ == "__main__":
    import sys, argparse

    parser = argparse.ArgumentParser(
        description="Dynamic TXM patcher")
    parser.add_argument("txm", help="Path to raw or IM4P TXM image")
    parser.add_argument("-q", "--quiet", action="store_true")
    args = parser.parse_args()

    print(f"Loading {args.txm}...")
    file_raw = open(args.txm, "rb").read()

    try:
        from pyimg4 import IM4P
        im4p = IM4P(file_raw)
        if im4p.payload.compression:
            im4p.payload.decompress()
        payload = im4p.payload.data
        print(f"  format: IM4P (fourcc={im4p.fourcc})")
    except Exception:
        payload = file_raw
        print(f"  format: raw")

    data = bytearray(payload)
    print(f"  size:   {len(data)} bytes ({len(data)/1024:.1f} KB)\n")

    patcher = TXMPatcher(data, verbose=not args.quiet)
    n = patcher.apply()
    print(f"\n  {n} patches applied.")

```

`scripts/patchers/txm_jb.py`:

```py
#!/usr/bin/env python3
"""
txm_jb.py — Jailbreak extension patcher for TXM images.

All patch sites are found dynamically via string xrefs + instruction pattern
matching. No fixed byte offsets.
"""

from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN as KS_MODE_LE

from .txm import TXMPatcher, MOV_X0_0, _asm, _disasm_one


_ks = Ks(KS_ARCH_ARM64, KS_MODE_LE)
NOP = _asm("nop")
MOV_X0_1 = _asm("mov x0, #1")
MOV_W0_1 = _asm("mov w0, #1")
MOV_X0_X20 = _asm("mov x0, x20")
STRB_W0_X20_30 = _asm("strb w0, [x20, #0x30]")
PACIBSP = _asm("hint #27")


class TXMJBPatcher(TXMPatcher):
    """JB-only TXM patcher."""

    def apply(self):
        self.find_all()
        for off, pb, _ in self.patches:
            self.data[off:off + len(pb)] = pb
        if self.verbose and self.patches:
            self._log(f"\n  [{len(self.patches)} TXM JB patches applied]")
        return len(self.patches)

    def find_all(self):
        self.patches = []
        self.patch_selector24_hashcmp_calls()
        self.patch_selector24_a1_path()
        self.patch_get_task_allow_force_true()
        self.patch_selector42_29_shellcode()
        self.patch_debugger_entitlement_force_true()
        self.patch_developer_mode_bypass()
        return self.patches

    # ── helpers ──────────────────────────────────────────────────
    def _asm_at(self, asm_line, addr):
        enc, _ = _ks.asm(asm_line, addr=addr)
        if not enc:
            raise RuntimeError(f"asm failed at 0x{addr:X}: {asm_line}")
        return bytes(enc)

    def _find_func_start(self, off, back=0x1000):
        start = max(0, off - back)
        for scan in range(off & ~3, start - 1, -4):
            if self.raw[scan:scan + 4] == PACIBSP:
                return scan
        return None

    def _find_func_end(self, func_start, forward=0x1200):
        end = min(self.size, func_start + forward)
        for scan in range(func_start + 4, end, 4):
            if self.raw[scan:scan + 4] == PACIBSP:
                return scan
        return end

    def _find_refs_to_offset(self, target_off):
        refs = []
        for off in range(0, self.size - 8, 4):
            a = _disasm_one(self.raw, off)
            b = _disasm_one(self.raw, off + 4)
            if not a or not b:
                continue
            if a.mnemonic != "adrp" or b.mnemonic != "add":
                continue
            if len(a.operands) < 2 or len(b.operands) < 3:
                continue
            if a.operands[0].reg != b.operands[1].reg:
                continue
            if a.operands[1].imm + b.operands[2].imm == target_off:
                refs.append((off, off + 4))
        return refs

    def _find_string_refs(self, needle):
        if isinstance(needle, str):
            needle = needle.encode()
        refs = []
        seen = set()
        off = 0
        while True:
            s_off = self.raw.find(needle, off)
            if s_off < 0:
                break
            off = s_off + 1
            for r in self._find_refs_to_offset(s_off):
                if r[0] not in seen:
                    seen.add(r[0])
                    refs.append((s_off, r[0], r[1]))
        return refs

    def _ref_in_function(self, refs, func_start):
        out = []
        for s_off, adrp_off, add_off in refs:
            fs = self._find_func_start(adrp_off)
            if fs == func_start:
                out.append((s_off, adrp_off, add_off))
        return out

    def _find_debugger_gate_func_start(self):
        refs = self._find_string_refs(b"com.apple.private.cs.debugger")
        starts = set()
        for _, _, add_off in refs:
            for scan in range(add_off, min(add_off + 0x20, self.size - 8), 4):
                i = _disasm_one(self.raw, scan)
                n = _disasm_one(self.raw, scan + 4)
                p1 = _disasm_one(self.raw, scan - 4) if scan >= 4 else None
                p2 = _disasm_one(self.raw, scan - 8) if scan >= 8 else None
                if not all((i, n, p1, p2)):
                    continue
                if not (i.mnemonic == "bl"
                        and n.mnemonic == "tbnz" and n.op_str.startswith("w0, #0,")
                        and p1.mnemonic == "mov" and p1.op_str == "x2, #0"
                        and p2.mnemonic == "mov" and p2.op_str == "x0, #0"):
                    continue
                fs = self._find_func_start(scan)
                if fs is not None:
                    starts.add(fs)
        if len(starts) != 1:
            return None
        return next(iter(starts))

    def _find_udf_cave(self, min_insns=6, near_off=None, max_distance=0x80000):
        need = min_insns * 4
        start = 0 if near_off is None else max(0, near_off - 0x1000)
        end = self.size if near_off is None else min(self.size, near_off + max_distance)
        best = None
        best_dist = None
        off = start
        while off < end:
            run = off
            while run < end and self.raw[run:run + 4] == b"\x00\x00\x00\x00":
                run += 4
            if run - off >= need:
                prev = _disasm_one(self.raw, off - 4) if off >= 4 else None
                if prev and prev.mnemonic in (
                    "b", "b.eq", "b.ne", "b.lo", "b.hs", "cbz", "cbnz", "tbz", "tbnz"
                ):
                    return off
                if near_off is not None and _disasm_one(self.raw, off):
                    dist = abs(off - near_off)
                    if best is None or dist < best_dist:
                        best = off
                        best_dist = dist
            off = run + 4 if run > off else off + 4
        return best

    # ── JB patches ───────────────────────────────────────────────
    def patch_selector24_hashcmp_calls(self):
        """Patch remaining selector-24 hashcmp BL callsites: bl -> mov x0,#0."""
        patched = 0
        for off in range(0, self.size - 8, 4):
            i0 = _disasm_one(self.raw, off)
            i1 = _disasm_one(self.raw, off + 4)
            i2 = _disasm_one(self.raw, off + 8)
            if not i0 or not i1 or not i2:
                continue
            if not (i0.mnemonic == "mov" and i0.op_str == "w2, #0x14"):
                continue
            if not (i1.mnemonic == "bl" and i2.mnemonic == "cbz"
                    and i2.op_str.startswith("w0,")):
                continue
            self.emit(off + 4, MOV_X0_0,
                      f"selector24 hashcmp bypass #{patched + 1}: bl -> mov x0,#0")
            patched += 1

        if patched > 3:
            self._log(f"  [-] TXM JB: selector24 hashcmp sites too many ({patched})")
            return False
        if patched == 0:
            self._log("  [-] TXM JB: no selector24 hashcmp BL sites to patch")
            return False
        return True

    def patch_selector24_a1_path(self):
        """Selector-24 A1 path bypass: NOP b.lo + cbz around mov w0,#0xa1."""
        locs = []
        for scan in range(0, self.size - 4, 4):
            ins = _disasm_one(self.raw, scan)
            if ins and ins.mnemonic == "mov" and ins.op_str == "w0, #0xa1":
                i_blo = _disasm_one(self.raw, scan - 0xC)
                i_cbz = _disasm_one(self.raw, scan - 0x4)
                if not i_blo or not i_cbz:
                    continue
                if (i_blo.mnemonic == "b.lo"
                        and i_cbz.mnemonic == "cbz"
                        and i_cbz.op_str.startswith("x9,")):
                    locs.append(scan)

        if len(locs) != 1:
            self._log(f"  [-] TXM JB: expected 1 selector24 A1 site, found {len(locs)}")
            return False
        off = locs[0]

        self.emit(off - 0xC, NOP, "selector24 A1: b.lo -> nop")
        self.emit(off - 0x4, NOP, "selector24 A1: cbz x9 -> nop")
        return True

    def patch_get_task_allow_force_true(self):
        """Force get-task-allow entitlement call to return true."""
        refs = self._find_string_refs(b"get-task-allow")
        if not refs:
            self._log("  [-] TXM JB: get-task-allow string refs not found")
            return False

        cands = []
        for _, _, add_off in refs:
            for scan in range(add_off, min(add_off + 0x20, self.size - 4), 4):
                i = _disasm_one(self.raw, scan)
                n = _disasm_one(self.raw, scan + 4)
                if not i or not n:
                    continue
                if i.mnemonic == "bl" and n.mnemonic == "tbnz" and n.op_str.startswith("w0, #0,"):
                    cands.append(scan)

        if len(cands) != 1:
            self._log(f"  [-] TXM JB: expected 1 get-task-allow BL site, found {len(cands)}")
            return False

        self.emit(cands[0], MOV_X0_1, "get-task-allow: bl -> mov x0,#1")
        return True

    def patch_selector42_29_shellcode(self):
        """Selector 42|29 patch via dynamic cave shellcode + branch redirect."""
        fn = self._find_debugger_gate_func_start()
        if fn is None:
            self._log("  [-] TXM JB: debugger-gate function not found (selector42|29)")
            return False

        stubs = []
        for off in range(4, self.size - 24, 4):
            p = _disasm_one(self.raw, off - 4)
            i0 = _disasm_one(self.raw, off)
            i1 = _disasm_one(self.raw, off + 4)
            i2 = _disasm_one(self.raw, off + 8)
            i3 = _disasm_one(self.raw, off + 12)
            i4 = _disasm_one(self.raw, off + 16)
            i5 = _disasm_one(self.raw, off + 20)
            if not all((p, i0, i1, i2, i3, i4, i5)):
                continue
            if not (p.mnemonic == "bti" and p.op_str == "j"):
                continue
            if not (i0.mnemonic == "mov" and i0.op_str == "x0, x20"):
                continue
            if not (i1.mnemonic == "bl" and i2.mnemonic == "mov"
                    and i2.op_str == "x1, x21"):
                continue
            if not (i3.mnemonic == "mov" and i3.op_str == "x2, x22"
                    and i4.mnemonic == "bl" and i5.mnemonic == "b"):
                continue
            if i4.operands and i4.operands[0].imm == fn:
                stubs.append(off)

        if len(stubs) != 1:
            self._log(f"  [-] TXM JB: selector42|29 stub expected 1, found {len(stubs)}")
            return False
        stub_off = stubs[0]

        cave = self._find_udf_cave(min_insns=6, near_off=stub_off)
        if cave is None:
            self._log("  [-] TXM JB: no UDF cave found for selector42|29 shellcode")
            return False

        self.emit(stub_off, self._asm_at(f"b #0x{cave:X}", stub_off),
                  "selector42|29: branch to shellcode")
        self.emit(cave, NOP, "selector42|29 shellcode pad: udf -> nop")
        self.emit(cave + 4, MOV_X0_1, "selector42|29 shellcode: mov x0,#1")
        self.emit(cave + 8, STRB_W0_X20_30, "selector42|29 shellcode: strb w0,[x20,#0x30]")
        self.emit(cave + 12, MOV_X0_X20, "selector42|29 shellcode: mov x0,x20")
        self.emit(cave + 16, self._asm_at(f"b #0x{stub_off + 4:X}", cave + 16),
                  "selector42|29 shellcode: branch back")
        return True

    def patch_debugger_entitlement_force_true(self):
        """Force debugger entitlement call to return true."""
        refs = self._find_string_refs(b"com.apple.private.cs.debugger")
        if not refs:
            self._log("  [-] TXM JB: debugger refs not found")
            return False

        cands = []
        for _, _, add_off in refs:
            for scan in range(add_off, min(add_off + 0x20, self.size - 4), 4):
                i = _disasm_one(self.raw, scan)
                n = _disasm_one(self.raw, scan + 4)
                p1 = _disasm_one(self.raw, scan - 4) if scan >= 4 else None
                p2 = _disasm_one(self.raw, scan - 8) if scan >= 8 else None
                if not all((i, n, p1, p2)):
                    continue
                if (i.mnemonic == "bl"
                        and n.mnemonic == "tbnz" and n.op_str.startswith("w0, #0,")
                        and p1.mnemonic == "mov" and p1.op_str == "x2, #0"
                        and p2.mnemonic == "mov" and p2.op_str == "x0, #0"):
                    cands.append(scan)

        if len(cands) != 1:
            self._log(f"  [-] TXM JB: expected 1 debugger BL site, found {len(cands)}")
            return False

        self.emit(cands[0], MOV_W0_1, "debugger entitlement: bl -> mov w0,#1")
        return True

    def patch_developer_mode_bypass(self):
        """Developer-mode bypass: NOP conditional guard before deny log path."""
        refs = self._find_string_refs(
            b"developer mode enabled due to system policy configuration")
        if not refs:
            self._log("  [-] TXM JB: developer-mode string ref not found")
            return False

        cands = []
        for _, _, add_off in refs:
            for back in range(add_off - 4, max(add_off - 0x20, 0), -4):
                ins = _disasm_one(self.raw, back)
                if not ins:
                    continue
                if ins.mnemonic not in ("tbz", "tbnz", "cbz", "cbnz"):
                    continue
                if not ins.op_str.startswith("w9, #0,"):
                    continue
                cands.append(back)

        if len(cands) != 1:
            self._log(f"  [-] TXM JB: expected 1 developer mode guard, found {len(cands)}")
            return False

        self.emit(cands[0], NOP, "developer mode bypass")
        return True

```

`scripts/patches/libirecovery-pcc-vm.patch`:

```patch
diff --git a/src/libirecovery.c b/src/libirecovery.c
index bf9a0d6..1323891 100644
--- a/src/libirecovery.c
+++ b/src/libirecovery.c
@@ -480,6 +480,8 @@ static struct irecv_device irecv_devices[] = {
 	/* Apple Vision Pro */
 	{ "RealityDevice14,1", "n301ap", 0x42, 0x8112, "Apple Vision Pro" },
 	{ "RealityDevice17,1", "n301aap", 0x42, 0x8142, "Apple Vision Pro (M5)" },
+	/* Private Cloud Compute Research Environment */
+	{ "iPhone99,11", "vresearch101ap", 0x90, 0xFE01, "iPhone 99,11" },
 	{ NULL,          NULL,         -1,     -1, NULL }
 };
 

```

`scripts/ramdisk_build.py`:

```py
#!/usr/bin/env python3
"""
build_ramdisk.py — Build a signed SSH ramdisk for vphone600.

Expects firmware already patched by patch_firmware.py.
Extracts patched components, signs with SHSH, and builds SSH ramdisk.

Usage:
    python3 build_ramdisk.py [vm_directory]

Directory structure:
    ./shsh/              — SHSH blobs (auto-discovered)
    ./ramdisk_input/     — Tools and SSH resources (auto-setup from CFW)
    ./ramdisk_builder_temp/ — Intermediate .raw files (cleaned up)
    ./Ramdisk/           — Final signed IMG4 output

Prerequisites:
    pip install keystone-engine capstone pyimg4
    Run patch_firmware.py first to patch boot-chain components.
"""

import gzip
import glob
import os
import plistlib
import shutil
import subprocess
import sys

# Ensure sibling modules (patch_firmware) are importable when run from any CWD
_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
if _SCRIPT_DIR not in sys.path:
    sys.path.insert(0, _SCRIPT_DIR)

from pyimg4 import IM4P

from fw_patch import (
    load_firmware,
    _save_im4p_with_payp,
    patch_txm,
    find_restore_dir,
    find_file,
)
from patchers.iboot import IBootPatcher

# ══════════════════════════════════════════════════════════════════
# Configuration
# ══════════════════════════════════════════════════════════════════

OUTPUT_DIR = "Ramdisk"
TEMP_DIR = "ramdisk_builder_temp"
INPUT_DIR = "ramdisk_input"

# Ramdisk boot-args
RAMDISK_BOOT_ARGS = b"serial=3 rd=md0 debug=0x2014e -v wdt=-1 %s"

# IM4P fourccs for restore mode
TXM_FOURCC = "trxm"
KERNEL_FOURCC = "rkrn"

# Files to remove from ramdisk to save space
RAMDISK_REMOVE = [
    "usr/bin/img4tool", "usr/bin/img4",
    "usr/sbin/dietappleh13camerad", "usr/sbin/dietappleh16camerad",
    "usr/local/bin/wget", "usr/local/bin/procexp",
]

# Directories to re-sign in ramdisk
SIGN_DIRS = [
    "usr/local/bin/*", "usr/local/lib/*",
    "usr/bin/*", "bin/*",
    "usr/lib/*", "sbin/*", "usr/sbin/*", "usr/libexec/*",
]

# Compressed archive of ramdisk_input/ (located next to this script)
INPUT_ARCHIVE = "ramdisk_input.tar.zst"


# ══════════════════════════════════════════════════════════════════
# Setup — extract ramdisk_input/ from zstd archive if needed
# ══════════════════════════════════════════════════════════════════

def setup_input(vm_dir):
    """Ensure ramdisk_input/ exists, extracting from .tar.zst if needed."""
    input_dir = os.path.join(vm_dir, INPUT_DIR)

    if os.path.isdir(input_dir):
        return input_dir

    # Look for archive next to this script, then in vm_dir
    for search_dir in (os.path.join(_SCRIPT_DIR, "resources"), _SCRIPT_DIR, vm_dir):
        archive = os.path.join(search_dir, INPUT_ARCHIVE)
        if os.path.isfile(archive):
            print(f"  Extracting {INPUT_ARCHIVE}...")
            subprocess.run(
                ["tar", "--zstd", "-xf", archive, "-C", vm_dir],
                check=True,
            )
            return input_dir

    print(f"[-] Neither {INPUT_DIR}/ nor {INPUT_ARCHIVE} found.")
    print(f"    Place {INPUT_ARCHIVE} next to this script or in the VM directory.")
    sys.exit(1)


# ══════════════════════════════════════════════════════════════════
# SHSH / signing helpers
# ══════════════════════════════════════════════════════════════════

def find_shsh(shsh_dir):
    """Find first SHSH blob in directory."""
    for ext in ("*.shsh", "*.shsh2"):
        matches = sorted(glob.glob(os.path.join(shsh_dir, ext)))
        if matches:
            return matches[0]
    return None


def extract_im4m(shsh_path, im4m_path):
    """Extract IM4M manifest from SHSH blob (handles gzip-compressed)."""
    raw = open(shsh_path, "rb").read()
    if raw[:2] == b"\x1f\x8b":
        raw = gzip.decompress(raw)
    tmp = shsh_path + ".tmp"
    try:
        open(tmp, "wb").write(raw)
        subprocess.run(
            ["pyimg4", "im4m", "extract", "-i", tmp, "-o", im4m_path],
            check=True, capture_output=True,
        )
    finally:
        if os.path.exists(tmp):
            os.remove(tmp)


def sign_img4(im4p_path, img4_path, im4m_path, tag=None, input_dir="."):
    """Create IMG4 from IM4P + IM4M. Uses tools/img4 for tag override."""
    if tag:
        img4_tool = os.path.join(input_dir, "tools/img4")
        subprocess.run(
            [img4_tool, "-i", im4p_path, "-o", img4_path,
             "-M", im4m_path, "-T", tag],
            check=True, capture_output=True,
        )
    else:
        subprocess.run(
            ["pyimg4", "img4", "create",
             "-p", im4p_path, "-o", img4_path, "-m", im4m_path],
            check=True, capture_output=True,
        )


def run(cmd, **kwargs):
    """Run a command, raising on failure."""
    return subprocess.run(cmd, check=True, **kwargs)


# ══════════════════════════════════════════════════════════════════
# Firmware extraction and IM4P creation
# ══════════════════════════════════════════════════════════════════

def extract_to_raw(src_path, raw_path):
    """Extract IM4P payload to .raw file. Returns (im4p_obj, data, original_raw)."""
    im4p, data, was_im4p, original_raw = load_firmware(src_path)
    with open(raw_path, "wb") as f:
        f.write(bytes(data))
    return im4p, data, original_raw


def create_im4p_uncompressed(raw_data, fourcc, description, output_path):
    """Create uncompressed IM4P from raw data."""
    new_im4p = IM4P(
        fourcc=fourcc,
        description=description,
        payload=bytes(raw_data),
    )
    with open(output_path, "wb") as f:
        f.write(new_im4p.output())


# ══════════════════════════════════════════════════════════════════
# iBEC boot-args patching
# ══════════════════════════════════════════════════════════════════

def patch_ibec_bootargs(data):
    """Replace normal boot-args with ramdisk boot-args in already-patched iBEC.

    Finds the boot-args string written by patch_firmware.py (via IBootPatcher)
    and overwrites it in-place. No hardcoded offsets needed — the ADRP+ADD
    instructions already point to the string location.
    """
    normal_args = IBootPatcher.BOOT_ARGS
    off = data.find(normal_args)
    if off < 0:
        print(f"  [-] boot-args: existing string not found ({normal_args.decode()!r})")
        return False

    args = RAMDISK_BOOT_ARGS + b"\x00"
    data[off:off + len(args)] = args

    # Zero out any leftover from the previous string
    end = off + len(args)
    while end < len(data) and data[end] != 0:
        data[end] = 0
        end += 1

    print(f'  boot-args -> "{RAMDISK_BOOT_ARGS.decode()}" at 0x{off:X}')
    return True


# ══════════════════════════════════════════════════════════════════
# Ramdisk DMG building
# ══════════════════════════════════════════════════════════════════

def build_ramdisk(restore_dir, im4m_path, vm_dir, input_dir, output_dir, temp_dir):
    """Build custom SSH ramdisk from restore DMG."""
    # Read RestoreRamDisk path dynamically from BuildManifest.plist
    bm_path = os.path.join(restore_dir, "BuildManifest.plist")
    with open(bm_path, "rb") as f:
        bm = plistlib.load(f)
    ramdisk_rel = bm["BuildIdentities"][0]["Manifest"]["RestoreRamDisk"]["Info"]["Path"]
    ramdisk_src = os.path.join(restore_dir, ramdisk_rel)
    mountpoint = os.path.join(vm_dir, "SSHRD")
    ramdisk_raw = os.path.join(temp_dir, "ramdisk.raw.dmg")
    ramdisk_custom = os.path.join(temp_dir, "ramdisk1.dmg")

    # Extract base ramdisk
    print("  Extracting base ramdisk...")
    run(["pyimg4", "im4p", "extract", "-i", ramdisk_src, "-o", ramdisk_raw],
        capture_output=True)

    os.makedirs(mountpoint, exist_ok=True)

    try:
        # Mount, create expanded copy
        print("  Mounting base ramdisk...")
        run(["sudo", "hdiutil", "attach", "-mountpoint", mountpoint,
             ramdisk_raw, "-owners", "off"])

        print("  Creating expanded ramdisk (254 MB)...")
        run(["sudo", "hdiutil", "create", "-size", "254m",
             "-imagekey", "diskimage-class=CRawDiskImage",
             "-format", "UDZO", "-fs", "APFS", "-layout", "NONE",
             "-srcfolder", mountpoint, "-copyuid", "root",
             ramdisk_custom])
        run(["sudo", "hdiutil", "detach", "-force", mountpoint])

        # Mount expanded, inject SSH
        print("  Mounting expanded ramdisk...")
        run(["sudo", "hdiutil", "attach", "-mountpoint", mountpoint,
             ramdisk_custom, "-owners", "off"])

        print("  Injecting SSH tools...")
        gtar = os.path.join(input_dir, "tools/gtar")
        ssh_tar = os.path.join(input_dir, "ssh.tar.gz")
        run(["sudo", gtar, "-x", "--no-overwrite-dir",
             "-f", ssh_tar, "-C", mountpoint])

        # Remove unnecessary files
        for rel_path in RAMDISK_REMOVE:
            full = os.path.join(mountpoint, rel_path)
            if os.path.exists(full):
                os.remove(full)

        # Re-sign Mach-O binaries
        print("  Re-signing Mach-O binaries...")
        ldid = os.path.join(input_dir, "tools/ldid_macosx_arm64")
        signcert = os.path.join(input_dir, "signcert.p12")

        for pattern in SIGN_DIRS:
            for path in glob.glob(os.path.join(mountpoint, pattern)):
                if os.path.isfile(path) and not os.path.islink(path):
                    if "Mach-O" in subprocess.run(
                            ["file", path], capture_output=True, text=True,
                        ).stdout:
                        subprocess.run(
                            [ldid, "-S", "-M", f"-K{signcert}", path],
                            capture_output=True,
                        )

        # Fix sftp-server entitlements
        sftp_ents = os.path.join(input_dir, "sftp_server_ents.plist")
        sftp_server = os.path.join(mountpoint, "usr/libexec/sftp-server")
        if os.path.exists(sftp_server):
            run([ldid, f"-S{sftp_ents}", "-M", f"-K{signcert}", sftp_server])

        # Build trustcache
        print("  Building trustcache...")
        tc_tool = os.path.join(input_dir, "tools/trustcache_macos_arm64")
        tc_raw = os.path.join(temp_dir, "sshrd.raw.tc")
        tc_im4p = os.path.join(temp_dir, "trustcache.im4p")

        run([tc_tool, "create", tc_raw, mountpoint])
        run(["pyimg4", "im4p", "create", "-i", tc_raw, "-o", tc_im4p,
             "-f", "rtsc"], capture_output=True)
        sign_img4(tc_im4p, os.path.join(output_dir, "trustcache.img4"),
                  im4m_path, input_dir=input_dir)
        print(f"  [+] trustcache.img4")

    finally:
        subprocess.run(["sudo", "hdiutil", "detach", "-force", mountpoint],
                       capture_output=True)

    # Shrink and sign ramdisk
    run(["sudo", "hdiutil", "resize", "-sectors", "min", ramdisk_custom])

    print("  Signing ramdisk...")
    rd_im4p = os.path.join(temp_dir, "ramdisk.im4p")
    run(["pyimg4", "im4p", "create", "-i", ramdisk_custom, "-o", rd_im4p,
         "-f", "rdsk"], capture_output=True)
    sign_img4(rd_im4p, os.path.join(output_dir, "ramdisk.img4"),
              im4m_path, input_dir=input_dir)
    print(f"  [+] ramdisk.img4")


# ══════════════════════════════════════════════════════════════════
# Main
# ══════════════════════════════════════════════════════════════════

def main():
    vm_dir = os.path.abspath(sys.argv[1] if len(sys.argv) > 1 else os.getcwd())

    if not os.path.isdir(vm_dir):
        print(f"[-] Not a directory: {vm_dir}")
        sys.exit(1)

    # Find SHSH
    shsh_dir = os.path.join(vm_dir, "shsh")
    shsh_path = find_shsh(shsh_dir)
    if not shsh_path:
        print(f"[-] No SHSH blob found in {shsh_dir}/")
        print("    Place your .shsh file in the shsh/ directory.")
        sys.exit(1)

    # Find restore directory
    restore_dir = find_restore_dir(vm_dir)
    if not restore_dir:
        print(f"[-] No *Restore* directory found in {vm_dir}")
        sys.exit(1)

    # Check pyimg4 CLI
    try:
        subprocess.run(["pyimg4", "--help"], capture_output=True, check=True)
    except (FileNotFoundError, subprocess.CalledProcessError):
        print("[-] pyimg4 CLI not found. Install with: pip install pyimg4")
        sys.exit(1)

    # Setup input resources (copy from CFW if needed)
    print(f"[*] Setting up {INPUT_DIR}/...")
    input_dir = setup_input(vm_dir)

    # Create temp and output directories
    temp_dir = os.path.join(vm_dir, TEMP_DIR)
    output_dir = os.path.join(vm_dir, OUTPUT_DIR)
    for d in (temp_dir, output_dir):
        if os.path.exists(d):
            shutil.rmtree(d)
        os.makedirs(d)

    print(f"[*] VM directory:      {vm_dir}")
    print(f"[*] Restore directory: {restore_dir}")
    print(f"[*] SHSH blob:         {shsh_path}")

    # Extract IM4M from SHSH
    im4m_path = os.path.join(temp_dir, "vphone.im4m")
    print(f"\n[*] Extracting IM4M from SHSH...")
    extract_im4m(shsh_path, im4m_path)

    # ── 1. iBSS (already patched by patch_firmware.py) ───────────
    print(f"\n{'=' * 60}")
    print(f"  1. iBSS (already patched — extract & sign)")
    print(f"{'=' * 60}")
    ibss_src = find_file(restore_dir, [
        "Firmware/dfu/iBSS.vresearch101.RELEASE.im4p",
    ], "iBSS")
    ibss_raw = os.path.join(temp_dir, "iBSS.raw")
    ibss_im4p = os.path.join(temp_dir, "iBSS.im4p")
    im4p_obj, data, _ = extract_to_raw(ibss_src, ibss_raw)
    create_im4p_uncompressed(data, im4p_obj.fourcc, im4p_obj.description, ibss_im4p)
    sign_img4(ibss_im4p, os.path.join(output_dir, "iBSS.vresearch101.RELEASE.img4"),
              im4m_path, input_dir=input_dir)
    print(f"  [+] iBSS.vresearch101.RELEASE.img4")

    # ── 2. iBEC (already patched — just fix boot-args for ramdisk)
    print(f"\n{'=' * 60}")
    print(f"  2. iBEC (patch boot-args for ramdisk)")
    print(f"{'=' * 60}")
    ibec_src = find_file(restore_dir, [
        "Firmware/dfu/iBEC.vresearch101.RELEASE.im4p",
    ], "iBEC")
    ibec_raw = os.path.join(temp_dir, "iBEC.raw")
    ibec_im4p = os.path.join(temp_dir, "iBEC.im4p")
    im4p_obj, data, _ = extract_to_raw(ibec_src, ibec_raw)
    patch_ibec_bootargs(data)
    create_im4p_uncompressed(data, im4p_obj.fourcc, im4p_obj.description, ibec_im4p)
    sign_img4(ibec_im4p, os.path.join(output_dir, "iBEC.vresearch101.RELEASE.img4"),
              im4m_path, input_dir=input_dir)
    print(f"  [+] iBEC.vresearch101.RELEASE.img4")

    # ── 3. SPTM (sign only) ─────────────────────────────────────
    print(f"\n{'=' * 60}")
    print(f"  3. SPTM (sign only)")
    print(f"{'=' * 60}")
    sptm_src = find_file(restore_dir, [
        "Firmware/sptm.vresearch1.release.im4p",
    ], "SPTM")
    sign_img4(sptm_src, os.path.join(output_dir, "sptm.vresearch1.release.img4"),
              im4m_path, tag="sptm", input_dir=input_dir)
    print(f"  [+] sptm.vresearch1.release.img4")

    # ── 4. DeviceTree (sign only) ────────────────────────────────
    print(f"\n{'=' * 60}")
    print(f"  4. DeviceTree (sign only)")
    print(f"{'=' * 60}")
    dt_src = find_file(restore_dir, [
        "Firmware/all_flash/DeviceTree.vphone600ap.im4p",
    ], "DeviceTree")
    sign_img4(dt_src, os.path.join(output_dir, "DeviceTree.vphone600ap.img4"),
              im4m_path, tag="rdtr", input_dir=input_dir)
    print(f"  [+] DeviceTree.vphone600ap.img4")

    # ── 5. SEP (sign only) ───────────────────────────────────────
    print(f"\n{'=' * 60}")
    print(f"  5. SEP (sign only)")
    print(f"{'=' * 60}")
    sep_src = find_file(restore_dir, [
        "Firmware/all_flash/sep-firmware.vresearch101.RELEASE.im4p",
    ], "SEP")
    sign_img4(sep_src, os.path.join(output_dir, "sep-firmware.vresearch101.RELEASE.img4"),
              im4m_path, tag="rsep", input_dir=input_dir)
    print(f"  [+] sep-firmware.vresearch101.RELEASE.img4")

    # ── 6. TXM (release variant — needs patching) ────────────────
    print(f"\n{'=' * 60}")
    print(f"  6. TXM (patch release variant)")
    print(f"{'=' * 60}")
    txm_src = find_file(restore_dir, [
        "Firmware/txm.iphoneos.release.im4p",
    ], "TXM")
    txm_raw = os.path.join(temp_dir, "txm.raw")
    im4p_obj, data, original_raw = extract_to_raw(txm_src, txm_raw)
    patch_txm(data)
    txm_im4p = os.path.join(temp_dir, "txm.im4p")
    _save_im4p_with_payp(txm_im4p, TXM_FOURCC, data, original_raw)
    sign_img4(txm_im4p, os.path.join(output_dir, "txm.img4"),
              im4m_path, input_dir=input_dir)
    print(f"  [+] txm.img4")

    # ── 7. Kernelcache (already patched — repack with rkrn) ──────
    print(f"\n{'=' * 60}")
    print(f"  7. Kernelcache (already patched — repack as rkrn)")
    print(f"{'=' * 60}")
    kc_src = find_file(restore_dir, [
        "kernelcache.research.vphone600",
    ], "kernelcache")
    kc_raw = os.path.join(temp_dir, "kcache.raw")
    im4p_obj, data, original_raw = extract_to_raw(kc_src, kc_raw)
    print(f"  format: IM4P, {len(data)} bytes")
    kc_im4p = os.path.join(temp_dir, "krnl.im4p")
    _save_im4p_with_payp(kc_im4p, KERNEL_FOURCC, data, original_raw)
    sign_img4(kc_im4p, os.path.join(output_dir, "krnl.img4"),
              im4m_path, input_dir=input_dir)
    print(f"  [+] krnl.img4")

    # ── 8. Ramdisk + Trustcache ──────────────────────────────────
    print(f"\n{'=' * 60}")
    print(f"  8. Ramdisk + Trustcache")
    print(f"{'=' * 60}")
    build_ramdisk(restore_dir, im4m_path, vm_dir, input_dir, output_dir, temp_dir)

    # ── Cleanup ──────────────────────────────────────────────────
    print(f"\n[*] Cleaning up {TEMP_DIR}/...")
    shutil.rmtree(temp_dir, ignore_errors=True)
    sshrd_dir = os.path.join(vm_dir, "SSHRD")
    if os.path.exists(sshrd_dir):
        shutil.rmtree(sshrd_dir, ignore_errors=True)

    # ── Summary ──────────────────────────────────────────────────
    print(f"\n{'=' * 60}")
    print(f"  Ramdisk build complete!")
    print(f"  Output: {output_dir}/")
    print(f"{'=' * 60}")
    for f in sorted(os.listdir(output_dir)):
        size = os.path.getsize(os.path.join(output_dir, f))
        print(f"    {f:45s} {size:>10,} bytes")


if __name__ == "__main__":
    main()

```

`scripts/ramdisk_send.sh`:

```sh
#!/bin/zsh
# ramdisk_send.sh — Send signed ramdisk components to device via irecovery.
#
# Usage: ./ramdisk_send.sh [ramdisk_dir]
#
# Expects device in DFU mode. Loads iBSS/iBEC, then boots with
# SPTM, TXM, trustcache, ramdisk, device tree, SEP, and kernel.
set -euo pipefail

IRECOVERY="${IRECOVERY:-irecovery}"
RAMDISK_DIR="${1:-Ramdisk}"

if [ ! -d "$RAMDISK_DIR" ]; then
    echo "[-] Ramdisk directory not found: $RAMDISK_DIR"
    echo "    Run 'make ramdisk_build' first."
    exit 1
fi

echo "[*] Sending ramdisk from $RAMDISK_DIR ..."

# 1. Load iBSS + iBEC (DFU → recovery)
echo "  [1/8] Loading iBSS..."
"$IRECOVERY" -f "$RAMDISK_DIR/iBSS.vresearch101.RELEASE.img4"

echo "  [2/8] Loading iBEC..."
"$IRECOVERY" -f "$RAMDISK_DIR/iBEC.vresearch101.RELEASE.img4"
"$IRECOVERY" -c go

sleep 1

# 2. Load SPTM
echo "  [3/8] Loading SPTM..."
"$IRECOVERY" -f "$RAMDISK_DIR/sptm.vresearch1.release.img4"
"$IRECOVERY" -c firmware

# 3. Load TXM
echo "  [4/8] Loading TXM..."
"$IRECOVERY" -f "$RAMDISK_DIR/txm.img4"
"$IRECOVERY" -c firmware

# 4. Load trustcache
echo "  [5/8] Loading trustcache..."
"$IRECOVERY" -f "$RAMDISK_DIR/trustcache.img4"
"$IRECOVERY" -c firmware

# 5. Load ramdisk
echo "  [6/8] Loading ramdisk..."
"$IRECOVERY" -f "$RAMDISK_DIR/ramdisk.img4"
sleep 2
"$IRECOVERY" -c ramdisk

# 6. Load device tree
echo "  [7/8] Loading device tree..."
"$IRECOVERY" -f "$RAMDISK_DIR/DeviceTree.vphone600ap.img4"
"$IRECOVERY" -c devicetree

# 7. Load SEP
echo "  [8/8] Loading SEP..."
"$IRECOVERY" -f "$RAMDISK_DIR/sep-firmware.vresearch101.RELEASE.img4"
"$IRECOVERY" -c firmware

# 8. Load kernel and boot
echo "  [*] Booting kernel..."
"$IRECOVERY" -f "$RAMDISK_DIR/krnl.img4"
"$IRECOVERY" -c bootx

echo "[+] Boot sequence complete. Device should be booting into ramdisk."

```

`scripts/setup_libimobiledevice.sh`:

```sh
#!/bin/bash
# setup_libimobiledevice.sh — Build libimobiledevice toolchain (static)
#
# Produces: idevicerestore, irecovery, and related idevice* tools
# Prefix:   .limd/  (override with LIMD_PREFIX env var)
# Requires: autoconf automake libtool pkg-config cmake git

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

PREFIX="${LIMD_PREFIX:-$PROJECT_DIR/.limd}"
SRC="$PREFIX/src"
LOG="$PREFIX/log"

NPROC="$(sysctl -n hw.logicalcpu)"
SDKROOT="$(xcrun --sdk macosx --show-sdk-path)"

export PKG_CONFIG_PATH="$PREFIX/lib/pkgconfig"
export CFLAGS="-mmacosx-version-min=14.0 -isysroot $SDKROOT"
export CPPFLAGS="$CFLAGS"
export LDFLAGS="-mmacosx-version-min=14.0"

mkdir -p "$SRC" "$LOG"

# ── Helpers ──────────────────────────────────────────────────────

die() { echo "[-] $*" >&2; exit 1; }

check_tools() {
    local missing=()
    for cmd in autoconf automake pkg-config cmake git; do
        command -v "$cmd" &>/dev/null || missing+=("$cmd")
    done
    command -v glibtoolize &>/dev/null || command -v libtoolize &>/dev/null \
        || missing+=("libtool(ize)")
    (( ${#missing[@]} == 0 )) || die "Missing: ${missing[*]} — brew install ${missing[*]}"
}

clone() {
    local url=$1 dir=$2
    if [[ -d "$dir/.git" ]]; then
        git -C "$dir" fetch --depth 1 origin --quiet
        git -C "$dir" reset --hard FETCH_HEAD --quiet
        git -C "$dir" clean -fdx --quiet
    else
        git clone --depth 1 "$url" "$dir" --quiet
    fi
}

build_lib() {
    local name=$1; shift
    echo "  $name"
    cd "$SRC/$name"
    ./autogen.sh --prefix="$PREFIX" \
        --enable-shared=no --enable-static=yes \
        "$@" > "$LOG/$name-configure.log" 2>&1
    make -j"$NPROC" > "$LOG/$name-build.log" 2>&1
    make install > "$LOG/$name-install.log" 2>&1
    cd "$SRC"
}

# ── Preflight ────────────────────────────────────────────────────

check_tools
echo "Building libimobiledevice toolchain → $PREFIX"
echo ""

# ── 1. OpenSSL (static) ─────────────────────────────────────────

echo "[1/4] OpenSSL"
OPENSSL_TAG=$(curl -sS "https://api.github.com/repos/openssl/openssl/releases/latest" \
    | grep '"tag_name"' | cut -d'"' -f4)
if [[ ! -d "$SRC/openssl/.git" ]]; then
    git clone --depth 1 --branch "$OPENSSL_TAG" \
        "https://github.com/openssl/openssl" "$SRC/openssl" --quiet
else
    cd "$SRC/openssl"
    git fetch --depth 1 origin tag "$OPENSSL_TAG" --quiet 2>/dev/null || true
    git checkout "$OPENSSL_TAG" --quiet 2>/dev/null || true
    git clean -fdx --quiet
    cd "$SRC"
fi
echo "  openssl ($OPENSSL_TAG)"
cd "$SRC/openssl"
./config --prefix="$PREFIX" no-shared no-tests \
    > "$LOG/openssl-configure.log" 2>&1
make -j"$NPROC" > "$LOG/openssl-build.log" 2>&1
make install_sw > "$LOG/openssl-install.log" 2>&1
cd "$SRC"

# ── 2. Core libraries ───────────────────────────────────────────

echo "[2/4] Core libraries"
for lib in libplist libimobiledevice-glue libusbmuxd libtatsu libimobiledevice; do
    clone "https://github.com/libimobiledevice/$lib" "$SRC/$lib"
    case "$lib" in
        libplist|libimobiledevice) build_lib "$lib" --without-cython ;;
        *)                         build_lib "$lib" ;;
    esac
done

# ── 3. libirecovery (+ PCC research VM patch) ───────────────────

echo "[3/4] libirecovery + libzip"
clone "https://github.com/libimobiledevice/libirecovery" "$SRC/libirecovery"

# PR #150: register iPhone99,11 / vresearch101ap for PCC research VMs
if ! grep -q 'vresearch101ap' "$SRC/libirecovery/src/libirecovery.c"; then
    cd "$SRC/libirecovery"
    git apply "$SCRIPT_DIR/patches/libirecovery-pcc-vm.patch" \
        || die "Failed to apply libirecovery PCC patch — check context"
    cd "$SRC"
fi
build_lib libirecovery

# ── libzip (static, for idevicerestore) ──────────────────────────

LIBZIP_VER="1.11.4"
if [[ ! -f "$PREFIX/lib/pkgconfig/libzip.pc" ]]; then
    echo "  libzip"
    [[ -d "$SRC/libzip-$LIBZIP_VER" ]] || \
        curl -LfsS "https://github.com/nih-at/libzip/releases/download/v$LIBZIP_VER/libzip-$LIBZIP_VER.tar.gz" \
        | tar xz -C "$SRC"
    cmake -S "$SRC/libzip-$LIBZIP_VER" -B "$SRC/libzip-$LIBZIP_VER/build" \
        -DCMAKE_INSTALL_PREFIX="$PREFIX" -DCMAKE_OSX_SYSROOT="$SDKROOT" \
        -DBUILD_SHARED_LIBS=OFF -DBUILD_DOC=OFF -DBUILD_EXAMPLES=OFF \
        -DBUILD_REGRESS=OFF -DBUILD_TOOLS=OFF \
        -DENABLE_BZIP2=OFF -DENABLE_LZMA=OFF -DENABLE_ZSTD=OFF \
        -DENABLE_GNUTLS=OFF -DENABLE_MBEDTLS=OFF -DENABLE_OPENSSL=OFF \
        > "$LOG/libzip-cmake.log" 2>&1
    cmake --build "$SRC/libzip-$LIBZIP_VER/build" -j"$NPROC" \
        > "$LOG/libzip-build.log" 2>&1
    cmake --install "$SRC/libzip-$LIBZIP_VER/build" \
        > "$LOG/libzip-install.log" 2>&1
fi

# ── 4. idevicerestore ───────────────────────────────────────────

echo "[4/4] idevicerestore"
clone "https://github.com/libimobiledevice/idevicerestore" "$SRC/idevicerestore"
build_lib idevicerestore \
    libcurl_CFLAGS="-I$SDKROOT/usr/include" \
    libcurl_LIBS="-lcurl" \
    libcurl_VERSION="$(/usr/bin/curl-config --version | cut -d' ' -f2)" \
    zlib_CFLAGS="-I$SDKROOT/usr/include" \
    zlib_LIBS="-lz" \
    zlib_VERSION="1.2"

# ── Done ─────────────────────────────────────────────────────────

echo ""
echo "Installed to $PREFIX/bin/:"
ls "$PREFIX/bin/" | sed 's/^/  /'

```

`scripts/setup_venv.sh`:

```sh
#!/bin/zsh
# setup_venv.sh — Create a self-contained Python venv at project root.
#
# Installs all dependencies including the keystone native library.
# Requires: python3, clang, Homebrew keystone (brew install keystone)
#
# Usage:
#   make setup_venv
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
VENV_DIR="${PROJECT_ROOT}/.venv"
REQUIREMENTS="${PROJECT_ROOT}/requirements.txt"

# Use system Python3
PYTHON="$(command -v python3)"
if [[ -z "${PYTHON}" ]]; then
  echo "Error: python3 not found in PATH"
  exit 1
fi

echo "=== Creating venv ==="
echo "  Python:  ${PYTHON} ($(${PYTHON} --version 2>&1))"
echo "  venv:    ${VENV_DIR}"
echo "  deps:    ${REQUIREMENTS}"
echo ""

# Create venv from system Python
"${PYTHON}" -m venv "${VENV_DIR}"

# Activate and install pip packages
source "${VENV_DIR}/bin/activate"
pip install --upgrade pip > /dev/null
pip install -r "${REQUIREMENTS}"

# --- Build keystone native library ---
# The keystone-engine pip package is Python bindings only.
# It needs libkeystone.dylib at runtime. Homebrew ships only the static .a,
# so we build a dylib from it and place it inside the venv.
echo ""
echo "=== Building keystone dylib ==="
KEYSTONE_DIR="/opt/homebrew/Cellar/keystone"
if [ ! -d "${KEYSTONE_DIR}" ]; then
  echo "Error: keystone not found. Install with: brew install keystone"
  exit 1
fi
KEYSTONE_STATIC="$(find "${KEYSTONE_DIR}" -name 'libkeystone.a' -type f 2>/dev/null | head -1)"
if [[ -z "${KEYSTONE_STATIC}" ]]; then
  echo "Error: libkeystone.a not found. Install with: brew install keystone"
  exit 1
fi

PYVER="$(python3 -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")')"
KS_PKG_DIR="${VENV_DIR}/lib/python${PYVER}/site-packages/keystone"
KS_DYLIB="${KS_PKG_DIR}/libkeystone.dylib"

echo "  static lib: ${KEYSTONE_STATIC}"
echo "  dylib dest: ${KS_DYLIB}"

clang -shared -o "${KS_DYLIB}" \
  -Wl,-all_load "${KEYSTONE_STATIC}" \
  -lc++ \
  -install_name @rpath/libkeystone.dylib

echo "  dylib built OK"

# --- Verify ---
echo ""
echo "=== Verifying imports ==="
python3 -c "
from capstone import Cs, CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN
from pyimg4 import IM4P
print('  capstone  OK')
print('  keystone  OK')
print('  pyimg4    OK')
"

echo ""
echo "=== venv ready ==="
echo "  Activate:   source ${VENV_DIR}/bin/activate"
echo "  Deactivate: deactivate"

```

`scripts/setup_venv_linux.sh`:

```sh
#!/bin/bash
# setup_venv_linux.sh — Create Python venv on Linux (Debian/Ubuntu).
#
# On Linux, keystone-engine pip package ships prebuilt .so — no manual build needed.
#
# Usage:
#   bash scripts/setup_venv_linux.sh
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
VENV_DIR="${PROJECT_ROOT}/.venv"
REQUIREMENTS="${PROJECT_ROOT}/requirements.txt"

echo "=== Installing system deps ==="
if command -v apt-get &>/dev/null; then
  apt-get update -qq
  apt-get install -y -qq python3 python3-venv python3-pip cmake gcc g++ pkg-config 2>/dev/null
elif command -v dnf &>/dev/null; then
  dnf install -y python3 python3-pip cmake gcc gcc-c++ 2>/dev/null
fi

PYTHON="$(command -v python3)"
if [[ -z "${PYTHON}" ]]; then
  echo "Error: python3 not found in PATH"
  exit 1
fi

echo ""
echo "=== Creating venv ==="
echo "  Python:  ${PYTHON} ($(${PYTHON} --version 2>&1))"
echo "  venv:    ${VENV_DIR}"
echo "  deps:    ${REQUIREMENTS}"
echo ""

"${PYTHON}" -m venv "${VENV_DIR}"

source "${VENV_DIR}/bin/activate"
pip install --upgrade pip > /dev/null
pip install -r "${REQUIREMENTS}"

# --- Verify ---
echo ""
echo "=== Verifying imports ==="
python3 -c "
from capstone import Cs, CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN
from pyimg4 import IM4P
print('  capstone  OK')
print('  keystone  OK')
print('  pyimg4    OK')
"

echo ""
echo "=== venv ready ==="
echo "  Activate:   source ${VENV_DIR}/bin/activate"
echo "  Deactivate: deactivate"

```

`scripts/vm_create.sh`:

```sh
#!/bin/zsh
# vm_create.sh — Create a new vphone VM directory with all required files.
#
# Mirrors the vrevm VM creation process:
#   1. Create VM directory structure
#   2. Create sparse disk image (default 64 GB)
#   3. Create SEP storage (512 KB flat file)
#   4. Copy AVPBooter and AVPSEPBooter ROMs
#
# machineIdentifier and NVRAM are auto-created on first boot by vphone-cli.
#
# Usage:
#   make vm_new                     # Create VM/ with framework ROMs
#   make vm_new VM_DIR=MyVM         # Custom directory name
#   make vm_new DISK_SIZE=32        # 32 GB disk
set -euo pipefail

# --- Defaults ---
VM_DIR="vm"
DISK_SIZE_GB=64
SEP_STORAGE_SIZE=$((512 * 1024))  # 512 KB (same as vrevm)

# Framework-bundled ROMs (vresearch1 / research1 chip)
FW_ROM_DIR="/System/Library/Frameworks/Virtualization.framework/Versions/A/Resources"
ROM_SRC="${FW_ROM_DIR}/AVPBooter.vresearch1.bin"
SEPROM_SRC="${FW_ROM_DIR}/AVPSEPBooter.vresearch1.bin"

# --- Parse args ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        --dir)      VM_DIR="$2";        shift 2 ;;
        --disk-size) DISK_SIZE_GB="$2"; shift 2 ;;
        --rom)      ROM_SRC="$2";       shift 2 ;;
        --seprom)   SEPROM_SRC="$2";    shift 2 ;;
        -h|--help)
            echo "Usage: $0 [--dir VM] [--disk-size 64] [--rom path] [--seprom path]"
            echo ""
            echo "Options:"
            echo "  --dir       VM directory name (default: VM)"
            echo "  --disk-size Disk image size in GB (default: 64)"
            echo "  --rom       Path to AVPBooter ROM (default: framework built-in)"
            echo "  --seprom    Path to AVPSEPBooter ROM (default: framework built-in)"
            exit 0
            ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

DISK_SIZE_BYTES=$((DISK_SIZE_GB * 1024 * 1024 * 1024))

echo "=== vphone create_vm ==="
echo "Directory : ${VM_DIR}"
echo "Disk size : ${DISK_SIZE_GB} GB"
echo "AVPBooter : ${ROM_SRC}"
echo "AVPSEPBooter: ${SEPROM_SRC}"
echo ""

# --- Validate ROM sources ---
if [[ ! -f "${ROM_SRC}" ]]; then
    echo "ERROR: AVPBooter ROM not found: ${ROM_SRC}"
    echo "  On Apple Internal macOS, this should be at:"
    echo "  ${FW_ROM_DIR}/AVPBooter.vresearch1.bin"
    exit 1
fi

if [[ ! -f "${SEPROM_SRC}" ]]; then
    echo "ERROR: AVPSEPBooter ROM not found: ${SEPROM_SRC}"
    echo "  On Apple Internal macOS, this should be at:"
    echo "  ${FW_ROM_DIR}/AVPSEPBooter.vresearch1.bin"
    exit 1
fi

# --- Create VM directory ---
if [[ -d "${VM_DIR}" ]]; then
    echo "WARNING: ${VM_DIR}/ already exists"
    # Check for existing disk to avoid accidental overwrite
    if [[ -f "${VM_DIR}/Disk.img" ]]; then
        echo "  Disk.img already exists — skipping disk creation"
        echo "  Delete ${VM_DIR}/Disk.img manually to recreate"
    fi
else
    echo "[1/4] Creating ${VM_DIR}/"
    mkdir -p "${VM_DIR}"
fi

# --- Create sparse disk image ---
if [[ ! -f "${VM_DIR}/Disk.img" ]]; then
    echo "[2/4] Creating sparse disk image (${DISK_SIZE_GB} GB)"
    # Use dd with seek to create a sparse file (same approach as vrevm)
    dd if=/dev/zero of="${VM_DIR}/Disk.img" bs=1 count=0 seek="${DISK_SIZE_BYTES}" 2>/dev/null
    echo "  -> ${VM_DIR}/Disk.img ($(du -h "${VM_DIR}/Disk.img" | cut -f1) on disk)"
else
    echo "[2/4] Disk.img exists — skipping"
fi

# --- Create SEP storage ---
if [[ ! -f "${VM_DIR}/SEPStorage" ]]; then
    echo "[3/4] Creating SEP storage (512 KB)"
    dd if=/dev/zero of="${VM_DIR}/SEPStorage" bs=1 count="${SEP_STORAGE_SIZE}" 2>/dev/null
else
    echo "[3/4] SEPStorage exists — skipping"
fi

# --- Copy ROMs ---
echo "[4/4] Copying ROMs"

ROM_DST="${VM_DIR}/AVPBooter.vresearch1.bin"
SEPROM_DST="${VM_DIR}/AVPSEPBooter.vresearch1.bin"

if [[ -f "${ROM_DST}" ]] && cmp -s "${ROM_SRC}" "${ROM_DST}"; then
    echo "  AVPBooter.vresearch1.bin — up to date"
else
    cp "${ROM_SRC}" "${ROM_DST}"
    echo "  AVPBooter.vresearch1.bin — copied ($(wc -c < "${ROM_DST}" | tr -d ' ') bytes)"
fi

if [[ -f "${SEPROM_DST}" ]] && cmp -s "${SEPROM_SRC}" "${SEPROM_DST}"; then
    echo "  AVPSEPBooter.vresearch1.bin — up to date"
else
    cp "${SEPROM_SRC}" "${SEPROM_DST}"
    echo "  AVPSEPBooter.vresearch1.bin — copied ($(wc -c < "${SEPROM_DST}" | tr -d ' ') bytes)"
fi

# --- Create .gitkeep ---
touch "${VM_DIR}/.gitkeep"

echo ""
echo "=== VM created at ${VM_DIR}/ ==="
echo ""
echo "Contents:"
ls -lh "${VM_DIR}/"
echo ""
echo "Next steps:"
echo "  1. Prepare firmware:  make fw_prepare"
echo "  2. Patch firmware:    make fw_patch"
echo "  3. Boot DFU:          make boot_dfu"
echo "  4. Boot normal:       make boot"

```

`sources/vphone-cli/VPhoneAppDelegate.swift`:

```swift
import AppKit
import Foundation
import Virtualization

class VPhoneAppDelegate: NSObject, NSApplicationDelegate {
    private let cli: VPhoneCLI
    private var vm: VPhoneVM?
    private var windowController: VPhoneWindowController?
    private var menuController: VPhoneMenuController?
    private var sigintSource: DispatchSourceSignal?

    init(cli: VPhoneCLI) {
        self.cli = cli
        super.init()
    }

    func applicationDidFinishLaunching(_: Notification) {
        NSApp.setActivationPolicy(cli.noGraphics ? .prohibited : .regular)

        signal(SIGINT, SIG_IGN)
        let src = DispatchSource.makeSignalSource(signal: SIGINT, queue: .main)
        src.setEventHandler {
            print("\n[vphone] SIGINT — shutting down")
            NSApp.terminate(nil)
        }
        src.activate()
        sigintSource = src

        Task { @MainActor in
            do {
                try await self.startVM()
            } catch {
                print("[vphone] Fatal: \(error)")
                NSApp.terminate(nil)
            }
        }
    }

    @MainActor
    private func startVM() async throws {
        let romURL = URL(fileURLWithPath: cli.rom)
        guard FileManager.default.fileExists(atPath: romURL.path) else {
            throw VPhoneError.romNotFound(cli.rom)
        }

        let diskURL = URL(fileURLWithPath: cli.disk)
        let nvramURL = URL(fileURLWithPath: cli.nvram)
        let machineIDURL = URL(fileURLWithPath: cli.machineId)
        let sepStorageURL = URL(fileURLWithPath: cli.sepStorage)
        let sepRomURL = URL(fileURLWithPath: cli.sepRom)

        print("=== vphone-cli ===")
        print("ROM   : \(cli.rom)")
        print("Disk  : \(cli.disk)")
        print("NVRAM : \(cli.nvram)")
        print("MachID: \(cli.machineId)")
        print("CPU   : \(cli.cpu)")
        print("Memory: \(cli.memory) MB")
        print("Screen: \(cli.screenWidth)x\(cli.screenHeight) @ \(cli.screenPpi) PPI (scale \(cli.screenScale)x)")
        print("SEP   : enabled")
        print("  storage: \(cli.sepStorage)")
        print("  rom    : \(cli.sepRom)")
        print("")

        let options = VPhoneVM.Options(
            romURL: romURL,
            nvramURL: nvramURL,
            machineIDURL: machineIDURL,
            diskURL: diskURL,
            cpuCount: cli.cpu,
            memorySize: UInt64(cli.memory) * 1024 * 1024,
            sepStorageURL: sepStorageURL,
            sepRomURL: sepRomURL,
            screenWidth: cli.screenWidth,
            screenHeight: cli.screenHeight,
            screenPPI: cli.screenPpi,
            screenScale: cli.screenScale
        )

        let vm = try VPhoneVM(options: options)
        self.vm = vm

        try await vm.start(forceDFU: cli.dfu)

        if !cli.noGraphics {
            let keyHelper = VPhoneKeyHelper(vm: vm.virtualMachine)
            let wc = VPhoneWindowController()
            wc.showWindow(
                for: vm.virtualMachine,
                screenWidth: cli.screenWidth,
                screenHeight: cli.screenHeight,
                screenScale: cli.screenScale,
                keyHelper: keyHelper
            )
            windowController = wc
            menuController = VPhoneMenuController(keyHelper: keyHelper)
        }
    }

    func applicationShouldTerminateAfterLastWindowClosed(_: NSApplication) -> Bool {
        !cli.noGraphics
    }
}

```

`sources/vphone-cli/VPhoneCLI.swift`:

```swift
import ArgumentParser
import Foundation

struct VPhoneCLI: ParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "vphone-cli",
        abstract: "Boot a virtual iPhone (PV=3)",
        discussion: """
        Creates a Virtualization.framework VM with platform version 3 (vphone)
        and boots it into DFU mode for firmware loading via irecovery.

        Requires:
          - macOS 15+ (Sequoia or later)
          - SIP/AMFI disabled
          - Signed with vphone entitlements (done automatically by wrapper script)

        Example:
          vphone-cli --rom firmware/rom.bin --disk firmware/disk.img
        """
    )

    @Option(help: "Path to the AVPBooter / ROM binary")
    var rom: String

    @Option(help: "Path to the disk image")
    var disk: String

    @Option(help: "Path to NVRAM storage (created/overwritten)")
    var nvram: String = "nvram.bin"

    @Option(help: "Path to machineIdentifier file (created if missing)")
    var machineId: String

    @Option(help: "Number of CPU cores")
    var cpu: Int = 8

    @Option(help: "Memory size in MB")
    var memory: Int = 8192

    @Option(help: "Path to SEP storage file (created if missing)")
    var sepStorage: String

    @Option(help: "Path to SEP ROM binary")
    var sepRom: String

    @Flag(help: "Boot into DFU mode")
    var dfu: Bool = false

    @Option(help: "Display width in pixels (default: 1290)")
    var screenWidth: Int = 1290

    @Option(help: "Display height in pixels (default: 2796)")
    var screenHeight: Int = 2796

    @Option(help: "Display pixels per inch (default: 460)")
    var screenPpi: Int = 460

    @Option(help: "Window scale divisor (default: 3.0)")
    var screenScale: Double = 3.0

    @Flag(help: "Run without GUI (headless)")
    var noGraphics: Bool = false

    /// Execution is driven by VPhoneAppDelegate; main.swift calls parseOrExit()
    /// and hands the parsed options to the delegate.
    mutating func run() throws {}
}

```

`sources/vphone-cli/VPhoneError.swift`:

```swift
import Foundation

enum VPhoneError: Error, CustomStringConvertible {
    case hardwareModelNotSupported
    case romNotFound(String)
    case diskNotFound(String)

    var description: String {
        switch self {
        case .hardwareModelNotSupported:
            """
            PV=3 hardware model not supported. Check:
              1. macOS >= 15.0 (Sequoia)
              2. Signed with com.apple.private.virtualization + \
            com.apple.private.virtualization.security-research
              3. SIP/AMFI disabled
            """
        case let .romNotFound(p):
            "ROM not found: \(p)"
        case let .diskNotFound(p):
            "Disk image not found: \(p)"
        }
    }
}

```

`sources/vphone-cli/VPhoneHardwareModel.swift`:

```swift
import Dynamic
import Foundation
import Virtualization

/// Creates a PV=3 hardware model via private _VZMacHardwareModelDescriptor.
///
/// The Virtualization.framework checks:
///   default_configuration_for_platform_version(3) validity byte =
///     (entitlements & 0x12) != 0
///   where bit 1 = com.apple.private.virtualization
///         bit 4 = com.apple.private.virtualization.security-research
///
/// Minimum host OS for PV=3: macOS 15.0 (Sequoia)
///
enum VPhoneHardware {
    static func createModel() throws -> VZMacHardwareModel {
        // platformVersion=3, boardID=0x90, ISA=2 matches vresearch101
        let desc = Dynamic._VZMacHardwareModelDescriptor()
        desc.setPlatformVersion(NSNumber(value: UInt32(3)))
        desc.setBoardID(NSNumber(value: UInt32(0x90)))
        desc.setISA(NSNumber(value: Int64(2)))

        let model = Dynamic.VZMacHardwareModel
            ._hardwareModelWithDescriptor(desc.asObject)
            .asObject as! VZMacHardwareModel

        guard model.isSupported else {
            throw VPhoneError.hardwareModelNotSupported
        }
        return model
    }
}

```

`sources/vphone-cli/VPhoneKeyHelper.swift`:

```swift
import AppKit
import Dynamic
import Foundation
import Virtualization

// MARK: - Key Helper

@MainActor
class VPhoneKeyHelper {
    private let vm: VZVirtualMachine

    /// First _VZKeyboard from the VM's internal keyboard array.
    private var firstKeyboard: AnyObject? {
        guard let arr = Dynamic(vm)._keyboards.asObject as? NSArray, arr.count > 0 else { return nil }
        return arr.object(at: 0) as AnyObject
    }

    /// Get _deviceIdentifier from _VZKeyboard via KVC (it's an ivar, not a property).
    private func keyboardDeviceId(_ keyboard: AnyObject) -> UInt32 {
        if let obj = keyboard as? NSObject,
           let val = obj.value(forKey: "_deviceIdentifier") as? UInt32
        {
            return val
        }
        print("[keys] WARNING: Could not read _deviceIdentifier, defaulting to 1")
        return 1
    }

    init(vm: VZVirtualMachine) {
        self.vm = vm
    }

    // MARK: - Send Key via _VZKeyEvent

    /// Send key down + up through _VZKeyEvent → _VZKeyboard.sendKeyEvents: pipeline.
    private func sendKeyPress(keyCode: UInt16) {
        guard let keyboard = firstKeyboard else {
            print("[keys] No keyboard found")
            return
        }

        let down = Dynamic._VZKeyEvent(type: 0, keyCode: keyCode)
        let up = Dynamic._VZKeyEvent(type: 1, keyCode: keyCode)

        guard let downObj = down.asAnyObject, let upObj = up.asAnyObject else {
            print("[keys] Failed to create _VZKeyEvent")
            return
        }

        Dynamic(keyboard).sendKeyEvents([downObj, upObj] as NSArray)
        print("[keys] Sent VK 0x\(String(keyCode, radix: 16)) (down+up)")
    }

    // MARK: - Fn+Key Combos (iOS Full Keyboard Access)

    /// Send modifier+key combo via _VZKeyEvent (mod down → key down → key up → mod up).
    private func sendVKCombo(modifierVK: UInt16, keyVK: UInt16) {
        guard let keyboard = firstKeyboard else {
            print("[keys] No keyboard found")
            return
        }

        var events: [AnyObject] = []
        if let obj = Dynamic._VZKeyEvent(type: 0, keyCode: modifierVK).asAnyObject { events.append(obj) }
        if let obj = Dynamic._VZKeyEvent(type: 0, keyCode: keyVK).asAnyObject { events.append(obj) }
        if let obj = Dynamic._VZKeyEvent(type: 1, keyCode: keyVK).asAnyObject { events.append(obj) }
        if let obj = Dynamic._VZKeyEvent(type: 1, keyCode: modifierVK).asAnyObject { events.append(obj) }

        print("[keys] events: \(events)")
        Dynamic(keyboard).sendKeyEvents(events as NSArray)
        print("[keys] VK combo: 0x\(String(modifierVK, radix: 16))+0x\(String(keyVK, radix: 16))")
    }

    // MARK: - Vector Injection (for keys with no VK code)

    /// Bypass _VZKeyEvent by calling sendKeyboardEvents:keyboardID: directly
    /// with a crafted std::vector<uint64_t>. Packed: (intermediate_index << 32) | is_key_down.
    private func sendRawKeyPress(index: UInt64) {
        guard let keyboard = firstKeyboard else {
            print("[keys] No keyboard found")
            return
        }
        let deviceId = keyboardDeviceId(keyboard)

        sendRawKeyEvent(index: index, isKeyDown: true, deviceId: deviceId)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) { [self] in
            sendRawKeyEvent(index: index, isKeyDown: false, deviceId: deviceId)
        }
    }

    private func sendRawKeyEvent(index: UInt64, isKeyDown: Bool, deviceId: UInt32) {
        let packed = (index << 32) | (isKeyDown ? 1 : 0)

        let data = UnsafeMutablePointer<UInt64>.allocate(capacity: 1)
        defer { data.deallocate() }
        data.pointee = packed

        var vec = (data, data.advanced(by: 1), data.advanced(by: 1))
        withUnsafeMutablePointer(to: &vec) { vecPtr in
            _ = Dynamic(vm).sendKeyboardEvents(UnsafeMutableRawPointer(vecPtr), keyboardID: deviceId)
        }
    }

    // MARK: - Named Key Actions

    /// iOS hardware keyboard shortcuts (Cmd-based, Fn has no table entry in _VZKeyEvent)
    func sendHome() {
        sendVKCombo(modifierVK: 0x37, keyVK: 0x04)
    } // Cmd+H → Home Screen
    func sendSpotlight() {
        sendVKCombo(modifierVK: 0x37, keyVK: 0x31)
    } // Cmd+Space → Spotlight

    /// Standard keyboard keys
    func sendReturn() {
        sendKeyPress(keyCode: 0x24)
    }

    func sendEscape() {
        sendKeyPress(keyCode: 0x35)
    }

    func sendSpace() {
        sendKeyPress(keyCode: 0x31)
    }

    func sendTab() {
        sendKeyPress(keyCode: 0x30)
    }

    func sendDeleteKey() {
        sendKeyPress(keyCode: 0x33)
    }

    func sendArrowUp() {
        sendKeyPress(keyCode: 0x7E)
    }

    func sendArrowDown() {
        sendKeyPress(keyCode: 0x7D)
    }

    func sendArrowLeft() {
        sendKeyPress(keyCode: 0x7B)
    }

    func sendArrowRight() {
        sendKeyPress(keyCode: 0x7C)
    }

    func sendShift() {
        sendKeyPress(keyCode: 0x38)
    }

    func sendCommand() {
        sendKeyPress(keyCode: 0x37)
    }

    /// Volume (Apple VK codes)
    func sendVolumeUp() {
        sendKeyPress(keyCode: 0x48)
    }

    func sendVolumeDown() {
        sendKeyPress(keyCode: 0x49)
    }

    /// Power — no VK code, use vector injection (intermediate index 0x72 = System Wake)
    func sendPower() {
        sendRawKeyPress(index: 0x72)
    }

    // MARK: - Type ASCII from Clipboard

    func typeFromClipboard() {
        guard let string = NSPasteboard.general.string(forType: .string) else {
            print("[keys] Clipboard has no string")
            return
        }
        print("[keys] Typing \(string.count) characters from clipboard")
        typeString(string)
    }

    func typeString(_ string: String) {
        guard let keyboard = firstKeyboard else {
            print("[keys] No keyboard found")
            return
        }

        var delay: TimeInterval = 0
        let interval: TimeInterval = 0.02

        for char in string {
            guard let (keyCode, needsShift) = asciiToVK(char) else {
                print("[keys] Skipping unsupported char: '\(char)'")
                continue
            }

            DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                var events: [AnyObject] = []
                if needsShift {
                    if let obj = Dynamic._VZKeyEvent(type: 0, keyCode: UInt16(0x38)).asAnyObject { events.append(obj) }
                }
                if let obj = Dynamic._VZKeyEvent(type: 0, keyCode: keyCode).asAnyObject { events.append(obj) }
                if let obj = Dynamic._VZKeyEvent(type: 1, keyCode: keyCode).asAnyObject { events.append(obj) }
                if needsShift {
                    if let obj = Dynamic._VZKeyEvent(type: 1, keyCode: UInt16(0x38)).asAnyObject { events.append(obj) }
                }
                Dynamic(keyboard).sendKeyEvents(events as NSArray)
            }

            delay += interval
        }
    }

    // MARK: - ASCII → Apple VK Code (US Layout)

    private func asciiToVK(_ char: Character) -> (UInt16, Bool)? {
        switch char {
        case "a": (0x00, false) case "b": (0x0B, false)
        case "c": (0x08, false) case "d": (0x02, false)
        case "e": (0x0E, false) case "f": (0x03, false)
        case "g": (0x05, false) case "h": (0x04, false)
        case "i": (0x22, false) case "j": (0x26, false)
        case "k": (0x28, false) case "l": (0x25, false)
        case "m": (0x2E, false) case "n": (0x2D, false)
        case "o": (0x1F, false) case "p": (0x23, false)
        case "q": (0x0C, false) case "r": (0x0F, false)
        case "s": (0x01, false) case "t": (0x11, false)
        case "u": (0x20, false) case "v": (0x09, false)
        case "w": (0x0D, false) case "x": (0x07, false)
        case "y": (0x10, false) case "z": (0x06, false)
        case "A": (0x00, true) case "B": (0x0B, true)
        case "C": (0x08, true) case "D": (0x02, true)
        case "E": (0x0E, true) case "F": (0x03, true)
        case "G": (0x05, true) case "H": (0x04, true)
        case "I": (0x22, true) case "J": (0x26, true)
        case "K": (0x28, true) case "L": (0x25, true)
        case "M": (0x2E, true) case "N": (0x2D, true)
        case "O": (0x1F, true) case "P": (0x23, true)
        case "Q": (0x0C, true) case "R": (0x0F, true)
        case "S": (0x01, true) case "T": (0x11, true)
        case "U": (0x20, true) case "V": (0x09, true)
        case "W": (0x0D, true) case "X": (0x07, true)
        case "Y": (0x10, true) case "Z": (0x06, true)
        case "0": (0x1D, false) case "1": (0x12, false)
        case "2": (0x13, false) case "3": (0x14, false)
        case "4": (0x15, false) case "5": (0x17, false)
        case "6": (0x16, false) case "7": (0x1A, false)
        case "8": (0x1C, false) case "9": (0x19, false)
        case "-": (0x1B, false) case "=": (0x18, false)
        case "[": (0x21, false) case "]": (0x1E, false)
        case "\\": (0x2A, false) case ";": (0x29, false)
        case "'": (0x27, false) case ",": (0x2B, false)
        case ".": (0x2F, false) case "/": (0x2C, false)
        case "`": (0x32, false)
        case "!": (0x12, true) case "@": (0x13, true)
        case "#": (0x14, true) case "$": (0x15, true)
        case "%": (0x17, true) case "^": (0x16, true)
        case "&": (0x1A, true) case "*": (0x1C, true)
        case "(": (0x19, true) case ")": (0x1D, true)
        case "_": (0x1B, true) case "+": (0x18, true)
        case "{": (0x21, true) case "}": (0x1E, true)
        case "|": (0x2A, true) case ":": (0x29, true)
        case "\"": (0x27, true) case "<": (0x2B, true)
        case ">": (0x2F, true) case "?": (0x2C, true)
        case "~": (0x32, true)
        case " ": (0x31, false) case "\t": (0x30, false)
        case "\n": (0x24, false) case "\r": (0x24, false)
        default: nil
        }
    }
}

```

`sources/vphone-cli/VPhoneMenuController.swift`:

```swift
import AppKit
import Foundation

// MARK: - Menu Controller

@MainActor
class VPhoneMenuController {
    private let keyHelper: VPhoneKeyHelper

    init(keyHelper: VPhoneKeyHelper) {
        self.keyHelper = keyHelper
        setupMenuBar()
    }

    // MARK: - Menu Bar Setup

    private func setupMenuBar() {
        let mainMenu = NSMenu()

        // App menu
        let appMenuItem = NSMenuItem()
        let appMenu = NSMenu(title: "vphone")
        appMenu.addItem(withTitle: "Quit vphone", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "q")
        appMenuItem.submenu = appMenu
        mainMenu.addItem(appMenuItem)

        // Keys menu — NO key equivalents to avoid intercepting VM keyboard input
        let keysMenuItem = NSMenuItem()
        let keysMenu = NSMenu(title: "Keys")

        // iOS hardware keyboard shortcuts
        keysMenu.addItem(makeItem("Home Screen (Cmd+H)", action: #selector(sendHome)))
        keysMenu.addItem(makeItem("Spotlight (Cmd+Space)", action: #selector(sendSpotlight)))
        keysMenu.addItem(NSMenuItem.separator())
        keysMenu.addItem(makeItem("Return", action: #selector(sendReturn)))
        keysMenu.addItem(makeItem("Escape", action: #selector(sendEscape)))
        keysMenu.addItem(makeItem("Space", action: #selector(sendSpace)))
        keysMenu.addItem(makeItem("Tab", action: #selector(sendTab)))
        keysMenu.addItem(makeItem("Delete", action: #selector(sendDeleteKey)))
        keysMenu.addItem(NSMenuItem.separator())
        keysMenu.addItem(makeItem("Arrow Up", action: #selector(sendArrowUp)))
        keysMenu.addItem(makeItem("Arrow Down", action: #selector(sendArrowDown)))
        keysMenu.addItem(makeItem("Arrow Left", action: #selector(sendArrowLeft)))
        keysMenu.addItem(makeItem("Arrow Right", action: #selector(sendArrowRight)))
        keysMenu.addItem(NSMenuItem.separator())
        keysMenu.addItem(makeItem("Power", action: #selector(sendPower)))
        keysMenu.addItem(makeItem("Volume Up", action: #selector(sendVolumeUp)))
        keysMenu.addItem(makeItem("Volume Down", action: #selector(sendVolumeDown)))
        keysMenu.addItem(NSMenuItem.separator())
        keysMenu.addItem(makeItem("Shift (tap)", action: #selector(sendShift)))
        keysMenu.addItem(makeItem("Command (tap)", action: #selector(sendCommand)))

        keysMenuItem.submenu = keysMenu
        mainMenu.addItem(keysMenuItem)

        // Type menu
        let typeMenuItem = NSMenuItem()
        let typeMenu = NSMenu(title: "Type")
        typeMenu.addItem(makeItem("Type ASCII from Clipboard", action: #selector(typeFromClipboard)))
        typeMenuItem.submenu = typeMenu
        mainMenu.addItem(typeMenuItem)

        NSApp.mainMenu = mainMenu
    }

    private func makeItem(_ title: String, action: Selector) -> NSMenuItem {
        let item = NSMenuItem(title: title, action: action, keyEquivalent: "")
        item.target = self
        return item
    }

    // MARK: - Menu Actions (delegate to helper)

    @objc private func sendHome() {
        keyHelper.sendHome()
    }

    @objc private func sendSpotlight() {
        keyHelper.sendSpotlight()
    }

    @objc private func sendReturn() {
        keyHelper.sendReturn()
    }

    @objc private func sendEscape() {
        keyHelper.sendEscape()
    }

    @objc private func sendSpace() {
        keyHelper.sendSpace()
    }

    @objc private func sendTab() {
        keyHelper.sendTab()
    }

    @objc private func sendDeleteKey() {
        keyHelper.sendDeleteKey()
    }

    @objc private func sendArrowUp() {
        keyHelper.sendArrowUp()
    }

    @objc private func sendArrowDown() {
        keyHelper.sendArrowDown()
    }

    @objc private func sendArrowLeft() {
        keyHelper.sendArrowLeft()
    }

    @objc private func sendArrowRight() {
        keyHelper.sendArrowRight()
    }

    @objc private func sendPower() {
        keyHelper.sendPower()
    }

    @objc private func sendVolumeUp() {
        keyHelper.sendVolumeUp()
    }

    @objc private func sendVolumeDown() {
        keyHelper.sendVolumeDown()
    }

    @objc private func sendShift() {
        keyHelper.sendShift()
    }

    @objc private func sendCommand() {
        keyHelper.sendCommand()
    }

    @objc private func typeFromClipboard() {
        keyHelper.typeFromClipboard()
    }
}

```

`sources/vphone-cli/VPhoneVM.swift`:

```swift
import Dynamic
import Foundation
import Virtualization

/// Minimal VM for booting a vphone (virtual iPhone) in DFU mode.
@MainActor
class VPhoneVM: NSObject, VZVirtualMachineDelegate {
    let virtualMachine: VZVirtualMachine

    struct Options {
        var romURL: URL
        var nvramURL: URL
        var machineIDURL: URL
        var diskURL: URL
        var cpuCount: Int = 8
        var memorySize: UInt64 = 8 * 1024 * 1024 * 1024
        var sepStorageURL: URL
        var sepRomURL: URL
        var screenWidth: Int = 1290
        var screenHeight: Int = 2796
        var screenPPI: Int = 460
        var screenScale: Double = 3.0
    }

    init(options: Options) throws {
        // --- Hardware model (PV=3) ---
        let hwModel = try VPhoneHardware.createModel()
        print("[vphone] PV=3 hardware model: isSupported = true")

        // --- Platform ---
        let platform = VZMacPlatformConfiguration()

        // Persist machineIdentifier for stable ECID
        if let savedData = try? Data(contentsOf: options.machineIDURL),
           let savedID = VZMacMachineIdentifier(dataRepresentation: savedData)
        {
            platform.machineIdentifier = savedID
            print("[vphone] Loaded machineIdentifier (ECID stable)")
        } else {
            let newID = VZMacMachineIdentifier()
            platform.machineIdentifier = newID
            try newID.dataRepresentation.write(to: options.machineIDURL)
            print("[vphone] Created new machineIdentifier -> \(options.machineIDURL.lastPathComponent)")
        }

        let auxStorage = try VZMacAuxiliaryStorage(
            creatingStorageAt: options.nvramURL,
            hardwareModel: hwModel,
            options: .allowOverwrite
        )
        platform.auxiliaryStorage = auxStorage
        platform.hardwareModel = hwModel

        // Set NVRAM boot-args to enable serial output
        let bootArgs = "serial=3 debug=0x104c04"
        if let bootArgsData = bootArgs.data(using: .utf8) {
            let ok = Dynamic(auxStorage)
                ._setDataValue(bootArgsData, forNVRAMVariableNamed: "boot-args", error: nil)
                .asBool ?? false
            if ok { print("[vphone] NVRAM boot-args: \(bootArgs)") }
        }

        // --- Boot loader with custom ROM ---
        let bootloader = VZMacOSBootLoader()
        Dynamic(bootloader)._setROMURL(options.romURL)

        // --- VM Configuration ---
        let config = VZVirtualMachineConfiguration()
        config.bootLoader = bootloader
        config.platform = platform
        config.cpuCount = max(options.cpuCount, VZVirtualMachineConfiguration.minimumAllowedCPUCount)
        config.memorySize = max(options.memorySize, VZVirtualMachineConfiguration.minimumAllowedMemorySize)

        // Display
        let gfx = VZMacGraphicsDeviceConfiguration()
        gfx.displays = [
            VZMacGraphicsDisplayConfiguration(
                widthInPixels: options.screenWidth, heightInPixels: options.screenHeight,
                pixelsPerInch: options.screenPPI
            ),
        ]
        config.graphicsDevices = [gfx]

        // Audio
        let afg = VZVirtioSoundDeviceConfiguration()
        let inputAudioStreamConfiguration = VZVirtioSoundDeviceInputStreamConfiguration()
        let outputAudioStreamConfiguration = VZVirtioSoundDeviceOutputStreamConfiguration()
        inputAudioStreamConfiguration.source = VZHostAudioInputStreamSource()
        outputAudioStreamConfiguration.sink = VZHostAudioOutputStreamSink()
        afg.streams = [inputAudioStreamConfiguration, outputAudioStreamConfiguration]
        config.audioDevices = [afg]

        // Storage
        guard FileManager.default.fileExists(atPath: options.diskURL.path) else {
            throw VPhoneError.diskNotFound(options.diskURL.path)
        }
        let attachment = try VZDiskImageStorageDeviceAttachment(url: options.diskURL, readOnly: false)
        config.storageDevices = [VZVirtioBlockDeviceConfiguration(attachment: attachment)]

        // Network (shared NAT)
        let net = VZVirtioNetworkDeviceConfiguration()
        net.attachment = VZNATNetworkDeviceAttachment()
        config.networkDevices = [net]

        // Serial port (PL011 UART — interactive stdin/stdout)
        if let serialPort = Dynamic._VZPL011SerialPortConfiguration().asObject as? VZSerialPortConfiguration {
            serialPort.attachment = VZFileHandleSerialPortAttachment(
                fileHandleForReading: FileHandle.standardInput,
                fileHandleForWriting: FileHandle.standardOutput
            )
            config.serialPorts = [serialPort]
            print("[vphone] PL011 serial port attached (interactive)")
        }

        // Multi-touch (USB touch screen)
        if let obj = Dynamic._VZUSBTouchScreenConfiguration().asObject {
            Dynamic(config)._setMultiTouchDevices([obj])
            print("[vphone] USB touch screen configured")
        }

        config.keyboards = [VZUSBKeyboardConfiguration()]

        // GDB debug stub (default init, system-assigned port)
        Dynamic(config)._setDebugStub(Dynamic._VZGDBDebugStubConfiguration().asObject)

        // Coprocessors
        let sepConfig = Dynamic._VZSEPCoprocessorConfiguration(storageURL: options.sepStorageURL)
        sepConfig.setRomBinaryURL(options.sepRomURL)
        sepConfig.setDebugStub(Dynamic._VZGDBDebugStubConfiguration().asObject)
        if let sepObj = sepConfig.asObject {
            Dynamic(config)._setCoprocessors([sepObj])
            print("[vphone] SEP coprocessor enabled (storage: \(options.sepStorageURL.path))")
        }

        // Validate
        try config.validate()
        print("[vphone] Configuration validated")

        virtualMachine = VZVirtualMachine(configuration: config)
        super.init()
        virtualMachine.delegate = self
    }

    // MARK: - Start

    @MainActor
    func start(forceDFU: Bool) async throws {
        let opts = VZMacOSVirtualMachineStartOptions()
        Dynamic(opts)._setForceDFU(forceDFU)
        Dynamic(opts)._setStopInIBootStage1(false)
        Dynamic(opts)._setStopInIBootStage2(false)
        print("[vphone] Starting\(forceDFU ? " DFU" : "")...")
        try await virtualMachine.start(options: opts)
        if forceDFU {
            print("[vphone] VM started in DFU mode — connect with irecovery")
        } else {
            print("[vphone] VM started — booting normally")
        }
    }

    // MARK: - Delegate

    // VZ delivers delegate callbacks via dispatch source on the main queue.

    nonisolated func guestDidStop(_: VZVirtualMachine) {
        print("[vphone] Guest stopped")
        exit(EXIT_SUCCESS)
    }

    nonisolated func virtualMachine(_: VZVirtualMachine, didStopWithError error: Error) {
        print("[vphone] Stopped with error: \(error)")
        exit(EXIT_FAILURE)
    }

    nonisolated func virtualMachine(_: VZVirtualMachine, networkDevice _: VZNetworkDevice,
                                    attachmentWasDisconnectedWithError error: Error)
    {
        print("[vphone] Network error: \(error)")
    }
}

```

`sources/vphone-cli/VPhoneVMView.swift`:

```swift
import AppKit
import Dynamic
import Foundation
import Virtualization

class VPhoneVMView: VZVirtualMachineView {
    var keyHelper: VPhoneKeyHelper?
    
    private var currentTouchSwipeAim: Int = 0

    // MARK: - Private API Accessors

    // https://github.com/wh1te4ever/super-tart-vphone-writeup/blob/main/contents/ScreenSharingVNC.swift
    private var multiTouchDevice: AnyObject? {
        guard let vm = self.virtualMachine else { return nil }
        guard let devices = Dynamic(vm)._multiTouchDevices.asObject as? NSArray,
            devices.count > 0
        else {
            return nil
        }
        return devices.object(at: 0) as AnyObject
    }

    // MARK: - Event Handling

    override func mouseDown(with event: NSEvent) {
        let location = self.convert(event.locationInWindow, from: nil)
        
        self.currentTouchSwipeAim = hitTestEdge(at: location)
        
        sendTouchEvent(
            phase: 0, // Began
            locationInWindow: event.locationInWindow,
            timestamp: event.timestamp
        )
    }

    override func mouseDragged(with event: NSEvent) {
        sendTouchEvent(
            phase: 1, // Moved
            locationInWindow: event.locationInWindow,
            timestamp: event.timestamp
        )
        super.mouseDragged(with: event)
    }

    override func mouseUp(with event: NSEvent) {
        sendTouchEvent(
            phase: 3, // Ended
            locationInWindow: event.locationInWindow,
            timestamp: event.timestamp
        )
        super.mouseUp(with: event)
    }

    override func rightMouseDown(with _: NSEvent) {
        guard let keyHelper else {
            print("[keys] keyHelper was not set, no way home!")
            return
        }
        keyHelper.sendHome()
    }

    // MARK: - Touch Injection Logic

    private func sendTouchEvent(phase: Int, locationInWindow: NSPoint, timestamp: TimeInterval) {
        guard let device = multiTouchDevice,
            let vm = self.virtualMachine
        else { return }

        let normalizedPoint = normalizeCoordinate(locationInWindow)

        let touch = Dynamic._VZTouch(
            view: vm,
            index: 0,
            phase: phase,
            location: normalizedPoint,
            swipeAim: currentTouchSwipeAim,
            timestamp: timestamp
        )

        guard let touchObj = touch.asObject else {
            print("[vphone] Error: Failed to create _VZTouch")
            return
        }

        let touchEvent = Dynamic._VZMultiTouchEvent(touches: [touchObj])
        guard let eventObj = touchEvent.asObject else { return }

        Dynamic(device).sendMultiTouchEvents([eventObj] as NSArray)
    }

    // MARK: - Coordinate Helpers

    private func normalizeCoordinate(_ locationInWindow: NSPoint) -> CGPoint {
        let localPoint = self.convert(locationInWindow, from: nil)
        let w = self.bounds.width
        let h = self.bounds.height

        guard w > 0, h > 0 else { return .zero }

        var nx = Double(localPoint.x / w)
        var ny = Double(localPoint.y / h)

        // Clamp
        nx = max(0.0, min(1.0, nx))
        ny = max(0.0, min(1.0, ny))

        if !self.isFlipped {
            ny = 1.0 - ny
        }

        return CGPoint(x: nx, y: ny)
    }

    private func hitTestEdge(at point: CGPoint) -> Int {
        let w = self.bounds.width
        let h = self.bounds.height
        
        let edgeThreshold: CGFloat = 32.0
        
        let distLeft = point.x
        let distRight = w - point.x
        let distTop = self.isFlipped ? point.y : (h - point.y)
        let distBottom = self.isFlipped ? (h - point.y) : point.y

        var minDist = distLeft
        var edgeCode = 8 // Left

        if distRight < minDist {
            minDist = distRight
            edgeCode = 4 // Right
        }
        
        if distBottom < minDist {
            minDist = distBottom
            edgeCode = 2 // Bottom (Home bar swipe up)
        }
        
        if distTop < minDist {
            minDist = distTop
            edgeCode = 1 // Top (Notification Center)
        }

        return minDist < edgeThreshold ? edgeCode : 0
    }
}
```

`sources/vphone-cli/VPhoneWindowController.swift`:

```swift
import AppKit
import Foundation
import Virtualization

@MainActor
class VPhoneWindowController {
    private var windowController: NSWindowController?

    func showWindow(for vm: VZVirtualMachine, screenWidth: Int, screenHeight: Int, screenScale: Double, keyHelper: VPhoneKeyHelper) {
        let view = VPhoneVMView()
        view.virtualMachine = vm
        view.capturesSystemKeys = true
        view.keyHelper = keyHelper
        let vmView: NSView = view

        let scale = CGFloat(screenScale)
        let windowSize = NSSize(width: CGFloat(screenWidth) / scale, height: CGFloat(screenHeight) / scale)

        let window = NSWindow(
            contentRect: NSRect(origin: .zero, size: windowSize),
            styleMask: [.titled, .closable, .resizable, .miniaturizable],
            backing: .buffered,
            defer: false
        )

        window.contentAspectRatio = windowSize
        window.title = "vphone"
        window.contentView = vmView
        window.center()

        let controller = NSWindowController(window: window)
        controller.showWindow(nil)
        windowController = controller

        window.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
    }
}

```

`sources/vphone-cli/main.swift`:

```swift
import AppKit
import Foundation

/// Parse CLI arguments before NSApplication starts so that bad-arg errors
/// print cleanly to the terminal without a run loop ever starting.
let cli = VPhoneCLI.parseOrExit()

let app = NSApplication.shared
let delegate = VPhoneAppDelegate(cli: cli)
app.delegate = delegate
app.run()

```

`sources/vphone.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.virtualization</key>
	<true/>
	<key>com.apple.private.virtualization</key>
	<true/>
	<key>com.apple.private.virtualization.security-research</key>
	<true/>
	<key>com.apple.vm.networking</key>
	<true/>
	<key>com.apple.security.get-task-allow</key>
	<true/>
</dict>
</plist>

```